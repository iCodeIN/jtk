// THIS FILE IS GENERATED BY WAYGEN - DO NOT EDIT
// Generated with: waygen ../third_party/wayland/protocol ../third_party/wayland-protocols
package wayland

////////////////////////////////////////////////////////////////////////////////
// #region Protocol drm_lease_v1

// ----------------------------------------------------------------------------
// #region Interface drm_lease_v1.wp_drm_lease_device_v1

// WpDrmLeaseDeviceV1CreateLeaseRequestRequest requests to create a lease request object
//
// Creates a lease request object.
//
// See the documentation for wp_drm_lease_request_v1 for details.
type WpDrmLeaseDeviceV1CreateLeaseRequestRequest struct {
	ID ObjectID
}

// Opcode returns the request opcode for wp_drm_lease_device_v1.create_lease_request in drm_lease_v1
func (WpDrmLeaseDeviceV1CreateLeaseRequestRequest) Opcode() uint16 { return 0 }

// Ensure WpDrmLeaseDeviceV1CreateLeaseRequestRequest implements Message.
var _ Message = WpDrmLeaseDeviceV1CreateLeaseRequestRequest{}

// WpDrmLeaseDeviceV1ReleaseRequest requests to release this object
//
// Indicates the client no longer wishes to use this object. In response
// the compositor will immediately send the released event and destroy
// this object. It can however not guarantee that the client won't receive
// connector events before the released event. The client must not send any
// requests after this one, doing so will raise a wl_display error.
// Existing connectors, lease request and leases will not be affected.
type WpDrmLeaseDeviceV1ReleaseRequest struct {
}

// Opcode returns the request opcode for wp_drm_lease_device_v1.release in drm_lease_v1
func (WpDrmLeaseDeviceV1ReleaseRequest) Opcode() uint16 { return 1 }

// Ensure WpDrmLeaseDeviceV1ReleaseRequest implements Message.
var _ Message = WpDrmLeaseDeviceV1ReleaseRequest{}

// WpDrmLeaseDeviceV1DrmFDEvent signals when open a non-master fd for this DRM node
//
// The compositor will send this event when the wp_drm_lease_device_v1
// global is bound, although there are no guarantees as to how long this
// takes - the compositor might need to wait until regaining DRM master.
// The included fd is a non-master DRM file descriptor opened for this
// device and the compositor must not authenticate it.
// The purpose of this event is to give the client the ability to
// query DRM and discover information which may help them pick the
// appropriate DRM device or select the appropriate connectors therein.
type WpDrmLeaseDeviceV1DrmFDEvent struct {
	// FD contains DRM file descriptor
	FD FD
}

// Opcode returns the event opcode for wp_drm_lease_device_v1.drm_fd in drm_lease_v1
func (WpDrmLeaseDeviceV1DrmFDEvent) Opcode() uint16 { return 0 }

// Ensure WpDrmLeaseDeviceV1DrmFDEvent implements Message.
var _ Message = WpDrmLeaseDeviceV1DrmFDEvent{}

// Scan scans the event from the socket.
func (e *WpDrmLeaseDeviceV1DrmFDEvent) Scan(s *EventScanner) error {
	if v, err := s.FD(); err != nil {
		return err
	} else {
		e.FD = v
	}
	return nil
}

// Ensure WpDrmLeaseDeviceV1DrmFDEvent implements Event.
var _ Event = &WpDrmLeaseDeviceV1DrmFDEvent{}

// WpDrmLeaseDeviceV1ConnectorEvent signals when advertise connectors available for leases
//
// The compositor will use this event to advertise connectors available for
// lease by clients. This object may be passed into a lease request to
// indicate the client would like to lease that connector, see
// wp_drm_lease_request_v1.request_connector for details. While the
// compositor will make a best effort to not send disconnected connectors,
// no guarantees can be made.
//
// The compositor must send the drm_fd event before sending connectors.
// After the drm_fd event it will send all available connectors but may
// send additional connectors at any time.
type WpDrmLeaseDeviceV1ConnectorEvent struct {
	ID ObjectID
}

// Opcode returns the event opcode for wp_drm_lease_device_v1.connector in drm_lease_v1
func (WpDrmLeaseDeviceV1ConnectorEvent) Opcode() uint16 { return 1 }

// Ensure WpDrmLeaseDeviceV1ConnectorEvent implements Message.
var _ Message = WpDrmLeaseDeviceV1ConnectorEvent{}

// Scan scans the event from the socket.
func (e *WpDrmLeaseDeviceV1ConnectorEvent) Scan(s *EventScanner) error {
	if v, err := s.ObjectID(); err != nil {
		return err
	} else {
		e.ID = v
	}
	return nil
}

// Ensure WpDrmLeaseDeviceV1ConnectorEvent implements Event.
var _ Event = &WpDrmLeaseDeviceV1ConnectorEvent{}

// WpDrmLeaseDeviceV1DoneEvent signals when signals grouping of connectors
//
// The compositor will send this event to indicate that it has sent all
// currently available connectors after the client binds to the global or
// when it updates the connector list, for example on hotplug, drm master
// change or when a leased connector becomes available again. It will
// similarly send this event to group wp_drm_lease_connector_v1.withdrawn
// events of connectors of this device.
type WpDrmLeaseDeviceV1DoneEvent struct {
}

// Opcode returns the event opcode for wp_drm_lease_device_v1.done in drm_lease_v1
func (WpDrmLeaseDeviceV1DoneEvent) Opcode() uint16 { return 2 }

// Ensure WpDrmLeaseDeviceV1DoneEvent implements Message.
var _ Message = WpDrmLeaseDeviceV1DoneEvent{}

// Scan scans the event from the socket.
func (e *WpDrmLeaseDeviceV1DoneEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure WpDrmLeaseDeviceV1DoneEvent implements Event.
var _ Event = &WpDrmLeaseDeviceV1DoneEvent{}

// WpDrmLeaseDeviceV1ReleasedEvent signals when the compositor has finished using the device
//
// This event is sent in response to the release request and indicates
// that the compositor is done sending connector events.
// The compositor will destroy this object immediately after sending the
// event and it will become invalid. The client should release any
// resources associated with this device after receiving this event.
type WpDrmLeaseDeviceV1ReleasedEvent struct {
}

// Opcode returns the event opcode for wp_drm_lease_device_v1.released in drm_lease_v1
func (WpDrmLeaseDeviceV1ReleasedEvent) Opcode() uint16 { return 3 }

// Ensure WpDrmLeaseDeviceV1ReleasedEvent implements Message.
var _ Message = WpDrmLeaseDeviceV1ReleasedEvent{}

// Scan scans the event from the socket.
func (e *WpDrmLeaseDeviceV1ReleasedEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure WpDrmLeaseDeviceV1ReleasedEvent implements Event.
var _ Event = &WpDrmLeaseDeviceV1ReleasedEvent{}

// #endregion Interface drm_lease_v1.wp_drm_lease_device_v1

// ----------------------------------------------------------------------------
// #region Interface drm_lease_v1.wp_drm_lease_connector_v1

// WpDrmLeaseConnectorV1DestroyRequest requests to destroy connector
//
// The client may send this request to indicate that it will not use this
// connector. Clients are encouraged to send this after receiving the
// "withdrawn" event so that the server can release the resources
// associated with this connector offer. Neither existing lease requests
// nor leases will be affected.
type WpDrmLeaseConnectorV1DestroyRequest struct {
}

// Opcode returns the request opcode for wp_drm_lease_connector_v1.destroy in drm_lease_v1
func (WpDrmLeaseConnectorV1DestroyRequest) Opcode() uint16 { return 0 }

// Ensure WpDrmLeaseConnectorV1DestroyRequest implements Message.
var _ Message = WpDrmLeaseConnectorV1DestroyRequest{}

// WpDrmLeaseConnectorV1NameEvent signals when name
//
// The compositor sends this event once the connector is created to
// indicate the name of this connector. This will not change for the
// duration of the Wayland session, but is not guaranteed to be consistent
// between sessions.
type WpDrmLeaseConnectorV1NameEvent struct {
	// Name contains connector name
	Name string
}

// Opcode returns the event opcode for wp_drm_lease_connector_v1.name in drm_lease_v1
func (WpDrmLeaseConnectorV1NameEvent) Opcode() uint16 { return 0 }

// Ensure WpDrmLeaseConnectorV1NameEvent implements Message.
var _ Message = WpDrmLeaseConnectorV1NameEvent{}

// Scan scans the event from the socket.
func (e *WpDrmLeaseConnectorV1NameEvent) Scan(s *EventScanner) error {
	if v, err := s.String(); err != nil {
		return err
	} else {
		e.Name = v
	}
	return nil
}

// Ensure WpDrmLeaseConnectorV1NameEvent implements Event.
var _ Event = &WpDrmLeaseConnectorV1NameEvent{}

// WpDrmLeaseConnectorV1DescriptionEvent signals when description
//
// The compositor sends this event once the connector is created to provide
// a human-readable description for this connector, which may be presented
// to the user. The compositor may send this event multiple times over the
// lifetime of this object to reflect changes in the description.
type WpDrmLeaseConnectorV1DescriptionEvent struct {
	// Description contains connector description
	Description string
}

// Opcode returns the event opcode for wp_drm_lease_connector_v1.description in drm_lease_v1
func (WpDrmLeaseConnectorV1DescriptionEvent) Opcode() uint16 { return 1 }

// Ensure WpDrmLeaseConnectorV1DescriptionEvent implements Message.
var _ Message = WpDrmLeaseConnectorV1DescriptionEvent{}

// Scan scans the event from the socket.
func (e *WpDrmLeaseConnectorV1DescriptionEvent) Scan(s *EventScanner) error {
	if v, err := s.String(); err != nil {
		return err
	} else {
		e.Description = v
	}
	return nil
}

// Ensure WpDrmLeaseConnectorV1DescriptionEvent implements Event.
var _ Event = &WpDrmLeaseConnectorV1DescriptionEvent{}

// WpDrmLeaseConnectorV1ConnectorIDEvent signals when connector_id
//
// The compositor sends this event once the connector is created to
// indicate the DRM object ID which represents the underlying connector
// that is being offered. Note that the final lease may include additional
// object IDs, such as CRTCs and planes.
type WpDrmLeaseConnectorV1ConnectorIDEvent struct {
	// ConnectorID contains DRM connector ID
	ConnectorID uint32
}

// Opcode returns the event opcode for wp_drm_lease_connector_v1.connector_id in drm_lease_v1
func (WpDrmLeaseConnectorV1ConnectorIDEvent) Opcode() uint16 { return 2 }

// Ensure WpDrmLeaseConnectorV1ConnectorIDEvent implements Message.
var _ Message = WpDrmLeaseConnectorV1ConnectorIDEvent{}

// Scan scans the event from the socket.
func (e *WpDrmLeaseConnectorV1ConnectorIDEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.ConnectorID = v
	}
	return nil
}

// Ensure WpDrmLeaseConnectorV1ConnectorIDEvent implements Event.
var _ Event = &WpDrmLeaseConnectorV1ConnectorIDEvent{}

// WpDrmLeaseConnectorV1DoneEvent signals when all properties have been sent
//
// This event is sent after all properties of a connector have been sent.
// This allows changes to the properties to be seen as atomic even if they
// happen via multiple events.
type WpDrmLeaseConnectorV1DoneEvent struct {
}

// Opcode returns the event opcode for wp_drm_lease_connector_v1.done in drm_lease_v1
func (WpDrmLeaseConnectorV1DoneEvent) Opcode() uint16 { return 3 }

// Ensure WpDrmLeaseConnectorV1DoneEvent implements Message.
var _ Message = WpDrmLeaseConnectorV1DoneEvent{}

// Scan scans the event from the socket.
func (e *WpDrmLeaseConnectorV1DoneEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure WpDrmLeaseConnectorV1DoneEvent implements Event.
var _ Event = &WpDrmLeaseConnectorV1DoneEvent{}

// WpDrmLeaseConnectorV1WithdrawnEvent signals when lease offer withdrawn
//
// Sent to indicate that the compositor will no longer honor requests for
// DRM leases which include this connector. The client may still issue a
// lease request including this connector, but the compositor will send
// wp_drm_lease_v1.finished without issuing a lease fd. Compositors are
// encouraged to send this event when they lose access to connector, for
// example when the connector is hot-unplugged, when the connector gets
// leased to a client or when the compositor loses DRM master.
type WpDrmLeaseConnectorV1WithdrawnEvent struct {
}

// Opcode returns the event opcode for wp_drm_lease_connector_v1.withdrawn in drm_lease_v1
func (WpDrmLeaseConnectorV1WithdrawnEvent) Opcode() uint16 { return 4 }

// Ensure WpDrmLeaseConnectorV1WithdrawnEvent implements Message.
var _ Message = WpDrmLeaseConnectorV1WithdrawnEvent{}

// Scan scans the event from the socket.
func (e *WpDrmLeaseConnectorV1WithdrawnEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure WpDrmLeaseConnectorV1WithdrawnEvent implements Event.
var _ Event = &WpDrmLeaseConnectorV1WithdrawnEvent{}

// #endregion Interface drm_lease_v1.wp_drm_lease_connector_v1

// ----------------------------------------------------------------------------
// #region Interface drm_lease_v1.wp_drm_lease_request_v1

type WpDrmLeaseRequestV1Error int

const (
	// WpDrmLeaseRequestV1ErrorWrongDevice corresponds to requested a connector from a different lease device
	WpDrmLeaseRequestV1ErrorWrongDevice WpDrmLeaseRequestV1Error = 0

	// WpDrmLeaseRequestV1ErrorDuplicateConnector corresponds to requested a connector twice
	WpDrmLeaseRequestV1ErrorDuplicateConnector WpDrmLeaseRequestV1Error = 1

	// WpDrmLeaseRequestV1ErrorEmptyLease corresponds to requested a lease without requesting a connector
	WpDrmLeaseRequestV1ErrorEmptyLease WpDrmLeaseRequestV1Error = 2
)

// WpDrmLeaseRequestV1RequestConnectorRequest requests to request a connector for this lease
//
// Indicates that the client would like to lease the given connector.
// This is only used as a suggestion, the compositor may choose to
// include any resources in the lease it issues, or change the set of
// leased resources at any time. Compositors are however encouraged to
// include the requested connector and other resources necessary
// to drive the connected output in the lease.
//
// Requesting a connector that was created from a different lease device
// than this lease request raises the wrong_device error. Requesting a
// connector twice will raise the duplicate_connector error.
type WpDrmLeaseRequestV1RequestConnectorRequest struct {
	Connector ObjectID
}

// Opcode returns the request opcode for wp_drm_lease_request_v1.request_connector in drm_lease_v1
func (WpDrmLeaseRequestV1RequestConnectorRequest) Opcode() uint16 { return 0 }

// Ensure WpDrmLeaseRequestV1RequestConnectorRequest implements Message.
var _ Message = WpDrmLeaseRequestV1RequestConnectorRequest{}

// WpDrmLeaseRequestV1SubmitRequest requests to submit the lease request
//
// Submits the lease request and creates a new wp_drm_lease_v1 object.
// After calling submit the compositor will immediately destroy this
// object, issuing any more requests will cause a wl_diplay error.
// The compositor doesn't make any guarantees about the events of the
// lease object, clients cannot expect an immediate response.
// Not requesting any connectors before submitting the lease request
// will raise the empty_lease error.
type WpDrmLeaseRequestV1SubmitRequest struct {
	ID ObjectID
}

// Opcode returns the request opcode for wp_drm_lease_request_v1.submit in drm_lease_v1
func (WpDrmLeaseRequestV1SubmitRequest) Opcode() uint16 { return 1 }

// Ensure WpDrmLeaseRequestV1SubmitRequest implements Message.
var _ Message = WpDrmLeaseRequestV1SubmitRequest{}

// #endregion Interface drm_lease_v1.wp_drm_lease_request_v1

// ----------------------------------------------------------------------------
// #region Interface drm_lease_v1.wp_drm_lease_v1

// WpDrmLeaseV1DestroyRequest requests to destroys the lease object
//
// The client should send this to indicate that it no longer wishes to use
// this lease. The compositor should use drmModeRevokeLease on the
// appropriate file descriptor, if necessary.
type WpDrmLeaseV1DestroyRequest struct {
}

// Opcode returns the request opcode for wp_drm_lease_v1.destroy in drm_lease_v1
func (WpDrmLeaseV1DestroyRequest) Opcode() uint16 { return 0 }

// Ensure WpDrmLeaseV1DestroyRequest implements Message.
var _ Message = WpDrmLeaseV1DestroyRequest{}

// WpDrmLeaseV1LeaseFDEvent signals when shares the DRM file descriptor
//
// This event returns a file descriptor suitable for use with DRM-related
// ioctls. The client should use drmModeGetLease to enumerate the DRM
// objects which have been leased to them. The compositor guarantees it
// will not use the leased DRM objects itself until it sends the finished
// event. If the compositor cannot or will not grant a lease for the
// requested connectors, it will not send this event, instead sending the
// finished event.
//
// The compositor will send this event at most once during this objects
// lifetime.
type WpDrmLeaseV1LeaseFDEvent struct {
	// LeasedFD contains leased DRM file descriptor
	LeasedFD FD
}

// Opcode returns the event opcode for wp_drm_lease_v1.lease_fd in drm_lease_v1
func (WpDrmLeaseV1LeaseFDEvent) Opcode() uint16 { return 0 }

// Ensure WpDrmLeaseV1LeaseFDEvent implements Message.
var _ Message = WpDrmLeaseV1LeaseFDEvent{}

// Scan scans the event from the socket.
func (e *WpDrmLeaseV1LeaseFDEvent) Scan(s *EventScanner) error {
	if v, err := s.FD(); err != nil {
		return err
	} else {
		e.LeasedFD = v
	}
	return nil
}

// Ensure WpDrmLeaseV1LeaseFDEvent implements Event.
var _ Event = &WpDrmLeaseV1LeaseFDEvent{}

// WpDrmLeaseV1FinishedEvent signals when sent when the lease has been revoked
//
// The compositor uses this event to either reject a lease request, or if
// it previously sent a lease_fd, to notify the client that the lease has
// been revoked. If the client requires a new lease, they should destroy
// this object and submit a new lease request. The compositor will send
// no further events for this object after sending the finish event.
// Compositors should revoke the lease when any of the leased resources
// become unavailable, namely when a hot-unplug occurs or when the
// compositor loses DRM master.
type WpDrmLeaseV1FinishedEvent struct {
}

// Opcode returns the event opcode for wp_drm_lease_v1.finished in drm_lease_v1
func (WpDrmLeaseV1FinishedEvent) Opcode() uint16 { return 1 }

// Ensure WpDrmLeaseV1FinishedEvent implements Message.
var _ Message = WpDrmLeaseV1FinishedEvent{}

// Scan scans the event from the socket.
func (e *WpDrmLeaseV1FinishedEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure WpDrmLeaseV1FinishedEvent implements Event.
var _ Event = &WpDrmLeaseV1FinishedEvent{}

// #endregion Interface drm_lease_v1.wp_drm_lease_v1

////////////////////////////////////////////////////////////////////////////////
// #endregion Protocol drm_lease_v1

////////////////////////////////////////////////////////////////////////////////
// #region Protocol fullscreen_shell_unstable_v1

// ----------------------------------------------------------------------------
// #region Interface fullscreen_shell_unstable_v1.zwp_fullscreen_shell_v1

// ZwpFullscreenShellV1Capability represents capabilities advertised by the compositor
//
// Various capabilities that can be advertised by the compositor.  They
// are advertised one-at-a-time when the wl_fullscreen_shell interface is
// bound.  See the wl_fullscreen_shell.capability event for more details.
//
// ARBITRARY_MODES:
// This is a hint to the client that indicates that the compositor is
// capable of setting practically any mode on its outputs.  If this
// capability is provided, wl_fullscreen_shell.present_surface_for_mode
// will almost never fail and clients should feel free to set whatever
// mode they like.  If the compositor does not advertise this, it may
// still support some modes that are not advertised through wl_global.mode
// but it is less likely.
//
// CURSOR_PLANE:
// This is a hint to the client that indicates that the compositor can
// handle a cursor surface from the client without actually compositing.
// This may be because of a hardware cursor plane or some other mechanism.
// If the compositor does not advertise this capability then setting
// wl_pointer.cursor may degrade performance or be ignored entirely.  If
// CURSOR_PLANE is not advertised, it is recommended that the client draw
// its own cursor and set wl_pointer.cursor(NULL).
type ZwpFullscreenShellV1Capability int

const (
	// ZwpFullscreenShellV1CapabilityArbitraryModes corresponds to compositor is capable of almost any output mode
	ZwpFullscreenShellV1CapabilityArbitraryModes ZwpFullscreenShellV1Capability = 1

	// ZwpFullscreenShellV1CapabilityCursorPlane corresponds to compositor has a separate cursor plane
	ZwpFullscreenShellV1CapabilityCursorPlane ZwpFullscreenShellV1Capability = 2
)

// ZwpFullscreenShellV1PresentMethod represents different method to set the surface fullscreen
//
// Hints to indicate to the compositor how to deal with a conflict
// between the dimensions of the surface and the dimensions of the
// output. The compositor is free to ignore this parameter.
type ZwpFullscreenShellV1PresentMethod int

const (
	// ZwpFullscreenShellV1PresentMethodDefault corresponds to no preference, apply default policy
	ZwpFullscreenShellV1PresentMethodDefault ZwpFullscreenShellV1PresentMethod = 0

	// ZwpFullscreenShellV1PresentMethodCenter corresponds to center the surface on the output
	ZwpFullscreenShellV1PresentMethodCenter ZwpFullscreenShellV1PresentMethod = 1

	// ZwpFullscreenShellV1PresentMethodZoom corresponds to scale the surface, preserving aspect ratio, to the largest size that will fit on the output
	ZwpFullscreenShellV1PresentMethodZoom ZwpFullscreenShellV1PresentMethod = 2

	// ZwpFullscreenShellV1PresentMethodZoomCrop corresponds to scale the surface, preserving aspect ratio, to fully fill the output cropping if needed
	ZwpFullscreenShellV1PresentMethodZoomCrop ZwpFullscreenShellV1PresentMethod = 3

	// ZwpFullscreenShellV1PresentMethodStretch corresponds to scale the surface to the size of the output ignoring aspect ratio
	ZwpFullscreenShellV1PresentMethodStretch ZwpFullscreenShellV1PresentMethod = 4
)

// ZwpFullscreenShellV1Error represents wl_fullscreen_shell error values
//
// These errors can be emitted in response to wl_fullscreen_shell requests.
type ZwpFullscreenShellV1Error int

const (
	// ZwpFullscreenShellV1ErrorInvalidMethod corresponds to present_method is not known
	ZwpFullscreenShellV1ErrorInvalidMethod ZwpFullscreenShellV1Error = 0

	// ZwpFullscreenShellV1ErrorRole corresponds to given wl_surface has another role
	ZwpFullscreenShellV1ErrorRole ZwpFullscreenShellV1Error = 1
)

// ZwpFullscreenShellV1ReleaseRequest requests to release the wl_fullscreen_shell interface
//
// Release the binding from the wl_fullscreen_shell interface.
//
// This destroys the server-side object and frees this binding.  If
// the client binds to wl_fullscreen_shell multiple times, it may wish
// to free some of those bindings.
type ZwpFullscreenShellV1ReleaseRequest struct {
}

// Opcode returns the request opcode for zwp_fullscreen_shell_v1.release in fullscreen_shell_unstable_v1
func (ZwpFullscreenShellV1ReleaseRequest) Opcode() uint16 { return 0 }

// Ensure ZwpFullscreenShellV1ReleaseRequest implements Message.
var _ Message = ZwpFullscreenShellV1ReleaseRequest{}

// ZwpFullscreenShellV1PresentSurfaceRequest requests to present surface for display
//
// Present a surface on the given output.
//
// If the output is null, the compositor will present the surface on
// whatever display (or displays) it thinks best.  In particular, this
// may replace any or all surfaces currently presented so it should
// not be used in combination with placing surfaces on specific
// outputs.
//
// The method parameter is a hint to the compositor for how the surface
// is to be presented.  In particular, it tells the compositor how to
// handle a size mismatch between the presented surface and the
// output.  The compositor is free to ignore this parameter.
//
// The "zoom", "zoom_crop", and "stretch" methods imply a scaling
// operation on the surface.  This will override any kind of output
// scaling, so the buffer_scale property of the surface is effectively
// ignored.
//
// This request gives the surface the role of a fullscreen shell surface.
// If the surface already has another role, it raises a role protocol
// error.
type ZwpFullscreenShellV1PresentSurfaceRequest struct {
	Surface ObjectID

	Method uint32

	Output ObjectID
}

// Opcode returns the request opcode for zwp_fullscreen_shell_v1.present_surface in fullscreen_shell_unstable_v1
func (ZwpFullscreenShellV1PresentSurfaceRequest) Opcode() uint16 { return 1 }

// Ensure ZwpFullscreenShellV1PresentSurfaceRequest implements Message.
var _ Message = ZwpFullscreenShellV1PresentSurfaceRequest{}

// ZwpFullscreenShellV1PresentSurfaceForModeRequest requests to present surface for display at a particular mode
//
// Presents a surface on the given output for a particular mode.
//
// If the current size of the output differs from that of the surface,
// the compositor will attempt to change the size of the output to
// match the surface.  The result of the mode-switch operation will be
// returned via the provided wl_fullscreen_shell_mode_feedback object.
//
// If the current output mode matches the one requested or if the
// compositor successfully switches the mode to match the surface,
// then the mode_successful event will be sent and the output will
// contain the contents of the given surface.  If the compositor
// cannot match the output size to the surface size, the mode_failed
// will be sent and the output will contain the contents of the
// previously presented surface (if any).  If another surface is
// presented on the given output before either of these has a chance
// to happen, the present_cancelled event will be sent.
//
// Due to race conditions and other issues unknown to the client, no
// mode-switch operation is guaranteed to succeed.  However, if the
// mode is one advertised by wl_output.mode or if the compositor
// advertises the ARBITRARY_MODES capability, then the client should
// expect that the mode-switch operation will usually succeed.
//
// If the size of the presented surface changes, the resulting output
// is undefined.  The compositor may attempt to change the output mode
// to compensate.  However, there is no guarantee that a suitable mode
// will be found and the client has no way to be notified of success
// or failure.
//
// The framerate parameter specifies the desired framerate for the
// output in mHz.  The compositor is free to ignore this parameter.  A
// value of 0 indicates that the client has no preference.
//
// If the value of wl_output.scale differs from wl_surface.buffer_scale,
// then the compositor may choose a mode that matches either the buffer
// size or the surface size.  In either case, the surface will fill the
// output.
//
// This request gives the surface the role of a fullscreen shell surface.
// If the surface already has another role, it raises a role protocol
// error.
type ZwpFullscreenShellV1PresentSurfaceForModeRequest struct {
	Surface ObjectID

	Output ObjectID

	Framerate int32

	Feedback ObjectID
}

// Opcode returns the request opcode for zwp_fullscreen_shell_v1.present_surface_for_mode in fullscreen_shell_unstable_v1
func (ZwpFullscreenShellV1PresentSurfaceForModeRequest) Opcode() uint16 { return 2 }

// Ensure ZwpFullscreenShellV1PresentSurfaceForModeRequest implements Message.
var _ Message = ZwpFullscreenShellV1PresentSurfaceForModeRequest{}

// ZwpFullscreenShellV1CapabilityEvent signals when advertises a capability of the compositor
//
// Advertises a single capability of the compositor.
//
// When the wl_fullscreen_shell interface is bound, this event is emitted
// once for each capability advertised.  Valid capabilities are given by
// the wl_fullscreen_shell.capability enum.  If clients want to take
// advantage of any of these capabilities, they should use a
// wl_display.sync request immediately after binding to ensure that they
// receive all the capability events.
type ZwpFullscreenShellV1CapabilityEvent struct {
	Capability uint32
}

// Opcode returns the event opcode for zwp_fullscreen_shell_v1.capability in fullscreen_shell_unstable_v1
func (ZwpFullscreenShellV1CapabilityEvent) Opcode() uint16 { return 0 }

// Ensure ZwpFullscreenShellV1CapabilityEvent implements Message.
var _ Message = ZwpFullscreenShellV1CapabilityEvent{}

// Scan scans the event from the socket.
func (e *ZwpFullscreenShellV1CapabilityEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Capability = v
	}
	return nil
}

// Ensure ZwpFullscreenShellV1CapabilityEvent implements Event.
var _ Event = &ZwpFullscreenShellV1CapabilityEvent{}

// #endregion Interface fullscreen_shell_unstable_v1.zwp_fullscreen_shell_v1

// ----------------------------------------------------------------------------
// #region Interface fullscreen_shell_unstable_v1.zwp_fullscreen_shell_mode_feedback_v1

// ZwpFullscreenShellModeFeedbackV1ModeSuccessfulEvent signals when mode switch succeeded
//
// This event indicates that the attempted mode switch operation was
// successful.  A surface of the size requested in the mode switch
// will fill the output without scaling.
//
// Upon receiving this event, the client should destroy the
// wl_fullscreen_shell_mode_feedback object.
type ZwpFullscreenShellModeFeedbackV1ModeSuccessfulEvent struct {
}

// Opcode returns the event opcode for zwp_fullscreen_shell_mode_feedback_v1.mode_successful in fullscreen_shell_unstable_v1
func (ZwpFullscreenShellModeFeedbackV1ModeSuccessfulEvent) Opcode() uint16 { return 0 }

// Ensure ZwpFullscreenShellModeFeedbackV1ModeSuccessfulEvent implements Message.
var _ Message = ZwpFullscreenShellModeFeedbackV1ModeSuccessfulEvent{}

// Scan scans the event from the socket.
func (e *ZwpFullscreenShellModeFeedbackV1ModeSuccessfulEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure ZwpFullscreenShellModeFeedbackV1ModeSuccessfulEvent implements Event.
var _ Event = &ZwpFullscreenShellModeFeedbackV1ModeSuccessfulEvent{}

// ZwpFullscreenShellModeFeedbackV1ModeFailedEvent signals when mode switch failed
//
// This event indicates that the attempted mode switch operation
// failed.  This may be because the requested output mode is not
// possible or it may mean that the compositor does not want to allow it.
//
// Upon receiving this event, the client should destroy the
// wl_fullscreen_shell_mode_feedback object.
type ZwpFullscreenShellModeFeedbackV1ModeFailedEvent struct {
}

// Opcode returns the event opcode for zwp_fullscreen_shell_mode_feedback_v1.mode_failed in fullscreen_shell_unstable_v1
func (ZwpFullscreenShellModeFeedbackV1ModeFailedEvent) Opcode() uint16 { return 1 }

// Ensure ZwpFullscreenShellModeFeedbackV1ModeFailedEvent implements Message.
var _ Message = ZwpFullscreenShellModeFeedbackV1ModeFailedEvent{}

// Scan scans the event from the socket.
func (e *ZwpFullscreenShellModeFeedbackV1ModeFailedEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure ZwpFullscreenShellModeFeedbackV1ModeFailedEvent implements Event.
var _ Event = &ZwpFullscreenShellModeFeedbackV1ModeFailedEvent{}

// ZwpFullscreenShellModeFeedbackV1PresentCancelledEvent signals when mode switch cancelled
//
// This event indicates that the attempted mode switch operation was
// cancelled.  Most likely this is because the client requested a
// second mode switch before the first one completed.
//
// Upon receiving this event, the client should destroy the
// wl_fullscreen_shell_mode_feedback object.
type ZwpFullscreenShellModeFeedbackV1PresentCancelledEvent struct {
}

// Opcode returns the event opcode for zwp_fullscreen_shell_mode_feedback_v1.present_cancelled in fullscreen_shell_unstable_v1
func (ZwpFullscreenShellModeFeedbackV1PresentCancelledEvent) Opcode() uint16 { return 2 }

// Ensure ZwpFullscreenShellModeFeedbackV1PresentCancelledEvent implements Message.
var _ Message = ZwpFullscreenShellModeFeedbackV1PresentCancelledEvent{}

// Scan scans the event from the socket.
func (e *ZwpFullscreenShellModeFeedbackV1PresentCancelledEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure ZwpFullscreenShellModeFeedbackV1PresentCancelledEvent implements Event.
var _ Event = &ZwpFullscreenShellModeFeedbackV1PresentCancelledEvent{}

// #endregion Interface fullscreen_shell_unstable_v1.zwp_fullscreen_shell_mode_feedback_v1

////////////////////////////////////////////////////////////////////////////////
// #endregion Protocol fullscreen_shell_unstable_v1

////////////////////////////////////////////////////////////////////////////////
// #region Protocol idle_inhibit_unstable_v1

// ----------------------------------------------------------------------------
// #region Interface idle_inhibit_unstable_v1.zwp_idle_inhibit_manager_v1

// ZwpIdleInhibitManagerV1DestroyRequest requests to destroy the idle inhibitor object
//
// Destroy the inhibit manager.
type ZwpIdleInhibitManagerV1DestroyRequest struct {
}

// Opcode returns the request opcode for zwp_idle_inhibit_manager_v1.destroy in idle_inhibit_unstable_v1
func (ZwpIdleInhibitManagerV1DestroyRequest) Opcode() uint16 { return 0 }

// Ensure ZwpIdleInhibitManagerV1DestroyRequest implements Message.
var _ Message = ZwpIdleInhibitManagerV1DestroyRequest{}

// ZwpIdleInhibitManagerV1CreateInhibitorRequest requests to create a new inhibitor object
//
// Create a new inhibitor object associated with the given surface.
type ZwpIdleInhibitManagerV1CreateInhibitorRequest struct {
	ID ObjectID

	// Surface contains the surface that inhibits the idle behavior
	Surface ObjectID
}

// Opcode returns the request opcode for zwp_idle_inhibit_manager_v1.create_inhibitor in idle_inhibit_unstable_v1
func (ZwpIdleInhibitManagerV1CreateInhibitorRequest) Opcode() uint16 { return 1 }

// Ensure ZwpIdleInhibitManagerV1CreateInhibitorRequest implements Message.
var _ Message = ZwpIdleInhibitManagerV1CreateInhibitorRequest{}

// #endregion Interface idle_inhibit_unstable_v1.zwp_idle_inhibit_manager_v1

// ----------------------------------------------------------------------------
// #region Interface idle_inhibit_unstable_v1.zwp_idle_inhibitor_v1

// ZwpIdleInhibitorV1DestroyRequest requests to destroy the idle inhibitor object
//
// Remove the inhibitor effect from the associated wl_surface.
type ZwpIdleInhibitorV1DestroyRequest struct {
}

// Opcode returns the request opcode for zwp_idle_inhibitor_v1.destroy in idle_inhibit_unstable_v1
func (ZwpIdleInhibitorV1DestroyRequest) Opcode() uint16 { return 0 }

// Ensure ZwpIdleInhibitorV1DestroyRequest implements Message.
var _ Message = ZwpIdleInhibitorV1DestroyRequest{}

// #endregion Interface idle_inhibit_unstable_v1.zwp_idle_inhibitor_v1

////////////////////////////////////////////////////////////////////////////////
// #endregion Protocol idle_inhibit_unstable_v1

////////////////////////////////////////////////////////////////////////////////
// #region Protocol input_method_unstable_v1

// ----------------------------------------------------------------------------
// #region Interface input_method_unstable_v1.zwp_input_method_context_v1

type ZwpInputMethodContextV1DestroyRequest struct {
}

// Opcode returns the request opcode for zwp_input_method_context_v1.destroy in input_method_unstable_v1
func (ZwpInputMethodContextV1DestroyRequest) Opcode() uint16 { return 0 }

// Ensure ZwpInputMethodContextV1DestroyRequest implements Message.
var _ Message = ZwpInputMethodContextV1DestroyRequest{}

// ZwpInputMethodContextV1CommitStringRequest requests to commit string
//
// Send the commit string text for insertion to the application.
//
// The text to commit could be either just a single character after a key
// press or the result of some composing (pre-edit). It could be also an
// empty text when some text should be removed (see
// delete_surrounding_text) or when the input cursor should be moved (see
// cursor_position).
//
// Any previously set composing text will be removed.
type ZwpInputMethodContextV1CommitStringRequest struct {
	// Serial contains serial of the latest known text input state
	Serial uint32

	Text string
}

// Opcode returns the request opcode for zwp_input_method_context_v1.commit_string in input_method_unstable_v1
func (ZwpInputMethodContextV1CommitStringRequest) Opcode() uint16 { return 1 }

// Ensure ZwpInputMethodContextV1CommitStringRequest implements Message.
var _ Message = ZwpInputMethodContextV1CommitStringRequest{}

// ZwpInputMethodContextV1PreeditStringRequest requests to pre-edit string
//
// Send the pre-edit string text to the application text input.
//
// The commit text can be used to replace the pre-edit text on reset (for
// example on unfocus).
//
// Previously sent preedit_style and preedit_cursor requests are also
// processed by the text_input.
type ZwpInputMethodContextV1PreeditStringRequest struct {
	// Serial contains serial of the latest known text input state
	Serial uint32

	Text string

	Commit string
}

// Opcode returns the request opcode for zwp_input_method_context_v1.preedit_string in input_method_unstable_v1
func (ZwpInputMethodContextV1PreeditStringRequest) Opcode() uint16 { return 2 }

// Ensure ZwpInputMethodContextV1PreeditStringRequest implements Message.
var _ Message = ZwpInputMethodContextV1PreeditStringRequest{}

// ZwpInputMethodContextV1PreeditStylingRequest requests to pre-edit styling
//
// Set the styling information on composing text. The style is applied for
// length in bytes from index relative to the beginning of
// the composing text (as byte offset). Multiple styles can
// be applied to a composing text.
//
// This request should be sent before sending a preedit_string request.
type ZwpInputMethodContextV1PreeditStylingRequest struct {
	Index uint32

	Length uint32

	Style uint32
}

// Opcode returns the request opcode for zwp_input_method_context_v1.preedit_styling in input_method_unstable_v1
func (ZwpInputMethodContextV1PreeditStylingRequest) Opcode() uint16 { return 3 }

// Ensure ZwpInputMethodContextV1PreeditStylingRequest implements Message.
var _ Message = ZwpInputMethodContextV1PreeditStylingRequest{}

// ZwpInputMethodContextV1PreeditCursorRequest requests to pre-edit cursor
//
// Set the cursor position inside the composing text (as byte offset)
// relative to the start of the composing text.
//
// When index is negative no cursor should be displayed.
//
// This request should be sent before sending a preedit_string request.
type ZwpInputMethodContextV1PreeditCursorRequest struct {
	Index int32
}

// Opcode returns the request opcode for zwp_input_method_context_v1.preedit_cursor in input_method_unstable_v1
func (ZwpInputMethodContextV1PreeditCursorRequest) Opcode() uint16 { return 4 }

// Ensure ZwpInputMethodContextV1PreeditCursorRequest implements Message.
var _ Message = ZwpInputMethodContextV1PreeditCursorRequest{}

// ZwpInputMethodContextV1DeleteSurroundingTextRequest requests to delete text
//
// Remove the surrounding text.
//
// This request will be handled on the text_input side directly following
// a commit_string request.
type ZwpInputMethodContextV1DeleteSurroundingTextRequest struct {
	Index int32

	Length uint32
}

// Opcode returns the request opcode for zwp_input_method_context_v1.delete_surrounding_text in input_method_unstable_v1
func (ZwpInputMethodContextV1DeleteSurroundingTextRequest) Opcode() uint16 { return 5 }

// Ensure ZwpInputMethodContextV1DeleteSurroundingTextRequest implements Message.
var _ Message = ZwpInputMethodContextV1DeleteSurroundingTextRequest{}

// ZwpInputMethodContextV1CursorPositionRequest requests to set cursor to a new position
//
// Set the cursor and anchor to a new position. Index is the new cursor
// position in bytes (when >= 0 this is relative to the end of the inserted text,
// otherwise it is relative to the beginning of the inserted text). Anchor is
// the new anchor position in bytes (when >= 0 this is relative to the end of the
// inserted text, otherwise it is relative to the beginning of the inserted
// text). When there should be no selected text, anchor should be the same
// as index.
//
// This request will be handled on the text_input side directly following
// a commit_string request.
type ZwpInputMethodContextV1CursorPositionRequest struct {
	Index int32

	Anchor int32
}

// Opcode returns the request opcode for zwp_input_method_context_v1.cursor_position in input_method_unstable_v1
func (ZwpInputMethodContextV1CursorPositionRequest) Opcode() uint16 { return 6 }

// Ensure ZwpInputMethodContextV1CursorPositionRequest implements Message.
var _ Message = ZwpInputMethodContextV1CursorPositionRequest{}

type ZwpInputMethodContextV1ModifiersMapRequest struct {
	Map []byte
}

// Opcode returns the request opcode for zwp_input_method_context_v1.modifiers_map in input_method_unstable_v1
func (ZwpInputMethodContextV1ModifiersMapRequest) Opcode() uint16 { return 7 }

// Ensure ZwpInputMethodContextV1ModifiersMapRequest implements Message.
var _ Message = ZwpInputMethodContextV1ModifiersMapRequest{}

// ZwpInputMethodContextV1KeysymRequest requests to keysym
//
// Notify when a key event was sent. Key events should not be used for
// normal text input operations, which should be done with commit_string,
// delete_surrounding_text, etc. The key event follows the wl_keyboard key
// event convention. Sym is an XKB keysym, state is a wl_keyboard key_state.
type ZwpInputMethodContextV1KeysymRequest struct {
	// Serial contains serial of the latest known text input state
	Serial uint32

	Time uint32

	Sym uint32

	State uint32

	Modifiers uint32
}

// Opcode returns the request opcode for zwp_input_method_context_v1.keysym in input_method_unstable_v1
func (ZwpInputMethodContextV1KeysymRequest) Opcode() uint16 { return 8 }

// Ensure ZwpInputMethodContextV1KeysymRequest implements Message.
var _ Message = ZwpInputMethodContextV1KeysymRequest{}

// ZwpInputMethodContextV1GrabKeyboardRequest requests to grab hardware keyboard
//
// Allow an input method to receive hardware keyboard input and process
// key events to generate text events (with pre-edit) over the wire. This
// allows input methods which compose multiple key events for inputting
// text like it is done for CJK languages.
type ZwpInputMethodContextV1GrabKeyboardRequest struct {
	Keyboard ObjectID
}

// Opcode returns the request opcode for zwp_input_method_context_v1.grab_keyboard in input_method_unstable_v1
func (ZwpInputMethodContextV1GrabKeyboardRequest) Opcode() uint16 { return 9 }

// Ensure ZwpInputMethodContextV1GrabKeyboardRequest implements Message.
var _ Message = ZwpInputMethodContextV1GrabKeyboardRequest{}

// ZwpInputMethodContextV1KeyRequest requests to forward key event
//
// Forward a wl_keyboard::key event to the client that was not processed
// by the input method itself. Should be used when filtering key events
// with grab_keyboard.  The arguments should be the ones from the
// wl_keyboard::key event.
//
// For generating custom key events use the keysym request instead.
type ZwpInputMethodContextV1KeyRequest struct {
	// Serial contains serial from wl_keyboard::key
	Serial uint32

	// Time contains time from wl_keyboard::key
	Time uint32

	// Key contains key from wl_keyboard::key
	Key uint32

	// State contains state from wl_keyboard::key
	State uint32
}

// Opcode returns the request opcode for zwp_input_method_context_v1.key in input_method_unstable_v1
func (ZwpInputMethodContextV1KeyRequest) Opcode() uint16 { return 10 }

// Ensure ZwpInputMethodContextV1KeyRequest implements Message.
var _ Message = ZwpInputMethodContextV1KeyRequest{}

// ZwpInputMethodContextV1ModifiersRequest requests to forward modifiers event
//
// Forward a wl_keyboard::modifiers event to the client that was not
// processed by the input method itself.  Should be used when filtering
// key events with grab_keyboard. The arguments should be the ones
// from the wl_keyboard::modifiers event.
type ZwpInputMethodContextV1ModifiersRequest struct {
	// Serial contains serial from wl_keyboard::modifiers
	Serial uint32

	// ModsDepressed contains mods_depressed from wl_keyboard::modifiers
	ModsDepressed uint32

	// ModsLatched contains mods_latched from wl_keyboard::modifiers
	ModsLatched uint32

	// ModsLocked contains mods_locked from wl_keyboard::modifiers
	ModsLocked uint32

	// Group contains group from wl_keyboard::modifiers
	Group uint32
}

// Opcode returns the request opcode for zwp_input_method_context_v1.modifiers in input_method_unstable_v1
func (ZwpInputMethodContextV1ModifiersRequest) Opcode() uint16 { return 11 }

// Ensure ZwpInputMethodContextV1ModifiersRequest implements Message.
var _ Message = ZwpInputMethodContextV1ModifiersRequest{}

type ZwpInputMethodContextV1LanguageRequest struct {
	// Serial contains serial of the latest known text input state
	Serial uint32

	Language string
}

// Opcode returns the request opcode for zwp_input_method_context_v1.language in input_method_unstable_v1
func (ZwpInputMethodContextV1LanguageRequest) Opcode() uint16 { return 12 }

// Ensure ZwpInputMethodContextV1LanguageRequest implements Message.
var _ Message = ZwpInputMethodContextV1LanguageRequest{}

type ZwpInputMethodContextV1TextDirectionRequest struct {
	// Serial contains serial of the latest known text input state
	Serial uint32

	Direction uint32
}

// Opcode returns the request opcode for zwp_input_method_context_v1.text_direction in input_method_unstable_v1
func (ZwpInputMethodContextV1TextDirectionRequest) Opcode() uint16 { return 13 }

// Ensure ZwpInputMethodContextV1TextDirectionRequest implements Message.
var _ Message = ZwpInputMethodContextV1TextDirectionRequest{}

// ZwpInputMethodContextV1SurroundingTextEvent signals when surrounding text event
//
// The plain surrounding text around the input position. Cursor is the
// position in bytes within the surrounding text relative to the beginning
// of the text. Anchor is the position in bytes of the selection anchor
// within the surrounding text relative to the beginning of the text. If
// there is no selected text then anchor is the same as cursor.
type ZwpInputMethodContextV1SurroundingTextEvent struct {
	Text string

	Cursor uint32

	Anchor uint32
}

// Opcode returns the event opcode for zwp_input_method_context_v1.surrounding_text in input_method_unstable_v1
func (ZwpInputMethodContextV1SurroundingTextEvent) Opcode() uint16 { return 0 }

// Ensure ZwpInputMethodContextV1SurroundingTextEvent implements Message.
var _ Message = ZwpInputMethodContextV1SurroundingTextEvent{}

// Scan scans the event from the socket.
func (e *ZwpInputMethodContextV1SurroundingTextEvent) Scan(s *EventScanner) error {
	if v, err := s.String(); err != nil {
		return err
	} else {
		e.Text = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Cursor = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Anchor = v
	}
	return nil
}

// Ensure ZwpInputMethodContextV1SurroundingTextEvent implements Event.
var _ Event = &ZwpInputMethodContextV1SurroundingTextEvent{}

type ZwpInputMethodContextV1ResetEvent struct {
}

// Opcode returns the event opcode for zwp_input_method_context_v1.reset in input_method_unstable_v1
func (ZwpInputMethodContextV1ResetEvent) Opcode() uint16 { return 1 }

// Ensure ZwpInputMethodContextV1ResetEvent implements Message.
var _ Message = ZwpInputMethodContextV1ResetEvent{}

// Scan scans the event from the socket.
func (e *ZwpInputMethodContextV1ResetEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure ZwpInputMethodContextV1ResetEvent implements Event.
var _ Event = &ZwpInputMethodContextV1ResetEvent{}

type ZwpInputMethodContextV1ContentTypeEvent struct {
	Hint uint32

	Purpose uint32
}

// Opcode returns the event opcode for zwp_input_method_context_v1.content_type in input_method_unstable_v1
func (ZwpInputMethodContextV1ContentTypeEvent) Opcode() uint16 { return 2 }

// Ensure ZwpInputMethodContextV1ContentTypeEvent implements Message.
var _ Message = ZwpInputMethodContextV1ContentTypeEvent{}

// Scan scans the event from the socket.
func (e *ZwpInputMethodContextV1ContentTypeEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Hint = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Purpose = v
	}
	return nil
}

// Ensure ZwpInputMethodContextV1ContentTypeEvent implements Event.
var _ Event = &ZwpInputMethodContextV1ContentTypeEvent{}

type ZwpInputMethodContextV1InvokeActionEvent struct {
	Button uint32

	Index uint32
}

// Opcode returns the event opcode for zwp_input_method_context_v1.invoke_action in input_method_unstable_v1
func (ZwpInputMethodContextV1InvokeActionEvent) Opcode() uint16 { return 3 }

// Ensure ZwpInputMethodContextV1InvokeActionEvent implements Message.
var _ Message = ZwpInputMethodContextV1InvokeActionEvent{}

// Scan scans the event from the socket.
func (e *ZwpInputMethodContextV1InvokeActionEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Button = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Index = v
	}
	return nil
}

// Ensure ZwpInputMethodContextV1InvokeActionEvent implements Event.
var _ Event = &ZwpInputMethodContextV1InvokeActionEvent{}

type ZwpInputMethodContextV1CommitStateEvent struct {
	// Serial contains serial of text input state
	Serial uint32
}

// Opcode returns the event opcode for zwp_input_method_context_v1.commit_state in input_method_unstable_v1
func (ZwpInputMethodContextV1CommitStateEvent) Opcode() uint16 { return 4 }

// Ensure ZwpInputMethodContextV1CommitStateEvent implements Message.
var _ Message = ZwpInputMethodContextV1CommitStateEvent{}

// Scan scans the event from the socket.
func (e *ZwpInputMethodContextV1CommitStateEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Serial = v
	}
	return nil
}

// Ensure ZwpInputMethodContextV1CommitStateEvent implements Event.
var _ Event = &ZwpInputMethodContextV1CommitStateEvent{}

type ZwpInputMethodContextV1PreferredLanguageEvent struct {
	Language string
}

// Opcode returns the event opcode for zwp_input_method_context_v1.preferred_language in input_method_unstable_v1
func (ZwpInputMethodContextV1PreferredLanguageEvent) Opcode() uint16 { return 5 }

// Ensure ZwpInputMethodContextV1PreferredLanguageEvent implements Message.
var _ Message = ZwpInputMethodContextV1PreferredLanguageEvent{}

// Scan scans the event from the socket.
func (e *ZwpInputMethodContextV1PreferredLanguageEvent) Scan(s *EventScanner) error {
	if v, err := s.String(); err != nil {
		return err
	} else {
		e.Language = v
	}
	return nil
}

// Ensure ZwpInputMethodContextV1PreferredLanguageEvent implements Event.
var _ Event = &ZwpInputMethodContextV1PreferredLanguageEvent{}

// #endregion Interface input_method_unstable_v1.zwp_input_method_context_v1

// ----------------------------------------------------------------------------
// #region Interface input_method_unstable_v1.zwp_input_method_v1

// ZwpInputMethodV1ActivateEvent signals when activate event
//
// A text input was activated. Creates an input method context object
// which allows communication with the text input.
type ZwpInputMethodV1ActivateEvent struct {
	ID ObjectID
}

// Opcode returns the event opcode for zwp_input_method_v1.activate in input_method_unstable_v1
func (ZwpInputMethodV1ActivateEvent) Opcode() uint16 { return 0 }

// Ensure ZwpInputMethodV1ActivateEvent implements Message.
var _ Message = ZwpInputMethodV1ActivateEvent{}

// Scan scans the event from the socket.
func (e *ZwpInputMethodV1ActivateEvent) Scan(s *EventScanner) error {
	if v, err := s.ObjectID(); err != nil {
		return err
	} else {
		e.ID = v
	}
	return nil
}

// Ensure ZwpInputMethodV1ActivateEvent implements Event.
var _ Event = &ZwpInputMethodV1ActivateEvent{}

// ZwpInputMethodV1DeactivateEvent signals when deactivate event
//
// The text input corresponding to the context argument was deactivated.
// The input method context should be destroyed after deactivation is
// handled.
type ZwpInputMethodV1DeactivateEvent struct {
	Context ObjectID
}

// Opcode returns the event opcode for zwp_input_method_v1.deactivate in input_method_unstable_v1
func (ZwpInputMethodV1DeactivateEvent) Opcode() uint16 { return 1 }

// Ensure ZwpInputMethodV1DeactivateEvent implements Message.
var _ Message = ZwpInputMethodV1DeactivateEvent{}

// Scan scans the event from the socket.
func (e *ZwpInputMethodV1DeactivateEvent) Scan(s *EventScanner) error {
	if v, err := s.ObjectID(); err != nil {
		return err
	} else {
		e.Context = v
	}
	return nil
}

// Ensure ZwpInputMethodV1DeactivateEvent implements Event.
var _ Event = &ZwpInputMethodV1DeactivateEvent{}

// #endregion Interface input_method_unstable_v1.zwp_input_method_v1

// ----------------------------------------------------------------------------
// #region Interface input_method_unstable_v1.zwp_input_panel_v1

type ZwpInputPanelV1GetInputPanelSurfaceRequest struct {
	ID ObjectID

	Surface ObjectID
}

// Opcode returns the request opcode for zwp_input_panel_v1.get_input_panel_surface in input_method_unstable_v1
func (ZwpInputPanelV1GetInputPanelSurfaceRequest) Opcode() uint16 { return 0 }

// Ensure ZwpInputPanelV1GetInputPanelSurfaceRequest implements Message.
var _ Message = ZwpInputPanelV1GetInputPanelSurfaceRequest{}

// #endregion Interface input_method_unstable_v1.zwp_input_panel_v1

// ----------------------------------------------------------------------------
// #region Interface input_method_unstable_v1.zwp_input_panel_surface_v1

type ZwpInputPanelSurfaceV1Position int

const (
	ZwpInputPanelSurfaceV1PositionCenterBottom ZwpInputPanelSurfaceV1Position = 0
)

// ZwpInputPanelSurfaceV1SetToplevelRequest requests to set the surface type as a keyboard
//
// Set the input_panel_surface type to keyboard.
//
// A keyboard surface is only shown when a text input is active.
type ZwpInputPanelSurfaceV1SetToplevelRequest struct {
	Output ObjectID

	Position uint32
}

// Opcode returns the request opcode for zwp_input_panel_surface_v1.set_toplevel in input_method_unstable_v1
func (ZwpInputPanelSurfaceV1SetToplevelRequest) Opcode() uint16 { return 0 }

// Ensure ZwpInputPanelSurfaceV1SetToplevelRequest implements Message.
var _ Message = ZwpInputPanelSurfaceV1SetToplevelRequest{}

// ZwpInputPanelSurfaceV1SetOverlayPanelRequest requests to set the surface type as an overlay panel
//
// Set the input_panel_surface to be an overlay panel.
//
// This is shown near the input cursor above the application window when
// a text input is active.
type ZwpInputPanelSurfaceV1SetOverlayPanelRequest struct {
}

// Opcode returns the request opcode for zwp_input_panel_surface_v1.set_overlay_panel in input_method_unstable_v1
func (ZwpInputPanelSurfaceV1SetOverlayPanelRequest) Opcode() uint16 { return 1 }

// Ensure ZwpInputPanelSurfaceV1SetOverlayPanelRequest implements Message.
var _ Message = ZwpInputPanelSurfaceV1SetOverlayPanelRequest{}

// #endregion Interface input_method_unstable_v1.zwp_input_panel_surface_v1

////////////////////////////////////////////////////////////////////////////////
// #endregion Protocol input_method_unstable_v1

////////////////////////////////////////////////////////////////////////////////
// #region Protocol input_timestamps_unstable_v1

// ----------------------------------------------------------------------------
// #region Interface input_timestamps_unstable_v1.zwp_input_timestamps_manager_v1

// ZwpInputTimestampsManagerV1DestroyRequest requests to destroy the input timestamps manager object
//
// Informs the server that the client will no longer be using this
// protocol object. Existing objects created by this object are not
// affected.
type ZwpInputTimestampsManagerV1DestroyRequest struct {
}

// Opcode returns the request opcode for zwp_input_timestamps_manager_v1.destroy in input_timestamps_unstable_v1
func (ZwpInputTimestampsManagerV1DestroyRequest) Opcode() uint16 { return 0 }

// Ensure ZwpInputTimestampsManagerV1DestroyRequest implements Message.
var _ Message = ZwpInputTimestampsManagerV1DestroyRequest{}

// ZwpInputTimestampsManagerV1GetKeyboardTimestampsRequest requests to subscribe to high-resolution keyboard timestamp events
//
// Creates a new input timestamps object that represents a subscription
// to high-resolution timestamp events for all wl_keyboard events that
// carry a timestamp.
//
// If the associated wl_keyboard object is invalidated, either through
// client action (e.g. release) or server-side changes, the input
// timestamps object becomes inert and the client should destroy it
// by calling zwp_input_timestamps_v1.destroy.
type ZwpInputTimestampsManagerV1GetKeyboardTimestampsRequest struct {
	ID ObjectID

	// Keyboard contains the wl_keyboard object for which to get timestamp events
	Keyboard ObjectID
}

// Opcode returns the request opcode for zwp_input_timestamps_manager_v1.get_keyboard_timestamps in input_timestamps_unstable_v1
func (ZwpInputTimestampsManagerV1GetKeyboardTimestampsRequest) Opcode() uint16 { return 1 }

// Ensure ZwpInputTimestampsManagerV1GetKeyboardTimestampsRequest implements Message.
var _ Message = ZwpInputTimestampsManagerV1GetKeyboardTimestampsRequest{}

// ZwpInputTimestampsManagerV1GetPointerTimestampsRequest requests to subscribe to high-resolution pointer timestamp events
//
// Creates a new input timestamps object that represents a subscription
// to high-resolution timestamp events for all wl_pointer events that
// carry a timestamp.
//
// If the associated wl_pointer object is invalidated, either through
// client action (e.g. release) or server-side changes, the input
// timestamps object becomes inert and the client should destroy it
// by calling zwp_input_timestamps_v1.destroy.
type ZwpInputTimestampsManagerV1GetPointerTimestampsRequest struct {
	ID ObjectID

	// Pointer contains the wl_pointer object for which to get timestamp events
	Pointer ObjectID
}

// Opcode returns the request opcode for zwp_input_timestamps_manager_v1.get_pointer_timestamps in input_timestamps_unstable_v1
func (ZwpInputTimestampsManagerV1GetPointerTimestampsRequest) Opcode() uint16 { return 2 }

// Ensure ZwpInputTimestampsManagerV1GetPointerTimestampsRequest implements Message.
var _ Message = ZwpInputTimestampsManagerV1GetPointerTimestampsRequest{}

// ZwpInputTimestampsManagerV1GetTouchTimestampsRequest requests to subscribe to high-resolution touch timestamp events
//
// Creates a new input timestamps object that represents a subscription
// to high-resolution timestamp events for all wl_touch events that
// carry a timestamp.
//
// If the associated wl_touch object becomes invalid, either through
// client action (e.g. release) or server-side changes, the input
// timestamps object becomes inert and the client should destroy it
// by calling zwp_input_timestamps_v1.destroy.
type ZwpInputTimestampsManagerV1GetTouchTimestampsRequest struct {
	ID ObjectID

	// Touch contains the wl_touch object for which to get timestamp events
	Touch ObjectID
}

// Opcode returns the request opcode for zwp_input_timestamps_manager_v1.get_touch_timestamps in input_timestamps_unstable_v1
func (ZwpInputTimestampsManagerV1GetTouchTimestampsRequest) Opcode() uint16 { return 3 }

// Ensure ZwpInputTimestampsManagerV1GetTouchTimestampsRequest implements Message.
var _ Message = ZwpInputTimestampsManagerV1GetTouchTimestampsRequest{}

// #endregion Interface input_timestamps_unstable_v1.zwp_input_timestamps_manager_v1

// ----------------------------------------------------------------------------
// #region Interface input_timestamps_unstable_v1.zwp_input_timestamps_v1

// ZwpInputTimestampsV1DestroyRequest requests to destroy the input timestamps object
//
// Informs the server that the client will no longer be using this
// protocol object. After the server processes the request, no more
// timestamp events will be emitted.
type ZwpInputTimestampsV1DestroyRequest struct {
}

// Opcode returns the request opcode for zwp_input_timestamps_v1.destroy in input_timestamps_unstable_v1
func (ZwpInputTimestampsV1DestroyRequest) Opcode() uint16 { return 0 }

// Ensure ZwpInputTimestampsV1DestroyRequest implements Message.
var _ Message = ZwpInputTimestampsV1DestroyRequest{}

// ZwpInputTimestampsV1TimestampEvent signals when high-resolution timestamp event
//
// The timestamp event is associated with the first subsequent input event
// carrying a timestamp which belongs to the set of input events this
// object is subscribed to.
//
// The timestamp provided by this event is a high-resolution version of
// the timestamp argument of the associated input event. The provided
// timestamp is in the same clock domain and is at least as accurate as
// the associated input event timestamp.
//
// The timestamp is expressed as tv_sec_hi, tv_sec_lo, tv_nsec triples,
// each component being an unsigned 32-bit value. Whole seconds are in
// tv_sec which is a 64-bit value combined from tv_sec_hi and tv_sec_lo,
// and the additional fractional part in tv_nsec as nanoseconds. Hence,
// for valid timestamps tv_nsec must be in [0, 999999999].
type ZwpInputTimestampsV1TimestampEvent struct {
	// TvSecHi contains high 32 bits of the seconds part of the timestamp
	TvSecHi uint32

	// TvSecLo contains low 32 bits of the seconds part of the timestamp
	TvSecLo uint32

	// TvNsec contains nanoseconds part of the timestamp
	TvNsec uint32
}

// Opcode returns the event opcode for zwp_input_timestamps_v1.timestamp in input_timestamps_unstable_v1
func (ZwpInputTimestampsV1TimestampEvent) Opcode() uint16 { return 0 }

// Ensure ZwpInputTimestampsV1TimestampEvent implements Message.
var _ Message = ZwpInputTimestampsV1TimestampEvent{}

// Scan scans the event from the socket.
func (e *ZwpInputTimestampsV1TimestampEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.TvSecHi = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.TvSecLo = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.TvNsec = v
	}
	return nil
}

// Ensure ZwpInputTimestampsV1TimestampEvent implements Event.
var _ Event = &ZwpInputTimestampsV1TimestampEvent{}

// #endregion Interface input_timestamps_unstable_v1.zwp_input_timestamps_v1

////////////////////////////////////////////////////////////////////////////////
// #endregion Protocol input_timestamps_unstable_v1

////////////////////////////////////////////////////////////////////////////////
// #region Protocol keyboard_shortcuts_inhibit_unstable_v1

// ----------------------------------------------------------------------------
// #region Interface keyboard_shortcuts_inhibit_unstable_v1.zwp_keyboard_shortcuts_inhibit_manager_v1

type ZwpKeyboardShortcutsInhibitManagerV1Error int

const (
	// ZwpKeyboardShortcutsInhibitManagerV1ErrorAlreadyInhibited corresponds to the shortcuts are already inhibited for this surface
	ZwpKeyboardShortcutsInhibitManagerV1ErrorAlreadyInhibited ZwpKeyboardShortcutsInhibitManagerV1Error = 0
)

// ZwpKeyboardShortcutsInhibitManagerV1DestroyRequest requests to destroy the keyboard shortcuts inhibitor object
//
// Destroy the keyboard shortcuts inhibitor manager.
type ZwpKeyboardShortcutsInhibitManagerV1DestroyRequest struct {
}

// Opcode returns the request opcode for zwp_keyboard_shortcuts_inhibit_manager_v1.destroy in keyboard_shortcuts_inhibit_unstable_v1
func (ZwpKeyboardShortcutsInhibitManagerV1DestroyRequest) Opcode() uint16 { return 0 }

// Ensure ZwpKeyboardShortcutsInhibitManagerV1DestroyRequest implements Message.
var _ Message = ZwpKeyboardShortcutsInhibitManagerV1DestroyRequest{}

// ZwpKeyboardShortcutsInhibitManagerV1InhibitShortcutsRequest requests to create a new keyboard shortcuts inhibitor object
//
// Create a new keyboard shortcuts inhibitor object associated with
// the given surface for the given seat.
//
// If shortcuts are already inhibited for the specified seat and surface,
// a protocol error "already_inhibited" is raised by the compositor.
type ZwpKeyboardShortcutsInhibitManagerV1InhibitShortcutsRequest struct {
	ID ObjectID

	// Surface contains the surface that inhibits the keyboard shortcuts behavior
	Surface ObjectID

	// Seat contains the wl_seat for which keyboard shortcuts should be disabled
	Seat ObjectID
}

// Opcode returns the request opcode for zwp_keyboard_shortcuts_inhibit_manager_v1.inhibit_shortcuts in keyboard_shortcuts_inhibit_unstable_v1
func (ZwpKeyboardShortcutsInhibitManagerV1InhibitShortcutsRequest) Opcode() uint16 { return 1 }

// Ensure ZwpKeyboardShortcutsInhibitManagerV1InhibitShortcutsRequest implements Message.
var _ Message = ZwpKeyboardShortcutsInhibitManagerV1InhibitShortcutsRequest{}

// #endregion Interface keyboard_shortcuts_inhibit_unstable_v1.zwp_keyboard_shortcuts_inhibit_manager_v1

// ----------------------------------------------------------------------------
// #region Interface keyboard_shortcuts_inhibit_unstable_v1.zwp_keyboard_shortcuts_inhibitor_v1

// ZwpKeyboardShortcutsInhibitorV1DestroyRequest requests to destroy the keyboard shortcuts inhibitor object
//
// Remove the keyboard shortcuts inhibitor from the associated wl_surface.
type ZwpKeyboardShortcutsInhibitorV1DestroyRequest struct {
}

// Opcode returns the request opcode for zwp_keyboard_shortcuts_inhibitor_v1.destroy in keyboard_shortcuts_inhibit_unstable_v1
func (ZwpKeyboardShortcutsInhibitorV1DestroyRequest) Opcode() uint16 { return 0 }

// Ensure ZwpKeyboardShortcutsInhibitorV1DestroyRequest implements Message.
var _ Message = ZwpKeyboardShortcutsInhibitorV1DestroyRequest{}

// ZwpKeyboardShortcutsInhibitorV1ActiveEvent signals when shortcuts are inhibited
//
// This event indicates that the shortcut inhibitor is active.
//
// The compositor sends this event every time compositor shortcuts
// are inhibited on behalf of the surface. When active, the client
// may receive input events normally reserved by the compositor
// (see zwp_keyboard_shortcuts_inhibitor_v1).
//
// This occurs typically when the initial request "inhibit_shortcuts"
// first becomes active or when the user instructs the compositor to
// re-enable and existing shortcuts inhibitor using any mechanism
// offered by the compositor.
type ZwpKeyboardShortcutsInhibitorV1ActiveEvent struct {
}

// Opcode returns the event opcode for zwp_keyboard_shortcuts_inhibitor_v1.active in keyboard_shortcuts_inhibit_unstable_v1
func (ZwpKeyboardShortcutsInhibitorV1ActiveEvent) Opcode() uint16 { return 0 }

// Ensure ZwpKeyboardShortcutsInhibitorV1ActiveEvent implements Message.
var _ Message = ZwpKeyboardShortcutsInhibitorV1ActiveEvent{}

// Scan scans the event from the socket.
func (e *ZwpKeyboardShortcutsInhibitorV1ActiveEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure ZwpKeyboardShortcutsInhibitorV1ActiveEvent implements Event.
var _ Event = &ZwpKeyboardShortcutsInhibitorV1ActiveEvent{}

// ZwpKeyboardShortcutsInhibitorV1InactiveEvent signals when shortcuts are restored
//
// This event indicates that the shortcuts inhibitor is inactive,
// normal shortcuts processing is restored by the compositor.
type ZwpKeyboardShortcutsInhibitorV1InactiveEvent struct {
}

// Opcode returns the event opcode for zwp_keyboard_shortcuts_inhibitor_v1.inactive in keyboard_shortcuts_inhibit_unstable_v1
func (ZwpKeyboardShortcutsInhibitorV1InactiveEvent) Opcode() uint16 { return 1 }

// Ensure ZwpKeyboardShortcutsInhibitorV1InactiveEvent implements Message.
var _ Message = ZwpKeyboardShortcutsInhibitorV1InactiveEvent{}

// Scan scans the event from the socket.
func (e *ZwpKeyboardShortcutsInhibitorV1InactiveEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure ZwpKeyboardShortcutsInhibitorV1InactiveEvent implements Event.
var _ Event = &ZwpKeyboardShortcutsInhibitorV1InactiveEvent{}

// #endregion Interface keyboard_shortcuts_inhibit_unstable_v1.zwp_keyboard_shortcuts_inhibitor_v1

////////////////////////////////////////////////////////////////////////////////
// #endregion Protocol keyboard_shortcuts_inhibit_unstable_v1

////////////////////////////////////////////////////////////////////////////////
// #region Protocol linux_dmabuf_unstable_v1

// ----------------------------------------------------------------------------
// #region Interface linux_dmabuf_unstable_v1.zwp_linux_dmabuf_v1

// ZwpLinuxDmabufV1DestroyRequest requests to unbind the factory
//
// Objects created through this interface, especially wl_buffers, will
// remain valid.
type ZwpLinuxDmabufV1DestroyRequest struct {
}

// Opcode returns the request opcode for zwp_linux_dmabuf_v1.destroy in linux_dmabuf_unstable_v1
func (ZwpLinuxDmabufV1DestroyRequest) Opcode() uint16 { return 0 }

// Ensure ZwpLinuxDmabufV1DestroyRequest implements Message.
var _ Message = ZwpLinuxDmabufV1DestroyRequest{}

// ZwpLinuxDmabufV1CreateParamsRequest requests to create a temporary object for buffer parameters
//
// This temporary object is used to collect multiple dmabuf handles into
// a single batch to create a wl_buffer. It can only be used once and
// should be destroyed after a 'created' or 'failed' event has been
// received.
type ZwpLinuxDmabufV1CreateParamsRequest struct {
	// ParamsID contains the new temporary
	ParamsID ObjectID
}

// Opcode returns the request opcode for zwp_linux_dmabuf_v1.create_params in linux_dmabuf_unstable_v1
func (ZwpLinuxDmabufV1CreateParamsRequest) Opcode() uint16 { return 1 }

// Ensure ZwpLinuxDmabufV1CreateParamsRequest implements Message.
var _ Message = ZwpLinuxDmabufV1CreateParamsRequest{}

// ZwpLinuxDmabufV1FormatEvent signals when supported buffer format
//
// This event advertises one buffer format that the server supports.
// All the supported formats are advertised once when the client
// binds to this interface. A roundtrip after binding guarantees
// that the client has received all supported formats.
//
// For the definition of the format codes, see the
// zwp_linux_buffer_params_v1::create request.
//
// Warning: the 'format' event is likely to be deprecated and replaced
// with the 'modifier' event introduced in zwp_linux_dmabuf_v1
// version 3, described below. Please refrain from using the information
// received from this event.
type ZwpLinuxDmabufV1FormatEvent struct {
	// Format contains DRM_FORMAT code
	Format uint32
}

// Opcode returns the event opcode for zwp_linux_dmabuf_v1.format in linux_dmabuf_unstable_v1
func (ZwpLinuxDmabufV1FormatEvent) Opcode() uint16 { return 0 }

// Ensure ZwpLinuxDmabufV1FormatEvent implements Message.
var _ Message = ZwpLinuxDmabufV1FormatEvent{}

// Scan scans the event from the socket.
func (e *ZwpLinuxDmabufV1FormatEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Format = v
	}
	return nil
}

// Ensure ZwpLinuxDmabufV1FormatEvent implements Event.
var _ Event = &ZwpLinuxDmabufV1FormatEvent{}

// ZwpLinuxDmabufV1ModifierEvent signals when supported buffer format modifier
//
// This event advertises the formats that the server supports, along with
// the modifiers supported for each format. All the supported modifiers
// for all the supported formats are advertised once when the client
// binds to this interface. A roundtrip after binding guarantees that
// the client has received all supported format-modifier pairs.
//
// For legacy support, DRM_FORMAT_MOD_INVALID (that is, modifier_hi ==
// 0x00ffffff and modifier_lo == 0xffffffff) is allowed in this event.
// It indicates that the server can support the format with an implicit
// modifier. When a plane has DRM_FORMAT_MOD_INVALID as its modifier, it
// is as if no explicit modifier is specified. The effective modifier
// will be derived from the dmabuf.
//
// A compositor that sends valid modifiers and DRM_FORMAT_MOD_INVALID for
// a given format supports both explicit modifiers and implicit modifiers.
//
// For the definition of the format and modifier codes, see the
// zwp_linux_buffer_params_v1::create and zwp_linux_buffer_params_v1::add
// requests.
type ZwpLinuxDmabufV1ModifierEvent struct {
	// Format contains DRM_FORMAT code
	Format uint32

	// ModifierHi contains high 32 bits of layout modifier
	ModifierHi uint32

	// ModifierLo contains low 32 bits of layout modifier
	ModifierLo uint32
}

// Opcode returns the event opcode for zwp_linux_dmabuf_v1.modifier in linux_dmabuf_unstable_v1
func (ZwpLinuxDmabufV1ModifierEvent) Opcode() uint16 { return 1 }

// Ensure ZwpLinuxDmabufV1ModifierEvent implements Message.
var _ Message = ZwpLinuxDmabufV1ModifierEvent{}

// Scan scans the event from the socket.
func (e *ZwpLinuxDmabufV1ModifierEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Format = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.ModifierHi = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.ModifierLo = v
	}
	return nil
}

// Ensure ZwpLinuxDmabufV1ModifierEvent implements Event.
var _ Event = &ZwpLinuxDmabufV1ModifierEvent{}

// #endregion Interface linux_dmabuf_unstable_v1.zwp_linux_dmabuf_v1

// ----------------------------------------------------------------------------
// #region Interface linux_dmabuf_unstable_v1.zwp_linux_buffer_params_v1

type ZwpLinuxBufferParamsV1Error int

const (
	// ZwpLinuxBufferParamsV1ErrorAlreadyUsed corresponds to the dmabuf_batch object has already been used to create a wl_buffer
	ZwpLinuxBufferParamsV1ErrorAlreadyUsed ZwpLinuxBufferParamsV1Error = 0

	// ZwpLinuxBufferParamsV1ErrorPlaneIdx corresponds to plane index out of bounds
	ZwpLinuxBufferParamsV1ErrorPlaneIdx ZwpLinuxBufferParamsV1Error = 1

	// ZwpLinuxBufferParamsV1ErrorPlaneSet corresponds to the plane index was already set
	ZwpLinuxBufferParamsV1ErrorPlaneSet ZwpLinuxBufferParamsV1Error = 2

	// ZwpLinuxBufferParamsV1ErrorIncomplete corresponds to missing or too many planes to create a buffer
	ZwpLinuxBufferParamsV1ErrorIncomplete ZwpLinuxBufferParamsV1Error = 3

	// ZwpLinuxBufferParamsV1ErrorInvalidFormat corresponds to format not supported
	ZwpLinuxBufferParamsV1ErrorInvalidFormat ZwpLinuxBufferParamsV1Error = 4

	// ZwpLinuxBufferParamsV1ErrorInvalidDimensions corresponds to invalid width or height
	ZwpLinuxBufferParamsV1ErrorInvalidDimensions ZwpLinuxBufferParamsV1Error = 5

	// ZwpLinuxBufferParamsV1ErrorOutOfBounds corresponds to offset + stride * height goes out of dmabuf bounds
	ZwpLinuxBufferParamsV1ErrorOutOfBounds ZwpLinuxBufferParamsV1Error = 6

	// ZwpLinuxBufferParamsV1ErrorInvalidWlBuffer corresponds to invalid wl_buffer resulted from importing dmabufs via the create_immed request on given buffer_params
	ZwpLinuxBufferParamsV1ErrorInvalidWlBuffer ZwpLinuxBufferParamsV1Error = 7
)

type ZwpLinuxBufferParamsV1Flags uint

const (
	// ZwpLinuxBufferParamsV1FlagsYInvert corresponds to contents are y-inverted
	ZwpLinuxBufferParamsV1FlagsYInvert ZwpLinuxBufferParamsV1Flags = 1

	// ZwpLinuxBufferParamsV1FlagsInterlaced corresponds to content is interlaced
	ZwpLinuxBufferParamsV1FlagsInterlaced ZwpLinuxBufferParamsV1Flags = 2

	// ZwpLinuxBufferParamsV1FlagsBottomFirst corresponds to bottom field first
	ZwpLinuxBufferParamsV1FlagsBottomFirst ZwpLinuxBufferParamsV1Flags = 4
)

// ZwpLinuxBufferParamsV1DestroyRequest requests to delete this object, used or not
//
// Cleans up the temporary data sent to the server for dmabuf-based
// wl_buffer creation.
type ZwpLinuxBufferParamsV1DestroyRequest struct {
}

// Opcode returns the request opcode for zwp_linux_buffer_params_v1.destroy in linux_dmabuf_unstable_v1
func (ZwpLinuxBufferParamsV1DestroyRequest) Opcode() uint16 { return 0 }

// Ensure ZwpLinuxBufferParamsV1DestroyRequest implements Message.
var _ Message = ZwpLinuxBufferParamsV1DestroyRequest{}

// ZwpLinuxBufferParamsV1AddRequest requests to add a dmabuf to the temporary set
//
// This request adds one dmabuf to the set in this
// zwp_linux_buffer_params_v1.
//
// The 64-bit unsigned value combined from modifier_hi and modifier_lo
// is the dmabuf layout modifier. DRM AddFB2 ioctl calls this the
// fb modifier, which is defined in drm_mode.h of Linux UAPI.
// This is an opaque token. Drivers use this token to express tiling,
// compression, etc. driver-specific modifications to the base format
// defined by the DRM fourcc code.
//
// Warning: It should be an error if the format/modifier pair was not
// advertised with the modifier event. This is not enforced yet because
// some implementations always accept DRM_FORMAT_MOD_INVALID. Also
// version 2 of this protocol does not have the modifier event.
//
// This request raises the PLANE_IDX error if plane_idx is too large.
// The error PLANE_SET is raised if attempting to set a plane that
// was already set.
type ZwpLinuxBufferParamsV1AddRequest struct {
	// FD contains dmabuf fd
	FD FD

	// PlaneIdx contains plane index
	PlaneIdx uint32

	// Offset contains offset in bytes
	Offset uint32

	// Stride contains stride in bytes
	Stride uint32

	// ModifierHi contains high 32 bits of layout modifier
	ModifierHi uint32

	// ModifierLo contains low 32 bits of layout modifier
	ModifierLo uint32
}

// Opcode returns the request opcode for zwp_linux_buffer_params_v1.add in linux_dmabuf_unstable_v1
func (ZwpLinuxBufferParamsV1AddRequest) Opcode() uint16 { return 1 }

// Ensure ZwpLinuxBufferParamsV1AddRequest implements Message.
var _ Message = ZwpLinuxBufferParamsV1AddRequest{}

// ZwpLinuxBufferParamsV1CreateRequest requests to create a wl_buffer from the given dmabufs
//
// This asks for creation of a wl_buffer from the added dmabuf
// buffers. The wl_buffer is not created immediately but returned via
// the 'created' event if the dmabuf sharing succeeds. The sharing
// may fail at runtime for reasons a client cannot predict, in
// which case the 'failed' event is triggered.
//
// The 'format' argument is a DRM_FORMAT code, as defined by the
// libdrm's drm_fourcc.h. The Linux kernel's DRM sub-system is the
// authoritative source on how the format codes should work.
//
// The 'flags' is a bitfield of the flags defined in enum "flags".
// 'y_invert' means the that the image needs to be y-flipped.
//
// Flag 'interlaced' means that the frame in the buffer is not
// progressive as usual, but interlaced. An interlaced buffer as
// supported here must always contain both top and bottom fields.
// The top field always begins on the first pixel row. The temporal
// ordering between the two fields is top field first, unless
// 'bottom_first' is specified. It is undefined whether 'bottom_first'
// is ignored if 'interlaced' is not set.
//
// This protocol does not convey any information about field rate,
// duration, or timing, other than the relative ordering between the
// two fields in one buffer. A compositor may have to estimate the
// intended field rate from the incoming buffer rate. It is undefined
// whether the time of receiving wl_surface.commit with a new buffer
// attached, applying the wl_surface state, wl_surface.frame callback
// trigger, presentation, or any other point in the compositor cycle
// is used to measure the frame or field times. There is no support
// for detecting missed or late frames/fields/buffers either, and
// there is no support whatsoever for cooperating with interlaced
// compositor output.
//
// The composited image quality resulting from the use of interlaced
// buffers is explicitly undefined. A compositor may use elaborate
// hardware features or software to deinterlace and create progressive
// output frames from a sequence of interlaced input buffers, or it
// may produce substandard image quality. However, compositors that
// cannot guarantee reasonable image quality in all cases are recommended
// to just reject all interlaced buffers.
//
// Any argument errors, including non-positive width or height,
// mismatch between the number of planes and the format, bad
// format, bad offset or stride, may be indicated by fatal protocol
// errors: INCOMPLETE, INVALID_FORMAT, INVALID_DIMENSIONS,
// OUT_OF_BOUNDS.
//
// Dmabuf import errors in the server that are not obvious client
// bugs are returned via the 'failed' event as non-fatal. This
// allows attempting dmabuf sharing and falling back in the client
// if it fails.
//
// This request can be sent only once in the object's lifetime, after
// which the only legal request is destroy. This object should be
// destroyed after issuing a 'create' request. Attempting to use this
// object after issuing 'create' raises ALREADY_USED protocol error.
//
// It is not mandatory to issue 'create'. If a client wants to
// cancel the buffer creation, it can just destroy this object.
type ZwpLinuxBufferParamsV1CreateRequest struct {
	// Width contains base plane width in pixels
	Width int32

	// Height contains base plane height in pixels
	Height int32

	// Format contains DRM_FORMAT code
	Format uint32

	// Flags contains see enum flags
	Flags uint32
}

// Opcode returns the request opcode for zwp_linux_buffer_params_v1.create in linux_dmabuf_unstable_v1
func (ZwpLinuxBufferParamsV1CreateRequest) Opcode() uint16 { return 2 }

// Ensure ZwpLinuxBufferParamsV1CreateRequest implements Message.
var _ Message = ZwpLinuxBufferParamsV1CreateRequest{}

// ZwpLinuxBufferParamsV1CreateImmedRequest requests to immediately create a wl_buffer from the given dmabufs
//
// This asks for immediate creation of a wl_buffer by importing the
// added dmabufs.
//
// In case of import success, no event is sent from the server, and the
// wl_buffer is ready to be used by the client.
//
// Upon import failure, either of the following may happen, as seen fit
// by the implementation:
// - the client is terminated with one of the following fatal protocol
// errors:
// - INCOMPLETE, INVALID_FORMAT, INVALID_DIMENSIONS, OUT_OF_BOUNDS,
// in case of argument errors such as mismatch between the number
// of planes and the format, bad format, non-positive width or
// height, or bad offset or stride.
// - INVALID_WL_BUFFER, in case the cause for failure is unknown or
// plaform specific.
// - the server creates an invalid wl_buffer, marks it as failed and
// sends a 'failed' event to the client. The result of using this
// invalid wl_buffer as an argument in any request by the client is
// defined by the compositor implementation.
//
// This takes the same arguments as a 'create' request, and obeys the
// same restrictions.
type ZwpLinuxBufferParamsV1CreateImmedRequest struct {
	// BufferID contains id for the newly created wl_buffer
	BufferID ObjectID

	// Width contains base plane width in pixels
	Width int32

	// Height contains base plane height in pixels
	Height int32

	// Format contains DRM_FORMAT code
	Format uint32

	// Flags contains see enum flags
	Flags uint32
}

// Opcode returns the request opcode for zwp_linux_buffer_params_v1.create_immed in linux_dmabuf_unstable_v1
func (ZwpLinuxBufferParamsV1CreateImmedRequest) Opcode() uint16 { return 3 }

// Ensure ZwpLinuxBufferParamsV1CreateImmedRequest implements Message.
var _ Message = ZwpLinuxBufferParamsV1CreateImmedRequest{}

// ZwpLinuxBufferParamsV1CreatedEvent signals when buffer creation succeeded
//
// This event indicates that the attempted buffer creation was
// successful. It provides the new wl_buffer referencing the dmabuf(s).
//
// Upon receiving this event, the client should destroy the
// zlinux_dmabuf_params object.
type ZwpLinuxBufferParamsV1CreatedEvent struct {
	// Buffer contains the newly created wl_buffer
	Buffer ObjectID
}

// Opcode returns the event opcode for zwp_linux_buffer_params_v1.created in linux_dmabuf_unstable_v1
func (ZwpLinuxBufferParamsV1CreatedEvent) Opcode() uint16 { return 0 }

// Ensure ZwpLinuxBufferParamsV1CreatedEvent implements Message.
var _ Message = ZwpLinuxBufferParamsV1CreatedEvent{}

// Scan scans the event from the socket.
func (e *ZwpLinuxBufferParamsV1CreatedEvent) Scan(s *EventScanner) error {
	if v, err := s.ObjectID(); err != nil {
		return err
	} else {
		e.Buffer = v
	}
	return nil
}

// Ensure ZwpLinuxBufferParamsV1CreatedEvent implements Event.
var _ Event = &ZwpLinuxBufferParamsV1CreatedEvent{}

// ZwpLinuxBufferParamsV1FailedEvent signals when buffer creation failed
//
// This event indicates that the attempted buffer creation has
// failed. It usually means that one of the dmabuf constraints
// has not been fulfilled.
//
// Upon receiving this event, the client should destroy the
// zlinux_buffer_params object.
type ZwpLinuxBufferParamsV1FailedEvent struct {
}

// Opcode returns the event opcode for zwp_linux_buffer_params_v1.failed in linux_dmabuf_unstable_v1
func (ZwpLinuxBufferParamsV1FailedEvent) Opcode() uint16 { return 1 }

// Ensure ZwpLinuxBufferParamsV1FailedEvent implements Message.
var _ Message = ZwpLinuxBufferParamsV1FailedEvent{}

// Scan scans the event from the socket.
func (e *ZwpLinuxBufferParamsV1FailedEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure ZwpLinuxBufferParamsV1FailedEvent implements Event.
var _ Event = &ZwpLinuxBufferParamsV1FailedEvent{}

// #endregion Interface linux_dmabuf_unstable_v1.zwp_linux_buffer_params_v1

////////////////////////////////////////////////////////////////////////////////
// #endregion Protocol linux_dmabuf_unstable_v1

////////////////////////////////////////////////////////////////////////////////
// #region Protocol pointer_constraints_unstable_v1

// ----------------------------------------------------------------------------
// #region Interface pointer_constraints_unstable_v1.zwp_pointer_constraints_v1

// ZwpPointerConstraintsV1Error represents wp_pointer_constraints error values
//
// These errors can be emitted in response to wp_pointer_constraints
// requests.
type ZwpPointerConstraintsV1Error int

const (
	// ZwpPointerConstraintsV1ErrorAlreadyConstrained corresponds to pointer constraint already requested on that surface
	ZwpPointerConstraintsV1ErrorAlreadyConstrained ZwpPointerConstraintsV1Error = 1
)

// ZwpPointerConstraintsV1Lifetime represents constraint lifetime
//
// These values represent different lifetime semantics. They are passed
// as arguments to the factory requests to specify how the constraint
// lifetimes should be managed.
type ZwpPointerConstraintsV1Lifetime int

const (
	ZwpPointerConstraintsV1LifetimeOneshot ZwpPointerConstraintsV1Lifetime = 1

	ZwpPointerConstraintsV1LifetimePersistent ZwpPointerConstraintsV1Lifetime = 2
)

// ZwpPointerConstraintsV1DestroyRequest requests to destroy the pointer constraints manager object
//
// Used by the client to notify the server that it will no longer use this
// pointer constraints object.
type ZwpPointerConstraintsV1DestroyRequest struct {
}

// Opcode returns the request opcode for zwp_pointer_constraints_v1.destroy in pointer_constraints_unstable_v1
func (ZwpPointerConstraintsV1DestroyRequest) Opcode() uint16 { return 0 }

// Ensure ZwpPointerConstraintsV1DestroyRequest implements Message.
var _ Message = ZwpPointerConstraintsV1DestroyRequest{}

// ZwpPointerConstraintsV1LockPointerRequest requests to lock pointer to a position
//
// The lock_pointer request lets the client request to disable movements of
// the virtual pointer (i.e. the cursor), effectively locking the pointer
// to a position. This request may not take effect immediately; in the
// future, when the compositor deems implementation-specific constraints
// are satisfied, the pointer lock will be activated and the compositor
// sends a locked event.
//
// The protocol provides no guarantee that the constraints are ever
// satisfied, and does not require the compositor to send an error if the
// constraints cannot ever be satisfied. It is thus possible to request a
// lock that will never activate.
//
// There may not be another pointer constraint of any kind requested or
// active on the surface for any of the wl_pointer objects of the seat of
// the passed pointer when requesting a lock. If there is, an error will be
// raised. See general pointer lock documentation for more details.
//
// The intersection of the region passed with this request and the input
// region of the surface is used to determine where the pointer must be
// in order for the lock to activate. It is up to the compositor whether to
// warp the pointer or require some kind of user interaction for the lock
// to activate. If the region is null the surface input region is used.
//
// A surface may receive pointer focus without the lock being activated.
//
// The request creates a new object wp_locked_pointer which is used to
// interact with the lock as well as receive updates about its state. See
// the the description of wp_locked_pointer for further information.
//
// Note that while a pointer is locked, the wl_pointer objects of the
// corresponding seat will not emit any wl_pointer.motion events, but
// relative motion events will still be emitted via wp_relative_pointer
// objects of the same seat. wl_pointer.axis and wl_pointer.button events
// are unaffected.
type ZwpPointerConstraintsV1LockPointerRequest struct {
	ID ObjectID

	// Surface contains surface to lock pointer to
	Surface ObjectID

	// Pointer contains the pointer that should be locked
	Pointer ObjectID

	// Region contains region of surface
	Region ObjectID

	// Lifetime contains lock lifetime
	Lifetime uint32
}

// Opcode returns the request opcode for zwp_pointer_constraints_v1.lock_pointer in pointer_constraints_unstable_v1
func (ZwpPointerConstraintsV1LockPointerRequest) Opcode() uint16 { return 1 }

// Ensure ZwpPointerConstraintsV1LockPointerRequest implements Message.
var _ Message = ZwpPointerConstraintsV1LockPointerRequest{}

// ZwpPointerConstraintsV1ConfinePointerRequest requests to confine pointer to a region
//
// The confine_pointer request lets the client request to confine the
// pointer cursor to a given region. This request may not take effect
// immediately; in the future, when the compositor deems implementation-
// specific constraints are satisfied, the pointer confinement will be
// activated and the compositor sends a confined event.
//
// The intersection of the region passed with this request and the input
// region of the surface is used to determine where the pointer must be
// in order for the confinement to activate. It is up to the compositor
// whether to warp the pointer or require some kind of user interaction for
// the confinement to activate. If the region is null the surface input
// region is used.
//
// The request will create a new object wp_confined_pointer which is used
// to interact with the confinement as well as receive updates about its
// state. See the the description of wp_confined_pointer for further
// information.
type ZwpPointerConstraintsV1ConfinePointerRequest struct {
	ID ObjectID

	// Surface contains surface to lock pointer to
	Surface ObjectID

	// Pointer contains the pointer that should be confined
	Pointer ObjectID

	// Region contains region of surface
	Region ObjectID

	// Lifetime contains confinement lifetime
	Lifetime uint32
}

// Opcode returns the request opcode for zwp_pointer_constraints_v1.confine_pointer in pointer_constraints_unstable_v1
func (ZwpPointerConstraintsV1ConfinePointerRequest) Opcode() uint16 { return 2 }

// Ensure ZwpPointerConstraintsV1ConfinePointerRequest implements Message.
var _ Message = ZwpPointerConstraintsV1ConfinePointerRequest{}

// #endregion Interface pointer_constraints_unstable_v1.zwp_pointer_constraints_v1

// ----------------------------------------------------------------------------
// #region Interface pointer_constraints_unstable_v1.zwp_locked_pointer_v1

// ZwpLockedPointerV1DestroyRequest requests to destroy the locked pointer object
//
// Destroy the locked pointer object. If applicable, the compositor will
// unlock the pointer.
type ZwpLockedPointerV1DestroyRequest struct {
}

// Opcode returns the request opcode for zwp_locked_pointer_v1.destroy in pointer_constraints_unstable_v1
func (ZwpLockedPointerV1DestroyRequest) Opcode() uint16 { return 0 }

// Ensure ZwpLockedPointerV1DestroyRequest implements Message.
var _ Message = ZwpLockedPointerV1DestroyRequest{}

// ZwpLockedPointerV1SetCursorPositionHintRequest requests to set the pointer cursor position hint
//
// Set the cursor position hint relative to the top left corner of the
// surface.
//
// If the client is drawing its own cursor, it should update the position
// hint to the position of its own cursor. A compositor may use this
// information to warp the pointer upon unlock in order to avoid pointer
// jumps.
//
// The cursor position hint is double buffered. The new hint will only take
// effect when the associated surface gets it pending state applied. See
// wl_surface.commit for details.
type ZwpLockedPointerV1SetCursorPositionHintRequest struct {
	// SurfaceX contains surface-local x coordinate
	SurfaceX Fixed

	// SurfaceY contains surface-local y coordinate
	SurfaceY Fixed
}

// Opcode returns the request opcode for zwp_locked_pointer_v1.set_cursor_position_hint in pointer_constraints_unstable_v1
func (ZwpLockedPointerV1SetCursorPositionHintRequest) Opcode() uint16 { return 1 }

// Ensure ZwpLockedPointerV1SetCursorPositionHintRequest implements Message.
var _ Message = ZwpLockedPointerV1SetCursorPositionHintRequest{}

// ZwpLockedPointerV1SetRegionRequest requests to set a new lock region
//
// Set a new region used to lock the pointer.
//
// The new lock region is double-buffered. The new lock region will
// only take effect when the associated surface gets its pending state
// applied. See wl_surface.commit for details.
//
// For details about the lock region, see wp_locked_pointer.
type ZwpLockedPointerV1SetRegionRequest struct {
	// Region contains region of surface
	Region ObjectID
}

// Opcode returns the request opcode for zwp_locked_pointer_v1.set_region in pointer_constraints_unstable_v1
func (ZwpLockedPointerV1SetRegionRequest) Opcode() uint16 { return 2 }

// Ensure ZwpLockedPointerV1SetRegionRequest implements Message.
var _ Message = ZwpLockedPointerV1SetRegionRequest{}

// ZwpLockedPointerV1LockedEvent signals when lock activation event
//
// Notification that the pointer lock of the seat's pointer is activated.
type ZwpLockedPointerV1LockedEvent struct {
}

// Opcode returns the event opcode for zwp_locked_pointer_v1.locked in pointer_constraints_unstable_v1
func (ZwpLockedPointerV1LockedEvent) Opcode() uint16 { return 0 }

// Ensure ZwpLockedPointerV1LockedEvent implements Message.
var _ Message = ZwpLockedPointerV1LockedEvent{}

// Scan scans the event from the socket.
func (e *ZwpLockedPointerV1LockedEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure ZwpLockedPointerV1LockedEvent implements Event.
var _ Event = &ZwpLockedPointerV1LockedEvent{}

// ZwpLockedPointerV1UnlockedEvent signals when lock deactivation event
//
// Notification that the pointer lock of the seat's pointer is no longer
// active. If this is a oneshot pointer lock (see
// wp_pointer_constraints.lifetime) this object is now defunct and should
// be destroyed. If this is a persistent pointer lock (see
// wp_pointer_constraints.lifetime) this pointer lock may again
// reactivate in the future.
type ZwpLockedPointerV1UnlockedEvent struct {
}

// Opcode returns the event opcode for zwp_locked_pointer_v1.unlocked in pointer_constraints_unstable_v1
func (ZwpLockedPointerV1UnlockedEvent) Opcode() uint16 { return 1 }

// Ensure ZwpLockedPointerV1UnlockedEvent implements Message.
var _ Message = ZwpLockedPointerV1UnlockedEvent{}

// Scan scans the event from the socket.
func (e *ZwpLockedPointerV1UnlockedEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure ZwpLockedPointerV1UnlockedEvent implements Event.
var _ Event = &ZwpLockedPointerV1UnlockedEvent{}

// #endregion Interface pointer_constraints_unstable_v1.zwp_locked_pointer_v1

// ----------------------------------------------------------------------------
// #region Interface pointer_constraints_unstable_v1.zwp_confined_pointer_v1

// ZwpConfinedPointerV1DestroyRequest requests to destroy the confined pointer object
//
// Destroy the confined pointer object. If applicable, the compositor will
// unconfine the pointer.
type ZwpConfinedPointerV1DestroyRequest struct {
}

// Opcode returns the request opcode for zwp_confined_pointer_v1.destroy in pointer_constraints_unstable_v1
func (ZwpConfinedPointerV1DestroyRequest) Opcode() uint16 { return 0 }

// Ensure ZwpConfinedPointerV1DestroyRequest implements Message.
var _ Message = ZwpConfinedPointerV1DestroyRequest{}

// ZwpConfinedPointerV1SetRegionRequest requests to set a new confine region
//
// Set a new region used to confine the pointer.
//
// The new confine region is double-buffered. The new confine region will
// only take effect when the associated surface gets its pending state
// applied. See wl_surface.commit for details.
//
// If the confinement is active when the new confinement region is applied
// and the pointer ends up outside of newly applied region, the pointer may
// warped to a position within the new confinement region. If warped, a
// wl_pointer.motion event will be emitted, but no
// wp_relative_pointer.relative_motion event.
//
// The compositor may also, instead of using the new region, unconfine the
// pointer.
//
// For details about the confine region, see wp_confined_pointer.
type ZwpConfinedPointerV1SetRegionRequest struct {
	// Region contains region of surface
	Region ObjectID
}

// Opcode returns the request opcode for zwp_confined_pointer_v1.set_region in pointer_constraints_unstable_v1
func (ZwpConfinedPointerV1SetRegionRequest) Opcode() uint16 { return 1 }

// Ensure ZwpConfinedPointerV1SetRegionRequest implements Message.
var _ Message = ZwpConfinedPointerV1SetRegionRequest{}

// ZwpConfinedPointerV1ConfinedEvent signals when pointer confined
//
// Notification that the pointer confinement of the seat's pointer is
// activated.
type ZwpConfinedPointerV1ConfinedEvent struct {
}

// Opcode returns the event opcode for zwp_confined_pointer_v1.confined in pointer_constraints_unstable_v1
func (ZwpConfinedPointerV1ConfinedEvent) Opcode() uint16 { return 0 }

// Ensure ZwpConfinedPointerV1ConfinedEvent implements Message.
var _ Message = ZwpConfinedPointerV1ConfinedEvent{}

// Scan scans the event from the socket.
func (e *ZwpConfinedPointerV1ConfinedEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure ZwpConfinedPointerV1ConfinedEvent implements Event.
var _ Event = &ZwpConfinedPointerV1ConfinedEvent{}

// ZwpConfinedPointerV1UnconfinedEvent signals when pointer unconfined
//
// Notification that the pointer confinement of the seat's pointer is no
// longer active. If this is a oneshot pointer confinement (see
// wp_pointer_constraints.lifetime) this object is now defunct and should
// be destroyed. If this is a persistent pointer confinement (see
// wp_pointer_constraints.lifetime) this pointer confinement may again
// reactivate in the future.
type ZwpConfinedPointerV1UnconfinedEvent struct {
}

// Opcode returns the event opcode for zwp_confined_pointer_v1.unconfined in pointer_constraints_unstable_v1
func (ZwpConfinedPointerV1UnconfinedEvent) Opcode() uint16 { return 1 }

// Ensure ZwpConfinedPointerV1UnconfinedEvent implements Message.
var _ Message = ZwpConfinedPointerV1UnconfinedEvent{}

// Scan scans the event from the socket.
func (e *ZwpConfinedPointerV1UnconfinedEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure ZwpConfinedPointerV1UnconfinedEvent implements Event.
var _ Event = &ZwpConfinedPointerV1UnconfinedEvent{}

// #endregion Interface pointer_constraints_unstable_v1.zwp_confined_pointer_v1

////////////////////////////////////////////////////////////////////////////////
// #endregion Protocol pointer_constraints_unstable_v1

////////////////////////////////////////////////////////////////////////////////
// #region Protocol pointer_gestures_unstable_v1

// ----------------------------------------------------------------------------
// #region Interface pointer_gestures_unstable_v1.zwp_pointer_gestures_v1

// ZwpPointerGesturesV1GetSwipeGestureRequest requests to get swipe gesture
//
// Create a swipe gesture object. See the
// wl_pointer_gesture_swipe interface for details.
type ZwpPointerGesturesV1GetSwipeGestureRequest struct {
	ID ObjectID

	Pointer ObjectID
}

// Opcode returns the request opcode for zwp_pointer_gestures_v1.get_swipe_gesture in pointer_gestures_unstable_v1
func (ZwpPointerGesturesV1GetSwipeGestureRequest) Opcode() uint16 { return 0 }

// Ensure ZwpPointerGesturesV1GetSwipeGestureRequest implements Message.
var _ Message = ZwpPointerGesturesV1GetSwipeGestureRequest{}

// ZwpPointerGesturesV1GetPinchGestureRequest requests to get pinch gesture
//
// Create a pinch gesture object. See the
// wl_pointer_gesture_pinch interface for details.
type ZwpPointerGesturesV1GetPinchGestureRequest struct {
	ID ObjectID

	Pointer ObjectID
}

// Opcode returns the request opcode for zwp_pointer_gestures_v1.get_pinch_gesture in pointer_gestures_unstable_v1
func (ZwpPointerGesturesV1GetPinchGestureRequest) Opcode() uint16 { return 1 }

// Ensure ZwpPointerGesturesV1GetPinchGestureRequest implements Message.
var _ Message = ZwpPointerGesturesV1GetPinchGestureRequest{}

// ZwpPointerGesturesV1ReleaseRequest requests to destroy the pointer gesture object
//
// Destroy the pointer gesture object. Swipe, pinch and hold objects
// created via this gesture object remain valid.
type ZwpPointerGesturesV1ReleaseRequest struct {
}

// Opcode returns the request opcode for zwp_pointer_gestures_v1.release in pointer_gestures_unstable_v1
func (ZwpPointerGesturesV1ReleaseRequest) Opcode() uint16 { return 2 }

// Ensure ZwpPointerGesturesV1ReleaseRequest implements Message.
var _ Message = ZwpPointerGesturesV1ReleaseRequest{}

// ZwpPointerGesturesV1GetHoldGestureRequest requests to get hold gesture
//
// Create a hold gesture object. See the
// wl_pointer_gesture_hold interface for details.
type ZwpPointerGesturesV1GetHoldGestureRequest struct {
	ID ObjectID

	Pointer ObjectID
}

// Opcode returns the request opcode for zwp_pointer_gestures_v1.get_hold_gesture in pointer_gestures_unstable_v1
func (ZwpPointerGesturesV1GetHoldGestureRequest) Opcode() uint16 { return 3 }

// Ensure ZwpPointerGesturesV1GetHoldGestureRequest implements Message.
var _ Message = ZwpPointerGesturesV1GetHoldGestureRequest{}

// #endregion Interface pointer_gestures_unstable_v1.zwp_pointer_gestures_v1

// ----------------------------------------------------------------------------
// #region Interface pointer_gestures_unstable_v1.zwp_pointer_gesture_swipe_v1

// ZwpPointerGestureSwipeV1DestroyRequest requests to destroy the pointer swipe gesture object
type ZwpPointerGestureSwipeV1DestroyRequest struct {
}

// Opcode returns the request opcode for zwp_pointer_gesture_swipe_v1.destroy in pointer_gestures_unstable_v1
func (ZwpPointerGestureSwipeV1DestroyRequest) Opcode() uint16 { return 0 }

// Ensure ZwpPointerGestureSwipeV1DestroyRequest implements Message.
var _ Message = ZwpPointerGestureSwipeV1DestroyRequest{}

// ZwpPointerGestureSwipeV1BeginEvent signals when multi-finger swipe begin
//
// This event is sent when a multi-finger swipe gesture is detected
// on the device.
type ZwpPointerGestureSwipeV1BeginEvent struct {
	Serial uint32

	// Time contains timestamp with millisecond granularity
	Time uint32

	Surface ObjectID

	// Fingers contains number of fingers
	Fingers uint32
}

// Opcode returns the event opcode for zwp_pointer_gesture_swipe_v1.begin in pointer_gestures_unstable_v1
func (ZwpPointerGestureSwipeV1BeginEvent) Opcode() uint16 { return 0 }

// Ensure ZwpPointerGestureSwipeV1BeginEvent implements Message.
var _ Message = ZwpPointerGestureSwipeV1BeginEvent{}

// Scan scans the event from the socket.
func (e *ZwpPointerGestureSwipeV1BeginEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Serial = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Time = v
	}
	if v, err := s.ObjectID(); err != nil {
		return err
	} else {
		e.Surface = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Fingers = v
	}
	return nil
}

// Ensure ZwpPointerGestureSwipeV1BeginEvent implements Event.
var _ Event = &ZwpPointerGestureSwipeV1BeginEvent{}

// ZwpPointerGestureSwipeV1UpdateEvent signals when multi-finger swipe motion
//
// This event is sent when a multi-finger swipe gesture changes the
// position of the logical center.
//
// The dx and dy coordinates are relative coordinates of the logical
// center of the gesture compared to the previous event.
type ZwpPointerGestureSwipeV1UpdateEvent struct {
	// Time contains timestamp with millisecond granularity
	Time uint32

	// Dx contains delta x coordinate in surface coordinate space
	Dx Fixed

	// Dy contains delta y coordinate in surface coordinate space
	Dy Fixed
}

// Opcode returns the event opcode for zwp_pointer_gesture_swipe_v1.update in pointer_gestures_unstable_v1
func (ZwpPointerGestureSwipeV1UpdateEvent) Opcode() uint16 { return 1 }

// Ensure ZwpPointerGestureSwipeV1UpdateEvent implements Message.
var _ Message = ZwpPointerGestureSwipeV1UpdateEvent{}

// Scan scans the event from the socket.
func (e *ZwpPointerGestureSwipeV1UpdateEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Time = v
	}
	if v, err := s.Fixed(); err != nil {
		return err
	} else {
		e.Dx = v
	}
	if v, err := s.Fixed(); err != nil {
		return err
	} else {
		e.Dy = v
	}
	return nil
}

// Ensure ZwpPointerGestureSwipeV1UpdateEvent implements Event.
var _ Event = &ZwpPointerGestureSwipeV1UpdateEvent{}

// ZwpPointerGestureSwipeV1EndEvent signals when multi-finger swipe end
//
// This event is sent when a multi-finger swipe gesture ceases to
// be valid. This may happen when one or more fingers are lifted or
// the gesture is cancelled.
//
// When a gesture is cancelled, the client should undo state changes
// caused by this gesture. What causes a gesture to be cancelled is
// implementation-dependent.
type ZwpPointerGestureSwipeV1EndEvent struct {
	Serial uint32

	// Time contains timestamp with millisecond granularity
	Time uint32

	// Cancelled contains 1 if the gesture was cancelled, 0 otherwise
	Cancelled int32
}

// Opcode returns the event opcode for zwp_pointer_gesture_swipe_v1.end in pointer_gestures_unstable_v1
func (ZwpPointerGestureSwipeV1EndEvent) Opcode() uint16 { return 2 }

// Ensure ZwpPointerGestureSwipeV1EndEvent implements Message.
var _ Message = ZwpPointerGestureSwipeV1EndEvent{}

// Scan scans the event from the socket.
func (e *ZwpPointerGestureSwipeV1EndEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Serial = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Time = v
	}
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.Cancelled = v
	}
	return nil
}

// Ensure ZwpPointerGestureSwipeV1EndEvent implements Event.
var _ Event = &ZwpPointerGestureSwipeV1EndEvent{}

// #endregion Interface pointer_gestures_unstable_v1.zwp_pointer_gesture_swipe_v1

// ----------------------------------------------------------------------------
// #region Interface pointer_gestures_unstable_v1.zwp_pointer_gesture_pinch_v1

// ZwpPointerGesturePinchV1DestroyRequest requests to destroy the pinch gesture object
type ZwpPointerGesturePinchV1DestroyRequest struct {
}

// Opcode returns the request opcode for zwp_pointer_gesture_pinch_v1.destroy in pointer_gestures_unstable_v1
func (ZwpPointerGesturePinchV1DestroyRequest) Opcode() uint16 { return 0 }

// Ensure ZwpPointerGesturePinchV1DestroyRequest implements Message.
var _ Message = ZwpPointerGesturePinchV1DestroyRequest{}

// ZwpPointerGesturePinchV1BeginEvent signals when multi-finger pinch begin
//
// This event is sent when a multi-finger pinch gesture is detected
// on the device.
type ZwpPointerGesturePinchV1BeginEvent struct {
	Serial uint32

	// Time contains timestamp with millisecond granularity
	Time uint32

	Surface ObjectID

	// Fingers contains number of fingers
	Fingers uint32
}

// Opcode returns the event opcode for zwp_pointer_gesture_pinch_v1.begin in pointer_gestures_unstable_v1
func (ZwpPointerGesturePinchV1BeginEvent) Opcode() uint16 { return 0 }

// Ensure ZwpPointerGesturePinchV1BeginEvent implements Message.
var _ Message = ZwpPointerGesturePinchV1BeginEvent{}

// Scan scans the event from the socket.
func (e *ZwpPointerGesturePinchV1BeginEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Serial = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Time = v
	}
	if v, err := s.ObjectID(); err != nil {
		return err
	} else {
		e.Surface = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Fingers = v
	}
	return nil
}

// Ensure ZwpPointerGesturePinchV1BeginEvent implements Event.
var _ Event = &ZwpPointerGesturePinchV1BeginEvent{}

// ZwpPointerGesturePinchV1UpdateEvent signals when multi-finger pinch motion
//
// This event is sent when a multi-finger pinch gesture changes the
// position of the logical center, the rotation or the relative scale.
//
// The dx and dy coordinates are relative coordinates in the
// surface coordinate space of the logical center of the gesture.
//
// The scale factor is an absolute scale compared to the
// pointer_gesture_pinch.begin event, e.g. a scale of 2 means the fingers
// are now twice as far apart as on pointer_gesture_pinch.begin.
//
// The rotation is the relative angle in degrees clockwise compared to the previous
// pointer_gesture_pinch.begin or pointer_gesture_pinch.update event.
type ZwpPointerGesturePinchV1UpdateEvent struct {
	// Time contains timestamp with millisecond granularity
	Time uint32

	// Dx contains delta x coordinate in surface coordinate space
	Dx Fixed

	// Dy contains delta y coordinate in surface coordinate space
	Dy Fixed

	// Scale contains scale relative to the initial finger position
	Scale Fixed

	// Rotation contains angle in degrees cw relative to the previous event
	Rotation Fixed
}

// Opcode returns the event opcode for zwp_pointer_gesture_pinch_v1.update in pointer_gestures_unstable_v1
func (ZwpPointerGesturePinchV1UpdateEvent) Opcode() uint16 { return 1 }

// Ensure ZwpPointerGesturePinchV1UpdateEvent implements Message.
var _ Message = ZwpPointerGesturePinchV1UpdateEvent{}

// Scan scans the event from the socket.
func (e *ZwpPointerGesturePinchV1UpdateEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Time = v
	}
	if v, err := s.Fixed(); err != nil {
		return err
	} else {
		e.Dx = v
	}
	if v, err := s.Fixed(); err != nil {
		return err
	} else {
		e.Dy = v
	}
	if v, err := s.Fixed(); err != nil {
		return err
	} else {
		e.Scale = v
	}
	if v, err := s.Fixed(); err != nil {
		return err
	} else {
		e.Rotation = v
	}
	return nil
}

// Ensure ZwpPointerGesturePinchV1UpdateEvent implements Event.
var _ Event = &ZwpPointerGesturePinchV1UpdateEvent{}

// ZwpPointerGesturePinchV1EndEvent signals when multi-finger pinch end
//
// This event is sent when a multi-finger pinch gesture ceases to
// be valid. This may happen when one or more fingers are lifted or
// the gesture is cancelled.
//
// When a gesture is cancelled, the client should undo state changes
// caused by this gesture. What causes a gesture to be cancelled is
// implementation-dependent.
type ZwpPointerGesturePinchV1EndEvent struct {
	Serial uint32

	// Time contains timestamp with millisecond granularity
	Time uint32

	// Cancelled contains 1 if the gesture was cancelled, 0 otherwise
	Cancelled int32
}

// Opcode returns the event opcode for zwp_pointer_gesture_pinch_v1.end in pointer_gestures_unstable_v1
func (ZwpPointerGesturePinchV1EndEvent) Opcode() uint16 { return 2 }

// Ensure ZwpPointerGesturePinchV1EndEvent implements Message.
var _ Message = ZwpPointerGesturePinchV1EndEvent{}

// Scan scans the event from the socket.
func (e *ZwpPointerGesturePinchV1EndEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Serial = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Time = v
	}
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.Cancelled = v
	}
	return nil
}

// Ensure ZwpPointerGesturePinchV1EndEvent implements Event.
var _ Event = &ZwpPointerGesturePinchV1EndEvent{}

// #endregion Interface pointer_gestures_unstable_v1.zwp_pointer_gesture_pinch_v1

// ----------------------------------------------------------------------------
// #region Interface pointer_gestures_unstable_v1.zwp_pointer_gesture_hold_v1

// ZwpPointerGestureHoldV1DestroyRequest requests to destroy the hold gesture object
type ZwpPointerGestureHoldV1DestroyRequest struct {
}

// Opcode returns the request opcode for zwp_pointer_gesture_hold_v1.destroy in pointer_gestures_unstable_v1
func (ZwpPointerGestureHoldV1DestroyRequest) Opcode() uint16 { return 0 }

// Ensure ZwpPointerGestureHoldV1DestroyRequest implements Message.
var _ Message = ZwpPointerGestureHoldV1DestroyRequest{}

// ZwpPointerGestureHoldV1BeginEvent signals when multi-finger hold begin
//
// This event is sent when a hold gesture is detected on the device.
type ZwpPointerGestureHoldV1BeginEvent struct {
	Serial uint32

	// Time contains timestamp with millisecond granularity
	Time uint32

	Surface ObjectID

	// Fingers contains number of fingers
	Fingers uint32
}

// Opcode returns the event opcode for zwp_pointer_gesture_hold_v1.begin in pointer_gestures_unstable_v1
func (ZwpPointerGestureHoldV1BeginEvent) Opcode() uint16 { return 0 }

// Ensure ZwpPointerGestureHoldV1BeginEvent implements Message.
var _ Message = ZwpPointerGestureHoldV1BeginEvent{}

// Scan scans the event from the socket.
func (e *ZwpPointerGestureHoldV1BeginEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Serial = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Time = v
	}
	if v, err := s.ObjectID(); err != nil {
		return err
	} else {
		e.Surface = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Fingers = v
	}
	return nil
}

// Ensure ZwpPointerGestureHoldV1BeginEvent implements Event.
var _ Event = &ZwpPointerGestureHoldV1BeginEvent{}

// ZwpPointerGestureHoldV1EndEvent signals when multi-finger hold end
//
// This event is sent when a hold gesture ceases to
// be valid. This may happen when the holding fingers are lifted or
// the gesture is cancelled, for example if the fingers move past an
// implementation-defined threshold, the finger count changes or the hold
// gesture changes into a different type of gesture.
//
// When a gesture is cancelled, the client may need to undo state changes
// caused by this gesture. What causes a gesture to be cancelled is
// implementation-dependent.
type ZwpPointerGestureHoldV1EndEvent struct {
	Serial uint32

	// Time contains timestamp with millisecond granularity
	Time uint32

	// Cancelled contains 1 if the gesture was cancelled, 0 otherwise
	Cancelled int32
}

// Opcode returns the event opcode for zwp_pointer_gesture_hold_v1.end in pointer_gestures_unstable_v1
func (ZwpPointerGestureHoldV1EndEvent) Opcode() uint16 { return 1 }

// Ensure ZwpPointerGestureHoldV1EndEvent implements Message.
var _ Message = ZwpPointerGestureHoldV1EndEvent{}

// Scan scans the event from the socket.
func (e *ZwpPointerGestureHoldV1EndEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Serial = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Time = v
	}
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.Cancelled = v
	}
	return nil
}

// Ensure ZwpPointerGestureHoldV1EndEvent implements Event.
var _ Event = &ZwpPointerGestureHoldV1EndEvent{}

// #endregion Interface pointer_gestures_unstable_v1.zwp_pointer_gesture_hold_v1

////////////////////////////////////////////////////////////////////////////////
// #endregion Protocol pointer_gestures_unstable_v1

////////////////////////////////////////////////////////////////////////////////
// #region Protocol presentation_time

// ----------------------------------------------------------------------------
// #region Interface presentation_time.wp_presentation

// WpPresentationError represents fatal presentation errors
//
// These fatal protocol errors may be emitted in response to
// illegal presentation requests.
type WpPresentationError int

const (
	// WpPresentationErrorInvalidTimestamp corresponds to invalid value in tv_nsec
	WpPresentationErrorInvalidTimestamp WpPresentationError = 0

	// WpPresentationErrorInvalidFlag corresponds to invalid flag
	WpPresentationErrorInvalidFlag WpPresentationError = 1
)

// WpPresentationDestroyRequest requests to unbind from the presentation interface
//
// Informs the server that the client will no longer be using
// this protocol object. Existing objects created by this object
// are not affected.
type WpPresentationDestroyRequest struct {
}

// Opcode returns the request opcode for wp_presentation.destroy in presentation_time
func (WpPresentationDestroyRequest) Opcode() uint16 { return 0 }

// Ensure WpPresentationDestroyRequest implements Message.
var _ Message = WpPresentationDestroyRequest{}

// WpPresentationFeedbackRequest requests to request presentation feedback information
//
// Request presentation feedback for the current content submission
// on the given surface. This creates a new presentation_feedback
// object, which will deliver the feedback information once. If
// multiple presentation_feedback objects are created for the same
// submission, they will all deliver the same information.
//
// For details on what information is returned, see the
// presentation_feedback interface.
type WpPresentationFeedbackRequest struct {
	// Surface contains target surface
	Surface ObjectID

	// Callback contains new feedback object
	Callback ObjectID
}

// Opcode returns the request opcode for wp_presentation.feedback in presentation_time
func (WpPresentationFeedbackRequest) Opcode() uint16 { return 1 }

// Ensure WpPresentationFeedbackRequest implements Message.
var _ Message = WpPresentationFeedbackRequest{}

// WpPresentationClockIDEvent signals when clock ID for timestamps
//
// This event tells the client in which clock domain the
// compositor interprets the timestamps used by the presentation
// extension. This clock is called the presentation clock.
//
// The compositor sends this event when the client binds to the
// presentation interface. The presentation clock does not change
// during the lifetime of the client connection.
//
// The clock identifier is platform dependent. On Linux/glibc,
// the identifier value is one of the clockid_t values accepted
// by clock_gettime(). clock_gettime() is defined by
// POSIX.1-2001.
//
// Timestamps in this clock domain are expressed as tv_sec_hi,
// tv_sec_lo, tv_nsec triples, each component being an unsigned
// 32-bit value. Whole seconds are in tv_sec which is a 64-bit
// value combined from tv_sec_hi and tv_sec_lo, and the
// additional fractional part in tv_nsec as nanoseconds. Hence,
// for valid timestamps tv_nsec must be in [0, 999999999].
//
// Note that clock_id applies only to the presentation clock,
// and implies nothing about e.g. the timestamps used in the
// Wayland core protocol input events.
//
// Compositors should prefer a clock which does not jump and is
// not slewed e.g. by NTP. The absolute value of the clock is
// irrelevant. Precision of one millisecond or better is
// recommended. Clients must be able to query the current clock
// value directly, not by asking the compositor.
type WpPresentationClockIDEvent struct {
	// ClkID contains platform clock identifier
	ClkID uint32
}

// Opcode returns the event opcode for wp_presentation.clock_id in presentation_time
func (WpPresentationClockIDEvent) Opcode() uint16 { return 0 }

// Ensure WpPresentationClockIDEvent implements Message.
var _ Message = WpPresentationClockIDEvent{}

// Scan scans the event from the socket.
func (e *WpPresentationClockIDEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.ClkID = v
	}
	return nil
}

// Ensure WpPresentationClockIDEvent implements Event.
var _ Event = &WpPresentationClockIDEvent{}

// #endregion Interface presentation_time.wp_presentation

// ----------------------------------------------------------------------------
// #region Interface presentation_time.wp_presentation_feedback

// WpPresentationFeedbackKind represents bitmask of flags in presented event
//
// These flags provide information about how the presentation of
// the related content update was done. The intent is to help
// clients assess the reliability of the feedback and the visual
// quality with respect to possible tearing and timings.
type WpPresentationFeedbackKind uint

const (
	WpPresentationFeedbackKindVsync WpPresentationFeedbackKind = 0x1

	WpPresentationFeedbackKindHwClock WpPresentationFeedbackKind = 0x2

	WpPresentationFeedbackKindHwCompletion WpPresentationFeedbackKind = 0x4

	WpPresentationFeedbackKindZeroCopy WpPresentationFeedbackKind = 0x8
)

// WpPresentationFeedbackSyncOutputEvent signals when presentation synchronized to this output
//
// As presentation can be synchronized to only one output at a
// time, this event tells which output it was. This event is only
// sent prior to the presented event.
//
// As clients may bind to the same global wl_output multiple
// times, this event is sent for each bound instance that matches
// the synchronized output. If a client has not bound to the
// right wl_output global at all, this event is not sent.
type WpPresentationFeedbackSyncOutputEvent struct {
	// Output contains presentation output
	Output ObjectID
}

// Opcode returns the event opcode for wp_presentation_feedback.sync_output in presentation_time
func (WpPresentationFeedbackSyncOutputEvent) Opcode() uint16 { return 0 }

// Ensure WpPresentationFeedbackSyncOutputEvent implements Message.
var _ Message = WpPresentationFeedbackSyncOutputEvent{}

// Scan scans the event from the socket.
func (e *WpPresentationFeedbackSyncOutputEvent) Scan(s *EventScanner) error {
	if v, err := s.ObjectID(); err != nil {
		return err
	} else {
		e.Output = v
	}
	return nil
}

// Ensure WpPresentationFeedbackSyncOutputEvent implements Event.
var _ Event = &WpPresentationFeedbackSyncOutputEvent{}

// WpPresentationFeedbackPresentedEvent signals when the content update was displayed
//
// The associated content update was displayed to the user at the
// indicated time (tv_sec_hi/lo, tv_nsec). For the interpretation of
// the timestamp, see presentation.clock_id event.
//
// The timestamp corresponds to the time when the content update
// turned into light the first time on the surface's main output.
// Compositors may approximate this from the framebuffer flip
// completion events from the system, and the latency of the
// physical display path if known.
//
// This event is preceded by all related sync_output events
// telling which output's refresh cycle the feedback corresponds
// to, i.e. the main output for the surface. Compositors are
// recommended to choose the output containing the largest part
// of the wl_surface, or keeping the output they previously
// chose. Having a stable presentation output association helps
// clients predict future output refreshes (vblank).
//
// The 'refresh' argument gives the compositor's prediction of how
// many nanoseconds after tv_sec, tv_nsec the very next output
// refresh may occur. This is to further aid clients in
// predicting future refreshes, i.e., estimating the timestamps
// targeting the next few vblanks. If such prediction cannot
// usefully be done, the argument is zero.
//
// If the output does not have a constant refresh rate, explicit
// video mode switches excluded, then the refresh argument must
// be zero.
//
// The 64-bit value combined from seq_hi and seq_lo is the value
// of the output's vertical retrace counter when the content
// update was first scanned out to the display. This value must
// be compatible with the definition of MSC in
// GLX_OML_sync_control specification. Note, that if the display
// path has a non-zero latency, the time instant specified by
// this counter may differ from the timestamp's.
//
// If the output does not have a concept of vertical retrace or a
// refresh cycle, or the output device is self-refreshing without
// a way to query the refresh count, then the arguments seq_hi
// and seq_lo must be zero.
type WpPresentationFeedbackPresentedEvent struct {
	// TvSecHi contains high 32 bits of the seconds part of the presentation timestamp
	TvSecHi uint32

	// TvSecLo contains low 32 bits of the seconds part of the presentation timestamp
	TvSecLo uint32

	// TvNsec contains nanoseconds part of the presentation timestamp
	TvNsec uint32

	// Refresh contains nanoseconds till next refresh
	Refresh uint32

	// SeqHi contains high 32 bits of refresh counter
	SeqHi uint32

	// SeqLo contains low 32 bits of refresh counter
	SeqLo uint32

	// Flags contains combination of 'kind' values
	Flags uint32
}

// Opcode returns the event opcode for wp_presentation_feedback.presented in presentation_time
func (WpPresentationFeedbackPresentedEvent) Opcode() uint16 { return 1 }

// Ensure WpPresentationFeedbackPresentedEvent implements Message.
var _ Message = WpPresentationFeedbackPresentedEvent{}

// Scan scans the event from the socket.
func (e *WpPresentationFeedbackPresentedEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.TvSecHi = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.TvSecLo = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.TvNsec = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Refresh = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.SeqHi = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.SeqLo = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Flags = v
	}
	return nil
}

// Ensure WpPresentationFeedbackPresentedEvent implements Event.
var _ Event = &WpPresentationFeedbackPresentedEvent{}

// WpPresentationFeedbackDiscardedEvent signals when the content update was not displayed
//
// The content update was never displayed to the user.
type WpPresentationFeedbackDiscardedEvent struct {
}

// Opcode returns the event opcode for wp_presentation_feedback.discarded in presentation_time
func (WpPresentationFeedbackDiscardedEvent) Opcode() uint16 { return 2 }

// Ensure WpPresentationFeedbackDiscardedEvent implements Message.
var _ Message = WpPresentationFeedbackDiscardedEvent{}

// Scan scans the event from the socket.
func (e *WpPresentationFeedbackDiscardedEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure WpPresentationFeedbackDiscardedEvent implements Event.
var _ Event = &WpPresentationFeedbackDiscardedEvent{}

// #endregion Interface presentation_time.wp_presentation_feedback

////////////////////////////////////////////////////////////////////////////////
// #endregion Protocol presentation_time

////////////////////////////////////////////////////////////////////////////////
// #region Protocol relative_pointer_unstable_v1

// ----------------------------------------------------------------------------
// #region Interface relative_pointer_unstable_v1.zwp_relative_pointer_manager_v1

// ZwpRelativePointerManagerV1DestroyRequest requests to destroy the relative pointer manager object
//
// Used by the client to notify the server that it will no longer use this
// relative pointer manager object.
type ZwpRelativePointerManagerV1DestroyRequest struct {
}

// Opcode returns the request opcode for zwp_relative_pointer_manager_v1.destroy in relative_pointer_unstable_v1
func (ZwpRelativePointerManagerV1DestroyRequest) Opcode() uint16 { return 0 }

// Ensure ZwpRelativePointerManagerV1DestroyRequest implements Message.
var _ Message = ZwpRelativePointerManagerV1DestroyRequest{}

// ZwpRelativePointerManagerV1GetRelativePointerRequest requests to get a relative pointer object
//
// Create a relative pointer interface given a wl_pointer object. See the
// wp_relative_pointer interface for more details.
type ZwpRelativePointerManagerV1GetRelativePointerRequest struct {
	ID ObjectID

	Pointer ObjectID
}

// Opcode returns the request opcode for zwp_relative_pointer_manager_v1.get_relative_pointer in relative_pointer_unstable_v1
func (ZwpRelativePointerManagerV1GetRelativePointerRequest) Opcode() uint16 { return 1 }

// Ensure ZwpRelativePointerManagerV1GetRelativePointerRequest implements Message.
var _ Message = ZwpRelativePointerManagerV1GetRelativePointerRequest{}

// #endregion Interface relative_pointer_unstable_v1.zwp_relative_pointer_manager_v1

// ----------------------------------------------------------------------------
// #region Interface relative_pointer_unstable_v1.zwp_relative_pointer_v1

// ZwpRelativePointerV1DestroyRequest requests to release the relative pointer object
type ZwpRelativePointerV1DestroyRequest struct {
}

// Opcode returns the request opcode for zwp_relative_pointer_v1.destroy in relative_pointer_unstable_v1
func (ZwpRelativePointerV1DestroyRequest) Opcode() uint16 { return 0 }

// Ensure ZwpRelativePointerV1DestroyRequest implements Message.
var _ Message = ZwpRelativePointerV1DestroyRequest{}

// ZwpRelativePointerV1RelativeMotionEvent signals when relative pointer motion
//
// Relative x/y pointer motion from the pointer of the seat associated with
// this object.
//
// A relative motion is in the same dimension as regular wl_pointer motion
// events, except they do not represent an absolute position. For example,
// moving a pointer from (x, y) to (x', y') would have the equivalent
// relative motion (x' - x, y' - y). If a pointer motion caused the
// absolute pointer position to be clipped by for example the edge of the
// monitor, the relative motion is unaffected by the clipping and will
// represent the unclipped motion.
//
// This event also contains non-accelerated motion deltas. The
// non-accelerated delta is, when applicable, the regular pointer motion
// delta as it was before having applied motion acceleration and other
// transformations such as normalization.
//
// Note that the non-accelerated delta does not represent 'raw' events as
// they were read from some device. Pointer motion acceleration is device-
// and configuration-specific and non-accelerated deltas and accelerated
// deltas may have the same value on some devices.
//
// Relative motions are not coupled to wl_pointer.motion events, and can be
// sent in combination with such events, but also independently. There may
// also be scenarios where wl_pointer.motion is sent, but there is no
// relative motion. The order of an absolute and relative motion event
// originating from the same physical motion is not guaranteed.
//
// If the client needs button events or focus state, it can receive them
// from a wl_pointer object of the same seat that the wp_relative_pointer
// object is associated with.
type ZwpRelativePointerV1RelativeMotionEvent struct {
	// UtimeHi contains high 32 bits of a 64 bit timestamp with microsecond granularity
	UtimeHi uint32

	// UtimeLo contains low 32 bits of a 64 bit timestamp with microsecond granularity
	UtimeLo uint32

	// Dx contains the x component of the motion vector
	Dx Fixed

	// Dy contains the y component of the motion vector
	Dy Fixed

	// DxUnaccel contains the x component of the unaccelerated motion vector
	DxUnaccel Fixed

	// DyUnaccel contains the y component of the unaccelerated motion vector
	DyUnaccel Fixed
}

// Opcode returns the event opcode for zwp_relative_pointer_v1.relative_motion in relative_pointer_unstable_v1
func (ZwpRelativePointerV1RelativeMotionEvent) Opcode() uint16 { return 0 }

// Ensure ZwpRelativePointerV1RelativeMotionEvent implements Message.
var _ Message = ZwpRelativePointerV1RelativeMotionEvent{}

// Scan scans the event from the socket.
func (e *ZwpRelativePointerV1RelativeMotionEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.UtimeHi = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.UtimeLo = v
	}
	if v, err := s.Fixed(); err != nil {
		return err
	} else {
		e.Dx = v
	}
	if v, err := s.Fixed(); err != nil {
		return err
	} else {
		e.Dy = v
	}
	if v, err := s.Fixed(); err != nil {
		return err
	} else {
		e.DxUnaccel = v
	}
	if v, err := s.Fixed(); err != nil {
		return err
	} else {
		e.DyUnaccel = v
	}
	return nil
}

// Ensure ZwpRelativePointerV1RelativeMotionEvent implements Event.
var _ Event = &ZwpRelativePointerV1RelativeMotionEvent{}

// #endregion Interface relative_pointer_unstable_v1.zwp_relative_pointer_v1

////////////////////////////////////////////////////////////////////////////////
// #endregion Protocol relative_pointer_unstable_v1

////////////////////////////////////////////////////////////////////////////////
// #region Protocol tablet_unstable_v1

// ----------------------------------------------------------------------------
// #region Interface tablet_unstable_v1.zwp_tablet_manager_v1

// ZwpTabletManagerV1GetTabletSeatRequest requests to get the tablet seat
//
// Get the wp_tablet_seat object for the given seat. This object
// provides access to all graphics tablets in this seat.
type ZwpTabletManagerV1GetTabletSeatRequest struct {
	TabletSeat ObjectID

	// Seat contains The wl_seat object to retrieve the tablets for
	Seat ObjectID
}

// Opcode returns the request opcode for zwp_tablet_manager_v1.get_tablet_seat in tablet_unstable_v1
func (ZwpTabletManagerV1GetTabletSeatRequest) Opcode() uint16 { return 0 }

// Ensure ZwpTabletManagerV1GetTabletSeatRequest implements Message.
var _ Message = ZwpTabletManagerV1GetTabletSeatRequest{}

// ZwpTabletManagerV1DestroyRequest requests to release the memory for the tablet manager object
//
// Destroy the wp_tablet_manager object. Objects created from this
// object are unaffected and should be destroyed separately.
type ZwpTabletManagerV1DestroyRequest struct {
}

// Opcode returns the request opcode for zwp_tablet_manager_v1.destroy in tablet_unstable_v1
func (ZwpTabletManagerV1DestroyRequest) Opcode() uint16 { return 1 }

// Ensure ZwpTabletManagerV1DestroyRequest implements Message.
var _ Message = ZwpTabletManagerV1DestroyRequest{}

// #endregion Interface tablet_unstable_v1.zwp_tablet_manager_v1

// ----------------------------------------------------------------------------
// #region Interface tablet_unstable_v1.zwp_tablet_seat_v1

// ZwpTabletSeatV1DestroyRequest requests to release the memory for the tablet seat object
//
// Destroy the wp_tablet_seat object. Objects created from this
// object are unaffected and should be destroyed separately.
type ZwpTabletSeatV1DestroyRequest struct {
}

// Opcode returns the request opcode for zwp_tablet_seat_v1.destroy in tablet_unstable_v1
func (ZwpTabletSeatV1DestroyRequest) Opcode() uint16 { return 0 }

// Ensure ZwpTabletSeatV1DestroyRequest implements Message.
var _ Message = ZwpTabletSeatV1DestroyRequest{}

// ZwpTabletSeatV1TabletAddedEvent signals when new device notification
//
// This event is sent whenever a new tablet becomes available on this
// seat. This event only provides the object id of the tablet, any
// static information about the tablet (device name, vid/pid, etc.) is
// sent through the wp_tablet interface.
type ZwpTabletSeatV1TabletAddedEvent struct {
	// ID contains the newly added graphics tablet
	ID ObjectID
}

// Opcode returns the event opcode for zwp_tablet_seat_v1.tablet_added in tablet_unstable_v1
func (ZwpTabletSeatV1TabletAddedEvent) Opcode() uint16 { return 0 }

// Ensure ZwpTabletSeatV1TabletAddedEvent implements Message.
var _ Message = ZwpTabletSeatV1TabletAddedEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletSeatV1TabletAddedEvent) Scan(s *EventScanner) error {
	if v, err := s.ObjectID(); err != nil {
		return err
	} else {
		e.ID = v
	}
	return nil
}

// Ensure ZwpTabletSeatV1TabletAddedEvent implements Event.
var _ Event = &ZwpTabletSeatV1TabletAddedEvent{}

// ZwpTabletSeatV1ToolAddedEvent signals when a new tool has been used with a tablet
//
// This event is sent whenever a tool that has not previously been used
// with a tablet comes into use. This event only provides the object id
// of the tool; any static information about the tool (capabilities,
// type, etc.) is sent through the wp_tablet_tool interface.
type ZwpTabletSeatV1ToolAddedEvent struct {
	// ID contains the newly added tablet tool
	ID ObjectID
}

// Opcode returns the event opcode for zwp_tablet_seat_v1.tool_added in tablet_unstable_v1
func (ZwpTabletSeatV1ToolAddedEvent) Opcode() uint16 { return 1 }

// Ensure ZwpTabletSeatV1ToolAddedEvent implements Message.
var _ Message = ZwpTabletSeatV1ToolAddedEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletSeatV1ToolAddedEvent) Scan(s *EventScanner) error {
	if v, err := s.ObjectID(); err != nil {
		return err
	} else {
		e.ID = v
	}
	return nil
}

// Ensure ZwpTabletSeatV1ToolAddedEvent implements Event.
var _ Event = &ZwpTabletSeatV1ToolAddedEvent{}

// #endregion Interface tablet_unstable_v1.zwp_tablet_seat_v1

// ----------------------------------------------------------------------------
// #region Interface tablet_unstable_v1.zwp_tablet_tool_v1

// ZwpTabletToolV1Type represents a physical tool type
//
// Describes the physical type of a tool. The physical type of a tool
// generally defines its base usage.
//
// The mouse tool represents a mouse-shaped tool that is not a relative
// device but bound to the tablet's surface, providing absolute
// coordinates.
//
// The lens tool is a mouse-shaped tool with an attached lens to
// provide precision focus.
type ZwpTabletToolV1Type int

const (
	// ZwpTabletToolV1TypePen corresponds to Pen
	ZwpTabletToolV1TypePen ZwpTabletToolV1Type = 0x140

	// ZwpTabletToolV1TypeEraser corresponds to Eraser
	ZwpTabletToolV1TypeEraser ZwpTabletToolV1Type = 0x141

	// ZwpTabletToolV1TypeBrush corresponds to Brush
	ZwpTabletToolV1TypeBrush ZwpTabletToolV1Type = 0x142

	// ZwpTabletToolV1TypePencil corresponds to Pencil
	ZwpTabletToolV1TypePencil ZwpTabletToolV1Type = 0x143

	// ZwpTabletToolV1TypeAirbrush corresponds to Airbrush
	ZwpTabletToolV1TypeAirbrush ZwpTabletToolV1Type = 0x144

	// ZwpTabletToolV1TypeFinger corresponds to Finger
	ZwpTabletToolV1TypeFinger ZwpTabletToolV1Type = 0x145

	// ZwpTabletToolV1TypeMouse corresponds to Mouse
	ZwpTabletToolV1TypeMouse ZwpTabletToolV1Type = 0x146

	// ZwpTabletToolV1TypeLens corresponds to Lens
	ZwpTabletToolV1TypeLens ZwpTabletToolV1Type = 0x147
)

// ZwpTabletToolV1Capability represents capability flags for a tool
//
// Describes extra capabilities on a tablet.
//
// Any tool must provide x and y values, extra axes are
// device-specific.
type ZwpTabletToolV1Capability int

const (
	// ZwpTabletToolV1CapabilityTilt corresponds to Tilt axes
	ZwpTabletToolV1CapabilityTilt ZwpTabletToolV1Capability = 1

	// ZwpTabletToolV1CapabilityPressure corresponds to Pressure axis
	ZwpTabletToolV1CapabilityPressure ZwpTabletToolV1Capability = 2

	// ZwpTabletToolV1CapabilityDistance corresponds to Distance axis
	ZwpTabletToolV1CapabilityDistance ZwpTabletToolV1Capability = 3

	// ZwpTabletToolV1CapabilityRotation corresponds to Z-rotation axis
	ZwpTabletToolV1CapabilityRotation ZwpTabletToolV1Capability = 4

	// ZwpTabletToolV1CapabilitySlider corresponds to Slider axis
	ZwpTabletToolV1CapabilitySlider ZwpTabletToolV1Capability = 5

	// ZwpTabletToolV1CapabilityWheel corresponds to Wheel axis
	ZwpTabletToolV1CapabilityWheel ZwpTabletToolV1Capability = 6
)

// ZwpTabletToolV1ButtonState represents physical button state
//
// Describes the physical state of a button that produced the button event.
type ZwpTabletToolV1ButtonState int

const (
	// ZwpTabletToolV1ButtonStateReleased corresponds to button is not pressed
	ZwpTabletToolV1ButtonStateReleased ZwpTabletToolV1ButtonState = 0

	// ZwpTabletToolV1ButtonStatePressed corresponds to button is pressed
	ZwpTabletToolV1ButtonStatePressed ZwpTabletToolV1ButtonState = 1
)

type ZwpTabletToolV1Error int

const (
	// ZwpTabletToolV1ErrorRole corresponds to given wl_surface has another role
	ZwpTabletToolV1ErrorRole ZwpTabletToolV1Error = 0
)

// ZwpTabletToolV1SetCursorRequest requests to set the tablet tool's surface
//
// Sets the surface of the cursor used for this tool on the given
// tablet. This request only takes effect if the tool is in proximity
// of one of the requesting client's surfaces or the surface parameter
// is the current pointer surface. If there was a previous surface set
// with this request it is replaced. If surface is NULL, the cursor
// image is hidden.
//
// The parameters hotspot_x and hotspot_y define the position of the
// pointer surface relative to the pointer location. Its top-left corner
// is always at (x, y) - (hotspot_x, hotspot_y), where (x, y) are the
// coordinates of the pointer location, in surface-local coordinates.
//
// On surface.attach requests to the pointer surface, hotspot_x and
// hotspot_y are decremented by the x and y parameters passed to the
// request. Attach must be confirmed by wl_surface.commit as usual.
//
// The hotspot can also be updated by passing the currently set pointer
// surface to this request with new values for hotspot_x and hotspot_y.
//
// The current and pending input regions of the wl_surface are cleared,
// and wl_surface.set_input_region is ignored until the wl_surface is no
// longer used as the cursor. When the use as a cursor ends, the current
// and pending input regions become undefined, and the wl_surface is
// unmapped.
//
// This request gives the surface the role of a cursor. The role
// assigned by this request is the same as assigned by
// wl_pointer.set_cursor meaning the same surface can be
// used both as a wl_pointer cursor and a wp_tablet cursor. If the
// surface already has another role, it raises a protocol error.
// The surface may be used on multiple tablets and across multiple
// seats.
type ZwpTabletToolV1SetCursorRequest struct {
	// Serial contains serial of the enter event
	Serial uint32

	Surface ObjectID

	// HotspotX contains surface-local x coordinate
	HotspotX int32

	// HotspotY contains surface-local y coordinate
	HotspotY int32
}

// Opcode returns the request opcode for zwp_tablet_tool_v1.set_cursor in tablet_unstable_v1
func (ZwpTabletToolV1SetCursorRequest) Opcode() uint16 { return 0 }

// Ensure ZwpTabletToolV1SetCursorRequest implements Message.
var _ Message = ZwpTabletToolV1SetCursorRequest{}

// ZwpTabletToolV1DestroyRequest requests to destroy the tool object
//
// This destroys the client's resource for this tool object.
type ZwpTabletToolV1DestroyRequest struct {
}

// Opcode returns the request opcode for zwp_tablet_tool_v1.destroy in tablet_unstable_v1
func (ZwpTabletToolV1DestroyRequest) Opcode() uint16 { return 1 }

// Ensure ZwpTabletToolV1DestroyRequest implements Message.
var _ Message = ZwpTabletToolV1DestroyRequest{}

// ZwpTabletToolV1TypeEvent signals when tool type
//
// The tool type is the high-level type of the tool and usually decides
// the interaction expected from this tool.
//
// This event is sent in the initial burst of events before the
// wp_tablet_tool.done event.
type ZwpTabletToolV1TypeEvent struct {
	// ToolType contains the physical tool type
	ToolType uint32
}

// Opcode returns the event opcode for zwp_tablet_tool_v1.type in tablet_unstable_v1
func (ZwpTabletToolV1TypeEvent) Opcode() uint16 { return 0 }

// Ensure ZwpTabletToolV1TypeEvent implements Message.
var _ Message = ZwpTabletToolV1TypeEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletToolV1TypeEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.ToolType = v
	}
	return nil
}

// Ensure ZwpTabletToolV1TypeEvent implements Event.
var _ Event = &ZwpTabletToolV1TypeEvent{}

// ZwpTabletToolV1HardwareSerialEvent signals when unique hardware serial number of the tool
//
// If the physical tool can be identified by a unique 64-bit serial
// number, this event notifies the client of this serial number.
//
// If multiple tablets are available in the same seat and the tool is
// uniquely identifiable by the serial number, that tool may move
// between tablets.
//
// Otherwise, if the tool has no serial number and this event is
// missing, the tool is tied to the tablet it first comes into
// proximity with. Even if the physical tool is used on multiple
// tablets, separate wp_tablet_tool objects will be created, one per
// tablet.
//
// This event is sent in the initial burst of events before the
// wp_tablet_tool.done event.
type ZwpTabletToolV1HardwareSerialEvent struct {
	// HardwareSerialHi contains the unique serial number of the tool, most significant bits
	HardwareSerialHi uint32

	// HardwareSerialLo contains the unique serial number of the tool, least significant bits
	HardwareSerialLo uint32
}

// Opcode returns the event opcode for zwp_tablet_tool_v1.hardware_serial in tablet_unstable_v1
func (ZwpTabletToolV1HardwareSerialEvent) Opcode() uint16 { return 1 }

// Ensure ZwpTabletToolV1HardwareSerialEvent implements Message.
var _ Message = ZwpTabletToolV1HardwareSerialEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletToolV1HardwareSerialEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.HardwareSerialHi = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.HardwareSerialLo = v
	}
	return nil
}

// Ensure ZwpTabletToolV1HardwareSerialEvent implements Event.
var _ Event = &ZwpTabletToolV1HardwareSerialEvent{}

// ZwpTabletToolV1HardwareIDWacomEvent signals when hardware id notification in Wacom's format
//
// This event notifies the client of a hardware id available on this tool.
//
// The hardware id is a device-specific 64-bit id that provides extra
// information about the tool in use, beyond the wl_tool.type
// enumeration. The format of the id is specific to tablets made by
// Wacom Inc. For example, the hardware id of a Wacom Grip
// Pen (a stylus) is 0x802.
//
// This event is sent in the initial burst of events before the
// wp_tablet_tool.done event.
type ZwpTabletToolV1HardwareIDWacomEvent struct {
	// HardwareIDHi contains the hardware id, most significant bits
	HardwareIDHi uint32

	// HardwareIDLo contains the hardware id, least significant bits
	HardwareIDLo uint32
}

// Opcode returns the event opcode for zwp_tablet_tool_v1.hardware_id_wacom in tablet_unstable_v1
func (ZwpTabletToolV1HardwareIDWacomEvent) Opcode() uint16 { return 2 }

// Ensure ZwpTabletToolV1HardwareIDWacomEvent implements Message.
var _ Message = ZwpTabletToolV1HardwareIDWacomEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletToolV1HardwareIDWacomEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.HardwareIDHi = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.HardwareIDLo = v
	}
	return nil
}

// Ensure ZwpTabletToolV1HardwareIDWacomEvent implements Event.
var _ Event = &ZwpTabletToolV1HardwareIDWacomEvent{}

// ZwpTabletToolV1CapabilityEvent signals when tool capability notification
//
// This event notifies the client of any capabilities of this tool,
// beyond the main set of x/y axes and tip up/down detection.
//
// One event is sent for each extra capability available on this tool.
//
// This event is sent in the initial burst of events before the
// wp_tablet_tool.done event.
type ZwpTabletToolV1CapabilityEvent struct {
	// Capability contains the capability
	Capability uint32
}

// Opcode returns the event opcode for zwp_tablet_tool_v1.capability in tablet_unstable_v1
func (ZwpTabletToolV1CapabilityEvent) Opcode() uint16 { return 3 }

// Ensure ZwpTabletToolV1CapabilityEvent implements Message.
var _ Message = ZwpTabletToolV1CapabilityEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletToolV1CapabilityEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Capability = v
	}
	return nil
}

// Ensure ZwpTabletToolV1CapabilityEvent implements Event.
var _ Event = &ZwpTabletToolV1CapabilityEvent{}

// ZwpTabletToolV1DoneEvent signals when tool description events sequence complete
//
// This event signals the end of the initial burst of descriptive
// events. A client may consider the static description of the tool to
// be complete and finalize initialization of the tool.
type ZwpTabletToolV1DoneEvent struct {
}

// Opcode returns the event opcode for zwp_tablet_tool_v1.done in tablet_unstable_v1
func (ZwpTabletToolV1DoneEvent) Opcode() uint16 { return 4 }

// Ensure ZwpTabletToolV1DoneEvent implements Message.
var _ Message = ZwpTabletToolV1DoneEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletToolV1DoneEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure ZwpTabletToolV1DoneEvent implements Event.
var _ Event = &ZwpTabletToolV1DoneEvent{}

// ZwpTabletToolV1RemovedEvent signals when tool removed
//
// This event is sent when the tool is removed from the system and will
// send no further events. Should the physical tool come back into
// proximity later, a new wp_tablet_tool object will be created.
//
// It is compositor-dependent when a tool is removed. A compositor may
// remove a tool on proximity out, tablet removal or any other reason.
// A compositor may also keep a tool alive until shutdown.
//
// If the tool is currently in proximity, a proximity_out event will be
// sent before the removed event. See wp_tablet_tool.proximity_out for
// the handling of any buttons logically down.
//
// When this event is received, the client must wp_tablet_tool.destroy
// the object.
type ZwpTabletToolV1RemovedEvent struct {
}

// Opcode returns the event opcode for zwp_tablet_tool_v1.removed in tablet_unstable_v1
func (ZwpTabletToolV1RemovedEvent) Opcode() uint16 { return 5 }

// Ensure ZwpTabletToolV1RemovedEvent implements Message.
var _ Message = ZwpTabletToolV1RemovedEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletToolV1RemovedEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure ZwpTabletToolV1RemovedEvent implements Event.
var _ Event = &ZwpTabletToolV1RemovedEvent{}

// ZwpTabletToolV1ProximityInEvent signals when proximity in event
//
// Notification that this tool is focused on a certain surface.
//
// This event can be received when the tool has moved from one surface to
// another, or when the tool has come back into proximity above the
// surface.
//
// If any button is logically down when the tool comes into proximity,
// the respective button event is sent after the proximity_in event but
// within the same frame as the proximity_in event.
type ZwpTabletToolV1ProximityInEvent struct {
	Serial uint32

	// Tablet contains The tablet the tool is in proximity of
	Tablet ObjectID

	// Surface contains The current surface the tablet tool is over
	Surface ObjectID
}

// Opcode returns the event opcode for zwp_tablet_tool_v1.proximity_in in tablet_unstable_v1
func (ZwpTabletToolV1ProximityInEvent) Opcode() uint16 { return 6 }

// Ensure ZwpTabletToolV1ProximityInEvent implements Message.
var _ Message = ZwpTabletToolV1ProximityInEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletToolV1ProximityInEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Serial = v
	}
	if v, err := s.ObjectID(); err != nil {
		return err
	} else {
		e.Tablet = v
	}
	if v, err := s.ObjectID(); err != nil {
		return err
	} else {
		e.Surface = v
	}
	return nil
}

// Ensure ZwpTabletToolV1ProximityInEvent implements Event.
var _ Event = &ZwpTabletToolV1ProximityInEvent{}

// ZwpTabletToolV1ProximityOutEvent signals when proximity out event
//
// Notification that this tool has either left proximity, or is no
// longer focused on a certain surface.
//
// When the tablet tool leaves proximity of the tablet, button release
// events are sent for each button that was held down at the time of
// leaving proximity. These events are sent before the proximity_out
// event but within the same wp_tablet.frame.
//
// If the tool stays within proximity of the tablet, but the focus
// changes from one surface to another, a button release event may not
// be sent until the button is actually released or the tool leaves the
// proximity of the tablet.
type ZwpTabletToolV1ProximityOutEvent struct {
}

// Opcode returns the event opcode for zwp_tablet_tool_v1.proximity_out in tablet_unstable_v1
func (ZwpTabletToolV1ProximityOutEvent) Opcode() uint16 { return 7 }

// Ensure ZwpTabletToolV1ProximityOutEvent implements Message.
var _ Message = ZwpTabletToolV1ProximityOutEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletToolV1ProximityOutEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure ZwpTabletToolV1ProximityOutEvent implements Event.
var _ Event = &ZwpTabletToolV1ProximityOutEvent{}

// ZwpTabletToolV1DownEvent signals when tablet tool is making contact
//
// Sent whenever the tablet tool comes in contact with the surface of the
// tablet.
//
// If the tool is already in contact with the tablet when entering the
// input region, the client owning said region will receive a
// wp_tablet.proximity_in event, followed by a wp_tablet.down
// event and a wp_tablet.frame event.
//
// Note that this event describes logical contact, not physical
// contact. On some devices, a compositor may not consider a tool in
// logical contact until a minimum physical pressure threshold is
// exceeded.
type ZwpTabletToolV1DownEvent struct {
	Serial uint32
}

// Opcode returns the event opcode for zwp_tablet_tool_v1.down in tablet_unstable_v1
func (ZwpTabletToolV1DownEvent) Opcode() uint16 { return 8 }

// Ensure ZwpTabletToolV1DownEvent implements Message.
var _ Message = ZwpTabletToolV1DownEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletToolV1DownEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Serial = v
	}
	return nil
}

// Ensure ZwpTabletToolV1DownEvent implements Event.
var _ Event = &ZwpTabletToolV1DownEvent{}

// ZwpTabletToolV1UpEvent signals when tablet tool is no longer making contact
//
// Sent whenever the tablet tool stops making contact with the surface of
// the tablet, or when the tablet tool moves out of the input region
// and the compositor grab (if any) is dismissed.
//
// If the tablet tool moves out of the input region while in contact
// with the surface of the tablet and the compositor does not have an
// ongoing grab on the surface, the client owning said region will
// receive a wp_tablet.up event, followed by a wp_tablet.proximity_out
// event and a wp_tablet.frame event. If the compositor has an ongoing
// grab on this device, this event sequence is sent whenever the grab
// is dismissed in the future.
//
// Note that this event describes logical contact, not physical
// contact. On some devices, a compositor may not consider a tool out
// of logical contact until physical pressure falls below a specific
// threshold.
type ZwpTabletToolV1UpEvent struct {
}

// Opcode returns the event opcode for zwp_tablet_tool_v1.up in tablet_unstable_v1
func (ZwpTabletToolV1UpEvent) Opcode() uint16 { return 9 }

// Ensure ZwpTabletToolV1UpEvent implements Message.
var _ Message = ZwpTabletToolV1UpEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletToolV1UpEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure ZwpTabletToolV1UpEvent implements Event.
var _ Event = &ZwpTabletToolV1UpEvent{}

// ZwpTabletToolV1MotionEvent signals when motion event
//
// Sent whenever a tablet tool moves.
type ZwpTabletToolV1MotionEvent struct {
	// X contains surface-local x coordinate
	X Fixed

	// Y contains surface-local y coordinate
	Y Fixed
}

// Opcode returns the event opcode for zwp_tablet_tool_v1.motion in tablet_unstable_v1
func (ZwpTabletToolV1MotionEvent) Opcode() uint16 { return 10 }

// Ensure ZwpTabletToolV1MotionEvent implements Message.
var _ Message = ZwpTabletToolV1MotionEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletToolV1MotionEvent) Scan(s *EventScanner) error {
	if v, err := s.Fixed(); err != nil {
		return err
	} else {
		e.X = v
	}
	if v, err := s.Fixed(); err != nil {
		return err
	} else {
		e.Y = v
	}
	return nil
}

// Ensure ZwpTabletToolV1MotionEvent implements Event.
var _ Event = &ZwpTabletToolV1MotionEvent{}

// ZwpTabletToolV1PressureEvent signals when pressure change event
//
// Sent whenever the pressure axis on a tool changes. The value of this
// event is normalized to a value between 0 and 65535.
//
// Note that pressure may be nonzero even when a tool is not in logical
// contact. See the down and up events for more details.
type ZwpTabletToolV1PressureEvent struct {
	// Pressure contains The current pressure value
	Pressure uint32
}

// Opcode returns the event opcode for zwp_tablet_tool_v1.pressure in tablet_unstable_v1
func (ZwpTabletToolV1PressureEvent) Opcode() uint16 { return 11 }

// Ensure ZwpTabletToolV1PressureEvent implements Message.
var _ Message = ZwpTabletToolV1PressureEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletToolV1PressureEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Pressure = v
	}
	return nil
}

// Ensure ZwpTabletToolV1PressureEvent implements Event.
var _ Event = &ZwpTabletToolV1PressureEvent{}

// ZwpTabletToolV1DistanceEvent signals when distance change event
//
// Sent whenever the distance axis on a tool changes. The value of this
// event is normalized to a value between 0 and 65535.
//
// Note that distance may be nonzero even when a tool is not in logical
// contact. See the down and up events for more details.
type ZwpTabletToolV1DistanceEvent struct {
	// Distance contains The current distance value
	Distance uint32
}

// Opcode returns the event opcode for zwp_tablet_tool_v1.distance in tablet_unstable_v1
func (ZwpTabletToolV1DistanceEvent) Opcode() uint16 { return 12 }

// Ensure ZwpTabletToolV1DistanceEvent implements Message.
var _ Message = ZwpTabletToolV1DistanceEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletToolV1DistanceEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Distance = v
	}
	return nil
}

// Ensure ZwpTabletToolV1DistanceEvent implements Event.
var _ Event = &ZwpTabletToolV1DistanceEvent{}

// ZwpTabletToolV1TiltEvent signals when tilt change event
//
// Sent whenever one or both of the tilt axes on a tool change. Each tilt
// value is in 0.01 of a degree, relative to the z-axis of the tablet.
// The angle is positive when the top of a tool tilts along the
// positive x or y axis.
type ZwpTabletToolV1TiltEvent struct {
	// TiltX contains The current value of the X tilt axis
	TiltX int32

	// TiltY contains The current value of the Y tilt axis
	TiltY int32
}

// Opcode returns the event opcode for zwp_tablet_tool_v1.tilt in tablet_unstable_v1
func (ZwpTabletToolV1TiltEvent) Opcode() uint16 { return 13 }

// Ensure ZwpTabletToolV1TiltEvent implements Message.
var _ Message = ZwpTabletToolV1TiltEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletToolV1TiltEvent) Scan(s *EventScanner) error {
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.TiltX = v
	}
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.TiltY = v
	}
	return nil
}

// Ensure ZwpTabletToolV1TiltEvent implements Event.
var _ Event = &ZwpTabletToolV1TiltEvent{}

// ZwpTabletToolV1RotationEvent signals when z-rotation change event
//
// Sent whenever the z-rotation axis on the tool changes. The
// rotation value is in 0.01 of a degree clockwise from the tool's
// logical neutral position.
type ZwpTabletToolV1RotationEvent struct {
	// Degrees contains The current rotation of the Z axis
	Degrees int32
}

// Opcode returns the event opcode for zwp_tablet_tool_v1.rotation in tablet_unstable_v1
func (ZwpTabletToolV1RotationEvent) Opcode() uint16 { return 14 }

// Ensure ZwpTabletToolV1RotationEvent implements Message.
var _ Message = ZwpTabletToolV1RotationEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletToolV1RotationEvent) Scan(s *EventScanner) error {
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.Degrees = v
	}
	return nil
}

// Ensure ZwpTabletToolV1RotationEvent implements Event.
var _ Event = &ZwpTabletToolV1RotationEvent{}

// ZwpTabletToolV1SliderEvent signals when Slider position change event
//
// Sent whenever the slider position on the tool changes. The
// value is normalized between -65535 and 65535, with 0 as the logical
// neutral position of the slider.
//
// The slider is available on e.g. the Wacom Airbrush tool.
type ZwpTabletToolV1SliderEvent struct {
	// Position contains The current position of slider
	Position int32
}

// Opcode returns the event opcode for zwp_tablet_tool_v1.slider in tablet_unstable_v1
func (ZwpTabletToolV1SliderEvent) Opcode() uint16 { return 15 }

// Ensure ZwpTabletToolV1SliderEvent implements Message.
var _ Message = ZwpTabletToolV1SliderEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletToolV1SliderEvent) Scan(s *EventScanner) error {
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.Position = v
	}
	return nil
}

// Ensure ZwpTabletToolV1SliderEvent implements Event.
var _ Event = &ZwpTabletToolV1SliderEvent{}

// ZwpTabletToolV1WheelEvent signals when Wheel delta event
//
// Sent whenever the wheel on the tool emits an event. This event
// contains two values for the same axis change. The degrees value is
// in 0.01 of a degree in the same orientation as the
// wl_pointer.vertical_scroll axis. The clicks value is in discrete
// logical clicks of the mouse wheel. This value may be zero if the
// movement of the wheel was less than one logical click.
//
// Clients should choose either value and avoid mixing degrees and
// clicks. The compositor may accumulate values smaller than a logical
// click and emulate click events when a certain threshold is met.
// Thus, wl_tablet_tool.wheel events with non-zero clicks values may
// have different degrees values.
type ZwpTabletToolV1WheelEvent struct {
	// Degrees contains The wheel delta in 0.01 of a degree
	Degrees int32

	// Clicks contains The wheel delta in discrete clicks
	Clicks int32
}

// Opcode returns the event opcode for zwp_tablet_tool_v1.wheel in tablet_unstable_v1
func (ZwpTabletToolV1WheelEvent) Opcode() uint16 { return 16 }

// Ensure ZwpTabletToolV1WheelEvent implements Message.
var _ Message = ZwpTabletToolV1WheelEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletToolV1WheelEvent) Scan(s *EventScanner) error {
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.Degrees = v
	}
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.Clicks = v
	}
	return nil
}

// Ensure ZwpTabletToolV1WheelEvent implements Event.
var _ Event = &ZwpTabletToolV1WheelEvent{}

// ZwpTabletToolV1ButtonEvent signals when button event
//
// Sent whenever a button on the tool is pressed or released.
//
// If a button is held down when the tool moves in or out of proximity,
// button events are generated by the compositor. See
// wp_tablet_tool.proximity_in and wp_tablet_tool.proximity_out for
// details.
type ZwpTabletToolV1ButtonEvent struct {
	Serial uint32

	// Button contains The button whose state has changed
	Button uint32

	// State contains Whether the button was pressed or released
	State uint32
}

// Opcode returns the event opcode for zwp_tablet_tool_v1.button in tablet_unstable_v1
func (ZwpTabletToolV1ButtonEvent) Opcode() uint16 { return 17 }

// Ensure ZwpTabletToolV1ButtonEvent implements Message.
var _ Message = ZwpTabletToolV1ButtonEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletToolV1ButtonEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Serial = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Button = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.State = v
	}
	return nil
}

// Ensure ZwpTabletToolV1ButtonEvent implements Event.
var _ Event = &ZwpTabletToolV1ButtonEvent{}

// ZwpTabletToolV1FrameEvent signals when frame event
//
// Marks the end of a series of axis and/or button updates from the
// tablet. The Wayland protocol requires axis updates to be sent
// sequentially, however all events within a frame should be considered
// one hardware event.
type ZwpTabletToolV1FrameEvent struct {
	// Time contains The time of the event with millisecond granularity
	Time uint32
}

// Opcode returns the event opcode for zwp_tablet_tool_v1.frame in tablet_unstable_v1
func (ZwpTabletToolV1FrameEvent) Opcode() uint16 { return 18 }

// Ensure ZwpTabletToolV1FrameEvent implements Message.
var _ Message = ZwpTabletToolV1FrameEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletToolV1FrameEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Time = v
	}
	return nil
}

// Ensure ZwpTabletToolV1FrameEvent implements Event.
var _ Event = &ZwpTabletToolV1FrameEvent{}

// #endregion Interface tablet_unstable_v1.zwp_tablet_tool_v1

// ----------------------------------------------------------------------------
// #region Interface tablet_unstable_v1.zwp_tablet_v1

// ZwpTabletV1DestroyRequest requests to destroy the tablet object
//
// This destroys the client's resource for this tablet object.
type ZwpTabletV1DestroyRequest struct {
}

// Opcode returns the request opcode for zwp_tablet_v1.destroy in tablet_unstable_v1
func (ZwpTabletV1DestroyRequest) Opcode() uint16 { return 0 }

// Ensure ZwpTabletV1DestroyRequest implements Message.
var _ Message = ZwpTabletV1DestroyRequest{}

// ZwpTabletV1NameEvent signals when tablet device name
//
// This event is sent in the initial burst of events before the
// wp_tablet.done event.
type ZwpTabletV1NameEvent struct {
	// Name contains the device name
	Name string
}

// Opcode returns the event opcode for zwp_tablet_v1.name in tablet_unstable_v1
func (ZwpTabletV1NameEvent) Opcode() uint16 { return 0 }

// Ensure ZwpTabletV1NameEvent implements Message.
var _ Message = ZwpTabletV1NameEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletV1NameEvent) Scan(s *EventScanner) error {
	if v, err := s.String(); err != nil {
		return err
	} else {
		e.Name = v
	}
	return nil
}

// Ensure ZwpTabletV1NameEvent implements Event.
var _ Event = &ZwpTabletV1NameEvent{}

// ZwpTabletV1IDEvent signals when tablet device USB vendor/product id
//
// This event is sent in the initial burst of events before the
// wp_tablet.done event.
type ZwpTabletV1IDEvent struct {
	// Vid contains USB vendor id
	Vid uint32

	// Pid contains USB product id
	Pid uint32
}

// Opcode returns the event opcode for zwp_tablet_v1.id in tablet_unstable_v1
func (ZwpTabletV1IDEvent) Opcode() uint16 { return 1 }

// Ensure ZwpTabletV1IDEvent implements Message.
var _ Message = ZwpTabletV1IDEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletV1IDEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Vid = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Pid = v
	}
	return nil
}

// Ensure ZwpTabletV1IDEvent implements Event.
var _ Event = &ZwpTabletV1IDEvent{}

// ZwpTabletV1PathEvent signals when path to the device
//
// A system-specific device path that indicates which device is behind
// this wp_tablet. This information may be used to gather additional
// information about the device, e.g. through libwacom.
//
// A device may have more than one device path. If so, multiple
// wp_tablet.path events are sent. A device may be emulated and not
// have a device path, and in that case this event will not be sent.
//
// The format of the path is unspecified, it may be a device node, a
// sysfs path, or some other identifier. It is up to the client to
// identify the string provided.
//
// This event is sent in the initial burst of events before the
// wp_tablet.done event.
type ZwpTabletV1PathEvent struct {
	// Path contains path to local device
	Path string
}

// Opcode returns the event opcode for zwp_tablet_v1.path in tablet_unstable_v1
func (ZwpTabletV1PathEvent) Opcode() uint16 { return 2 }

// Ensure ZwpTabletV1PathEvent implements Message.
var _ Message = ZwpTabletV1PathEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletV1PathEvent) Scan(s *EventScanner) error {
	if v, err := s.String(); err != nil {
		return err
	} else {
		e.Path = v
	}
	return nil
}

// Ensure ZwpTabletV1PathEvent implements Event.
var _ Event = &ZwpTabletV1PathEvent{}

// ZwpTabletV1DoneEvent signals when tablet description events sequence complete
//
// This event is sent immediately to signal the end of the initial
// burst of descriptive events. A client may consider the static
// description of the tablet to be complete and finalize initialization
// of the tablet.
type ZwpTabletV1DoneEvent struct {
}

// Opcode returns the event opcode for zwp_tablet_v1.done in tablet_unstable_v1
func (ZwpTabletV1DoneEvent) Opcode() uint16 { return 3 }

// Ensure ZwpTabletV1DoneEvent implements Message.
var _ Message = ZwpTabletV1DoneEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletV1DoneEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure ZwpTabletV1DoneEvent implements Event.
var _ Event = &ZwpTabletV1DoneEvent{}

// ZwpTabletV1RemovedEvent signals when tablet removed event
//
// Sent when the tablet has been removed from the system. When a tablet
// is removed, some tools may be removed.
//
// When this event is received, the client must wp_tablet.destroy
// the object.
type ZwpTabletV1RemovedEvent struct {
}

// Opcode returns the event opcode for zwp_tablet_v1.removed in tablet_unstable_v1
func (ZwpTabletV1RemovedEvent) Opcode() uint16 { return 4 }

// Ensure ZwpTabletV1RemovedEvent implements Message.
var _ Message = ZwpTabletV1RemovedEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletV1RemovedEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure ZwpTabletV1RemovedEvent implements Event.
var _ Event = &ZwpTabletV1RemovedEvent{}

// #endregion Interface tablet_unstable_v1.zwp_tablet_v1

////////////////////////////////////////////////////////////////////////////////
// #endregion Protocol tablet_unstable_v1

////////////////////////////////////////////////////////////////////////////////
// #region Protocol tablet_unstable_v2

// ----------------------------------------------------------------------------
// #region Interface tablet_unstable_v2.zwp_tablet_manager_v2

// ZwpTabletManagerV2GetTabletSeatRequest requests to get the tablet seat
//
// Get the wp_tablet_seat object for the given seat. This object
// provides access to all graphics tablets in this seat.
type ZwpTabletManagerV2GetTabletSeatRequest struct {
	TabletSeat ObjectID

	// Seat contains The wl_seat object to retrieve the tablets for
	Seat ObjectID
}

// Opcode returns the request opcode for zwp_tablet_manager_v2.get_tablet_seat in tablet_unstable_v2
func (ZwpTabletManagerV2GetTabletSeatRequest) Opcode() uint16 { return 0 }

// Ensure ZwpTabletManagerV2GetTabletSeatRequest implements Message.
var _ Message = ZwpTabletManagerV2GetTabletSeatRequest{}

// ZwpTabletManagerV2DestroyRequest requests to release the memory for the tablet manager object
//
// Destroy the wp_tablet_manager object. Objects created from this
// object are unaffected and should be destroyed separately.
type ZwpTabletManagerV2DestroyRequest struct {
}

// Opcode returns the request opcode for zwp_tablet_manager_v2.destroy in tablet_unstable_v2
func (ZwpTabletManagerV2DestroyRequest) Opcode() uint16 { return 1 }

// Ensure ZwpTabletManagerV2DestroyRequest implements Message.
var _ Message = ZwpTabletManagerV2DestroyRequest{}

// #endregion Interface tablet_unstable_v2.zwp_tablet_manager_v2

// ----------------------------------------------------------------------------
// #region Interface tablet_unstable_v2.zwp_tablet_seat_v2

// ZwpTabletSeatV2DestroyRequest requests to release the memory for the tablet seat object
//
// Destroy the wp_tablet_seat object. Objects created from this
// object are unaffected and should be destroyed separately.
type ZwpTabletSeatV2DestroyRequest struct {
}

// Opcode returns the request opcode for zwp_tablet_seat_v2.destroy in tablet_unstable_v2
func (ZwpTabletSeatV2DestroyRequest) Opcode() uint16 { return 0 }

// Ensure ZwpTabletSeatV2DestroyRequest implements Message.
var _ Message = ZwpTabletSeatV2DestroyRequest{}

// ZwpTabletSeatV2TabletAddedEvent signals when new device notification
//
// This event is sent whenever a new tablet becomes available on this
// seat. This event only provides the object id of the tablet, any
// static information about the tablet (device name, vid/pid, etc.) is
// sent through the wp_tablet interface.
type ZwpTabletSeatV2TabletAddedEvent struct {
	// ID contains the newly added graphics tablet
	ID ObjectID
}

// Opcode returns the event opcode for zwp_tablet_seat_v2.tablet_added in tablet_unstable_v2
func (ZwpTabletSeatV2TabletAddedEvent) Opcode() uint16 { return 0 }

// Ensure ZwpTabletSeatV2TabletAddedEvent implements Message.
var _ Message = ZwpTabletSeatV2TabletAddedEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletSeatV2TabletAddedEvent) Scan(s *EventScanner) error {
	if v, err := s.ObjectID(); err != nil {
		return err
	} else {
		e.ID = v
	}
	return nil
}

// Ensure ZwpTabletSeatV2TabletAddedEvent implements Event.
var _ Event = &ZwpTabletSeatV2TabletAddedEvent{}

// ZwpTabletSeatV2ToolAddedEvent signals when a new tool has been used with a tablet
//
// This event is sent whenever a tool that has not previously been used
// with a tablet comes into use. This event only provides the object id
// of the tool; any static information about the tool (capabilities,
// type, etc.) is sent through the wp_tablet_tool interface.
type ZwpTabletSeatV2ToolAddedEvent struct {
	// ID contains the newly added tablet tool
	ID ObjectID
}

// Opcode returns the event opcode for zwp_tablet_seat_v2.tool_added in tablet_unstable_v2
func (ZwpTabletSeatV2ToolAddedEvent) Opcode() uint16 { return 1 }

// Ensure ZwpTabletSeatV2ToolAddedEvent implements Message.
var _ Message = ZwpTabletSeatV2ToolAddedEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletSeatV2ToolAddedEvent) Scan(s *EventScanner) error {
	if v, err := s.ObjectID(); err != nil {
		return err
	} else {
		e.ID = v
	}
	return nil
}

// Ensure ZwpTabletSeatV2ToolAddedEvent implements Event.
var _ Event = &ZwpTabletSeatV2ToolAddedEvent{}

// ZwpTabletSeatV2PadAddedEvent signals when new pad notification
//
// This event is sent whenever a new pad is known to the system. Typically,
// pads are physically attached to tablets and a pad_added event is
// sent immediately after the wp_tablet_seat.tablet_added.
// However, some standalone pad devices logically attach to tablets at
// runtime, and the client must wait for wp_tablet_pad.enter to know
// the tablet a pad is attached to.
//
// This event only provides the object id of the pad. All further
// features (buttons, strips, rings) are sent through the wp_tablet_pad
// interface.
type ZwpTabletSeatV2PadAddedEvent struct {
	// ID contains the newly added pad
	ID ObjectID
}

// Opcode returns the event opcode for zwp_tablet_seat_v2.pad_added in tablet_unstable_v2
func (ZwpTabletSeatV2PadAddedEvent) Opcode() uint16 { return 2 }

// Ensure ZwpTabletSeatV2PadAddedEvent implements Message.
var _ Message = ZwpTabletSeatV2PadAddedEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletSeatV2PadAddedEvent) Scan(s *EventScanner) error {
	if v, err := s.ObjectID(); err != nil {
		return err
	} else {
		e.ID = v
	}
	return nil
}

// Ensure ZwpTabletSeatV2PadAddedEvent implements Event.
var _ Event = &ZwpTabletSeatV2PadAddedEvent{}

// #endregion Interface tablet_unstable_v2.zwp_tablet_seat_v2

// ----------------------------------------------------------------------------
// #region Interface tablet_unstable_v2.zwp_tablet_tool_v2

// ZwpTabletToolV2Type represents a physical tool type
//
// Describes the physical type of a tool. The physical type of a tool
// generally defines its base usage.
//
// The mouse tool represents a mouse-shaped tool that is not a relative
// device but bound to the tablet's surface, providing absolute
// coordinates.
//
// The lens tool is a mouse-shaped tool with an attached lens to
// provide precision focus.
type ZwpTabletToolV2Type int

const (
	// ZwpTabletToolV2TypePen corresponds to Pen
	ZwpTabletToolV2TypePen ZwpTabletToolV2Type = 0x140

	// ZwpTabletToolV2TypeEraser corresponds to Eraser
	ZwpTabletToolV2TypeEraser ZwpTabletToolV2Type = 0x141

	// ZwpTabletToolV2TypeBrush corresponds to Brush
	ZwpTabletToolV2TypeBrush ZwpTabletToolV2Type = 0x142

	// ZwpTabletToolV2TypePencil corresponds to Pencil
	ZwpTabletToolV2TypePencil ZwpTabletToolV2Type = 0x143

	// ZwpTabletToolV2TypeAirbrush corresponds to Airbrush
	ZwpTabletToolV2TypeAirbrush ZwpTabletToolV2Type = 0x144

	// ZwpTabletToolV2TypeFinger corresponds to Finger
	ZwpTabletToolV2TypeFinger ZwpTabletToolV2Type = 0x145

	// ZwpTabletToolV2TypeMouse corresponds to Mouse
	ZwpTabletToolV2TypeMouse ZwpTabletToolV2Type = 0x146

	// ZwpTabletToolV2TypeLens corresponds to Lens
	ZwpTabletToolV2TypeLens ZwpTabletToolV2Type = 0x147
)

// ZwpTabletToolV2Capability represents capability flags for a tool
//
// Describes extra capabilities on a tablet.
//
// Any tool must provide x and y values, extra axes are
// device-specific.
type ZwpTabletToolV2Capability int

const (
	// ZwpTabletToolV2CapabilityTilt corresponds to Tilt axes
	ZwpTabletToolV2CapabilityTilt ZwpTabletToolV2Capability = 1

	// ZwpTabletToolV2CapabilityPressure corresponds to Pressure axis
	ZwpTabletToolV2CapabilityPressure ZwpTabletToolV2Capability = 2

	// ZwpTabletToolV2CapabilityDistance corresponds to Distance axis
	ZwpTabletToolV2CapabilityDistance ZwpTabletToolV2Capability = 3

	// ZwpTabletToolV2CapabilityRotation corresponds to Z-rotation axis
	ZwpTabletToolV2CapabilityRotation ZwpTabletToolV2Capability = 4

	// ZwpTabletToolV2CapabilitySlider corresponds to Slider axis
	ZwpTabletToolV2CapabilitySlider ZwpTabletToolV2Capability = 5

	// ZwpTabletToolV2CapabilityWheel corresponds to Wheel axis
	ZwpTabletToolV2CapabilityWheel ZwpTabletToolV2Capability = 6
)

// ZwpTabletToolV2ButtonState represents physical button state
//
// Describes the physical state of a button that produced the button event.
type ZwpTabletToolV2ButtonState int

const (
	// ZwpTabletToolV2ButtonStateReleased corresponds to button is not pressed
	ZwpTabletToolV2ButtonStateReleased ZwpTabletToolV2ButtonState = 0

	// ZwpTabletToolV2ButtonStatePressed corresponds to button is pressed
	ZwpTabletToolV2ButtonStatePressed ZwpTabletToolV2ButtonState = 1
)

type ZwpTabletToolV2Error int

const (
	// ZwpTabletToolV2ErrorRole corresponds to given wl_surface has another role
	ZwpTabletToolV2ErrorRole ZwpTabletToolV2Error = 0
)

// ZwpTabletToolV2SetCursorRequest requests to set the tablet tool's surface
//
// Sets the surface of the cursor used for this tool on the given
// tablet. This request only takes effect if the tool is in proximity
// of one of the requesting client's surfaces or the surface parameter
// is the current pointer surface. If there was a previous surface set
// with this request it is replaced. If surface is NULL, the cursor
// image is hidden.
//
// The parameters hotspot_x and hotspot_y define the position of the
// pointer surface relative to the pointer location. Its top-left corner
// is always at (x, y) - (hotspot_x, hotspot_y), where (x, y) are the
// coordinates of the pointer location, in surface-local coordinates.
//
// On surface.attach requests to the pointer surface, hotspot_x and
// hotspot_y are decremented by the x and y parameters passed to the
// request. Attach must be confirmed by wl_surface.commit as usual.
//
// The hotspot can also be updated by passing the currently set pointer
// surface to this request with new values for hotspot_x and hotspot_y.
//
// The current and pending input regions of the wl_surface are cleared,
// and wl_surface.set_input_region is ignored until the wl_surface is no
// longer used as the cursor. When the use as a cursor ends, the current
// and pending input regions become undefined, and the wl_surface is
// unmapped.
//
// This request gives the surface the role of a wp_tablet_tool cursor. A
// surface may only ever be used as the cursor surface for one
// wp_tablet_tool. If the surface already has another role or has
// previously been used as cursor surface for a different tool, a
// protocol error is raised.
type ZwpTabletToolV2SetCursorRequest struct {
	// Serial contains serial of the enter event
	Serial uint32

	Surface ObjectID

	// HotspotX contains surface-local x coordinate
	HotspotX int32

	// HotspotY contains surface-local y coordinate
	HotspotY int32
}

// Opcode returns the request opcode for zwp_tablet_tool_v2.set_cursor in tablet_unstable_v2
func (ZwpTabletToolV2SetCursorRequest) Opcode() uint16 { return 0 }

// Ensure ZwpTabletToolV2SetCursorRequest implements Message.
var _ Message = ZwpTabletToolV2SetCursorRequest{}

// ZwpTabletToolV2DestroyRequest requests to destroy the tool object
//
// This destroys the client's resource for this tool object.
type ZwpTabletToolV2DestroyRequest struct {
}

// Opcode returns the request opcode for zwp_tablet_tool_v2.destroy in tablet_unstable_v2
func (ZwpTabletToolV2DestroyRequest) Opcode() uint16 { return 1 }

// Ensure ZwpTabletToolV2DestroyRequest implements Message.
var _ Message = ZwpTabletToolV2DestroyRequest{}

// ZwpTabletToolV2TypeEvent signals when tool type
//
// The tool type is the high-level type of the tool and usually decides
// the interaction expected from this tool.
//
// This event is sent in the initial burst of events before the
// wp_tablet_tool.done event.
type ZwpTabletToolV2TypeEvent struct {
	// ToolType contains the physical tool type
	ToolType uint32
}

// Opcode returns the event opcode for zwp_tablet_tool_v2.type in tablet_unstable_v2
func (ZwpTabletToolV2TypeEvent) Opcode() uint16 { return 0 }

// Ensure ZwpTabletToolV2TypeEvent implements Message.
var _ Message = ZwpTabletToolV2TypeEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletToolV2TypeEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.ToolType = v
	}
	return nil
}

// Ensure ZwpTabletToolV2TypeEvent implements Event.
var _ Event = &ZwpTabletToolV2TypeEvent{}

// ZwpTabletToolV2HardwareSerialEvent signals when unique hardware serial number of the tool
//
// If the physical tool can be identified by a unique 64-bit serial
// number, this event notifies the client of this serial number.
//
// If multiple tablets are available in the same seat and the tool is
// uniquely identifiable by the serial number, that tool may move
// between tablets.
//
// Otherwise, if the tool has no serial number and this event is
// missing, the tool is tied to the tablet it first comes into
// proximity with. Even if the physical tool is used on multiple
// tablets, separate wp_tablet_tool objects will be created, one per
// tablet.
//
// This event is sent in the initial burst of events before the
// wp_tablet_tool.done event.
type ZwpTabletToolV2HardwareSerialEvent struct {
	// HardwareSerialHi contains the unique serial number of the tool, most significant bits
	HardwareSerialHi uint32

	// HardwareSerialLo contains the unique serial number of the tool, least significant bits
	HardwareSerialLo uint32
}

// Opcode returns the event opcode for zwp_tablet_tool_v2.hardware_serial in tablet_unstable_v2
func (ZwpTabletToolV2HardwareSerialEvent) Opcode() uint16 { return 1 }

// Ensure ZwpTabletToolV2HardwareSerialEvent implements Message.
var _ Message = ZwpTabletToolV2HardwareSerialEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletToolV2HardwareSerialEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.HardwareSerialHi = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.HardwareSerialLo = v
	}
	return nil
}

// Ensure ZwpTabletToolV2HardwareSerialEvent implements Event.
var _ Event = &ZwpTabletToolV2HardwareSerialEvent{}

// ZwpTabletToolV2HardwareIDWacomEvent signals when hardware id notification in Wacom's format
//
// This event notifies the client of a hardware id available on this tool.
//
// The hardware id is a device-specific 64-bit id that provides extra
// information about the tool in use, beyond the wl_tool.type
// enumeration. The format of the id is specific to tablets made by
// Wacom Inc. For example, the hardware id of a Wacom Grip
// Pen (a stylus) is 0x802.
//
// This event is sent in the initial burst of events before the
// wp_tablet_tool.done event.
type ZwpTabletToolV2HardwareIDWacomEvent struct {
	// HardwareIDHi contains the hardware id, most significant bits
	HardwareIDHi uint32

	// HardwareIDLo contains the hardware id, least significant bits
	HardwareIDLo uint32
}

// Opcode returns the event opcode for zwp_tablet_tool_v2.hardware_id_wacom in tablet_unstable_v2
func (ZwpTabletToolV2HardwareIDWacomEvent) Opcode() uint16 { return 2 }

// Ensure ZwpTabletToolV2HardwareIDWacomEvent implements Message.
var _ Message = ZwpTabletToolV2HardwareIDWacomEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletToolV2HardwareIDWacomEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.HardwareIDHi = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.HardwareIDLo = v
	}
	return nil
}

// Ensure ZwpTabletToolV2HardwareIDWacomEvent implements Event.
var _ Event = &ZwpTabletToolV2HardwareIDWacomEvent{}

// ZwpTabletToolV2CapabilityEvent signals when tool capability notification
//
// This event notifies the client of any capabilities of this tool,
// beyond the main set of x/y axes and tip up/down detection.
//
// One event is sent for each extra capability available on this tool.
//
// This event is sent in the initial burst of events before the
// wp_tablet_tool.done event.
type ZwpTabletToolV2CapabilityEvent struct {
	// Capability contains the capability
	Capability uint32
}

// Opcode returns the event opcode for zwp_tablet_tool_v2.capability in tablet_unstable_v2
func (ZwpTabletToolV2CapabilityEvent) Opcode() uint16 { return 3 }

// Ensure ZwpTabletToolV2CapabilityEvent implements Message.
var _ Message = ZwpTabletToolV2CapabilityEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletToolV2CapabilityEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Capability = v
	}
	return nil
}

// Ensure ZwpTabletToolV2CapabilityEvent implements Event.
var _ Event = &ZwpTabletToolV2CapabilityEvent{}

// ZwpTabletToolV2DoneEvent signals when tool description events sequence complete
//
// This event signals the end of the initial burst of descriptive
// events. A client may consider the static description of the tool to
// be complete and finalize initialization of the tool.
type ZwpTabletToolV2DoneEvent struct {
}

// Opcode returns the event opcode for zwp_tablet_tool_v2.done in tablet_unstable_v2
func (ZwpTabletToolV2DoneEvent) Opcode() uint16 { return 4 }

// Ensure ZwpTabletToolV2DoneEvent implements Message.
var _ Message = ZwpTabletToolV2DoneEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletToolV2DoneEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure ZwpTabletToolV2DoneEvent implements Event.
var _ Event = &ZwpTabletToolV2DoneEvent{}

// ZwpTabletToolV2RemovedEvent signals when tool removed
//
// This event is sent when the tool is removed from the system and will
// send no further events. Should the physical tool come back into
// proximity later, a new wp_tablet_tool object will be created.
//
// It is compositor-dependent when a tool is removed. A compositor may
// remove a tool on proximity out, tablet removal or any other reason.
// A compositor may also keep a tool alive until shutdown.
//
// If the tool is currently in proximity, a proximity_out event will be
// sent before the removed event. See wp_tablet_tool.proximity_out for
// the handling of any buttons logically down.
//
// When this event is received, the client must wp_tablet_tool.destroy
// the object.
type ZwpTabletToolV2RemovedEvent struct {
}

// Opcode returns the event opcode for zwp_tablet_tool_v2.removed in tablet_unstable_v2
func (ZwpTabletToolV2RemovedEvent) Opcode() uint16 { return 5 }

// Ensure ZwpTabletToolV2RemovedEvent implements Message.
var _ Message = ZwpTabletToolV2RemovedEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletToolV2RemovedEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure ZwpTabletToolV2RemovedEvent implements Event.
var _ Event = &ZwpTabletToolV2RemovedEvent{}

// ZwpTabletToolV2ProximityInEvent signals when proximity in event
//
// Notification that this tool is focused on a certain surface.
//
// This event can be received when the tool has moved from one surface to
// another, or when the tool has come back into proximity above the
// surface.
//
// If any button is logically down when the tool comes into proximity,
// the respective button event is sent after the proximity_in event but
// within the same frame as the proximity_in event.
type ZwpTabletToolV2ProximityInEvent struct {
	Serial uint32

	// Tablet contains The tablet the tool is in proximity of
	Tablet ObjectID

	// Surface contains The current surface the tablet tool is over
	Surface ObjectID
}

// Opcode returns the event opcode for zwp_tablet_tool_v2.proximity_in in tablet_unstable_v2
func (ZwpTabletToolV2ProximityInEvent) Opcode() uint16 { return 6 }

// Ensure ZwpTabletToolV2ProximityInEvent implements Message.
var _ Message = ZwpTabletToolV2ProximityInEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletToolV2ProximityInEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Serial = v
	}
	if v, err := s.ObjectID(); err != nil {
		return err
	} else {
		e.Tablet = v
	}
	if v, err := s.ObjectID(); err != nil {
		return err
	} else {
		e.Surface = v
	}
	return nil
}

// Ensure ZwpTabletToolV2ProximityInEvent implements Event.
var _ Event = &ZwpTabletToolV2ProximityInEvent{}

// ZwpTabletToolV2ProximityOutEvent signals when proximity out event
//
// Notification that this tool has either left proximity, or is no
// longer focused on a certain surface.
//
// When the tablet tool leaves proximity of the tablet, button release
// events are sent for each button that was held down at the time of
// leaving proximity. These events are sent before the proximity_out
// event but within the same wp_tablet.frame.
//
// If the tool stays within proximity of the tablet, but the focus
// changes from one surface to another, a button release event may not
// be sent until the button is actually released or the tool leaves the
// proximity of the tablet.
type ZwpTabletToolV2ProximityOutEvent struct {
}

// Opcode returns the event opcode for zwp_tablet_tool_v2.proximity_out in tablet_unstable_v2
func (ZwpTabletToolV2ProximityOutEvent) Opcode() uint16 { return 7 }

// Ensure ZwpTabletToolV2ProximityOutEvent implements Message.
var _ Message = ZwpTabletToolV2ProximityOutEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletToolV2ProximityOutEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure ZwpTabletToolV2ProximityOutEvent implements Event.
var _ Event = &ZwpTabletToolV2ProximityOutEvent{}

// ZwpTabletToolV2DownEvent signals when tablet tool is making contact
//
// Sent whenever the tablet tool comes in contact with the surface of the
// tablet.
//
// If the tool is already in contact with the tablet when entering the
// input region, the client owning said region will receive a
// wp_tablet.proximity_in event, followed by a wp_tablet.down
// event and a wp_tablet.frame event.
//
// Note that this event describes logical contact, not physical
// contact. On some devices, a compositor may not consider a tool in
// logical contact until a minimum physical pressure threshold is
// exceeded.
type ZwpTabletToolV2DownEvent struct {
	Serial uint32
}

// Opcode returns the event opcode for zwp_tablet_tool_v2.down in tablet_unstable_v2
func (ZwpTabletToolV2DownEvent) Opcode() uint16 { return 8 }

// Ensure ZwpTabletToolV2DownEvent implements Message.
var _ Message = ZwpTabletToolV2DownEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletToolV2DownEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Serial = v
	}
	return nil
}

// Ensure ZwpTabletToolV2DownEvent implements Event.
var _ Event = &ZwpTabletToolV2DownEvent{}

// ZwpTabletToolV2UpEvent signals when tablet tool is no longer making contact
//
// Sent whenever the tablet tool stops making contact with the surface of
// the tablet, or when the tablet tool moves out of the input region
// and the compositor grab (if any) is dismissed.
//
// If the tablet tool moves out of the input region while in contact
// with the surface of the tablet and the compositor does not have an
// ongoing grab on the surface, the client owning said region will
// receive a wp_tablet.up event, followed by a wp_tablet.proximity_out
// event and a wp_tablet.frame event. If the compositor has an ongoing
// grab on this device, this event sequence is sent whenever the grab
// is dismissed in the future.
//
// Note that this event describes logical contact, not physical
// contact. On some devices, a compositor may not consider a tool out
// of logical contact until physical pressure falls below a specific
// threshold.
type ZwpTabletToolV2UpEvent struct {
}

// Opcode returns the event opcode for zwp_tablet_tool_v2.up in tablet_unstable_v2
func (ZwpTabletToolV2UpEvent) Opcode() uint16 { return 9 }

// Ensure ZwpTabletToolV2UpEvent implements Message.
var _ Message = ZwpTabletToolV2UpEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletToolV2UpEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure ZwpTabletToolV2UpEvent implements Event.
var _ Event = &ZwpTabletToolV2UpEvent{}

// ZwpTabletToolV2MotionEvent signals when motion event
//
// Sent whenever a tablet tool moves.
type ZwpTabletToolV2MotionEvent struct {
	// X contains surface-local x coordinate
	X Fixed

	// Y contains surface-local y coordinate
	Y Fixed
}

// Opcode returns the event opcode for zwp_tablet_tool_v2.motion in tablet_unstable_v2
func (ZwpTabletToolV2MotionEvent) Opcode() uint16 { return 10 }

// Ensure ZwpTabletToolV2MotionEvent implements Message.
var _ Message = ZwpTabletToolV2MotionEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletToolV2MotionEvent) Scan(s *EventScanner) error {
	if v, err := s.Fixed(); err != nil {
		return err
	} else {
		e.X = v
	}
	if v, err := s.Fixed(); err != nil {
		return err
	} else {
		e.Y = v
	}
	return nil
}

// Ensure ZwpTabletToolV2MotionEvent implements Event.
var _ Event = &ZwpTabletToolV2MotionEvent{}

// ZwpTabletToolV2PressureEvent signals when pressure change event
//
// Sent whenever the pressure axis on a tool changes. The value of this
// event is normalized to a value between 0 and 65535.
//
// Note that pressure may be nonzero even when a tool is not in logical
// contact. See the down and up events for more details.
type ZwpTabletToolV2PressureEvent struct {
	// Pressure contains The current pressure value
	Pressure uint32
}

// Opcode returns the event opcode for zwp_tablet_tool_v2.pressure in tablet_unstable_v2
func (ZwpTabletToolV2PressureEvent) Opcode() uint16 { return 11 }

// Ensure ZwpTabletToolV2PressureEvent implements Message.
var _ Message = ZwpTabletToolV2PressureEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletToolV2PressureEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Pressure = v
	}
	return nil
}

// Ensure ZwpTabletToolV2PressureEvent implements Event.
var _ Event = &ZwpTabletToolV2PressureEvent{}

// ZwpTabletToolV2DistanceEvent signals when distance change event
//
// Sent whenever the distance axis on a tool changes. The value of this
// event is normalized to a value between 0 and 65535.
//
// Note that distance may be nonzero even when a tool is not in logical
// contact. See the down and up events for more details.
type ZwpTabletToolV2DistanceEvent struct {
	// Distance contains The current distance value
	Distance uint32
}

// Opcode returns the event opcode for zwp_tablet_tool_v2.distance in tablet_unstable_v2
func (ZwpTabletToolV2DistanceEvent) Opcode() uint16 { return 12 }

// Ensure ZwpTabletToolV2DistanceEvent implements Message.
var _ Message = ZwpTabletToolV2DistanceEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletToolV2DistanceEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Distance = v
	}
	return nil
}

// Ensure ZwpTabletToolV2DistanceEvent implements Event.
var _ Event = &ZwpTabletToolV2DistanceEvent{}

// ZwpTabletToolV2TiltEvent signals when tilt change event
//
// Sent whenever one or both of the tilt axes on a tool change. Each tilt
// value is in degrees, relative to the z-axis of the tablet.
// The angle is positive when the top of a tool tilts along the
// positive x or y axis.
type ZwpTabletToolV2TiltEvent struct {
	// TiltX contains The current value of the X tilt axis
	TiltX Fixed

	// TiltY contains The current value of the Y tilt axis
	TiltY Fixed
}

// Opcode returns the event opcode for zwp_tablet_tool_v2.tilt in tablet_unstable_v2
func (ZwpTabletToolV2TiltEvent) Opcode() uint16 { return 13 }

// Ensure ZwpTabletToolV2TiltEvent implements Message.
var _ Message = ZwpTabletToolV2TiltEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletToolV2TiltEvent) Scan(s *EventScanner) error {
	if v, err := s.Fixed(); err != nil {
		return err
	} else {
		e.TiltX = v
	}
	if v, err := s.Fixed(); err != nil {
		return err
	} else {
		e.TiltY = v
	}
	return nil
}

// Ensure ZwpTabletToolV2TiltEvent implements Event.
var _ Event = &ZwpTabletToolV2TiltEvent{}

// ZwpTabletToolV2RotationEvent signals when z-rotation change event
//
// Sent whenever the z-rotation axis on the tool changes. The
// rotation value is in degrees clockwise from the tool's
// logical neutral position.
type ZwpTabletToolV2RotationEvent struct {
	// Degrees contains The current rotation of the Z axis
	Degrees Fixed
}

// Opcode returns the event opcode for zwp_tablet_tool_v2.rotation in tablet_unstable_v2
func (ZwpTabletToolV2RotationEvent) Opcode() uint16 { return 14 }

// Ensure ZwpTabletToolV2RotationEvent implements Message.
var _ Message = ZwpTabletToolV2RotationEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletToolV2RotationEvent) Scan(s *EventScanner) error {
	if v, err := s.Fixed(); err != nil {
		return err
	} else {
		e.Degrees = v
	}
	return nil
}

// Ensure ZwpTabletToolV2RotationEvent implements Event.
var _ Event = &ZwpTabletToolV2RotationEvent{}

// ZwpTabletToolV2SliderEvent signals when Slider position change event
//
// Sent whenever the slider position on the tool changes. The
// value is normalized between -65535 and 65535, with 0 as the logical
// neutral position of the slider.
//
// The slider is available on e.g. the Wacom Airbrush tool.
type ZwpTabletToolV2SliderEvent struct {
	// Position contains The current position of slider
	Position int32
}

// Opcode returns the event opcode for zwp_tablet_tool_v2.slider in tablet_unstable_v2
func (ZwpTabletToolV2SliderEvent) Opcode() uint16 { return 15 }

// Ensure ZwpTabletToolV2SliderEvent implements Message.
var _ Message = ZwpTabletToolV2SliderEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletToolV2SliderEvent) Scan(s *EventScanner) error {
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.Position = v
	}
	return nil
}

// Ensure ZwpTabletToolV2SliderEvent implements Event.
var _ Event = &ZwpTabletToolV2SliderEvent{}

// ZwpTabletToolV2WheelEvent signals when Wheel delta event
//
// Sent whenever the wheel on the tool emits an event. This event
// contains two values for the same axis change. The degrees value is
// in the same orientation as the wl_pointer.vertical_scroll axis. The
// clicks value is in discrete logical clicks of the mouse wheel. This
// value may be zero if the movement of the wheel was less
// than one logical click.
//
// Clients should choose either value and avoid mixing degrees and
// clicks. The compositor may accumulate values smaller than a logical
// click and emulate click events when a certain threshold is met.
// Thus, wl_tablet_tool.wheel events with non-zero clicks values may
// have different degrees values.
type ZwpTabletToolV2WheelEvent struct {
	// Degrees contains The wheel delta in degrees
	Degrees Fixed

	// Clicks contains The wheel delta in discrete clicks
	Clicks int32
}

// Opcode returns the event opcode for zwp_tablet_tool_v2.wheel in tablet_unstable_v2
func (ZwpTabletToolV2WheelEvent) Opcode() uint16 { return 16 }

// Ensure ZwpTabletToolV2WheelEvent implements Message.
var _ Message = ZwpTabletToolV2WheelEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletToolV2WheelEvent) Scan(s *EventScanner) error {
	if v, err := s.Fixed(); err != nil {
		return err
	} else {
		e.Degrees = v
	}
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.Clicks = v
	}
	return nil
}

// Ensure ZwpTabletToolV2WheelEvent implements Event.
var _ Event = &ZwpTabletToolV2WheelEvent{}

// ZwpTabletToolV2ButtonEvent signals when button event
//
// Sent whenever a button on the tool is pressed or released.
//
// If a button is held down when the tool moves in or out of proximity,
// button events are generated by the compositor. See
// wp_tablet_tool.proximity_in and wp_tablet_tool.proximity_out for
// details.
type ZwpTabletToolV2ButtonEvent struct {
	Serial uint32

	// Button contains The button whose state has changed
	Button uint32

	// State contains Whether the button was pressed or released
	State uint32
}

// Opcode returns the event opcode for zwp_tablet_tool_v2.button in tablet_unstable_v2
func (ZwpTabletToolV2ButtonEvent) Opcode() uint16 { return 17 }

// Ensure ZwpTabletToolV2ButtonEvent implements Message.
var _ Message = ZwpTabletToolV2ButtonEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletToolV2ButtonEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Serial = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Button = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.State = v
	}
	return nil
}

// Ensure ZwpTabletToolV2ButtonEvent implements Event.
var _ Event = &ZwpTabletToolV2ButtonEvent{}

// ZwpTabletToolV2FrameEvent signals when frame event
//
// Marks the end of a series of axis and/or button updates from the
// tablet. The Wayland protocol requires axis updates to be sent
// sequentially, however all events within a frame should be considered
// one hardware event.
type ZwpTabletToolV2FrameEvent struct {
	// Time contains The time of the event with millisecond granularity
	Time uint32
}

// Opcode returns the event opcode for zwp_tablet_tool_v2.frame in tablet_unstable_v2
func (ZwpTabletToolV2FrameEvent) Opcode() uint16 { return 18 }

// Ensure ZwpTabletToolV2FrameEvent implements Message.
var _ Message = ZwpTabletToolV2FrameEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletToolV2FrameEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Time = v
	}
	return nil
}

// Ensure ZwpTabletToolV2FrameEvent implements Event.
var _ Event = &ZwpTabletToolV2FrameEvent{}

// #endregion Interface tablet_unstable_v2.zwp_tablet_tool_v2

// ----------------------------------------------------------------------------
// #region Interface tablet_unstable_v2.zwp_tablet_v2

// ZwpTabletV2DestroyRequest requests to destroy the tablet object
//
// This destroys the client's resource for this tablet object.
type ZwpTabletV2DestroyRequest struct {
}

// Opcode returns the request opcode for zwp_tablet_v2.destroy in tablet_unstable_v2
func (ZwpTabletV2DestroyRequest) Opcode() uint16 { return 0 }

// Ensure ZwpTabletV2DestroyRequest implements Message.
var _ Message = ZwpTabletV2DestroyRequest{}

// ZwpTabletV2NameEvent signals when tablet device name
//
// This event is sent in the initial burst of events before the
// wp_tablet.done event.
type ZwpTabletV2NameEvent struct {
	// Name contains the device name
	Name string
}

// Opcode returns the event opcode for zwp_tablet_v2.name in tablet_unstable_v2
func (ZwpTabletV2NameEvent) Opcode() uint16 { return 0 }

// Ensure ZwpTabletV2NameEvent implements Message.
var _ Message = ZwpTabletV2NameEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletV2NameEvent) Scan(s *EventScanner) error {
	if v, err := s.String(); err != nil {
		return err
	} else {
		e.Name = v
	}
	return nil
}

// Ensure ZwpTabletV2NameEvent implements Event.
var _ Event = &ZwpTabletV2NameEvent{}

// ZwpTabletV2IDEvent signals when tablet device USB vendor/product id
//
// This event is sent in the initial burst of events before the
// wp_tablet.done event.
type ZwpTabletV2IDEvent struct {
	// Vid contains USB vendor id
	Vid uint32

	// Pid contains USB product id
	Pid uint32
}

// Opcode returns the event opcode for zwp_tablet_v2.id in tablet_unstable_v2
func (ZwpTabletV2IDEvent) Opcode() uint16 { return 1 }

// Ensure ZwpTabletV2IDEvent implements Message.
var _ Message = ZwpTabletV2IDEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletV2IDEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Vid = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Pid = v
	}
	return nil
}

// Ensure ZwpTabletV2IDEvent implements Event.
var _ Event = &ZwpTabletV2IDEvent{}

// ZwpTabletV2PathEvent signals when path to the device
//
// A system-specific device path that indicates which device is behind
// this wp_tablet. This information may be used to gather additional
// information about the device, e.g. through libwacom.
//
// A device may have more than one device path. If so, multiple
// wp_tablet.path events are sent. A device may be emulated and not
// have a device path, and in that case this event will not be sent.
//
// The format of the path is unspecified, it may be a device node, a
// sysfs path, or some other identifier. It is up to the client to
// identify the string provided.
//
// This event is sent in the initial burst of events before the
// wp_tablet.done event.
type ZwpTabletV2PathEvent struct {
	// Path contains path to local device
	Path string
}

// Opcode returns the event opcode for zwp_tablet_v2.path in tablet_unstable_v2
func (ZwpTabletV2PathEvent) Opcode() uint16 { return 2 }

// Ensure ZwpTabletV2PathEvent implements Message.
var _ Message = ZwpTabletV2PathEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletV2PathEvent) Scan(s *EventScanner) error {
	if v, err := s.String(); err != nil {
		return err
	} else {
		e.Path = v
	}
	return nil
}

// Ensure ZwpTabletV2PathEvent implements Event.
var _ Event = &ZwpTabletV2PathEvent{}

// ZwpTabletV2DoneEvent signals when tablet description events sequence complete
//
// This event is sent immediately to signal the end of the initial
// burst of descriptive events. A client may consider the static
// description of the tablet to be complete and finalize initialization
// of the tablet.
type ZwpTabletV2DoneEvent struct {
}

// Opcode returns the event opcode for zwp_tablet_v2.done in tablet_unstable_v2
func (ZwpTabletV2DoneEvent) Opcode() uint16 { return 3 }

// Ensure ZwpTabletV2DoneEvent implements Message.
var _ Message = ZwpTabletV2DoneEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletV2DoneEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure ZwpTabletV2DoneEvent implements Event.
var _ Event = &ZwpTabletV2DoneEvent{}

// ZwpTabletV2RemovedEvent signals when tablet removed event
//
// Sent when the tablet has been removed from the system. When a tablet
// is removed, some tools may be removed.
//
// When this event is received, the client must wp_tablet.destroy
// the object.
type ZwpTabletV2RemovedEvent struct {
}

// Opcode returns the event opcode for zwp_tablet_v2.removed in tablet_unstable_v2
func (ZwpTabletV2RemovedEvent) Opcode() uint16 { return 4 }

// Ensure ZwpTabletV2RemovedEvent implements Message.
var _ Message = ZwpTabletV2RemovedEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletV2RemovedEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure ZwpTabletV2RemovedEvent implements Event.
var _ Event = &ZwpTabletV2RemovedEvent{}

// #endregion Interface tablet_unstable_v2.zwp_tablet_v2

// ----------------------------------------------------------------------------
// #region Interface tablet_unstable_v2.zwp_tablet_pad_ring_v2

// ZwpTabletPadRingV2Source represents ring axis source
//
// Describes the source types for ring events. This indicates to the
// client how a ring event was physically generated; a client may
// adjust the user interface accordingly. For example, events
// from a "finger" source may trigger kinetic scrolling.
type ZwpTabletPadRingV2Source int

const (
	// ZwpTabletPadRingV2SourceFinger corresponds to finger
	ZwpTabletPadRingV2SourceFinger ZwpTabletPadRingV2Source = 1
)

// ZwpTabletPadRingV2SetFeedbackRequest requests to set compositor feedback
//
// Request that the compositor use the provided feedback string
// associated with this ring. This request should be issued immediately
// after a wp_tablet_pad_group.mode_switch event from the corresponding
// group is received, or whenever the ring is mapped to a different
// action. See wp_tablet_pad_group.mode_switch for more details.
//
// Clients are encouraged to provide context-aware descriptions for
// the actions associated with the ring; compositors may use this
// information to offer visual feedback about the button layout
// (eg. on-screen displays).
//
// The provided string 'description' is a UTF-8 encoded string to be
// associated with this ring, and is considered user-visible; general
// internationalization rules apply.
//
// The serial argument will be that of the last
// wp_tablet_pad_group.mode_switch event received for the group of this
// ring. Requests providing other serials than the most recent one will be
// ignored.
type ZwpTabletPadRingV2SetFeedbackRequest struct {
	// Description contains ring description
	Description string

	// Serial contains serial of the mode switch event
	Serial uint32
}

// Opcode returns the request opcode for zwp_tablet_pad_ring_v2.set_feedback in tablet_unstable_v2
func (ZwpTabletPadRingV2SetFeedbackRequest) Opcode() uint16 { return 0 }

// Ensure ZwpTabletPadRingV2SetFeedbackRequest implements Message.
var _ Message = ZwpTabletPadRingV2SetFeedbackRequest{}

// ZwpTabletPadRingV2DestroyRequest requests to destroy the ring object
//
// This destroys the client's resource for this ring object.
type ZwpTabletPadRingV2DestroyRequest struct {
}

// Opcode returns the request opcode for zwp_tablet_pad_ring_v2.destroy in tablet_unstable_v2
func (ZwpTabletPadRingV2DestroyRequest) Opcode() uint16 { return 1 }

// Ensure ZwpTabletPadRingV2DestroyRequest implements Message.
var _ Message = ZwpTabletPadRingV2DestroyRequest{}

// ZwpTabletPadRingV2SourceEvent signals when ring event source
//
// Source information for ring events.
//
// This event does not occur on its own. It is sent before a
// wp_tablet_pad_ring.frame event and carries the source information
// for all events within that frame.
//
// The source specifies how this event was generated. If the source is
// wp_tablet_pad_ring.source.finger, a wp_tablet_pad_ring.stop event
// will be sent when the user lifts the finger off the device.
//
// This event is optional. If the source is unknown for an interaction,
// no event is sent.
type ZwpTabletPadRingV2SourceEvent struct {
	// Source contains the event source
	Source uint32
}

// Opcode returns the event opcode for zwp_tablet_pad_ring_v2.source in tablet_unstable_v2
func (ZwpTabletPadRingV2SourceEvent) Opcode() uint16 { return 0 }

// Ensure ZwpTabletPadRingV2SourceEvent implements Message.
var _ Message = ZwpTabletPadRingV2SourceEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletPadRingV2SourceEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Source = v
	}
	return nil
}

// Ensure ZwpTabletPadRingV2SourceEvent implements Event.
var _ Event = &ZwpTabletPadRingV2SourceEvent{}

// ZwpTabletPadRingV2AngleEvent signals when angle changed
//
// Sent whenever the angle on a ring changes.
//
// The angle is provided in degrees clockwise from the logical
// north of the ring in the pad's current rotation.
type ZwpTabletPadRingV2AngleEvent struct {
	// Degrees contains the current angle in degrees
	Degrees Fixed
}

// Opcode returns the event opcode for zwp_tablet_pad_ring_v2.angle in tablet_unstable_v2
func (ZwpTabletPadRingV2AngleEvent) Opcode() uint16 { return 1 }

// Ensure ZwpTabletPadRingV2AngleEvent implements Message.
var _ Message = ZwpTabletPadRingV2AngleEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletPadRingV2AngleEvent) Scan(s *EventScanner) error {
	if v, err := s.Fixed(); err != nil {
		return err
	} else {
		e.Degrees = v
	}
	return nil
}

// Ensure ZwpTabletPadRingV2AngleEvent implements Event.
var _ Event = &ZwpTabletPadRingV2AngleEvent{}

// ZwpTabletPadRingV2StopEvent signals when interaction stopped
//
// Stop notification for ring events.
//
// For some wp_tablet_pad_ring.source types, a wp_tablet_pad_ring.stop
// event is sent to notify a client that the interaction with the ring
// has terminated. This enables the client to implement kinetic scrolling.
// See the wp_tablet_pad_ring.source documentation for information on
// when this event may be generated.
//
// Any wp_tablet_pad_ring.angle events with the same source after this
// event should be considered as the start of a new interaction.
type ZwpTabletPadRingV2StopEvent struct {
}

// Opcode returns the event opcode for zwp_tablet_pad_ring_v2.stop in tablet_unstable_v2
func (ZwpTabletPadRingV2StopEvent) Opcode() uint16 { return 2 }

// Ensure ZwpTabletPadRingV2StopEvent implements Message.
var _ Message = ZwpTabletPadRingV2StopEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletPadRingV2StopEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure ZwpTabletPadRingV2StopEvent implements Event.
var _ Event = &ZwpTabletPadRingV2StopEvent{}

// ZwpTabletPadRingV2FrameEvent signals when end of a ring event sequence
//
// Indicates the end of a set of ring events that logically belong
// together. A client is expected to accumulate the data in all events
// within the frame before proceeding.
//
// All wp_tablet_pad_ring events before a wp_tablet_pad_ring.frame event belong
// logically together. For example, on termination of a finger interaction
// on a ring the compositor will send a wp_tablet_pad_ring.source event,
// a wp_tablet_pad_ring.stop event and a wp_tablet_pad_ring.frame event.
//
// A wp_tablet_pad_ring.frame event is sent for every logical event
// group, even if the group only contains a single wp_tablet_pad_ring
// event. Specifically, a client may get a sequence: angle, frame,
// angle, frame, etc.
type ZwpTabletPadRingV2FrameEvent struct {
	// Time contains timestamp with millisecond granularity
	Time uint32
}

// Opcode returns the event opcode for zwp_tablet_pad_ring_v2.frame in tablet_unstable_v2
func (ZwpTabletPadRingV2FrameEvent) Opcode() uint16 { return 3 }

// Ensure ZwpTabletPadRingV2FrameEvent implements Message.
var _ Message = ZwpTabletPadRingV2FrameEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletPadRingV2FrameEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Time = v
	}
	return nil
}

// Ensure ZwpTabletPadRingV2FrameEvent implements Event.
var _ Event = &ZwpTabletPadRingV2FrameEvent{}

// #endregion Interface tablet_unstable_v2.zwp_tablet_pad_ring_v2

// ----------------------------------------------------------------------------
// #region Interface tablet_unstable_v2.zwp_tablet_pad_strip_v2

// ZwpTabletPadStripV2Source represents strip axis source
//
// Describes the source types for strip events. This indicates to the
// client how a strip event was physically generated; a client may
// adjust the user interface accordingly. For example, events
// from a "finger" source may trigger kinetic scrolling.
type ZwpTabletPadStripV2Source int

const (
	// ZwpTabletPadStripV2SourceFinger corresponds to finger
	ZwpTabletPadStripV2SourceFinger ZwpTabletPadStripV2Source = 1
)

// ZwpTabletPadStripV2SetFeedbackRequest requests to set compositor feedback
//
// Requests the compositor to use the provided feedback string
// associated with this strip. This request should be issued immediately
// after a wp_tablet_pad_group.mode_switch event from the corresponding
// group is received, or whenever the strip is mapped to a different
// action. See wp_tablet_pad_group.mode_switch for more details.
//
// Clients are encouraged to provide context-aware descriptions for
// the actions associated with the strip, and compositors may use this
// information to offer visual feedback about the button layout
// (eg. on-screen displays).
//
// The provided string 'description' is a UTF-8 encoded string to be
// associated with this ring, and is considered user-visible; general
// internationalization rules apply.
//
// The serial argument will be that of the last
// wp_tablet_pad_group.mode_switch event received for the group of this
// strip. Requests providing other serials than the most recent one will be
// ignored.
type ZwpTabletPadStripV2SetFeedbackRequest struct {
	// Description contains strip description
	Description string

	// Serial contains serial of the mode switch event
	Serial uint32
}

// Opcode returns the request opcode for zwp_tablet_pad_strip_v2.set_feedback in tablet_unstable_v2
func (ZwpTabletPadStripV2SetFeedbackRequest) Opcode() uint16 { return 0 }

// Ensure ZwpTabletPadStripV2SetFeedbackRequest implements Message.
var _ Message = ZwpTabletPadStripV2SetFeedbackRequest{}

// ZwpTabletPadStripV2DestroyRequest requests to destroy the strip object
//
// This destroys the client's resource for this strip object.
type ZwpTabletPadStripV2DestroyRequest struct {
}

// Opcode returns the request opcode for zwp_tablet_pad_strip_v2.destroy in tablet_unstable_v2
func (ZwpTabletPadStripV2DestroyRequest) Opcode() uint16 { return 1 }

// Ensure ZwpTabletPadStripV2DestroyRequest implements Message.
var _ Message = ZwpTabletPadStripV2DestroyRequest{}

// ZwpTabletPadStripV2SourceEvent signals when strip event source
//
// Source information for strip events.
//
// This event does not occur on its own. It is sent before a
// wp_tablet_pad_strip.frame event and carries the source information
// for all events within that frame.
//
// The source specifies how this event was generated. If the source is
// wp_tablet_pad_strip.source.finger, a wp_tablet_pad_strip.stop event
// will be sent when the user lifts their finger off the device.
//
// This event is optional. If the source is unknown for an interaction,
// no event is sent.
type ZwpTabletPadStripV2SourceEvent struct {
	// Source contains the event source
	Source uint32
}

// Opcode returns the event opcode for zwp_tablet_pad_strip_v2.source in tablet_unstable_v2
func (ZwpTabletPadStripV2SourceEvent) Opcode() uint16 { return 0 }

// Ensure ZwpTabletPadStripV2SourceEvent implements Message.
var _ Message = ZwpTabletPadStripV2SourceEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletPadStripV2SourceEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Source = v
	}
	return nil
}

// Ensure ZwpTabletPadStripV2SourceEvent implements Event.
var _ Event = &ZwpTabletPadStripV2SourceEvent{}

// ZwpTabletPadStripV2PositionEvent signals when position changed
//
// Sent whenever the position on a strip changes.
//
// The position is normalized to a range of [0, 65535], the 0-value
// represents the top-most and/or left-most position of the strip in
// the pad's current rotation.
type ZwpTabletPadStripV2PositionEvent struct {
	// Position contains the current position
	Position uint32
}

// Opcode returns the event opcode for zwp_tablet_pad_strip_v2.position in tablet_unstable_v2
func (ZwpTabletPadStripV2PositionEvent) Opcode() uint16 { return 1 }

// Ensure ZwpTabletPadStripV2PositionEvent implements Message.
var _ Message = ZwpTabletPadStripV2PositionEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletPadStripV2PositionEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Position = v
	}
	return nil
}

// Ensure ZwpTabletPadStripV2PositionEvent implements Event.
var _ Event = &ZwpTabletPadStripV2PositionEvent{}

// ZwpTabletPadStripV2StopEvent signals when interaction stopped
//
// Stop notification for strip events.
//
// For some wp_tablet_pad_strip.source types, a wp_tablet_pad_strip.stop
// event is sent to notify a client that the interaction with the strip
// has terminated. This enables the client to implement kinetic
// scrolling. See the wp_tablet_pad_strip.source documentation for
// information on when this event may be generated.
//
// Any wp_tablet_pad_strip.position events with the same source after this
// event should be considered as the start of a new interaction.
type ZwpTabletPadStripV2StopEvent struct {
}

// Opcode returns the event opcode for zwp_tablet_pad_strip_v2.stop in tablet_unstable_v2
func (ZwpTabletPadStripV2StopEvent) Opcode() uint16 { return 2 }

// Ensure ZwpTabletPadStripV2StopEvent implements Message.
var _ Message = ZwpTabletPadStripV2StopEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletPadStripV2StopEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure ZwpTabletPadStripV2StopEvent implements Event.
var _ Event = &ZwpTabletPadStripV2StopEvent{}

// ZwpTabletPadStripV2FrameEvent signals when end of a strip event sequence
//
// Indicates the end of a set of events that represent one logical
// hardware strip event. A client is expected to accumulate the data
// in all events within the frame before proceeding.
//
// All wp_tablet_pad_strip events before a wp_tablet_pad_strip.frame event belong
// logically together. For example, on termination of a finger interaction
// on a strip the compositor will send a wp_tablet_pad_strip.source event,
// a wp_tablet_pad_strip.stop event and a wp_tablet_pad_strip.frame
// event.
//
// A wp_tablet_pad_strip.frame event is sent for every logical event
// group, even if the group only contains a single wp_tablet_pad_strip
// event. Specifically, a client may get a sequence: position, frame,
// position, frame, etc.
type ZwpTabletPadStripV2FrameEvent struct {
	// Time contains timestamp with millisecond granularity
	Time uint32
}

// Opcode returns the event opcode for zwp_tablet_pad_strip_v2.frame in tablet_unstable_v2
func (ZwpTabletPadStripV2FrameEvent) Opcode() uint16 { return 3 }

// Ensure ZwpTabletPadStripV2FrameEvent implements Message.
var _ Message = ZwpTabletPadStripV2FrameEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletPadStripV2FrameEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Time = v
	}
	return nil
}

// Ensure ZwpTabletPadStripV2FrameEvent implements Event.
var _ Event = &ZwpTabletPadStripV2FrameEvent{}

// #endregion Interface tablet_unstable_v2.zwp_tablet_pad_strip_v2

// ----------------------------------------------------------------------------
// #region Interface tablet_unstable_v2.zwp_tablet_pad_group_v2

// ZwpTabletPadGroupV2DestroyRequest requests to destroy the pad object
//
// Destroy the wp_tablet_pad_group object. Objects created from this object
// are unaffected and should be destroyed separately.
type ZwpTabletPadGroupV2DestroyRequest struct {
}

// Opcode returns the request opcode for zwp_tablet_pad_group_v2.destroy in tablet_unstable_v2
func (ZwpTabletPadGroupV2DestroyRequest) Opcode() uint16 { return 0 }

// Ensure ZwpTabletPadGroupV2DestroyRequest implements Message.
var _ Message = ZwpTabletPadGroupV2DestroyRequest{}

// ZwpTabletPadGroupV2ButtonsEvent signals when buttons announced
//
// Sent on wp_tablet_pad_group initialization to announce the available
// buttons in the group. Button indices start at 0, a button may only be
// in one group at a time.
//
// This event is first sent in the initial burst of events before the
// wp_tablet_pad_group.done event.
//
// Some buttons are reserved by the compositor. These buttons may not be
// assigned to any wp_tablet_pad_group. Compositors may broadcast this
// event in the case of changes to the mapping of these reserved buttons.
// If the compositor happens to reserve all buttons in a group, this event
// will be sent with an empty array.
type ZwpTabletPadGroupV2ButtonsEvent struct {
	// Buttons contains buttons in this group
	Buttons []byte
}

// Opcode returns the event opcode for zwp_tablet_pad_group_v2.buttons in tablet_unstable_v2
func (ZwpTabletPadGroupV2ButtonsEvent) Opcode() uint16 { return 0 }

// Ensure ZwpTabletPadGroupV2ButtonsEvent implements Message.
var _ Message = ZwpTabletPadGroupV2ButtonsEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletPadGroupV2ButtonsEvent) Scan(s *EventScanner) error {
	if v, err := s.Array(); err != nil {
		return err
	} else {
		e.Buttons = v
	}
	return nil
}

// Ensure ZwpTabletPadGroupV2ButtonsEvent implements Event.
var _ Event = &ZwpTabletPadGroupV2ButtonsEvent{}

// ZwpTabletPadGroupV2RingEvent signals when ring announced
//
// Sent on wp_tablet_pad_group initialization to announce available rings.
// One event is sent for each ring available on this pad group.
//
// This event is sent in the initial burst of events before the
// wp_tablet_pad_group.done event.
type ZwpTabletPadGroupV2RingEvent struct {
	Ring ObjectID
}

// Opcode returns the event opcode for zwp_tablet_pad_group_v2.ring in tablet_unstable_v2
func (ZwpTabletPadGroupV2RingEvent) Opcode() uint16 { return 1 }

// Ensure ZwpTabletPadGroupV2RingEvent implements Message.
var _ Message = ZwpTabletPadGroupV2RingEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletPadGroupV2RingEvent) Scan(s *EventScanner) error {
	if v, err := s.ObjectID(); err != nil {
		return err
	} else {
		e.Ring = v
	}
	return nil
}

// Ensure ZwpTabletPadGroupV2RingEvent implements Event.
var _ Event = &ZwpTabletPadGroupV2RingEvent{}

// ZwpTabletPadGroupV2StripEvent signals when strip announced
//
// Sent on wp_tablet_pad initialization to announce available strips.
// One event is sent for each strip available on this pad group.
//
// This event is sent in the initial burst of events before the
// wp_tablet_pad_group.done event.
type ZwpTabletPadGroupV2StripEvent struct {
	Strip ObjectID
}

// Opcode returns the event opcode for zwp_tablet_pad_group_v2.strip in tablet_unstable_v2
func (ZwpTabletPadGroupV2StripEvent) Opcode() uint16 { return 2 }

// Ensure ZwpTabletPadGroupV2StripEvent implements Message.
var _ Message = ZwpTabletPadGroupV2StripEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletPadGroupV2StripEvent) Scan(s *EventScanner) error {
	if v, err := s.ObjectID(); err != nil {
		return err
	} else {
		e.Strip = v
	}
	return nil
}

// Ensure ZwpTabletPadGroupV2StripEvent implements Event.
var _ Event = &ZwpTabletPadGroupV2StripEvent{}

// ZwpTabletPadGroupV2ModesEvent signals when mode-switch ability announced
//
// Sent on wp_tablet_pad_group initialization to announce that the pad
// group may switch between modes. A client may use a mode to store a
// specific configuration for buttons, rings and strips and use the
// wl_tablet_pad_group.mode_switch event to toggle between these
// configurations. Mode indices start at 0.
//
// Switching modes is compositor-dependent. See the
// wp_tablet_pad_group.mode_switch event for more details.
//
// This event is sent in the initial burst of events before the
// wp_tablet_pad_group.done event. This event is only sent when more than
// more than one mode is available.
type ZwpTabletPadGroupV2ModesEvent struct {
	// Modes contains the number of modes
	Modes uint32
}

// Opcode returns the event opcode for zwp_tablet_pad_group_v2.modes in tablet_unstable_v2
func (ZwpTabletPadGroupV2ModesEvent) Opcode() uint16 { return 3 }

// Ensure ZwpTabletPadGroupV2ModesEvent implements Message.
var _ Message = ZwpTabletPadGroupV2ModesEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletPadGroupV2ModesEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Modes = v
	}
	return nil
}

// Ensure ZwpTabletPadGroupV2ModesEvent implements Event.
var _ Event = &ZwpTabletPadGroupV2ModesEvent{}

// ZwpTabletPadGroupV2DoneEvent signals when tablet group description events sequence complete
//
// This event is sent immediately to signal the end of the initial
// burst of descriptive events. A client may consider the static
// description of the tablet to be complete and finalize initialization
// of the tablet group.
type ZwpTabletPadGroupV2DoneEvent struct {
}

// Opcode returns the event opcode for zwp_tablet_pad_group_v2.done in tablet_unstable_v2
func (ZwpTabletPadGroupV2DoneEvent) Opcode() uint16 { return 4 }

// Ensure ZwpTabletPadGroupV2DoneEvent implements Message.
var _ Message = ZwpTabletPadGroupV2DoneEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletPadGroupV2DoneEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure ZwpTabletPadGroupV2DoneEvent implements Event.
var _ Event = &ZwpTabletPadGroupV2DoneEvent{}

// ZwpTabletPadGroupV2ModeSwitchEvent signals when mode switch event
//
// Notification that the mode was switched.
//
// A mode applies to all buttons, rings and strips in a group
// simultaneously, but a client is not required to assign different actions
// for each mode. For example, a client may have mode-specific button
// mappings but map the ring to vertical scrolling in all modes. Mode
// indices start at 0.
//
// Switching modes is compositor-dependent. The compositor may provide
// visual cues to the client about the mode, e.g. by toggling LEDs on
// the tablet device. Mode-switching may be software-controlled or
// controlled by one or more physical buttons. For example, on a Wacom
// Intuos Pro, the button inside the ring may be assigned to switch
// between modes.
//
// The compositor will also send this event after wp_tablet_pad.enter on
// each group in order to notify of the current mode. Groups that only
// feature one mode will use mode=0 when emitting this event.
//
// If a button action in the new mode differs from the action in the
// previous mode, the client should immediately issue a
// wp_tablet_pad.set_feedback request for each changed button.
//
// If a ring or strip action in the new mode differs from the action
// in the previous mode, the client should immediately issue a
// wp_tablet_ring.set_feedback or wp_tablet_strip.set_feedback request
// for each changed ring or strip.
type ZwpTabletPadGroupV2ModeSwitchEvent struct {
	// Time contains the time of the event with millisecond granularity
	Time uint32

	Serial uint32

	// Mode contains the new mode of the pad
	Mode uint32
}

// Opcode returns the event opcode for zwp_tablet_pad_group_v2.mode_switch in tablet_unstable_v2
func (ZwpTabletPadGroupV2ModeSwitchEvent) Opcode() uint16 { return 5 }

// Ensure ZwpTabletPadGroupV2ModeSwitchEvent implements Message.
var _ Message = ZwpTabletPadGroupV2ModeSwitchEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletPadGroupV2ModeSwitchEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Time = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Serial = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Mode = v
	}
	return nil
}

// Ensure ZwpTabletPadGroupV2ModeSwitchEvent implements Event.
var _ Event = &ZwpTabletPadGroupV2ModeSwitchEvent{}

// #endregion Interface tablet_unstable_v2.zwp_tablet_pad_group_v2

// ----------------------------------------------------------------------------
// #region Interface tablet_unstable_v2.zwp_tablet_pad_v2

// ZwpTabletPadV2ButtonState represents physical button state
//
// Describes the physical state of a button that caused the button
// event.
type ZwpTabletPadV2ButtonState int

const (
	// ZwpTabletPadV2ButtonStateReleased corresponds to the button is not pressed
	ZwpTabletPadV2ButtonStateReleased ZwpTabletPadV2ButtonState = 0

	// ZwpTabletPadV2ButtonStatePressed corresponds to the button is pressed
	ZwpTabletPadV2ButtonStatePressed ZwpTabletPadV2ButtonState = 1
)

// ZwpTabletPadV2SetFeedbackRequest requests to set compositor feedback
//
// Requests the compositor to use the provided feedback string
// associated with this button. This request should be issued immediately
// after a wp_tablet_pad_group.mode_switch event from the corresponding
// group is received, or whenever a button is mapped to a different
// action. See wp_tablet_pad_group.mode_switch for more details.
//
// Clients are encouraged to provide context-aware descriptions for
// the actions associated with each button, and compositors may use
// this information to offer visual feedback on the button layout
// (e.g. on-screen displays).
//
// Button indices start at 0. Setting the feedback string on a button
// that is reserved by the compositor (i.e. not belonging to any
// wp_tablet_pad_group) does not generate an error but the compositor
// is free to ignore the request.
//
// The provided string 'description' is a UTF-8 encoded string to be
// associated with this ring, and is considered user-visible; general
// internationalization rules apply.
//
// The serial argument will be that of the last
// wp_tablet_pad_group.mode_switch event received for the group of this
// button. Requests providing other serials than the most recent one will
// be ignored.
type ZwpTabletPadV2SetFeedbackRequest struct {
	// Button contains button index
	Button uint32

	// Description contains button description
	Description string

	// Serial contains serial of the mode switch event
	Serial uint32
}

// Opcode returns the request opcode for zwp_tablet_pad_v2.set_feedback in tablet_unstable_v2
func (ZwpTabletPadV2SetFeedbackRequest) Opcode() uint16 { return 0 }

// Ensure ZwpTabletPadV2SetFeedbackRequest implements Message.
var _ Message = ZwpTabletPadV2SetFeedbackRequest{}

// ZwpTabletPadV2DestroyRequest requests to destroy the pad object
//
// Destroy the wp_tablet_pad object. Objects created from this object
// are unaffected and should be destroyed separately.
type ZwpTabletPadV2DestroyRequest struct {
}

// Opcode returns the request opcode for zwp_tablet_pad_v2.destroy in tablet_unstable_v2
func (ZwpTabletPadV2DestroyRequest) Opcode() uint16 { return 1 }

// Ensure ZwpTabletPadV2DestroyRequest implements Message.
var _ Message = ZwpTabletPadV2DestroyRequest{}

// ZwpTabletPadV2GroupEvent signals when group announced
//
// Sent on wp_tablet_pad initialization to announce available groups.
// One event is sent for each pad group available.
//
// This event is sent in the initial burst of events before the
// wp_tablet_pad.done event. At least one group will be announced.
type ZwpTabletPadV2GroupEvent struct {
	PadGroup ObjectID
}

// Opcode returns the event opcode for zwp_tablet_pad_v2.group in tablet_unstable_v2
func (ZwpTabletPadV2GroupEvent) Opcode() uint16 { return 0 }

// Ensure ZwpTabletPadV2GroupEvent implements Message.
var _ Message = ZwpTabletPadV2GroupEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletPadV2GroupEvent) Scan(s *EventScanner) error {
	if v, err := s.ObjectID(); err != nil {
		return err
	} else {
		e.PadGroup = v
	}
	return nil
}

// Ensure ZwpTabletPadV2GroupEvent implements Event.
var _ Event = &ZwpTabletPadV2GroupEvent{}

// ZwpTabletPadV2PathEvent signals when path to the device
//
// A system-specific device path that indicates which device is behind
// this wp_tablet_pad. This information may be used to gather additional
// information about the device, e.g. through libwacom.
//
// The format of the path is unspecified, it may be a device node, a
// sysfs path, or some other identifier. It is up to the client to
// identify the string provided.
//
// This event is sent in the initial burst of events before the
// wp_tablet_pad.done event.
type ZwpTabletPadV2PathEvent struct {
	// Path contains path to local device
	Path string
}

// Opcode returns the event opcode for zwp_tablet_pad_v2.path in tablet_unstable_v2
func (ZwpTabletPadV2PathEvent) Opcode() uint16 { return 1 }

// Ensure ZwpTabletPadV2PathEvent implements Message.
var _ Message = ZwpTabletPadV2PathEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletPadV2PathEvent) Scan(s *EventScanner) error {
	if v, err := s.String(); err != nil {
		return err
	} else {
		e.Path = v
	}
	return nil
}

// Ensure ZwpTabletPadV2PathEvent implements Event.
var _ Event = &ZwpTabletPadV2PathEvent{}

// ZwpTabletPadV2ButtonsEvent signals when buttons announced
//
// Sent on wp_tablet_pad initialization to announce the available
// buttons.
//
// This event is sent in the initial burst of events before the
// wp_tablet_pad.done event. This event is only sent when at least one
// button is available.
type ZwpTabletPadV2ButtonsEvent struct {
	// Buttons contains the number of buttons
	Buttons uint32
}

// Opcode returns the event opcode for zwp_tablet_pad_v2.buttons in tablet_unstable_v2
func (ZwpTabletPadV2ButtonsEvent) Opcode() uint16 { return 2 }

// Ensure ZwpTabletPadV2ButtonsEvent implements Message.
var _ Message = ZwpTabletPadV2ButtonsEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletPadV2ButtonsEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Buttons = v
	}
	return nil
}

// Ensure ZwpTabletPadV2ButtonsEvent implements Event.
var _ Event = &ZwpTabletPadV2ButtonsEvent{}

// ZwpTabletPadV2DoneEvent signals when pad description event sequence complete
//
// This event signals the end of the initial burst of descriptive
// events. A client may consider the static description of the pad to
// be complete and finalize initialization of the pad.
type ZwpTabletPadV2DoneEvent struct {
}

// Opcode returns the event opcode for zwp_tablet_pad_v2.done in tablet_unstable_v2
func (ZwpTabletPadV2DoneEvent) Opcode() uint16 { return 3 }

// Ensure ZwpTabletPadV2DoneEvent implements Message.
var _ Message = ZwpTabletPadV2DoneEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletPadV2DoneEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure ZwpTabletPadV2DoneEvent implements Event.
var _ Event = &ZwpTabletPadV2DoneEvent{}

// ZwpTabletPadV2ButtonEvent signals when physical button state
//
// Sent whenever the physical state of a button changes.
type ZwpTabletPadV2ButtonEvent struct {
	// Time contains the time of the event with millisecond granularity
	Time uint32

	// Button contains the index of the button that changed state
	Button uint32

	State uint32
}

// Opcode returns the event opcode for zwp_tablet_pad_v2.button in tablet_unstable_v2
func (ZwpTabletPadV2ButtonEvent) Opcode() uint16 { return 4 }

// Ensure ZwpTabletPadV2ButtonEvent implements Message.
var _ Message = ZwpTabletPadV2ButtonEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletPadV2ButtonEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Time = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Button = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.State = v
	}
	return nil
}

// Ensure ZwpTabletPadV2ButtonEvent implements Event.
var _ Event = &ZwpTabletPadV2ButtonEvent{}

// ZwpTabletPadV2EnterEvent signals when enter event
//
// Notification that this pad is focused on the specified surface.
type ZwpTabletPadV2EnterEvent struct {
	// Serial contains serial number of the enter event
	Serial uint32

	// Tablet contains the tablet the pad is attached to
	Tablet ObjectID

	// Surface contains surface the pad is focused on
	Surface ObjectID
}

// Opcode returns the event opcode for zwp_tablet_pad_v2.enter in tablet_unstable_v2
func (ZwpTabletPadV2EnterEvent) Opcode() uint16 { return 5 }

// Ensure ZwpTabletPadV2EnterEvent implements Message.
var _ Message = ZwpTabletPadV2EnterEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletPadV2EnterEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Serial = v
	}
	if v, err := s.ObjectID(); err != nil {
		return err
	} else {
		e.Tablet = v
	}
	if v, err := s.ObjectID(); err != nil {
		return err
	} else {
		e.Surface = v
	}
	return nil
}

// Ensure ZwpTabletPadV2EnterEvent implements Event.
var _ Event = &ZwpTabletPadV2EnterEvent{}

// ZwpTabletPadV2LeaveEvent signals when enter event
//
// Notification that this pad is no longer focused on the specified
// surface.
type ZwpTabletPadV2LeaveEvent struct {
	// Serial contains serial number of the leave event
	Serial uint32

	// Surface contains surface the pad is no longer focused on
	Surface ObjectID
}

// Opcode returns the event opcode for zwp_tablet_pad_v2.leave in tablet_unstable_v2
func (ZwpTabletPadV2LeaveEvent) Opcode() uint16 { return 6 }

// Ensure ZwpTabletPadV2LeaveEvent implements Message.
var _ Message = ZwpTabletPadV2LeaveEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletPadV2LeaveEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Serial = v
	}
	if v, err := s.ObjectID(); err != nil {
		return err
	} else {
		e.Surface = v
	}
	return nil
}

// Ensure ZwpTabletPadV2LeaveEvent implements Event.
var _ Event = &ZwpTabletPadV2LeaveEvent{}

// ZwpTabletPadV2RemovedEvent signals when pad removed event
//
// Sent when the pad has been removed from the system. When a tablet
// is removed its pad(s) will be removed too.
//
// When this event is received, the client must destroy all rings, strips
// and groups that were offered by this pad, and issue wp_tablet_pad.destroy
// the pad itself.
type ZwpTabletPadV2RemovedEvent struct {
}

// Opcode returns the event opcode for zwp_tablet_pad_v2.removed in tablet_unstable_v2
func (ZwpTabletPadV2RemovedEvent) Opcode() uint16 { return 7 }

// Ensure ZwpTabletPadV2RemovedEvent implements Message.
var _ Message = ZwpTabletPadV2RemovedEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletPadV2RemovedEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure ZwpTabletPadV2RemovedEvent implements Event.
var _ Event = &ZwpTabletPadV2RemovedEvent{}

// #endregion Interface tablet_unstable_v2.zwp_tablet_pad_v2

////////////////////////////////////////////////////////////////////////////////
// #endregion Protocol tablet_unstable_v2

////////////////////////////////////////////////////////////////////////////////
// #region Protocol text_input_unstable_v1

// ----------------------------------------------------------------------------
// #region Interface text_input_unstable_v1.zwp_text_input_v1

// ZwpTextInputV1ContentHint represents content hint
//
// Content hint is a bitmask to allow to modify the behavior of the text
// input.
type ZwpTextInputV1ContentHint uint

const (
	// ZwpTextInputV1ContentHintNone corresponds to no special behaviour
	ZwpTextInputV1ContentHintNone ZwpTextInputV1ContentHint = 0x0

	// ZwpTextInputV1ContentHintDefault corresponds to auto completion, correction and capitalization
	ZwpTextInputV1ContentHintDefault ZwpTextInputV1ContentHint = 0x7

	// ZwpTextInputV1ContentHintPassword corresponds to hidden and sensitive text
	ZwpTextInputV1ContentHintPassword ZwpTextInputV1ContentHint = 0xc0

	// ZwpTextInputV1ContentHintAutoCompletion corresponds to suggest word completions
	ZwpTextInputV1ContentHintAutoCompletion ZwpTextInputV1ContentHint = 0x1

	// ZwpTextInputV1ContentHintAutoCorrection corresponds to suggest word corrections
	ZwpTextInputV1ContentHintAutoCorrection ZwpTextInputV1ContentHint = 0x2

	// ZwpTextInputV1ContentHintAutoCapitalization corresponds to switch to uppercase letters at the start of a sentence
	ZwpTextInputV1ContentHintAutoCapitalization ZwpTextInputV1ContentHint = 0x4

	// ZwpTextInputV1ContentHintLowercase corresponds to prefer lowercase letters
	ZwpTextInputV1ContentHintLowercase ZwpTextInputV1ContentHint = 0x8

	// ZwpTextInputV1ContentHintUppercase corresponds to prefer uppercase letters
	ZwpTextInputV1ContentHintUppercase ZwpTextInputV1ContentHint = 0x10

	// ZwpTextInputV1ContentHintTitlecase corresponds to prefer casing for titles and headings (can be language dependent)
	ZwpTextInputV1ContentHintTitlecase ZwpTextInputV1ContentHint = 0x20

	// ZwpTextInputV1ContentHintHiddenText corresponds to characters should be hidden
	ZwpTextInputV1ContentHintHiddenText ZwpTextInputV1ContentHint = 0x40

	// ZwpTextInputV1ContentHintSensitiveData corresponds to typed text should not be stored
	ZwpTextInputV1ContentHintSensitiveData ZwpTextInputV1ContentHint = 0x80

	// ZwpTextInputV1ContentHintLatin corresponds to just latin characters should be entered
	ZwpTextInputV1ContentHintLatin ZwpTextInputV1ContentHint = 0x100

	// ZwpTextInputV1ContentHintMultiline corresponds to the text input is multiline
	ZwpTextInputV1ContentHintMultiline ZwpTextInputV1ContentHint = 0x200
)

// ZwpTextInputV1ContentPurpose represents content purpose
//
// The content purpose allows to specify the primary purpose of a text
// input.
//
// This allows an input method to show special purpose input panels with
// extra characters or to disallow some characters.
type ZwpTextInputV1ContentPurpose int

const (
	// ZwpTextInputV1ContentPurposeNormal corresponds to default input, allowing all characters
	ZwpTextInputV1ContentPurposeNormal ZwpTextInputV1ContentPurpose = 0

	// ZwpTextInputV1ContentPurposeAlpha corresponds to allow only alphabetic characters
	ZwpTextInputV1ContentPurposeAlpha ZwpTextInputV1ContentPurpose = 1

	// ZwpTextInputV1ContentPurposeDigits corresponds to allow only digits
	ZwpTextInputV1ContentPurposeDigits ZwpTextInputV1ContentPurpose = 2

	// ZwpTextInputV1ContentPurposeNumber corresponds to input a number (including decimal separator and sign)
	ZwpTextInputV1ContentPurposeNumber ZwpTextInputV1ContentPurpose = 3

	// ZwpTextInputV1ContentPurposePhone corresponds to input a phone number
	ZwpTextInputV1ContentPurposePhone ZwpTextInputV1ContentPurpose = 4

	// ZwpTextInputV1ContentPurposeUrl corresponds to input an URL
	ZwpTextInputV1ContentPurposeUrl ZwpTextInputV1ContentPurpose = 5

	// ZwpTextInputV1ContentPurposeEmail corresponds to input an email address
	ZwpTextInputV1ContentPurposeEmail ZwpTextInputV1ContentPurpose = 6

	// ZwpTextInputV1ContentPurposeName corresponds to input a name of a person
	ZwpTextInputV1ContentPurposeName ZwpTextInputV1ContentPurpose = 7

	// ZwpTextInputV1ContentPurposePassword corresponds to input a password (combine with password or sensitive_data hint)
	ZwpTextInputV1ContentPurposePassword ZwpTextInputV1ContentPurpose = 8

	// ZwpTextInputV1ContentPurposeDate corresponds to input a date
	ZwpTextInputV1ContentPurposeDate ZwpTextInputV1ContentPurpose = 9

	// ZwpTextInputV1ContentPurposeTime corresponds to input a time
	ZwpTextInputV1ContentPurposeTime ZwpTextInputV1ContentPurpose = 10

	// ZwpTextInputV1ContentPurposeDatetime corresponds to input a date and time
	ZwpTextInputV1ContentPurposeDatetime ZwpTextInputV1ContentPurpose = 11

	// ZwpTextInputV1ContentPurposeTerminal corresponds to input for a terminal
	ZwpTextInputV1ContentPurposeTerminal ZwpTextInputV1ContentPurpose = 12
)

type ZwpTextInputV1PreeditStyle int

const (
	// ZwpTextInputV1PreeditStyleDefault corresponds to default style for composing text
	ZwpTextInputV1PreeditStyleDefault ZwpTextInputV1PreeditStyle = 0

	// ZwpTextInputV1PreeditStyleNone corresponds to style should be the same as in non-composing text
	ZwpTextInputV1PreeditStyleNone ZwpTextInputV1PreeditStyle = 1

	ZwpTextInputV1PreeditStyleActive ZwpTextInputV1PreeditStyle = 2

	ZwpTextInputV1PreeditStyleInactive ZwpTextInputV1PreeditStyle = 3

	ZwpTextInputV1PreeditStyleHighlight ZwpTextInputV1PreeditStyle = 4

	ZwpTextInputV1PreeditStyleUnderline ZwpTextInputV1PreeditStyle = 5

	ZwpTextInputV1PreeditStyleSelection ZwpTextInputV1PreeditStyle = 6

	ZwpTextInputV1PreeditStyleIncorrect ZwpTextInputV1PreeditStyle = 7
)

type ZwpTextInputV1TextDirection int

const (
	// ZwpTextInputV1TextDirectionAuto corresponds to automatic text direction based on text and language
	ZwpTextInputV1TextDirectionAuto ZwpTextInputV1TextDirection = 0

	// ZwpTextInputV1TextDirectionLtr corresponds to left-to-right
	ZwpTextInputV1TextDirectionLtr ZwpTextInputV1TextDirection = 1

	// ZwpTextInputV1TextDirectionRtl corresponds to right-to-left
	ZwpTextInputV1TextDirectionRtl ZwpTextInputV1TextDirection = 2
)

// ZwpTextInputV1ActivateRequest requests to request activation
//
// Requests the text_input object to be activated (typically when the
// text entry gets focus).
//
// The seat argument is a wl_seat which maintains the focus for this
// activation. The surface argument is a wl_surface assigned to the
// text_input object and tracked for focus lost. The enter event
// is emitted on successful activation.
type ZwpTextInputV1ActivateRequest struct {
	Seat ObjectID

	Surface ObjectID
}

// Opcode returns the request opcode for zwp_text_input_v1.activate in text_input_unstable_v1
func (ZwpTextInputV1ActivateRequest) Opcode() uint16 { return 0 }

// Ensure ZwpTextInputV1ActivateRequest implements Message.
var _ Message = ZwpTextInputV1ActivateRequest{}

// ZwpTextInputV1DeactivateRequest requests to request deactivation
//
// Requests the text_input object to be deactivated (typically when the
// text entry lost focus). The seat argument is a wl_seat which was used
// for activation.
type ZwpTextInputV1DeactivateRequest struct {
	Seat ObjectID
}

// Opcode returns the request opcode for zwp_text_input_v1.deactivate in text_input_unstable_v1
func (ZwpTextInputV1DeactivateRequest) Opcode() uint16 { return 1 }

// Ensure ZwpTextInputV1DeactivateRequest implements Message.
var _ Message = ZwpTextInputV1DeactivateRequest{}

// ZwpTextInputV1ShowInputPanelRequest requests to show input panels
//
// Requests input panels (virtual keyboard) to show.
type ZwpTextInputV1ShowInputPanelRequest struct {
}

// Opcode returns the request opcode for zwp_text_input_v1.show_input_panel in text_input_unstable_v1
func (ZwpTextInputV1ShowInputPanelRequest) Opcode() uint16 { return 2 }

// Ensure ZwpTextInputV1ShowInputPanelRequest implements Message.
var _ Message = ZwpTextInputV1ShowInputPanelRequest{}

// ZwpTextInputV1HideInputPanelRequest requests to hide input panels
//
// Requests input panels (virtual keyboard) to hide.
type ZwpTextInputV1HideInputPanelRequest struct {
}

// Opcode returns the request opcode for zwp_text_input_v1.hide_input_panel in text_input_unstable_v1
func (ZwpTextInputV1HideInputPanelRequest) Opcode() uint16 { return 3 }

// Ensure ZwpTextInputV1HideInputPanelRequest implements Message.
var _ Message = ZwpTextInputV1HideInputPanelRequest{}

// ZwpTextInputV1ResetRequest requests to reset
//
// Should be called by an editor widget when the input state should be
// reset, for example after the text was changed outside of the normal
// input method flow.
type ZwpTextInputV1ResetRequest struct {
}

// Opcode returns the request opcode for zwp_text_input_v1.reset in text_input_unstable_v1
func (ZwpTextInputV1ResetRequest) Opcode() uint16 { return 4 }

// Ensure ZwpTextInputV1ResetRequest implements Message.
var _ Message = ZwpTextInputV1ResetRequest{}

// ZwpTextInputV1SetSurroundingTextRequest requests to sets the surrounding text
//
// Sets the plain surrounding text around the input position. Text is
// UTF-8 encoded. Cursor is the byte offset within the
// surrounding text. Anchor is the byte offset of the
// selection anchor within the surrounding text. If there is no selected
// text anchor, then it is the same as cursor.
type ZwpTextInputV1SetSurroundingTextRequest struct {
	Text string

	Cursor uint32

	Anchor uint32
}

// Opcode returns the request opcode for zwp_text_input_v1.set_surrounding_text in text_input_unstable_v1
func (ZwpTextInputV1SetSurroundingTextRequest) Opcode() uint16 { return 5 }

// Ensure ZwpTextInputV1SetSurroundingTextRequest implements Message.
var _ Message = ZwpTextInputV1SetSurroundingTextRequest{}

// ZwpTextInputV1SetContentTypeRequest requests to set content purpose and hint
//
// Sets the content purpose and content hint. While the purpose is the
// basic purpose of an input field, the hint flags allow to modify some
// of the behavior.
//
// When no content type is explicitly set, a normal content purpose with
// default hints (auto completion, auto correction, auto capitalization)
// should be assumed.
type ZwpTextInputV1SetContentTypeRequest struct {
	Hint uint32

	Purpose uint32
}

// Opcode returns the request opcode for zwp_text_input_v1.set_content_type in text_input_unstable_v1
func (ZwpTextInputV1SetContentTypeRequest) Opcode() uint16 { return 6 }

// Ensure ZwpTextInputV1SetContentTypeRequest implements Message.
var _ Message = ZwpTextInputV1SetContentTypeRequest{}

type ZwpTextInputV1SetCursorRectangleRequest struct {
	X int32

	Y int32

	Width int32

	Height int32
}

// Opcode returns the request opcode for zwp_text_input_v1.set_cursor_rectangle in text_input_unstable_v1
func (ZwpTextInputV1SetCursorRectangleRequest) Opcode() uint16 { return 7 }

// Ensure ZwpTextInputV1SetCursorRectangleRequest implements Message.
var _ Message = ZwpTextInputV1SetCursorRectangleRequest{}

// ZwpTextInputV1SetPreferredLanguageRequest requests to sets preferred language
//
// Sets a specific language. This allows for example a virtual keyboard to
// show a language specific layout. The "language" argument is an RFC-3066
// format language tag.
//
// It could be used for example in a word processor to indicate the
// language of the currently edited document or in an instant message
// application which tracks languages of contacts.
type ZwpTextInputV1SetPreferredLanguageRequest struct {
	Language string
}

// Opcode returns the request opcode for zwp_text_input_v1.set_preferred_language in text_input_unstable_v1
func (ZwpTextInputV1SetPreferredLanguageRequest) Opcode() uint16 { return 8 }

// Ensure ZwpTextInputV1SetPreferredLanguageRequest implements Message.
var _ Message = ZwpTextInputV1SetPreferredLanguageRequest{}

type ZwpTextInputV1CommitStateRequest struct {
	// Serial contains used to identify the known state
	Serial uint32
}

// Opcode returns the request opcode for zwp_text_input_v1.commit_state in text_input_unstable_v1
func (ZwpTextInputV1CommitStateRequest) Opcode() uint16 { return 9 }

// Ensure ZwpTextInputV1CommitStateRequest implements Message.
var _ Message = ZwpTextInputV1CommitStateRequest{}

type ZwpTextInputV1InvokeActionRequest struct {
	Button uint32

	Index uint32
}

// Opcode returns the request opcode for zwp_text_input_v1.invoke_action in text_input_unstable_v1
func (ZwpTextInputV1InvokeActionRequest) Opcode() uint16 { return 10 }

// Ensure ZwpTextInputV1InvokeActionRequest implements Message.
var _ Message = ZwpTextInputV1InvokeActionRequest{}

// ZwpTextInputV1EnterEvent signals when enter event
//
// Notify the text_input object when it received focus. Typically in
// response to an activate request.
type ZwpTextInputV1EnterEvent struct {
	Surface ObjectID
}

// Opcode returns the event opcode for zwp_text_input_v1.enter in text_input_unstable_v1
func (ZwpTextInputV1EnterEvent) Opcode() uint16 { return 0 }

// Ensure ZwpTextInputV1EnterEvent implements Message.
var _ Message = ZwpTextInputV1EnterEvent{}

// Scan scans the event from the socket.
func (e *ZwpTextInputV1EnterEvent) Scan(s *EventScanner) error {
	if v, err := s.ObjectID(); err != nil {
		return err
	} else {
		e.Surface = v
	}
	return nil
}

// Ensure ZwpTextInputV1EnterEvent implements Event.
var _ Event = &ZwpTextInputV1EnterEvent{}

// ZwpTextInputV1LeaveEvent signals when leave event
//
// Notify the text_input object when it lost focus. Either in response
// to a deactivate request or when the assigned surface lost focus or was
// destroyed.
type ZwpTextInputV1LeaveEvent struct {
}

// Opcode returns the event opcode for zwp_text_input_v1.leave in text_input_unstable_v1
func (ZwpTextInputV1LeaveEvent) Opcode() uint16 { return 1 }

// Ensure ZwpTextInputV1LeaveEvent implements Message.
var _ Message = ZwpTextInputV1LeaveEvent{}

// Scan scans the event from the socket.
func (e *ZwpTextInputV1LeaveEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure ZwpTextInputV1LeaveEvent implements Event.
var _ Event = &ZwpTextInputV1LeaveEvent{}

// ZwpTextInputV1ModifiersMapEvent signals when modifiers map
//
// Transfer an array of 0-terminated modifier names. The position in
// the array is the index of the modifier as used in the modifiers
// bitmask in the keysym event.
type ZwpTextInputV1ModifiersMapEvent struct {
	Map []byte
}

// Opcode returns the event opcode for zwp_text_input_v1.modifiers_map in text_input_unstable_v1
func (ZwpTextInputV1ModifiersMapEvent) Opcode() uint16 { return 2 }

// Ensure ZwpTextInputV1ModifiersMapEvent implements Message.
var _ Message = ZwpTextInputV1ModifiersMapEvent{}

// Scan scans the event from the socket.
func (e *ZwpTextInputV1ModifiersMapEvent) Scan(s *EventScanner) error {
	if v, err := s.Array(); err != nil {
		return err
	} else {
		e.Map = v
	}
	return nil
}

// Ensure ZwpTextInputV1ModifiersMapEvent implements Event.
var _ Event = &ZwpTextInputV1ModifiersMapEvent{}

// ZwpTextInputV1InputPanelStateEvent signals when state of the input panel
//
// Notify when the visibility state of the input panel changed.
type ZwpTextInputV1InputPanelStateEvent struct {
	State uint32
}

// Opcode returns the event opcode for zwp_text_input_v1.input_panel_state in text_input_unstable_v1
func (ZwpTextInputV1InputPanelStateEvent) Opcode() uint16 { return 3 }

// Ensure ZwpTextInputV1InputPanelStateEvent implements Message.
var _ Message = ZwpTextInputV1InputPanelStateEvent{}

// Scan scans the event from the socket.
func (e *ZwpTextInputV1InputPanelStateEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.State = v
	}
	return nil
}

// Ensure ZwpTextInputV1InputPanelStateEvent implements Event.
var _ Event = &ZwpTextInputV1InputPanelStateEvent{}

// ZwpTextInputV1PreeditStringEvent signals when pre-edit
//
// Notify when a new composing text (pre-edit) should be set around the
// current cursor position. Any previously set composing text should
// be removed.
//
// The commit text can be used to replace the preedit text on reset
// (for example on unfocus).
//
// The text input should also handle all preedit_style and preedit_cursor
// events occurring directly before preedit_string.
type ZwpTextInputV1PreeditStringEvent struct {
	// Serial contains serial of the latest known text input state
	Serial uint32

	Text string

	Commit string
}

// Opcode returns the event opcode for zwp_text_input_v1.preedit_string in text_input_unstable_v1
func (ZwpTextInputV1PreeditStringEvent) Opcode() uint16 { return 4 }

// Ensure ZwpTextInputV1PreeditStringEvent implements Message.
var _ Message = ZwpTextInputV1PreeditStringEvent{}

// Scan scans the event from the socket.
func (e *ZwpTextInputV1PreeditStringEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Serial = v
	}
	if v, err := s.String(); err != nil {
		return err
	} else {
		e.Text = v
	}
	if v, err := s.String(); err != nil {
		return err
	} else {
		e.Commit = v
	}
	return nil
}

// Ensure ZwpTextInputV1PreeditStringEvent implements Event.
var _ Event = &ZwpTextInputV1PreeditStringEvent{}

// ZwpTextInputV1PreeditStylingEvent signals when pre-edit styling
//
// Sets styling information on composing text. The style is applied for
// length bytes from index relative to the beginning of the composing
// text (as byte offset). Multiple styles can
// be applied to a composing text by sending multiple preedit_styling
// events.
//
// This event is handled as part of a following preedit_string event.
type ZwpTextInputV1PreeditStylingEvent struct {
	Index uint32

	Length uint32

	Style uint32
}

// Opcode returns the event opcode for zwp_text_input_v1.preedit_styling in text_input_unstable_v1
func (ZwpTextInputV1PreeditStylingEvent) Opcode() uint16 { return 5 }

// Ensure ZwpTextInputV1PreeditStylingEvent implements Message.
var _ Message = ZwpTextInputV1PreeditStylingEvent{}

// Scan scans the event from the socket.
func (e *ZwpTextInputV1PreeditStylingEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Index = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Length = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Style = v
	}
	return nil
}

// Ensure ZwpTextInputV1PreeditStylingEvent implements Event.
var _ Event = &ZwpTextInputV1PreeditStylingEvent{}

// ZwpTextInputV1PreeditCursorEvent signals when pre-edit cursor
//
// Sets the cursor position inside the composing text (as byte
// offset) relative to the start of the composing text. When index is a
// negative number no cursor is shown.
//
// This event is handled as part of a following preedit_string event.
type ZwpTextInputV1PreeditCursorEvent struct {
	Index int32
}

// Opcode returns the event opcode for zwp_text_input_v1.preedit_cursor in text_input_unstable_v1
func (ZwpTextInputV1PreeditCursorEvent) Opcode() uint16 { return 6 }

// Ensure ZwpTextInputV1PreeditCursorEvent implements Message.
var _ Message = ZwpTextInputV1PreeditCursorEvent{}

// Scan scans the event from the socket.
func (e *ZwpTextInputV1PreeditCursorEvent) Scan(s *EventScanner) error {
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.Index = v
	}
	return nil
}

// Ensure ZwpTextInputV1PreeditCursorEvent implements Event.
var _ Event = &ZwpTextInputV1PreeditCursorEvent{}

// ZwpTextInputV1CommitStringEvent signals when commit
//
// Notify when text should be inserted into the editor widget. The text to
// commit could be either just a single character after a key press or the
// result of some composing (pre-edit). It could also be an empty text
// when some text should be removed (see delete_surrounding_text) or when
// the input cursor should be moved (see cursor_position).
//
// Any previously set composing text should be removed.
type ZwpTextInputV1CommitStringEvent struct {
	// Serial contains serial of the latest known text input state
	Serial uint32

	Text string
}

// Opcode returns the event opcode for zwp_text_input_v1.commit_string in text_input_unstable_v1
func (ZwpTextInputV1CommitStringEvent) Opcode() uint16 { return 7 }

// Ensure ZwpTextInputV1CommitStringEvent implements Message.
var _ Message = ZwpTextInputV1CommitStringEvent{}

// Scan scans the event from the socket.
func (e *ZwpTextInputV1CommitStringEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Serial = v
	}
	if v, err := s.String(); err != nil {
		return err
	} else {
		e.Text = v
	}
	return nil
}

// Ensure ZwpTextInputV1CommitStringEvent implements Event.
var _ Event = &ZwpTextInputV1CommitStringEvent{}

// ZwpTextInputV1CursorPositionEvent signals when set cursor to new position
//
// Notify when the cursor or anchor position should be modified.
//
// This event should be handled as part of a following commit_string
// event.
type ZwpTextInputV1CursorPositionEvent struct {
	Index int32

	Anchor int32
}

// Opcode returns the event opcode for zwp_text_input_v1.cursor_position in text_input_unstable_v1
func (ZwpTextInputV1CursorPositionEvent) Opcode() uint16 { return 8 }

// Ensure ZwpTextInputV1CursorPositionEvent implements Message.
var _ Message = ZwpTextInputV1CursorPositionEvent{}

// Scan scans the event from the socket.
func (e *ZwpTextInputV1CursorPositionEvent) Scan(s *EventScanner) error {
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.Index = v
	}
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.Anchor = v
	}
	return nil
}

// Ensure ZwpTextInputV1CursorPositionEvent implements Event.
var _ Event = &ZwpTextInputV1CursorPositionEvent{}

// ZwpTextInputV1DeleteSurroundingTextEvent signals when delete surrounding text
//
// Notify when the text around the current cursor position should be
// deleted.
//
// Index is relative to the current cursor (in bytes).
// Length is the length of deleted text (in bytes).
//
// This event should be handled as part of a following commit_string
// event.
type ZwpTextInputV1DeleteSurroundingTextEvent struct {
	Index int32

	Length uint32
}

// Opcode returns the event opcode for zwp_text_input_v1.delete_surrounding_text in text_input_unstable_v1
func (ZwpTextInputV1DeleteSurroundingTextEvent) Opcode() uint16 { return 9 }

// Ensure ZwpTextInputV1DeleteSurroundingTextEvent implements Message.
var _ Message = ZwpTextInputV1DeleteSurroundingTextEvent{}

// Scan scans the event from the socket.
func (e *ZwpTextInputV1DeleteSurroundingTextEvent) Scan(s *EventScanner) error {
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.Index = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Length = v
	}
	return nil
}

// Ensure ZwpTextInputV1DeleteSurroundingTextEvent implements Event.
var _ Event = &ZwpTextInputV1DeleteSurroundingTextEvent{}

// ZwpTextInputV1KeysymEvent signals when keysym
//
// Notify when a key event was sent. Key events should not be used
// for normal text input operations, which should be done with
// commit_string, delete_surrounding_text, etc. The key event follows
// the wl_keyboard key event convention. Sym is an XKB keysym, state a
// wl_keyboard key_state. Modifiers are a mask for effective modifiers
// (where the modifier indices are set by the modifiers_map event)
type ZwpTextInputV1KeysymEvent struct {
	// Serial contains serial of the latest known text input state
	Serial uint32

	Time uint32

	Sym uint32

	State uint32

	Modifiers uint32
}

// Opcode returns the event opcode for zwp_text_input_v1.keysym in text_input_unstable_v1
func (ZwpTextInputV1KeysymEvent) Opcode() uint16 { return 10 }

// Ensure ZwpTextInputV1KeysymEvent implements Message.
var _ Message = ZwpTextInputV1KeysymEvent{}

// Scan scans the event from the socket.
func (e *ZwpTextInputV1KeysymEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Serial = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Time = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Sym = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.State = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Modifiers = v
	}
	return nil
}

// Ensure ZwpTextInputV1KeysymEvent implements Event.
var _ Event = &ZwpTextInputV1KeysymEvent{}

// ZwpTextInputV1LanguageEvent signals when language
//
// Sets the language of the input text. The "language" argument is an
// RFC-3066 format language tag.
type ZwpTextInputV1LanguageEvent struct {
	// Serial contains serial of the latest known text input state
	Serial uint32

	Language string
}

// Opcode returns the event opcode for zwp_text_input_v1.language in text_input_unstable_v1
func (ZwpTextInputV1LanguageEvent) Opcode() uint16 { return 11 }

// Ensure ZwpTextInputV1LanguageEvent implements Message.
var _ Message = ZwpTextInputV1LanguageEvent{}

// Scan scans the event from the socket.
func (e *ZwpTextInputV1LanguageEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Serial = v
	}
	if v, err := s.String(); err != nil {
		return err
	} else {
		e.Language = v
	}
	return nil
}

// Ensure ZwpTextInputV1LanguageEvent implements Event.
var _ Event = &ZwpTextInputV1LanguageEvent{}

// ZwpTextInputV1TextDirectionEvent signals when text direction
//
// Sets the text direction of input text.
//
// It is mainly needed for showing an input cursor on the correct side of
// the editor when there is no input done yet and making sure neutral
// direction text is laid out properly.
type ZwpTextInputV1TextDirectionEvent struct {
	// Serial contains serial of the latest known text input state
	Serial uint32

	Direction uint32
}

// Opcode returns the event opcode for zwp_text_input_v1.text_direction in text_input_unstable_v1
func (ZwpTextInputV1TextDirectionEvent) Opcode() uint16 { return 12 }

// Ensure ZwpTextInputV1TextDirectionEvent implements Message.
var _ Message = ZwpTextInputV1TextDirectionEvent{}

// Scan scans the event from the socket.
func (e *ZwpTextInputV1TextDirectionEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Serial = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Direction = v
	}
	return nil
}

// Ensure ZwpTextInputV1TextDirectionEvent implements Event.
var _ Event = &ZwpTextInputV1TextDirectionEvent{}

// #endregion Interface text_input_unstable_v1.zwp_text_input_v1

// ----------------------------------------------------------------------------
// #region Interface text_input_unstable_v1.zwp_text_input_manager_v1

// ZwpTextInputManagerV1CreateTextInputRequest requests to create text input
//
// Creates a new text_input object.
type ZwpTextInputManagerV1CreateTextInputRequest struct {
	ID ObjectID
}

// Opcode returns the request opcode for zwp_text_input_manager_v1.create_text_input in text_input_unstable_v1
func (ZwpTextInputManagerV1CreateTextInputRequest) Opcode() uint16 { return 0 }

// Ensure ZwpTextInputManagerV1CreateTextInputRequest implements Message.
var _ Message = ZwpTextInputManagerV1CreateTextInputRequest{}

// #endregion Interface text_input_unstable_v1.zwp_text_input_manager_v1

////////////////////////////////////////////////////////////////////////////////
// #endregion Protocol text_input_unstable_v1

////////////////////////////////////////////////////////////////////////////////
// #region Protocol text_input_unstable_v3

// ----------------------------------------------------------------------------
// #region Interface text_input_unstable_v3.zwp_text_input_v3

// ZwpTextInputV3ChangeCause represents text change reason
//
// Reason for the change of surrounding text or cursor posision.
type ZwpTextInputV3ChangeCause int

const (
	// ZwpTextInputV3ChangeCauseInputMethod corresponds to input method caused the change
	ZwpTextInputV3ChangeCauseInputMethod ZwpTextInputV3ChangeCause = 0

	// ZwpTextInputV3ChangeCauseOther corresponds to something else than the input method caused the change
	ZwpTextInputV3ChangeCauseOther ZwpTextInputV3ChangeCause = 1
)

// ZwpTextInputV3ContentHint represents content hint
//
// Content hint is a bitmask to allow to modify the behavior of the text
// input.
type ZwpTextInputV3ContentHint uint

const (
	// ZwpTextInputV3ContentHintNone corresponds to no special behavior
	ZwpTextInputV3ContentHintNone ZwpTextInputV3ContentHint = 0x0

	// ZwpTextInputV3ContentHintCompletion corresponds to suggest word completions
	ZwpTextInputV3ContentHintCompletion ZwpTextInputV3ContentHint = 0x1

	// ZwpTextInputV3ContentHintSpellcheck corresponds to suggest word corrections
	ZwpTextInputV3ContentHintSpellcheck ZwpTextInputV3ContentHint = 0x2

	// ZwpTextInputV3ContentHintAutoCapitalization corresponds to switch to uppercase letters at the start of a sentence
	ZwpTextInputV3ContentHintAutoCapitalization ZwpTextInputV3ContentHint = 0x4

	// ZwpTextInputV3ContentHintLowercase corresponds to prefer lowercase letters
	ZwpTextInputV3ContentHintLowercase ZwpTextInputV3ContentHint = 0x8

	// ZwpTextInputV3ContentHintUppercase corresponds to prefer uppercase letters
	ZwpTextInputV3ContentHintUppercase ZwpTextInputV3ContentHint = 0x10

	// ZwpTextInputV3ContentHintTitlecase corresponds to prefer casing for titles and headings (can be language dependent)
	ZwpTextInputV3ContentHintTitlecase ZwpTextInputV3ContentHint = 0x20

	// ZwpTextInputV3ContentHintHiddenText corresponds to characters should be hidden
	ZwpTextInputV3ContentHintHiddenText ZwpTextInputV3ContentHint = 0x40

	// ZwpTextInputV3ContentHintSensitiveData corresponds to typed text should not be stored
	ZwpTextInputV3ContentHintSensitiveData ZwpTextInputV3ContentHint = 0x80

	// ZwpTextInputV3ContentHintLatin corresponds to just Latin characters should be entered
	ZwpTextInputV3ContentHintLatin ZwpTextInputV3ContentHint = 0x100

	// ZwpTextInputV3ContentHintMultiline corresponds to the text input is multiline
	ZwpTextInputV3ContentHintMultiline ZwpTextInputV3ContentHint = 0x200
)

// ZwpTextInputV3ContentPurpose represents content purpose
//
// The content purpose allows to specify the primary purpose of a text
// input.
//
// This allows an input method to show special purpose input panels with
// extra characters or to disallow some characters.
type ZwpTextInputV3ContentPurpose int

const (
	// ZwpTextInputV3ContentPurposeNormal corresponds to default input, allowing all characters
	ZwpTextInputV3ContentPurposeNormal ZwpTextInputV3ContentPurpose = 0

	// ZwpTextInputV3ContentPurposeAlpha corresponds to allow only alphabetic characters
	ZwpTextInputV3ContentPurposeAlpha ZwpTextInputV3ContentPurpose = 1

	// ZwpTextInputV3ContentPurposeDigits corresponds to allow only digits
	ZwpTextInputV3ContentPurposeDigits ZwpTextInputV3ContentPurpose = 2

	// ZwpTextInputV3ContentPurposeNumber corresponds to input a number (including decimal separator and sign)
	ZwpTextInputV3ContentPurposeNumber ZwpTextInputV3ContentPurpose = 3

	// ZwpTextInputV3ContentPurposePhone corresponds to input a phone number
	ZwpTextInputV3ContentPurposePhone ZwpTextInputV3ContentPurpose = 4

	// ZwpTextInputV3ContentPurposeUrl corresponds to input an URL
	ZwpTextInputV3ContentPurposeUrl ZwpTextInputV3ContentPurpose = 5

	// ZwpTextInputV3ContentPurposeEmail corresponds to input an email address
	ZwpTextInputV3ContentPurposeEmail ZwpTextInputV3ContentPurpose = 6

	// ZwpTextInputV3ContentPurposeName corresponds to input a name of a person
	ZwpTextInputV3ContentPurposeName ZwpTextInputV3ContentPurpose = 7

	// ZwpTextInputV3ContentPurposePassword corresponds to input a password (combine with sensitive_data hint)
	ZwpTextInputV3ContentPurposePassword ZwpTextInputV3ContentPurpose = 8

	// ZwpTextInputV3ContentPurposePin corresponds to input is a numeric password (combine with sensitive_data hint)
	ZwpTextInputV3ContentPurposePin ZwpTextInputV3ContentPurpose = 9

	// ZwpTextInputV3ContentPurposeDate corresponds to input a date
	ZwpTextInputV3ContentPurposeDate ZwpTextInputV3ContentPurpose = 10

	// ZwpTextInputV3ContentPurposeTime corresponds to input a time
	ZwpTextInputV3ContentPurposeTime ZwpTextInputV3ContentPurpose = 11

	// ZwpTextInputV3ContentPurposeDatetime corresponds to input a date and time
	ZwpTextInputV3ContentPurposeDatetime ZwpTextInputV3ContentPurpose = 12

	// ZwpTextInputV3ContentPurposeTerminal corresponds to input for a terminal
	ZwpTextInputV3ContentPurposeTerminal ZwpTextInputV3ContentPurpose = 13
)

// ZwpTextInputV3DestroyRequest requests to Destroy the wp_text_input
//
// Destroy the wp_text_input object. Also disables all surfaces enabled
// through this wp_text_input object.
type ZwpTextInputV3DestroyRequest struct {
}

// Opcode returns the request opcode for zwp_text_input_v3.destroy in text_input_unstable_v3
func (ZwpTextInputV3DestroyRequest) Opcode() uint16 { return 0 }

// Ensure ZwpTextInputV3DestroyRequest implements Message.
var _ Message = ZwpTextInputV3DestroyRequest{}

// ZwpTextInputV3EnableRequest requests to Request text input to be enabled
//
// Requests text input on the surface previously obtained from the enter
// event.
//
// This request must be issued every time the active text input changes
// to a new one, including within the current surface. Use
// zwp_text_input_v3.disable when there is no longer any input focus on
// the current surface.
//
// Clients must not enable more than one text input on the single seat
// and should disable the current text input before enabling the new one.
// At most one instance of text input may be in enabled state per instance,
// Requests to enable the another text input when some text input is active
// must be ignored by compositor.
//
// This request resets all state associated with previous enable, disable,
// set_surrounding_text, set_text_change_cause, set_content_type, and
// set_cursor_rectangle requests, as well as the state associated with
// preedit_string, commit_string, and delete_surrounding_text events.
//
// The set_surrounding_text, set_content_type and set_cursor_rectangle
// requests must follow if the text input supports the necessary
// functionality.
//
// State set with this request is double-buffered. It will get applied on
// the next zwp_text_input_v3.commit request, and stay valid until the
// next committed enable or disable request.
//
// The changes must be applied by the compositor after issuing a
// zwp_text_input_v3.commit request.
type ZwpTextInputV3EnableRequest struct {
}

// Opcode returns the request opcode for zwp_text_input_v3.enable in text_input_unstable_v3
func (ZwpTextInputV3EnableRequest) Opcode() uint16 { return 1 }

// Ensure ZwpTextInputV3EnableRequest implements Message.
var _ Message = ZwpTextInputV3EnableRequest{}

// ZwpTextInputV3DisableRequest requests to Disable text input on a surface
//
// Explicitly disable text input on the current surface (typically when
// there is no focus on any text entry inside the surface).
//
// State set with this request is double-buffered. It will get applied on
// the next zwp_text_input_v3.commit request.
type ZwpTextInputV3DisableRequest struct {
}

// Opcode returns the request opcode for zwp_text_input_v3.disable in text_input_unstable_v3
func (ZwpTextInputV3DisableRequest) Opcode() uint16 { return 2 }

// Ensure ZwpTextInputV3DisableRequest implements Message.
var _ Message = ZwpTextInputV3DisableRequest{}

// ZwpTextInputV3SetSurroundingTextRequest requests to sets the surrounding text
//
// Sets the surrounding plain text around the input, excluding the preedit
// text.
//
// The client should notify the compositor of any changes in any of the
// values carried with this request, including changes caused by handling
// incoming text-input events as well as changes caused by other
// mechanisms like keyboard typing.
//
// If the client is unaware of the text around the cursor, it should not
// issue this request, to signify lack of support to the compositor.
//
// Text is UTF-8 encoded, and should include the cursor position, the
// complete selection and additional characters before and after them.
// There is a maximum length of wayland messages, so text can not be
// longer than 4000 bytes.
//
// Cursor is the byte offset of the cursor within text buffer.
//
// Anchor is the byte offset of the selection anchor within text buffer.
// If there is no selected text, anchor is the same as cursor.
//
// If any preedit text is present, it is replaced with a cursor for the
// purpose of this event.
//
// Values set with this request are double-buffered. They will get applied
// on the next zwp_text_input_v3.commit request, and stay valid until the
// next committed enable or disable request.
//
// The initial state for affected fields is empty, meaning that the text
// input does not support sending surrounding text. If the empty values
// get applied, subsequent attempts to change them may have no effect.
type ZwpTextInputV3SetSurroundingTextRequest struct {
	Text string

	Cursor int32

	Anchor int32
}

// Opcode returns the request opcode for zwp_text_input_v3.set_surrounding_text in text_input_unstable_v3
func (ZwpTextInputV3SetSurroundingTextRequest) Opcode() uint16 { return 3 }

// Ensure ZwpTextInputV3SetSurroundingTextRequest implements Message.
var _ Message = ZwpTextInputV3SetSurroundingTextRequest{}

// ZwpTextInputV3SetTextChangeCauseRequest requests to indicates the cause of surrounding text change
//
// Tells the compositor why the text surrounding the cursor changed.
//
// Whenever the client detects an external change in text, cursor, or
// anchor posision, it must issue this request to the compositor. This
// request is intended to give the input method a chance to update the
// preedit text in an appropriate way, e.g. by removing it when the user
// starts typing with a keyboard.
//
// cause describes the source of the change.
//
// The value set with this request is double-buffered. It must be applied
// and reset to initial at the next zwp_text_input_v3.commit request.
//
// The initial value of cause is input_method.
type ZwpTextInputV3SetTextChangeCauseRequest struct {
	Cause uint32
}

// Opcode returns the request opcode for zwp_text_input_v3.set_text_change_cause in text_input_unstable_v3
func (ZwpTextInputV3SetTextChangeCauseRequest) Opcode() uint16 { return 4 }

// Ensure ZwpTextInputV3SetTextChangeCauseRequest implements Message.
var _ Message = ZwpTextInputV3SetTextChangeCauseRequest{}

// ZwpTextInputV3SetContentTypeRequest requests to set content purpose and hint
//
// Sets the content purpose and content hint. While the purpose is the
// basic purpose of an input field, the hint flags allow to modify some of
// the behavior.
//
// Values set with this request are double-buffered. They will get applied
// on the next zwp_text_input_v3.commit request.
// Subsequent attempts to update them may have no effect. The values
// remain valid until the next committed enable or disable request.
//
// The initial value for hint is none, and the initial value for purpose
// is normal.
type ZwpTextInputV3SetContentTypeRequest struct {
	Hint uint32

	Purpose uint32
}

// Opcode returns the request opcode for zwp_text_input_v3.set_content_type in text_input_unstable_v3
func (ZwpTextInputV3SetContentTypeRequest) Opcode() uint16 { return 5 }

// Ensure ZwpTextInputV3SetContentTypeRequest implements Message.
var _ Message = ZwpTextInputV3SetContentTypeRequest{}

// ZwpTextInputV3SetCursorRectangleRequest requests to set cursor position
//
// Marks an area around the cursor as a x, y, width, height rectangle in
// surface local coordinates.
//
// Allows the compositor to put a window with word suggestions near the
// cursor, without obstructing the text being input.
//
// If the client is unaware of the position of edited text, it should not
// issue this request, to signify lack of support to the compositor.
//
// Values set with this request are double-buffered. They will get applied
// on the next zwp_text_input_v3.commit request, and stay valid until the
// next committed enable or disable request.
//
// The initial values describing a cursor rectangle are empty. That means
// the text input does not support describing the cursor area. If the
// empty values get applied, subsequent attempts to change them may have
// no effect.
type ZwpTextInputV3SetCursorRectangleRequest struct {
	X int32

	Y int32

	Width int32

	Height int32
}

// Opcode returns the request opcode for zwp_text_input_v3.set_cursor_rectangle in text_input_unstable_v3
func (ZwpTextInputV3SetCursorRectangleRequest) Opcode() uint16 { return 6 }

// Ensure ZwpTextInputV3SetCursorRectangleRequest implements Message.
var _ Message = ZwpTextInputV3SetCursorRectangleRequest{}

// ZwpTextInputV3CommitRequest requests to commit state
//
// Atomically applies state changes recently sent to the compositor.
//
// The commit request establishes and updates the state of the client, and
// must be issued after any changes to apply them.
//
// Text input state (enabled status, content purpose, content hint,
// surrounding text and change cause, cursor rectangle) is conceptually
// double-buffered within the context of a text input, i.e. between a
// committed enable request and the following committed enable or disable
// request.
//
// Protocol requests modify the pending state, as opposed to the current
// state in use by the input method. A commit request atomically applies
// all pending state, replacing the current state. After commit, the new
// pending state is as documented for each related request.
//
// Requests are applied in the order of arrival.
//
// Neither current nor pending state are modified unless noted otherwise.
//
// The compositor must count the number of commit requests coming from
// each zwp_text_input_v3 object and use the count as the serial in done
// events.
type ZwpTextInputV3CommitRequest struct {
}

// Opcode returns the request opcode for zwp_text_input_v3.commit in text_input_unstable_v3
func (ZwpTextInputV3CommitRequest) Opcode() uint16 { return 7 }

// Ensure ZwpTextInputV3CommitRequest implements Message.
var _ Message = ZwpTextInputV3CommitRequest{}

// ZwpTextInputV3EnterEvent signals when enter event
//
// Notification that this seat's text-input focus is on a certain surface.
//
// If client has created multiple text input objects, compositor must send
// this event to all of them.
//
// When the seat has the keyboard capability the text-input focus follows
// the keyboard focus. This event sets the current surface for the
// text-input object.
type ZwpTextInputV3EnterEvent struct {
	Surface ObjectID
}

// Opcode returns the event opcode for zwp_text_input_v3.enter in text_input_unstable_v3
func (ZwpTextInputV3EnterEvent) Opcode() uint16 { return 0 }

// Ensure ZwpTextInputV3EnterEvent implements Message.
var _ Message = ZwpTextInputV3EnterEvent{}

// Scan scans the event from the socket.
func (e *ZwpTextInputV3EnterEvent) Scan(s *EventScanner) error {
	if v, err := s.ObjectID(); err != nil {
		return err
	} else {
		e.Surface = v
	}
	return nil
}

// Ensure ZwpTextInputV3EnterEvent implements Event.
var _ Event = &ZwpTextInputV3EnterEvent{}

// ZwpTextInputV3LeaveEvent signals when leave event
//
// Notification that this seat's text-input focus is no longer on a
// certain surface. The client should reset any preedit string previously
// set.
//
// The leave notification clears the current surface. It is sent before
// the enter notification for the new focus. After leave event, compositor
// must ignore requests from any text input instances until next enter
// event.
//
// When the seat has the keyboard capability the text-input focus follows
// the keyboard focus.
type ZwpTextInputV3LeaveEvent struct {
	Surface ObjectID
}

// Opcode returns the event opcode for zwp_text_input_v3.leave in text_input_unstable_v3
func (ZwpTextInputV3LeaveEvent) Opcode() uint16 { return 1 }

// Ensure ZwpTextInputV3LeaveEvent implements Message.
var _ Message = ZwpTextInputV3LeaveEvent{}

// Scan scans the event from the socket.
func (e *ZwpTextInputV3LeaveEvent) Scan(s *EventScanner) error {
	if v, err := s.ObjectID(); err != nil {
		return err
	} else {
		e.Surface = v
	}
	return nil
}

// Ensure ZwpTextInputV3LeaveEvent implements Event.
var _ Event = &ZwpTextInputV3LeaveEvent{}

// ZwpTextInputV3PreeditStringEvent signals when pre-edit
//
// Notify when a new composing text (pre-edit) should be set at the
// current cursor position. Any previously set composing text must be
// removed. Any previously existing selected text must be removed.
//
// The argument text contains the pre-edit string buffer.
//
// The parameters cursor_begin and cursor_end are counted in bytes
// relative to the beginning of the submitted text buffer. Cursor should
// be hidden when both are equal to -1.
//
// They could be represented by the client as a line if both values are
// the same, or as a text highlight otherwise.
//
// Values set with this event are double-buffered. They must be applied
// and reset to initial on the next zwp_text_input_v3.done event.
//
// The initial value of text is an empty string, and cursor_begin,
// cursor_end and cursor_hidden are all 0.
type ZwpTextInputV3PreeditStringEvent struct {
	Text string

	CursorBegin int32

	CursorEnd int32
}

// Opcode returns the event opcode for zwp_text_input_v3.preedit_string in text_input_unstable_v3
func (ZwpTextInputV3PreeditStringEvent) Opcode() uint16 { return 2 }

// Ensure ZwpTextInputV3PreeditStringEvent implements Message.
var _ Message = ZwpTextInputV3PreeditStringEvent{}

// Scan scans the event from the socket.
func (e *ZwpTextInputV3PreeditStringEvent) Scan(s *EventScanner) error {
	if v, err := s.String(); err != nil {
		return err
	} else {
		e.Text = v
	}
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.CursorBegin = v
	}
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.CursorEnd = v
	}
	return nil
}

// Ensure ZwpTextInputV3PreeditStringEvent implements Event.
var _ Event = &ZwpTextInputV3PreeditStringEvent{}

// ZwpTextInputV3CommitStringEvent signals when text commit
//
// Notify when text should be inserted into the editor widget. The text to
// commit could be either just a single character after a key press or the
// result of some composing (pre-edit).
//
// Values set with this event are double-buffered. They must be applied
// and reset to initial on the next zwp_text_input_v3.done event.
//
// The initial value of text is an empty string.
type ZwpTextInputV3CommitStringEvent struct {
	Text string
}

// Opcode returns the event opcode for zwp_text_input_v3.commit_string in text_input_unstable_v3
func (ZwpTextInputV3CommitStringEvent) Opcode() uint16 { return 3 }

// Ensure ZwpTextInputV3CommitStringEvent implements Message.
var _ Message = ZwpTextInputV3CommitStringEvent{}

// Scan scans the event from the socket.
func (e *ZwpTextInputV3CommitStringEvent) Scan(s *EventScanner) error {
	if v, err := s.String(); err != nil {
		return err
	} else {
		e.Text = v
	}
	return nil
}

// Ensure ZwpTextInputV3CommitStringEvent implements Event.
var _ Event = &ZwpTextInputV3CommitStringEvent{}

// ZwpTextInputV3DeleteSurroundingTextEvent signals when delete surrounding text
//
// Notify when the text around the current cursor position should be
// deleted.
//
// Before_length and after_length are the number of bytes before and after
// the current cursor index (excluding the selection) to delete.
//
// If a preedit text is present, in effect before_length is counted from
// the beginning of it, and after_length from its end (see done event
// sequence).
//
// Values set with this event are double-buffered. They must be applied
// and reset to initial on the next zwp_text_input_v3.done event.
//
// The initial values of both before_length and after_length are 0.
type ZwpTextInputV3DeleteSurroundingTextEvent struct {
	// BeforeLength contains length of text before current cursor position
	BeforeLength uint32

	// AfterLength contains length of text after current cursor position
	AfterLength uint32
}

// Opcode returns the event opcode for zwp_text_input_v3.delete_surrounding_text in text_input_unstable_v3
func (ZwpTextInputV3DeleteSurroundingTextEvent) Opcode() uint16 { return 4 }

// Ensure ZwpTextInputV3DeleteSurroundingTextEvent implements Message.
var _ Message = ZwpTextInputV3DeleteSurroundingTextEvent{}

// Scan scans the event from the socket.
func (e *ZwpTextInputV3DeleteSurroundingTextEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.BeforeLength = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.AfterLength = v
	}
	return nil
}

// Ensure ZwpTextInputV3DeleteSurroundingTextEvent implements Event.
var _ Event = &ZwpTextInputV3DeleteSurroundingTextEvent{}

// ZwpTextInputV3DoneEvent signals when apply changes
//
// Instruct the application to apply changes to state requested by the
// preedit_string, commit_string and delete_surrounding_text events. The
// state relating to these events is double-buffered, and each one
// modifies the pending state. This event replaces the current state with
// the pending state.
//
// The application must proceed by evaluating the changes in the following
// order:
//
// 1. Replace existing preedit string with the cursor.
// 2. Delete requested surrounding text.
// 3. Insert commit string with the cursor at its end.
// 4. Calculate surrounding text to send.
// 5. Insert new preedit text in cursor position.
// 6. Place cursor inside preedit text.
//
// The serial number reflects the last state of the zwp_text_input_v3
// object known to the compositor. The value of the serial argument must
// be equal to the number of commit requests already issued on that object.
// When the client receives a done event with a serial different than the
// number of past commit requests, it must proceed as normal, except it
// should not change the current state of the zwp_text_input_v3 object.
type ZwpTextInputV3DoneEvent struct {
	Serial uint32
}

// Opcode returns the event opcode for zwp_text_input_v3.done in text_input_unstable_v3
func (ZwpTextInputV3DoneEvent) Opcode() uint16 { return 5 }

// Ensure ZwpTextInputV3DoneEvent implements Message.
var _ Message = ZwpTextInputV3DoneEvent{}

// Scan scans the event from the socket.
func (e *ZwpTextInputV3DoneEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Serial = v
	}
	return nil
}

// Ensure ZwpTextInputV3DoneEvent implements Event.
var _ Event = &ZwpTextInputV3DoneEvent{}

// #endregion Interface text_input_unstable_v3.zwp_text_input_v3

// ----------------------------------------------------------------------------
// #region Interface text_input_unstable_v3.zwp_text_input_manager_v3

// ZwpTextInputManagerV3DestroyRequest requests to Destroy the wp_text_input_manager
//
// Destroy the wp_text_input_manager object.
type ZwpTextInputManagerV3DestroyRequest struct {
}

// Opcode returns the request opcode for zwp_text_input_manager_v3.destroy in text_input_unstable_v3
func (ZwpTextInputManagerV3DestroyRequest) Opcode() uint16 { return 0 }

// Ensure ZwpTextInputManagerV3DestroyRequest implements Message.
var _ Message = ZwpTextInputManagerV3DestroyRequest{}

// ZwpTextInputManagerV3GetTextInputRequest requests to create a new text input object
//
// Creates a new text-input object for a given seat.
type ZwpTextInputManagerV3GetTextInputRequest struct {
	ID ObjectID

	Seat ObjectID
}

// Opcode returns the request opcode for zwp_text_input_manager_v3.get_text_input in text_input_unstable_v3
func (ZwpTextInputManagerV3GetTextInputRequest) Opcode() uint16 { return 1 }

// Ensure ZwpTextInputManagerV3GetTextInputRequest implements Message.
var _ Message = ZwpTextInputManagerV3GetTextInputRequest{}

// #endregion Interface text_input_unstable_v3.zwp_text_input_manager_v3

////////////////////////////////////////////////////////////////////////////////
// #endregion Protocol text_input_unstable_v3

////////////////////////////////////////////////////////////////////////////////
// #region Protocol viewporter

// ----------------------------------------------------------------------------
// #region Interface viewporter.wp_viewporter

type WpViewporterError int

const (
	// WpViewporterErrorViewportExists corresponds to the surface already has a viewport object associated
	WpViewporterErrorViewportExists WpViewporterError = 0
)

// WpViewporterDestroyRequest requests to unbind from the cropping and scaling interface
//
// Informs the server that the client will not be using this
// protocol object anymore. This does not affect any other objects,
// wp_viewport objects included.
type WpViewporterDestroyRequest struct {
}

// Opcode returns the request opcode for wp_viewporter.destroy in viewporter
func (WpViewporterDestroyRequest) Opcode() uint16 { return 0 }

// Ensure WpViewporterDestroyRequest implements Message.
var _ Message = WpViewporterDestroyRequest{}

// WpViewporterGetViewportRequest requests to extend surface interface for crop and scale
//
// Instantiate an interface extension for the given wl_surface to
// crop and scale its content. If the given wl_surface already has
// a wp_viewport object associated, the viewport_exists
// protocol error is raised.
type WpViewporterGetViewportRequest struct {
	// ID contains the new viewport interface id
	ID ObjectID

	// Surface contains the surface
	Surface ObjectID
}

// Opcode returns the request opcode for wp_viewporter.get_viewport in viewporter
func (WpViewporterGetViewportRequest) Opcode() uint16 { return 1 }

// Ensure WpViewporterGetViewportRequest implements Message.
var _ Message = WpViewporterGetViewportRequest{}

// #endregion Interface viewporter.wp_viewporter

// ----------------------------------------------------------------------------
// #region Interface viewporter.wp_viewport

type WpViewportError int

const (
	// WpViewportErrorBadValue corresponds to negative or zero values in width or height
	WpViewportErrorBadValue WpViewportError = 0

	// WpViewportErrorBadSize corresponds to destination size is not integer
	WpViewportErrorBadSize WpViewportError = 1

	// WpViewportErrorOutOfBuffer corresponds to source rectangle extends outside of the content area
	WpViewportErrorOutOfBuffer WpViewportError = 2

	// WpViewportErrorNoSurface corresponds to the wl_surface was destroyed
	WpViewportErrorNoSurface WpViewportError = 3
)

// WpViewportDestroyRequest requests to remove scaling and cropping from the surface
//
// The associated wl_surface's crop and scale state is removed.
// The change is applied on the next wl_surface.commit.
type WpViewportDestroyRequest struct {
}

// Opcode returns the request opcode for wp_viewport.destroy in viewporter
func (WpViewportDestroyRequest) Opcode() uint16 { return 0 }

// Ensure WpViewportDestroyRequest implements Message.
var _ Message = WpViewportDestroyRequest{}

// WpViewportSetSourceRequest requests to set the source rectangle for cropping
//
// Set the source rectangle of the associated wl_surface. See
// wp_viewport for the description, and relation to the wl_buffer
// size.
//
// If all of x, y, width and height are -1.0, the source rectangle is
// unset instead. Any other set of values where width or height are zero
// or negative, or x or y are negative, raise the bad_value protocol
// error.
//
// The crop and scale state is double-buffered state, and will be
// applied on the next wl_surface.commit.
type WpViewportSetSourceRequest struct {
	// X contains source rectangle x
	X Fixed

	// Y contains source rectangle y
	Y Fixed

	// Width contains source rectangle width
	Width Fixed

	// Height contains source rectangle height
	Height Fixed
}

// Opcode returns the request opcode for wp_viewport.set_source in viewporter
func (WpViewportSetSourceRequest) Opcode() uint16 { return 1 }

// Ensure WpViewportSetSourceRequest implements Message.
var _ Message = WpViewportSetSourceRequest{}

// WpViewportSetDestinationRequest requests to set the surface size for scaling
//
// Set the destination size of the associated wl_surface. See
// wp_viewport for the description, and relation to the wl_buffer
// size.
//
// If width is -1 and height is -1, the destination size is unset
// instead. Any other pair of values for width and height that
// contains zero or negative values raises the bad_value protocol
// error.
//
// The crop and scale state is double-buffered state, and will be
// applied on the next wl_surface.commit.
type WpViewportSetDestinationRequest struct {
	// Width contains surface width
	Width int32

	// Height contains surface height
	Height int32
}

// Opcode returns the request opcode for wp_viewport.set_destination in viewporter
func (WpViewportSetDestinationRequest) Opcode() uint16 { return 2 }

// Ensure WpViewportSetDestinationRequest implements Message.
var _ Message = WpViewportSetDestinationRequest{}

// #endregion Interface viewporter.wp_viewport

////////////////////////////////////////////////////////////////////////////////
// #endregion Protocol viewporter

////////////////////////////////////////////////////////////////////////////////
// #region Protocol wayland

// ----------------------------------------------------------------------------
// #region Interface wayland.wl_display

// WlDisplayError represents global error values
//
// These errors are global and can be emitted in response to any
// server request.
type WlDisplayError int

const (
	// WlDisplayErrorInvalidObject corresponds to server couldn't find object
	WlDisplayErrorInvalidObject WlDisplayError = 0

	// WlDisplayErrorInvalidMethod corresponds to method doesn't exist on the specified interface or malformed request
	WlDisplayErrorInvalidMethod WlDisplayError = 1

	// WlDisplayErrorNoMemory corresponds to server is out of memory
	WlDisplayErrorNoMemory WlDisplayError = 2

	// WlDisplayErrorImplementation corresponds to implementation error in compositor
	WlDisplayErrorImplementation WlDisplayError = 3
)

// WlDisplaySyncRequest requests to asynchronous roundtrip
//
// The sync request asks the server to emit the 'done' event
// on the returned wl_callback object.  Since requests are
// handled in-order and events are delivered in-order, this can
// be used as a barrier to ensure all previous requests and the
// resulting events have been handled.
//
// The object returned by this request will be destroyed by the
// compositor after the callback is fired and as such the client must not
// attempt to use it after that point.
//
// The callback_data passed in the callback is the event serial.
type WlDisplaySyncRequest struct {
	// Callback contains callback object for the sync request
	Callback ObjectID
}

// Opcode returns the request opcode for wl_display.sync in wayland
func (WlDisplaySyncRequest) Opcode() uint16 { return 0 }

// Ensure WlDisplaySyncRequest implements Message.
var _ Message = WlDisplaySyncRequest{}

// WlDisplayGetRegistryRequest requests to get global registry object
//
// This request creates a registry object that allows the client
// to list and bind the global objects available from the
// compositor.
//
// It should be noted that the server side resources consumed in
// response to a get_registry request can only be released when the
// client disconnects, not when the client side proxy is destroyed.
// Therefore, clients should invoke get_registry as infrequently as
// possible to avoid wasting memory.
type WlDisplayGetRegistryRequest struct {
	// Registry contains global registry object
	Registry ObjectID
}

// Opcode returns the request opcode for wl_display.get_registry in wayland
func (WlDisplayGetRegistryRequest) Opcode() uint16 { return 1 }

// Ensure WlDisplayGetRegistryRequest implements Message.
var _ Message = WlDisplayGetRegistryRequest{}

// WlDisplayErrorEvent signals when fatal error event
//
// The error event is sent out when a fatal (non-recoverable)
// error has occurred.  The object_id argument is the object
// where the error occurred, most often in response to a request
// to that object.  The code identifies the error and is defined
// by the object interface.  As such, each interface defines its
// own set of error codes.  The message is a brief description
// of the error, for (debugging) convenience.
type WlDisplayErrorEvent struct {
	// ObjectID contains object where the error occurred
	ObjectID ObjectID

	// Code contains error code
	Code uint32

	// Message contains error description
	Message string
}

// Opcode returns the event opcode for wl_display.error in wayland
func (WlDisplayErrorEvent) Opcode() uint16 { return 0 }

// Ensure WlDisplayErrorEvent implements Message.
var _ Message = WlDisplayErrorEvent{}

// Scan scans the event from the socket.
func (e *WlDisplayErrorEvent) Scan(s *EventScanner) error {
	if v, err := s.ObjectID(); err != nil {
		return err
	} else {
		e.ObjectID = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Code = v
	}
	if v, err := s.String(); err != nil {
		return err
	} else {
		e.Message = v
	}
	return nil
}

// Ensure WlDisplayErrorEvent implements Event.
var _ Event = &WlDisplayErrorEvent{}

// WlDisplayDeleteIDEvent signals when acknowledge object ID deletion
//
// This event is used internally by the object ID management
// logic. When a client deletes an object that it had created,
// the server will send this event to acknowledge that it has
// seen the delete request. When the client receives this event,
// it will know that it can safely reuse the object ID.
type WlDisplayDeleteIDEvent struct {
	// ID contains deleted object ID
	ID uint32
}

// Opcode returns the event opcode for wl_display.delete_id in wayland
func (WlDisplayDeleteIDEvent) Opcode() uint16 { return 1 }

// Ensure WlDisplayDeleteIDEvent implements Message.
var _ Message = WlDisplayDeleteIDEvent{}

// Scan scans the event from the socket.
func (e *WlDisplayDeleteIDEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.ID = v
	}
	return nil
}

// Ensure WlDisplayDeleteIDEvent implements Event.
var _ Event = &WlDisplayDeleteIDEvent{}

// #endregion Interface wayland.wl_display

// ----------------------------------------------------------------------------
// #region Interface wayland.wl_registry

// WlRegistryBindRequest requests to bind an object to the display
//
// Binds a new, client-created object to the server using the
// specified name as the identifier.
type WlRegistryBindRequest struct {
	// Name contains unique numeric name of the object
	Name uint32

	// ID contains bounded object
	ID ObjectID
}

// Opcode returns the request opcode for wl_registry.bind in wayland
func (WlRegistryBindRequest) Opcode() uint16 { return 0 }

// Ensure WlRegistryBindRequest implements Message.
var _ Message = WlRegistryBindRequest{}

// WlRegistryGlobalEvent signals when announce global object
//
// Notify the client of global objects.
//
// The event notifies the client that a global object with
// the given name is now available, and it implements the
// given version of the given interface.
type WlRegistryGlobalEvent struct {
	// Name contains numeric name of the global object
	Name uint32

	// Interface contains interface implemented by the object
	Interface string

	// Version contains interface version
	Version uint32
}

// Opcode returns the event opcode for wl_registry.global in wayland
func (WlRegistryGlobalEvent) Opcode() uint16 { return 0 }

// Ensure WlRegistryGlobalEvent implements Message.
var _ Message = WlRegistryGlobalEvent{}

// Scan scans the event from the socket.
func (e *WlRegistryGlobalEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Name = v
	}
	if v, err := s.String(); err != nil {
		return err
	} else {
		e.Interface = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Version = v
	}
	return nil
}

// Ensure WlRegistryGlobalEvent implements Event.
var _ Event = &WlRegistryGlobalEvent{}

// WlRegistryGlobalRemoveEvent signals when announce removal of global object
//
// Notify the client of removed global objects.
//
// This event notifies the client that the global identified
// by name is no longer available.  If the client bound to
// the global using the bind request, the client should now
// destroy that object.
//
// The object remains valid and requests to the object will be
// ignored until the client destroys it, to avoid races between
// the global going away and a client sending a request to it.
type WlRegistryGlobalRemoveEvent struct {
	// Name contains numeric name of the global object
	Name uint32
}

// Opcode returns the event opcode for wl_registry.global_remove in wayland
func (WlRegistryGlobalRemoveEvent) Opcode() uint16 { return 1 }

// Ensure WlRegistryGlobalRemoveEvent implements Message.
var _ Message = WlRegistryGlobalRemoveEvent{}

// Scan scans the event from the socket.
func (e *WlRegistryGlobalRemoveEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Name = v
	}
	return nil
}

// Ensure WlRegistryGlobalRemoveEvent implements Event.
var _ Event = &WlRegistryGlobalRemoveEvent{}

// #endregion Interface wayland.wl_registry

// ----------------------------------------------------------------------------
// #region Interface wayland.wl_callback

// WlCallbackDoneEvent signals when done event
//
// Notify the client when the related request is done.
type WlCallbackDoneEvent struct {
	// CallbackData contains request-specific data for the callback
	CallbackData uint32
}

// Opcode returns the event opcode for wl_callback.done in wayland
func (WlCallbackDoneEvent) Opcode() uint16 { return 0 }

// Ensure WlCallbackDoneEvent implements Message.
var _ Message = WlCallbackDoneEvent{}

// Scan scans the event from the socket.
func (e *WlCallbackDoneEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.CallbackData = v
	}
	return nil
}

// Ensure WlCallbackDoneEvent implements Event.
var _ Event = &WlCallbackDoneEvent{}

// #endregion Interface wayland.wl_callback

// ----------------------------------------------------------------------------
// #region Interface wayland.wl_compositor

// WlCompositorCreateSurfaceRequest requests to create new surface
//
// Ask the compositor to create a new surface.
type WlCompositorCreateSurfaceRequest struct {
	// ID contains the new surface
	ID ObjectID
}

// Opcode returns the request opcode for wl_compositor.create_surface in wayland
func (WlCompositorCreateSurfaceRequest) Opcode() uint16 { return 0 }

// Ensure WlCompositorCreateSurfaceRequest implements Message.
var _ Message = WlCompositorCreateSurfaceRequest{}

// WlCompositorCreateRegionRequest requests to create new region
//
// Ask the compositor to create a new region.
type WlCompositorCreateRegionRequest struct {
	// ID contains the new region
	ID ObjectID
}

// Opcode returns the request opcode for wl_compositor.create_region in wayland
func (WlCompositorCreateRegionRequest) Opcode() uint16 { return 1 }

// Ensure WlCompositorCreateRegionRequest implements Message.
var _ Message = WlCompositorCreateRegionRequest{}

// #endregion Interface wayland.wl_compositor

// ----------------------------------------------------------------------------
// #region Interface wayland.wl_shm_pool

// WlShmPoolCreateBufferRequest requests to create a buffer from the pool
//
// Create a wl_buffer object from the pool.
//
// The buffer is created offset bytes into the pool and has
// width and height as specified.  The stride argument specifies
// the number of bytes from the beginning of one row to the beginning
// of the next.  The format is the pixel format of the buffer and
// must be one of those advertised through the wl_shm.format event.
//
// A buffer will keep a reference to the pool it was created from
// so it is valid to destroy the pool immediately after creating
// a buffer from it.
type WlShmPoolCreateBufferRequest struct {
	// ID contains buffer to create
	ID ObjectID

	// Offset contains buffer byte offset within the pool
	Offset int32

	// Width contains buffer width, in pixels
	Width int32

	// Height contains buffer height, in pixels
	Height int32

	// Stride contains number of bytes from the beginning of one row to the beginning of the next row
	Stride int32

	// Format contains buffer pixel format
	Format uint32
}

// Opcode returns the request opcode for wl_shm_pool.create_buffer in wayland
func (WlShmPoolCreateBufferRequest) Opcode() uint16 { return 0 }

// Ensure WlShmPoolCreateBufferRequest implements Message.
var _ Message = WlShmPoolCreateBufferRequest{}

// WlShmPoolDestroyRequest requests to destroy the pool
//
// Destroy the shared memory pool.
//
// The mmapped memory will be released when all
// buffers that have been created from this pool
// are gone.
type WlShmPoolDestroyRequest struct {
}

// Opcode returns the request opcode for wl_shm_pool.destroy in wayland
func (WlShmPoolDestroyRequest) Opcode() uint16 { return 1 }

// Ensure WlShmPoolDestroyRequest implements Message.
var _ Message = WlShmPoolDestroyRequest{}

// WlShmPoolResizeRequest requests to change the size of the pool mapping
//
// This request will cause the server to remap the backing memory
// for the pool from the file descriptor passed when the pool was
// created, but using the new size.  This request can only be
// used to make the pool bigger.
type WlShmPoolResizeRequest struct {
	// Size contains new size of the pool, in bytes
	Size int32
}

// Opcode returns the request opcode for wl_shm_pool.resize in wayland
func (WlShmPoolResizeRequest) Opcode() uint16 { return 2 }

// Ensure WlShmPoolResizeRequest implements Message.
var _ Message = WlShmPoolResizeRequest{}

// #endregion Interface wayland.wl_shm_pool

// ----------------------------------------------------------------------------
// #region Interface wayland.wl_shm

// WlShmError represents wl_shm error values
//
// These errors can be emitted in response to wl_shm requests.
type WlShmError int

const (
	// WlShmErrorInvalidFormat corresponds to buffer format is not known
	WlShmErrorInvalidFormat WlShmError = 0

	// WlShmErrorInvalidStride corresponds to invalid size or stride during pool or buffer creation
	WlShmErrorInvalidStride WlShmError = 1

	// WlShmErrorInvalidFD corresponds to mmapping the file descriptor failed
	WlShmErrorInvalidFD WlShmError = 2
)

// WlShmFormat represents pixel formats
//
// This describes the memory layout of an individual pixel.
//
// All renderers should support argb8888 and xrgb8888 but any other
// formats are optional and may not be supported by the particular
// renderer in use.
//
// The drm format codes match the macros defined in drm_fourcc.h, except
// argb8888 and xrgb8888. The formats actually supported by the compositor
// will be reported by the format event.
type WlShmFormat int

const (
	// WlShmFormatArgb8888 corresponds to 32-bit ARGB format, [31:0] A:R:G:B 8:8:8:8 little endian
	WlShmFormatArgb8888 WlShmFormat = 0

	// WlShmFormatXrgb8888 corresponds to 32-bit RGB format, [31:0] x:R:G:B 8:8:8:8 little endian
	WlShmFormatXrgb8888 WlShmFormat = 1

	// WlShmFormatC8 corresponds to 8-bit color index format, [7:0] C
	WlShmFormatC8 WlShmFormat = 0x20203843

	// WlShmFormatRgb332 corresponds to 8-bit RGB format, [7:0] R:G:B 3:3:2
	WlShmFormatRgb332 WlShmFormat = 0x38424752

	// WlShmFormatBgr233 corresponds to 8-bit BGR format, [7:0] B:G:R 2:3:3
	WlShmFormatBgr233 WlShmFormat = 0x38524742

	// WlShmFormatXrgb4444 corresponds to 16-bit xRGB format, [15:0] x:R:G:B 4:4:4:4 little endian
	WlShmFormatXrgb4444 WlShmFormat = 0x32315258

	// WlShmFormatXbgr4444 corresponds to 16-bit xBGR format, [15:0] x:B:G:R 4:4:4:4 little endian
	WlShmFormatXbgr4444 WlShmFormat = 0x32314258

	// WlShmFormatRgbx4444 corresponds to 16-bit RGBx format, [15:0] R:G:B:x 4:4:4:4 little endian
	WlShmFormatRgbx4444 WlShmFormat = 0x32315852

	// WlShmFormatBgrx4444 corresponds to 16-bit BGRx format, [15:0] B:G:R:x 4:4:4:4 little endian
	WlShmFormatBgrx4444 WlShmFormat = 0x32315842

	// WlShmFormatArgb4444 corresponds to 16-bit ARGB format, [15:0] A:R:G:B 4:4:4:4 little endian
	WlShmFormatArgb4444 WlShmFormat = 0x32315241

	// WlShmFormatAbgr4444 corresponds to 16-bit ABGR format, [15:0] A:B:G:R 4:4:4:4 little endian
	WlShmFormatAbgr4444 WlShmFormat = 0x32314241

	// WlShmFormatRgba4444 corresponds to 16-bit RBGA format, [15:0] R:G:B:A 4:4:4:4 little endian
	WlShmFormatRgba4444 WlShmFormat = 0x32314152

	// WlShmFormatBgra4444 corresponds to 16-bit BGRA format, [15:0] B:G:R:A 4:4:4:4 little endian
	WlShmFormatBgra4444 WlShmFormat = 0x32314142

	// WlShmFormatXrgb1555 corresponds to 16-bit xRGB format, [15:0] x:R:G:B 1:5:5:5 little endian
	WlShmFormatXrgb1555 WlShmFormat = 0x35315258

	// WlShmFormatXbgr1555 corresponds to 16-bit xBGR 1555 format, [15:0] x:B:G:R 1:5:5:5 little endian
	WlShmFormatXbgr1555 WlShmFormat = 0x35314258

	// WlShmFormatRgbx5551 corresponds to 16-bit RGBx 5551 format, [15:0] R:G:B:x 5:5:5:1 little endian
	WlShmFormatRgbx5551 WlShmFormat = 0x35315852

	// WlShmFormatBgrx5551 corresponds to 16-bit BGRx 5551 format, [15:0] B:G:R:x 5:5:5:1 little endian
	WlShmFormatBgrx5551 WlShmFormat = 0x35315842

	// WlShmFormatArgb1555 corresponds to 16-bit ARGB 1555 format, [15:0] A:R:G:B 1:5:5:5 little endian
	WlShmFormatArgb1555 WlShmFormat = 0x35315241

	// WlShmFormatAbgr1555 corresponds to 16-bit ABGR 1555 format, [15:0] A:B:G:R 1:5:5:5 little endian
	WlShmFormatAbgr1555 WlShmFormat = 0x35314241

	// WlShmFormatRgba5551 corresponds to 16-bit RGBA 5551 format, [15:0] R:G:B:A 5:5:5:1 little endian
	WlShmFormatRgba5551 WlShmFormat = 0x35314152

	// WlShmFormatBgra5551 corresponds to 16-bit BGRA 5551 format, [15:0] B:G:R:A 5:5:5:1 little endian
	WlShmFormatBgra5551 WlShmFormat = 0x35314142

	// WlShmFormatRgb565 corresponds to 16-bit RGB 565 format, [15:0] R:G:B 5:6:5 little endian
	WlShmFormatRgb565 WlShmFormat = 0x36314752

	// WlShmFormatBgr565 corresponds to 16-bit BGR 565 format, [15:0] B:G:R 5:6:5 little endian
	WlShmFormatBgr565 WlShmFormat = 0x36314742

	// WlShmFormatRgb888 corresponds to 24-bit RGB format, [23:0] R:G:B little endian
	WlShmFormatRgb888 WlShmFormat = 0x34324752

	// WlShmFormatBgr888 corresponds to 24-bit BGR format, [23:0] B:G:R little endian
	WlShmFormatBgr888 WlShmFormat = 0x34324742

	// WlShmFormatXbgr8888 corresponds to 32-bit xBGR format, [31:0] x:B:G:R 8:8:8:8 little endian
	WlShmFormatXbgr8888 WlShmFormat = 0x34324258

	// WlShmFormatRgbx8888 corresponds to 32-bit RGBx format, [31:0] R:G:B:x 8:8:8:8 little endian
	WlShmFormatRgbx8888 WlShmFormat = 0x34325852

	// WlShmFormatBgrx8888 corresponds to 32-bit BGRx format, [31:0] B:G:R:x 8:8:8:8 little endian
	WlShmFormatBgrx8888 WlShmFormat = 0x34325842

	// WlShmFormatAbgr8888 corresponds to 32-bit ABGR format, [31:0] A:B:G:R 8:8:8:8 little endian
	WlShmFormatAbgr8888 WlShmFormat = 0x34324241

	// WlShmFormatRgba8888 corresponds to 32-bit RGBA format, [31:0] R:G:B:A 8:8:8:8 little endian
	WlShmFormatRgba8888 WlShmFormat = 0x34324152

	// WlShmFormatBgra8888 corresponds to 32-bit BGRA format, [31:0] B:G:R:A 8:8:8:8 little endian
	WlShmFormatBgra8888 WlShmFormat = 0x34324142

	// WlShmFormatXrgb2101010 corresponds to 32-bit xRGB format, [31:0] x:R:G:B 2:10:10:10 little endian
	WlShmFormatXrgb2101010 WlShmFormat = 0x30335258

	// WlShmFormatXbgr2101010 corresponds to 32-bit xBGR format, [31:0] x:B:G:R 2:10:10:10 little endian
	WlShmFormatXbgr2101010 WlShmFormat = 0x30334258

	// WlShmFormatRgbx1010102 corresponds to 32-bit RGBx format, [31:0] R:G:B:x 10:10:10:2 little endian
	WlShmFormatRgbx1010102 WlShmFormat = 0x30335852

	// WlShmFormatBgrx1010102 corresponds to 32-bit BGRx format, [31:0] B:G:R:x 10:10:10:2 little endian
	WlShmFormatBgrx1010102 WlShmFormat = 0x30335842

	// WlShmFormatArgb2101010 corresponds to 32-bit ARGB format, [31:0] A:R:G:B 2:10:10:10 little endian
	WlShmFormatArgb2101010 WlShmFormat = 0x30335241

	// WlShmFormatAbgr2101010 corresponds to 32-bit ABGR format, [31:0] A:B:G:R 2:10:10:10 little endian
	WlShmFormatAbgr2101010 WlShmFormat = 0x30334241

	// WlShmFormatRgba1010102 corresponds to 32-bit RGBA format, [31:0] R:G:B:A 10:10:10:2 little endian
	WlShmFormatRgba1010102 WlShmFormat = 0x30334152

	// WlShmFormatBgra1010102 corresponds to 32-bit BGRA format, [31:0] B:G:R:A 10:10:10:2 little endian
	WlShmFormatBgra1010102 WlShmFormat = 0x30334142

	// WlShmFormatYuyv corresponds to packed YCbCr format, [31:0] Cr0:Y1:Cb0:Y0 8:8:8:8 little endian
	WlShmFormatYuyv WlShmFormat = 0x56595559

	// WlShmFormatYvyu corresponds to packed YCbCr format, [31:0] Cb0:Y1:Cr0:Y0 8:8:8:8 little endian
	WlShmFormatYvyu WlShmFormat = 0x55595659

	// WlShmFormatUyvy corresponds to packed YCbCr format, [31:0] Y1:Cr0:Y0:Cb0 8:8:8:8 little endian
	WlShmFormatUyvy WlShmFormat = 0x59565955

	// WlShmFormatVyuy corresponds to packed YCbCr format, [31:0] Y1:Cb0:Y0:Cr0 8:8:8:8 little endian
	WlShmFormatVyuy WlShmFormat = 0x59555956

	// WlShmFormatAyuv corresponds to packed AYCbCr format, [31:0] A:Y:Cb:Cr 8:8:8:8 little endian
	WlShmFormatAyuv WlShmFormat = 0x56555941

	// WlShmFormatNv12 corresponds to 2 plane YCbCr Cr:Cb format, 2x2 subsampled Cr:Cb plane
	WlShmFormatNv12 WlShmFormat = 0x3231564e

	// WlShmFormatNv21 corresponds to 2 plane YCbCr Cb:Cr format, 2x2 subsampled Cb:Cr plane
	WlShmFormatNv21 WlShmFormat = 0x3132564e

	// WlShmFormatNv16 corresponds to 2 plane YCbCr Cr:Cb format, 2x1 subsampled Cr:Cb plane
	WlShmFormatNv16 WlShmFormat = 0x3631564e

	// WlShmFormatNv61 corresponds to 2 plane YCbCr Cb:Cr format, 2x1 subsampled Cb:Cr plane
	WlShmFormatNv61 WlShmFormat = 0x3136564e

	// WlShmFormatYuv410 corresponds to 3 plane YCbCr format, 4x4 subsampled Cb (1) and Cr (2) planes
	WlShmFormatYuv410 WlShmFormat = 0x39565559

	// WlShmFormatYvu410 corresponds to 3 plane YCbCr format, 4x4 subsampled Cr (1) and Cb (2) planes
	WlShmFormatYvu410 WlShmFormat = 0x39555659

	// WlShmFormatYuv411 corresponds to 3 plane YCbCr format, 4x1 subsampled Cb (1) and Cr (2) planes
	WlShmFormatYuv411 WlShmFormat = 0x31315559

	// WlShmFormatYvu411 corresponds to 3 plane YCbCr format, 4x1 subsampled Cr (1) and Cb (2) planes
	WlShmFormatYvu411 WlShmFormat = 0x31315659

	// WlShmFormatYuv420 corresponds to 3 plane YCbCr format, 2x2 subsampled Cb (1) and Cr (2) planes
	WlShmFormatYuv420 WlShmFormat = 0x32315559

	// WlShmFormatYvu420 corresponds to 3 plane YCbCr format, 2x2 subsampled Cr (1) and Cb (2) planes
	WlShmFormatYvu420 WlShmFormat = 0x32315659

	// WlShmFormatYuv422 corresponds to 3 plane YCbCr format, 2x1 subsampled Cb (1) and Cr (2) planes
	WlShmFormatYuv422 WlShmFormat = 0x36315559

	// WlShmFormatYvu422 corresponds to 3 plane YCbCr format, 2x1 subsampled Cr (1) and Cb (2) planes
	WlShmFormatYvu422 WlShmFormat = 0x36315659

	// WlShmFormatYuv444 corresponds to 3 plane YCbCr format, non-subsampled Cb (1) and Cr (2) planes
	WlShmFormatYuv444 WlShmFormat = 0x34325559

	// WlShmFormatYvu444 corresponds to 3 plane YCbCr format, non-subsampled Cr (1) and Cb (2) planes
	WlShmFormatYvu444 WlShmFormat = 0x34325659

	// WlShmFormatR8 corresponds to [7:0] R
	WlShmFormatR8 WlShmFormat = 0x20203852

	// WlShmFormatR16 corresponds to [15:0] R little endian
	WlShmFormatR16 WlShmFormat = 0x20363152

	// WlShmFormatRg88 corresponds to [15:0] R:G 8:8 little endian
	WlShmFormatRg88 WlShmFormat = 0x38384752

	// WlShmFormatGr88 corresponds to [15:0] G:R 8:8 little endian
	WlShmFormatGr88 WlShmFormat = 0x38385247

	// WlShmFormatRg1616 corresponds to [31:0] R:G 16:16 little endian
	WlShmFormatRg1616 WlShmFormat = 0x32334752

	// WlShmFormatGr1616 corresponds to [31:0] G:R 16:16 little endian
	WlShmFormatGr1616 WlShmFormat = 0x32335247

	// WlShmFormatXrgb16161616f corresponds to [63:0] x:R:G:B 16:16:16:16 little endian
	WlShmFormatXrgb16161616f WlShmFormat = 0x48345258

	// WlShmFormatXbgr16161616f corresponds to [63:0] x:B:G:R 16:16:16:16 little endian
	WlShmFormatXbgr16161616f WlShmFormat = 0x48344258

	// WlShmFormatArgb16161616f corresponds to [63:0] A:R:G:B 16:16:16:16 little endian
	WlShmFormatArgb16161616f WlShmFormat = 0x48345241

	// WlShmFormatAbgr16161616f corresponds to [63:0] A:B:G:R 16:16:16:16 little endian
	WlShmFormatAbgr16161616f WlShmFormat = 0x48344241

	// WlShmFormatXyuv8888 corresponds to [31:0] X:Y:Cb:Cr 8:8:8:8 little endian
	WlShmFormatXyuv8888 WlShmFormat = 0x56555958

	// WlShmFormatVuy888 corresponds to [23:0] Cr:Cb:Y 8:8:8 little endian
	WlShmFormatVuy888 WlShmFormat = 0x34325556

	// WlShmFormatVuy101010 corresponds to Y followed by U then V, 10:10:10. Non-linear modifier only
	WlShmFormatVuy101010 WlShmFormat = 0x30335556

	// WlShmFormatY210 corresponds to [63:0] Cr0:0:Y1:0:Cb0:0:Y0:0 10:6:10:6:10:6:10:6 little endian per 2 Y pixels
	WlShmFormatY210 WlShmFormat = 0x30313259

	// WlShmFormatY212 corresponds to [63:0] Cr0:0:Y1:0:Cb0:0:Y0:0 12:4:12:4:12:4:12:4 little endian per 2 Y pixels
	WlShmFormatY212 WlShmFormat = 0x32313259

	// WlShmFormatY216 corresponds to [63:0] Cr0:Y1:Cb0:Y0 16:16:16:16 little endian per 2 Y pixels
	WlShmFormatY216 WlShmFormat = 0x36313259

	// WlShmFormatY410 corresponds to [31:0] A:Cr:Y:Cb 2:10:10:10 little endian
	WlShmFormatY410 WlShmFormat = 0x30313459

	// WlShmFormatY412 corresponds to [63:0] A:0:Cr:0:Y:0:Cb:0 12:4:12:4:12:4:12:4 little endian
	WlShmFormatY412 WlShmFormat = 0x32313459

	// WlShmFormatY416 corresponds to [63:0] A:Cr:Y:Cb 16:16:16:16 little endian
	WlShmFormatY416 WlShmFormat = 0x36313459

	// WlShmFormatXvyu2101010 corresponds to [31:0] X:Cr:Y:Cb 2:10:10:10 little endian
	WlShmFormatXvyu2101010 WlShmFormat = 0x30335658

	// WlShmFormatXvyu1216161616 corresponds to [63:0] X:0:Cr:0:Y:0:Cb:0 12:4:12:4:12:4:12:4 little endian
	WlShmFormatXvyu1216161616 WlShmFormat = 0x36335658

	// WlShmFormatXvyu16161616 corresponds to [63:0] X:Cr:Y:Cb 16:16:16:16 little endian
	WlShmFormatXvyu16161616 WlShmFormat = 0x38345658

	// WlShmFormatY0l0 corresponds to [63:0] A3:A2:Y3:0:Cr0:0:Y2:0:A1:A0:Y1:0:Cb0:0:Y0:0 1:1:8:2:8:2:8:2:1:1:8:2:8:2:8:2 little endian
	WlShmFormatY0l0 WlShmFormat = 0x304c3059

	// WlShmFormatX0l0 corresponds to [63:0] X3:X2:Y3:0:Cr0:0:Y2:0:X1:X0:Y1:0:Cb0:0:Y0:0 1:1:8:2:8:2:8:2:1:1:8:2:8:2:8:2 little endian
	WlShmFormatX0l0 WlShmFormat = 0x304c3058

	// WlShmFormatY0l2 corresponds to [63:0] A3:A2:Y3:Cr0:Y2:A1:A0:Y1:Cb0:Y0 1:1:10:10:10:1:1:10:10:10 little endian
	WlShmFormatY0l2 WlShmFormat = 0x324c3059

	// WlShmFormatX0l2 corresponds to [63:0] X3:X2:Y3:Cr0:Y2:X1:X0:Y1:Cb0:Y0 1:1:10:10:10:1:1:10:10:10 little endian
	WlShmFormatX0l2 WlShmFormat = 0x324c3058

	WlShmFormatYuv4208bit WlShmFormat = 0x38305559

	WlShmFormatYuv42010bit WlShmFormat = 0x30315559

	WlShmFormatXrgb8888A8 WlShmFormat = 0x38415258

	WlShmFormatXbgr8888A8 WlShmFormat = 0x38414258

	WlShmFormatRgbx8888A8 WlShmFormat = 0x38415852

	WlShmFormatBgrx8888A8 WlShmFormat = 0x38415842

	WlShmFormatRgb888A8 WlShmFormat = 0x38413852

	WlShmFormatBgr888A8 WlShmFormat = 0x38413842

	WlShmFormatRgb565A8 WlShmFormat = 0x38413552

	WlShmFormatBgr565A8 WlShmFormat = 0x38413542

	// WlShmFormatNv24 corresponds to non-subsampled Cr:Cb plane
	WlShmFormatNv24 WlShmFormat = 0x3432564e

	// WlShmFormatNv42 corresponds to non-subsampled Cb:Cr plane
	WlShmFormatNv42 WlShmFormat = 0x3234564e

	// WlShmFormatP210 corresponds to 2x1 subsampled Cr:Cb plane, 10 bit per channel
	WlShmFormatP210 WlShmFormat = 0x30313250

	// WlShmFormatP010 corresponds to 2x2 subsampled Cr:Cb plane 10 bits per channel
	WlShmFormatP010 WlShmFormat = 0x30313050

	// WlShmFormatP012 corresponds to 2x2 subsampled Cr:Cb plane 12 bits per channel
	WlShmFormatP012 WlShmFormat = 0x32313050

	// WlShmFormatP016 corresponds to 2x2 subsampled Cr:Cb plane 16 bits per channel
	WlShmFormatP016 WlShmFormat = 0x36313050

	// WlShmFormatAxbxgxrx106106106106 corresponds to [63:0] A:x:B:x:G:x:R:x 10:6:10:6:10:6:10:6 little endian
	WlShmFormatAxbxgxrx106106106106 WlShmFormat = 0x30314241

	// WlShmFormatNv15 corresponds to 2x2 subsampled Cr:Cb plane
	WlShmFormatNv15 WlShmFormat = 0x3531564e

	WlShmFormatQ410 WlShmFormat = 0x30313451

	WlShmFormatQ401 WlShmFormat = 0x31303451
)

// WlShmCreatePoolRequest requests to create a shm pool
//
// Create a new wl_shm_pool object.
//
// The pool can be used to create shared memory based buffer
// objects.  The server will mmap size bytes of the passed file
// descriptor, to use as backing memory for the pool.
type WlShmCreatePoolRequest struct {
	// ID contains pool to create
	ID ObjectID

	// FD contains file descriptor for the pool
	FD FD

	// Size contains pool size, in bytes
	Size int32
}

// Opcode returns the request opcode for wl_shm.create_pool in wayland
func (WlShmCreatePoolRequest) Opcode() uint16 { return 0 }

// Ensure WlShmCreatePoolRequest implements Message.
var _ Message = WlShmCreatePoolRequest{}

// WlShmFormatEvent signals when pixel format description
//
// Informs the client about a valid pixel format that
// can be used for buffers. Known formats include
// argb8888 and xrgb8888.
type WlShmFormatEvent struct {
	// Format contains buffer pixel format
	Format uint32
}

// Opcode returns the event opcode for wl_shm.format in wayland
func (WlShmFormatEvent) Opcode() uint16 { return 0 }

// Ensure WlShmFormatEvent implements Message.
var _ Message = WlShmFormatEvent{}

// Scan scans the event from the socket.
func (e *WlShmFormatEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Format = v
	}
	return nil
}

// Ensure WlShmFormatEvent implements Event.
var _ Event = &WlShmFormatEvent{}

// #endregion Interface wayland.wl_shm

// ----------------------------------------------------------------------------
// #region Interface wayland.wl_buffer

// WlBufferDestroyRequest requests to destroy a buffer
//
// Destroy a buffer. If and how you need to release the backing
// storage is defined by the buffer factory interface.
//
// For possible side-effects to a surface, see wl_surface.attach.
type WlBufferDestroyRequest struct {
}

// Opcode returns the request opcode for wl_buffer.destroy in wayland
func (WlBufferDestroyRequest) Opcode() uint16 { return 0 }

// Ensure WlBufferDestroyRequest implements Message.
var _ Message = WlBufferDestroyRequest{}

// WlBufferReleaseEvent signals when compositor releases buffer
//
// Sent when this wl_buffer is no longer used by the compositor.
// The client is now free to reuse or destroy this buffer and its
// backing storage.
//
// If a client receives a release event before the frame callback
// requested in the same wl_surface.commit that attaches this
// wl_buffer to a surface, then the client is immediately free to
// reuse the buffer and its backing storage, and does not need a
// second buffer for the next surface content update. Typically
// this is possible, when the compositor maintains a copy of the
// wl_surface contents, e.g. as a GL texture. This is an important
// optimization for GL(ES) compositors with wl_shm clients.
type WlBufferReleaseEvent struct {
}

// Opcode returns the event opcode for wl_buffer.release in wayland
func (WlBufferReleaseEvent) Opcode() uint16 { return 0 }

// Ensure WlBufferReleaseEvent implements Message.
var _ Message = WlBufferReleaseEvent{}

// Scan scans the event from the socket.
func (e *WlBufferReleaseEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure WlBufferReleaseEvent implements Event.
var _ Event = &WlBufferReleaseEvent{}

// #endregion Interface wayland.wl_buffer

// ----------------------------------------------------------------------------
// #region Interface wayland.wl_data_offer

type WlDataOfferError int

const (
	// WlDataOfferErrorInvalidFinish corresponds to finish request was called untimely
	WlDataOfferErrorInvalidFinish WlDataOfferError = 0

	// WlDataOfferErrorInvalidActionMask corresponds to action mask contains invalid values
	WlDataOfferErrorInvalidActionMask WlDataOfferError = 1

	// WlDataOfferErrorInvalidAction corresponds to action argument has an invalid value
	WlDataOfferErrorInvalidAction WlDataOfferError = 2

	// WlDataOfferErrorInvalidOffer corresponds to offer doesn't accept this request
	WlDataOfferErrorInvalidOffer WlDataOfferError = 3
)

// WlDataOfferAcceptRequest requests to accept one of the offered mime types
//
// Indicate that the client can accept the given mime type, or
// NULL for not accepted.
//
// For objects of version 2 or older, this request is used by the
// client to give feedback whether the client can receive the given
// mime type, or NULL if none is accepted; the feedback does not
// determine whether the drag-and-drop operation succeeds or not.
//
// For objects of version 3 or newer, this request determines the
// final result of the drag-and-drop operation. If the end result
// is that no mime types were accepted, the drag-and-drop operation
// will be cancelled and the corresponding drag source will receive
// wl_data_source.cancelled. Clients may still use this event in
// conjunction with wl_data_source.action for feedback.
type WlDataOfferAcceptRequest struct {
	// Serial contains serial number of the accept request
	Serial uint32

	// MimeType contains mime type accepted by the client
	MimeType string
}

// Opcode returns the request opcode for wl_data_offer.accept in wayland
func (WlDataOfferAcceptRequest) Opcode() uint16 { return 0 }

// Ensure WlDataOfferAcceptRequest implements Message.
var _ Message = WlDataOfferAcceptRequest{}

// WlDataOfferReceiveRequest requests to request that the data is transferred
//
// To transfer the offered data, the client issues this request
// and indicates the mime type it wants to receive.  The transfer
// happens through the passed file descriptor (typically created
// with the pipe system call).  The source client writes the data
// in the mime type representation requested and then closes the
// file descriptor.
//
// The receiving client reads from the read end of the pipe until
// EOF and then closes its end, at which point the transfer is
// complete.
//
// This request may happen multiple times for different mime types,
// both before and after wl_data_device.drop. Drag-and-drop destination
// clients may preemptively fetch data or examine it more closely to
// determine acceptance.
type WlDataOfferReceiveRequest struct {
	// MimeType contains mime type desired by receiver
	MimeType string

	// FD contains file descriptor for data transfer
	FD FD
}

// Opcode returns the request opcode for wl_data_offer.receive in wayland
func (WlDataOfferReceiveRequest) Opcode() uint16 { return 1 }

// Ensure WlDataOfferReceiveRequest implements Message.
var _ Message = WlDataOfferReceiveRequest{}

// WlDataOfferDestroyRequest requests to destroy data offer
//
// Destroy the data offer.
type WlDataOfferDestroyRequest struct {
}

// Opcode returns the request opcode for wl_data_offer.destroy in wayland
func (WlDataOfferDestroyRequest) Opcode() uint16 { return 2 }

// Ensure WlDataOfferDestroyRequest implements Message.
var _ Message = WlDataOfferDestroyRequest{}

// WlDataOfferFinishRequest requests to the offer will no longer be used
//
// Notifies the compositor that the drag destination successfully
// finished the drag-and-drop operation.
//
// Upon receiving this request, the compositor will emit
// wl_data_source.dnd_finished on the drag source client.
//
// It is a client error to perform other requests than
// wl_data_offer.destroy after this one. It is also an error to perform
// this request after a NULL mime type has been set in
// wl_data_offer.accept or no action was received through
// wl_data_offer.action.
//
// If wl_data_offer.finish request is received for a non drag and drop
// operation, the invalid_finish protocol error is raised.
type WlDataOfferFinishRequest struct {
}

// Opcode returns the request opcode for wl_data_offer.finish in wayland
func (WlDataOfferFinishRequest) Opcode() uint16 { return 3 }

// Ensure WlDataOfferFinishRequest implements Message.
var _ Message = WlDataOfferFinishRequest{}

// WlDataOfferSetActionsRequest requests to set the available/preferred drag-and-drop actions
//
// Sets the actions that the destination side client supports for
// this operation. This request may trigger the emission of
// wl_data_source.action and wl_data_offer.action events if the compositor
// needs to change the selected action.
//
// This request can be called multiple times throughout the
// drag-and-drop operation, typically in response to wl_data_device.enter
// or wl_data_device.motion events.
//
// This request determines the final result of the drag-and-drop
// operation. If the end result is that no action is accepted,
// the drag source will receive wl_data_source.cancelled.
//
// The dnd_actions argument must contain only values expressed in the
// wl_data_device_manager.dnd_actions enum, and the preferred_action
// argument must only contain one of those values set, otherwise it
// will result in a protocol error.
//
// While managing an "ask" action, the destination drag-and-drop client
// may perform further wl_data_offer.receive requests, and is expected
// to perform one last wl_data_offer.set_actions request with a preferred
// action other than "ask" (and optionally wl_data_offer.accept) before
// requesting wl_data_offer.finish, in order to convey the action selected
// by the user. If the preferred action is not in the
// wl_data_offer.source_actions mask, an error will be raised.
//
// If the "ask" action is dismissed (e.g. user cancellation), the client
// is expected to perform wl_data_offer.destroy right away.
//
// This request can only be made on drag-and-drop offers, a protocol error
// will be raised otherwise.
type WlDataOfferSetActionsRequest struct {
	// DndActions contains actions supported by the destination client
	DndActions uint32

	// PreferredAction contains action preferred by the destination client
	PreferredAction uint32
}

// Opcode returns the request opcode for wl_data_offer.set_actions in wayland
func (WlDataOfferSetActionsRequest) Opcode() uint16 { return 4 }

// Ensure WlDataOfferSetActionsRequest implements Message.
var _ Message = WlDataOfferSetActionsRequest{}

// WlDataOfferOfferEvent signals when advertise offered mime type
//
// Sent immediately after creating the wl_data_offer object.  One
// event per offered mime type.
type WlDataOfferOfferEvent struct {
	// MimeType contains offered mime type
	MimeType string
}

// Opcode returns the event opcode for wl_data_offer.offer in wayland
func (WlDataOfferOfferEvent) Opcode() uint16 { return 0 }

// Ensure WlDataOfferOfferEvent implements Message.
var _ Message = WlDataOfferOfferEvent{}

// Scan scans the event from the socket.
func (e *WlDataOfferOfferEvent) Scan(s *EventScanner) error {
	if v, err := s.String(); err != nil {
		return err
	} else {
		e.MimeType = v
	}
	return nil
}

// Ensure WlDataOfferOfferEvent implements Event.
var _ Event = &WlDataOfferOfferEvent{}

// WlDataOfferSourceActionsEvent signals when notify the source-side available actions
//
// This event indicates the actions offered by the data source. It
// will be sent right after wl_data_device.enter, or anytime the source
// side changes its offered actions through wl_data_source.set_actions.
type WlDataOfferSourceActionsEvent struct {
	// SourceActions contains actions offered by the data source
	SourceActions uint32
}

// Opcode returns the event opcode for wl_data_offer.source_actions in wayland
func (WlDataOfferSourceActionsEvent) Opcode() uint16 { return 1 }

// Ensure WlDataOfferSourceActionsEvent implements Message.
var _ Message = WlDataOfferSourceActionsEvent{}

// Scan scans the event from the socket.
func (e *WlDataOfferSourceActionsEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.SourceActions = v
	}
	return nil
}

// Ensure WlDataOfferSourceActionsEvent implements Event.
var _ Event = &WlDataOfferSourceActionsEvent{}

// WlDataOfferActionEvent signals when notify the selected action
//
// This event indicates the action selected by the compositor after
// matching the source/destination side actions. Only one action (or
// none) will be offered here.
//
// This event can be emitted multiple times during the drag-and-drop
// operation in response to destination side action changes through
// wl_data_offer.set_actions.
//
// This event will no longer be emitted after wl_data_device.drop
// happened on the drag-and-drop destination, the client must
// honor the last action received, or the last preferred one set
// through wl_data_offer.set_actions when handling an "ask" action.
//
// Compositors may also change the selected action on the fly, mainly
// in response to keyboard modifier changes during the drag-and-drop
// operation.
//
// The most recent action received is always the valid one. Prior to
// receiving wl_data_device.drop, the chosen action may change (e.g.
// due to keyboard modifiers being pressed). At the time of receiving
// wl_data_device.drop the drag-and-drop destination must honor the
// last action received.
//
// Action changes may still happen after wl_data_device.drop,
// especially on "ask" actions, where the drag-and-drop destination
// may choose another action afterwards. Action changes happening
// at this stage are always the result of inter-client negotiation, the
// compositor shall no longer be able to induce a different action.
//
// Upon "ask" actions, it is expected that the drag-and-drop destination
// may potentially choose a different action and/or mime type,
// based on wl_data_offer.source_actions and finally chosen by the
// user (e.g. popping up a menu with the available options). The
// final wl_data_offer.set_actions and wl_data_offer.accept requests
// must happen before the call to wl_data_offer.finish.
type WlDataOfferActionEvent struct {
	// DndAction contains action selected by the compositor
	DndAction uint32
}

// Opcode returns the event opcode for wl_data_offer.action in wayland
func (WlDataOfferActionEvent) Opcode() uint16 { return 2 }

// Ensure WlDataOfferActionEvent implements Message.
var _ Message = WlDataOfferActionEvent{}

// Scan scans the event from the socket.
func (e *WlDataOfferActionEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.DndAction = v
	}
	return nil
}

// Ensure WlDataOfferActionEvent implements Event.
var _ Event = &WlDataOfferActionEvent{}

// #endregion Interface wayland.wl_data_offer

// ----------------------------------------------------------------------------
// #region Interface wayland.wl_data_source

type WlDataSourceError int

const (
	// WlDataSourceErrorInvalidActionMask corresponds to action mask contains invalid values
	WlDataSourceErrorInvalidActionMask WlDataSourceError = 0

	// WlDataSourceErrorInvalidSource corresponds to source doesn't accept this request
	WlDataSourceErrorInvalidSource WlDataSourceError = 1
)

// WlDataSourceOfferRequest requests to add an offered mime type
//
// This request adds a mime type to the set of mime types
// advertised to targets.  Can be called several times to offer
// multiple types.
type WlDataSourceOfferRequest struct {
	// MimeType contains mime type offered by the data source
	MimeType string
}

// Opcode returns the request opcode for wl_data_source.offer in wayland
func (WlDataSourceOfferRequest) Opcode() uint16 { return 0 }

// Ensure WlDataSourceOfferRequest implements Message.
var _ Message = WlDataSourceOfferRequest{}

// WlDataSourceDestroyRequest requests to destroy the data source
//
// Destroy the data source.
type WlDataSourceDestroyRequest struct {
}

// Opcode returns the request opcode for wl_data_source.destroy in wayland
func (WlDataSourceDestroyRequest) Opcode() uint16 { return 1 }

// Ensure WlDataSourceDestroyRequest implements Message.
var _ Message = WlDataSourceDestroyRequest{}

// WlDataSourceSetActionsRequest requests to set the available drag-and-drop actions
//
// Sets the actions that the source side client supports for this
// operation. This request may trigger wl_data_source.action and
// wl_data_offer.action events if the compositor needs to change the
// selected action.
//
// The dnd_actions argument must contain only values expressed in the
// wl_data_device_manager.dnd_actions enum, otherwise it will result
// in a protocol error.
//
// This request must be made once only, and can only be made on sources
// used in drag-and-drop, so it must be performed before
// wl_data_device.start_drag. Attempting to use the source other than
// for drag-and-drop will raise a protocol error.
type WlDataSourceSetActionsRequest struct {
	// DndActions contains actions supported by the data source
	DndActions uint32
}

// Opcode returns the request opcode for wl_data_source.set_actions in wayland
func (WlDataSourceSetActionsRequest) Opcode() uint16 { return 2 }

// Ensure WlDataSourceSetActionsRequest implements Message.
var _ Message = WlDataSourceSetActionsRequest{}

// WlDataSourceTargetEvent signals when a target accepts an offered mime type
//
// Sent when a target accepts pointer_focus or motion events.  If
// a target does not accept any of the offered types, type is NULL.
//
// Used for feedback during drag-and-drop.
type WlDataSourceTargetEvent struct {
	// MimeType contains mime type accepted by the target
	MimeType string
}

// Opcode returns the event opcode for wl_data_source.target in wayland
func (WlDataSourceTargetEvent) Opcode() uint16 { return 0 }

// Ensure WlDataSourceTargetEvent implements Message.
var _ Message = WlDataSourceTargetEvent{}

// Scan scans the event from the socket.
func (e *WlDataSourceTargetEvent) Scan(s *EventScanner) error {
	if v, err := s.String(); err != nil {
		return err
	} else {
		e.MimeType = v
	}
	return nil
}

// Ensure WlDataSourceTargetEvent implements Event.
var _ Event = &WlDataSourceTargetEvent{}

// WlDataSourceSendEvent signals when send the data
//
// Request for data from the client.  Send the data as the
// specified mime type over the passed file descriptor, then
// close it.
type WlDataSourceSendEvent struct {
	// MimeType contains mime type for the data
	MimeType string

	// FD contains file descriptor for the data
	FD FD
}

// Opcode returns the event opcode for wl_data_source.send in wayland
func (WlDataSourceSendEvent) Opcode() uint16 { return 1 }

// Ensure WlDataSourceSendEvent implements Message.
var _ Message = WlDataSourceSendEvent{}

// Scan scans the event from the socket.
func (e *WlDataSourceSendEvent) Scan(s *EventScanner) error {
	if v, err := s.String(); err != nil {
		return err
	} else {
		e.MimeType = v
	}
	if v, err := s.FD(); err != nil {
		return err
	} else {
		e.FD = v
	}
	return nil
}

// Ensure WlDataSourceSendEvent implements Event.
var _ Event = &WlDataSourceSendEvent{}

// WlDataSourceCancelledEvent signals when selection was cancelled
//
// This data source is no longer valid. There are several reasons why
// this could happen:
//
// - The data source has been replaced by another data source.
// - The drag-and-drop operation was performed, but the drop destination
// did not accept any of the mime types offered through
// wl_data_source.target.
// - The drag-and-drop operation was performed, but the drop destination
// did not select any of the actions present in the mask offered through
// wl_data_source.action.
// - The drag-and-drop operation was performed but didn't happen over a
// surface.
// - The compositor cancelled the drag-and-drop operation (e.g. compositor
// dependent timeouts to avoid stale drag-and-drop transfers).
//
// The client should clean up and destroy this data source.
//
// For objects of version 2 or older, wl_data_source.cancelled will
// only be emitted if the data source was replaced by another data
// source.
type WlDataSourceCancelledEvent struct {
}

// Opcode returns the event opcode for wl_data_source.cancelled in wayland
func (WlDataSourceCancelledEvent) Opcode() uint16 { return 2 }

// Ensure WlDataSourceCancelledEvent implements Message.
var _ Message = WlDataSourceCancelledEvent{}

// Scan scans the event from the socket.
func (e *WlDataSourceCancelledEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure WlDataSourceCancelledEvent implements Event.
var _ Event = &WlDataSourceCancelledEvent{}

// WlDataSourceDndDropPerformedEvent signals when the drag-and-drop operation physically finished
//
// The user performed the drop action. This event does not indicate
// acceptance, wl_data_source.cancelled may still be emitted afterwards
// if the drop destination does not accept any mime type.
//
// However, this event might however not be received if the compositor
// cancelled the drag-and-drop operation before this event could happen.
//
// Note that the data_source may still be used in the future and should
// not be destroyed here.
type WlDataSourceDndDropPerformedEvent struct {
}

// Opcode returns the event opcode for wl_data_source.dnd_drop_performed in wayland
func (WlDataSourceDndDropPerformedEvent) Opcode() uint16 { return 3 }

// Ensure WlDataSourceDndDropPerformedEvent implements Message.
var _ Message = WlDataSourceDndDropPerformedEvent{}

// Scan scans the event from the socket.
func (e *WlDataSourceDndDropPerformedEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure WlDataSourceDndDropPerformedEvent implements Event.
var _ Event = &WlDataSourceDndDropPerformedEvent{}

// WlDataSourceDndFinishedEvent signals when the drag-and-drop operation concluded
//
// The drop destination finished interoperating with this data
// source, so the client is now free to destroy this data source and
// free all associated data.
//
// If the action used to perform the operation was "move", the
// source can now delete the transferred data.
type WlDataSourceDndFinishedEvent struct {
}

// Opcode returns the event opcode for wl_data_source.dnd_finished in wayland
func (WlDataSourceDndFinishedEvent) Opcode() uint16 { return 4 }

// Ensure WlDataSourceDndFinishedEvent implements Message.
var _ Message = WlDataSourceDndFinishedEvent{}

// Scan scans the event from the socket.
func (e *WlDataSourceDndFinishedEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure WlDataSourceDndFinishedEvent implements Event.
var _ Event = &WlDataSourceDndFinishedEvent{}

// WlDataSourceActionEvent signals when notify the selected action
//
// This event indicates the action selected by the compositor after
// matching the source/destination side actions. Only one action (or
// none) will be offered here.
//
// This event can be emitted multiple times during the drag-and-drop
// operation, mainly in response to destination side changes through
// wl_data_offer.set_actions, and as the data device enters/leaves
// surfaces.
//
// It is only possible to receive this event after
// wl_data_source.dnd_drop_performed if the drag-and-drop operation
// ended in an "ask" action, in which case the final wl_data_source.action
// event will happen immediately before wl_data_source.dnd_finished.
//
// Compositors may also change the selected action on the fly, mainly
// in response to keyboard modifier changes during the drag-and-drop
// operation.
//
// The most recent action received is always the valid one. The chosen
// action may change alongside negotiation (e.g. an "ask" action can turn
// into a "move" operation), so the effects of the final action must
// always be applied in wl_data_offer.dnd_finished.
//
// Clients can trigger cursor surface changes from this point, so
// they reflect the current action.
type WlDataSourceActionEvent struct {
	// DndAction contains action selected by the compositor
	DndAction uint32
}

// Opcode returns the event opcode for wl_data_source.action in wayland
func (WlDataSourceActionEvent) Opcode() uint16 { return 5 }

// Ensure WlDataSourceActionEvent implements Message.
var _ Message = WlDataSourceActionEvent{}

// Scan scans the event from the socket.
func (e *WlDataSourceActionEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.DndAction = v
	}
	return nil
}

// Ensure WlDataSourceActionEvent implements Event.
var _ Event = &WlDataSourceActionEvent{}

// #endregion Interface wayland.wl_data_source

// ----------------------------------------------------------------------------
// #region Interface wayland.wl_data_device

type WlDataDeviceError int

const (
	// WlDataDeviceErrorRole corresponds to given wl_surface has another role
	WlDataDeviceErrorRole WlDataDeviceError = 0
)

// WlDataDeviceStartDragRequest requests to start drag-and-drop operation
//
// This request asks the compositor to start a drag-and-drop
// operation on behalf of the client.
//
// The source argument is the data source that provides the data
// for the eventual data transfer. If source is NULL, enter, leave
// and motion events are sent only to the client that initiated the
// drag and the client is expected to handle the data passing
// internally. If source is destroyed, the drag-and-drop session will be
// cancelled.
//
// The origin surface is the surface where the drag originates and
// the client must have an active implicit grab that matches the
// serial.
//
// The icon surface is an optional (can be NULL) surface that
// provides an icon to be moved around with the cursor.  Initially,
// the top-left corner of the icon surface is placed at the cursor
// hotspot, but subsequent wl_surface.attach request can move the
// relative position. Attach requests must be confirmed with
// wl_surface.commit as usual. The icon surface is given the role of
// a drag-and-drop icon. If the icon surface already has another role,
// it raises a protocol error.
//
// The current and pending input regions of the icon wl_surface are
// cleared, and wl_surface.set_input_region is ignored until the
// wl_surface is no longer used as the icon surface. When the use
// as an icon ends, the current and pending input regions become
// undefined, and the wl_surface is unmapped.
type WlDataDeviceStartDragRequest struct {
	// Source contains data source for the eventual transfer
	Source ObjectID

	// Origin contains surface where the drag originates
	Origin ObjectID

	// Icon contains drag-and-drop icon surface
	Icon ObjectID

	// Serial contains serial number of the implicit grab on the origin
	Serial uint32
}

// Opcode returns the request opcode for wl_data_device.start_drag in wayland
func (WlDataDeviceStartDragRequest) Opcode() uint16 { return 0 }

// Ensure WlDataDeviceStartDragRequest implements Message.
var _ Message = WlDataDeviceStartDragRequest{}

// WlDataDeviceSetSelectionRequest requests to copy data to the selection
//
// This request asks the compositor to set the selection
// to the data from the source on behalf of the client.
//
// To unset the selection, set the source to NULL.
type WlDataDeviceSetSelectionRequest struct {
	// Source contains data source for the selection
	Source ObjectID

	// Serial contains serial number of the event that triggered this request
	Serial uint32
}

// Opcode returns the request opcode for wl_data_device.set_selection in wayland
func (WlDataDeviceSetSelectionRequest) Opcode() uint16 { return 1 }

// Ensure WlDataDeviceSetSelectionRequest implements Message.
var _ Message = WlDataDeviceSetSelectionRequest{}

// WlDataDeviceReleaseRequest requests to destroy data device
//
// This request destroys the data device.
type WlDataDeviceReleaseRequest struct {
}

// Opcode returns the request opcode for wl_data_device.release in wayland
func (WlDataDeviceReleaseRequest) Opcode() uint16 { return 2 }

// Ensure WlDataDeviceReleaseRequest implements Message.
var _ Message = WlDataDeviceReleaseRequest{}

// WlDataDeviceDataOfferEvent signals when introduce a new wl_data_offer
//
// The data_offer event introduces a new wl_data_offer object,
// which will subsequently be used in either the
// data_device.enter event (for drag-and-drop) or the
// data_device.selection event (for selections).  Immediately
// following the data_device_data_offer event, the new data_offer
// object will send out data_offer.offer events to describe the
// mime types it offers.
type WlDataDeviceDataOfferEvent struct {
	// ID contains the new data_offer object
	ID ObjectID
}

// Opcode returns the event opcode for wl_data_device.data_offer in wayland
func (WlDataDeviceDataOfferEvent) Opcode() uint16 { return 0 }

// Ensure WlDataDeviceDataOfferEvent implements Message.
var _ Message = WlDataDeviceDataOfferEvent{}

// Scan scans the event from the socket.
func (e *WlDataDeviceDataOfferEvent) Scan(s *EventScanner) error {
	if v, err := s.ObjectID(); err != nil {
		return err
	} else {
		e.ID = v
	}
	return nil
}

// Ensure WlDataDeviceDataOfferEvent implements Event.
var _ Event = &WlDataDeviceDataOfferEvent{}

// WlDataDeviceEnterEvent signals when initiate drag-and-drop session
//
// This event is sent when an active drag-and-drop pointer enters
// a surface owned by the client.  The position of the pointer at
// enter time is provided by the x and y arguments, in surface-local
// coordinates.
type WlDataDeviceEnterEvent struct {
	// Serial contains serial number of the enter event
	Serial uint32

	// Surface contains client surface entered
	Surface ObjectID

	// X contains surface-local x coordinate
	X Fixed

	// Y contains surface-local y coordinate
	Y Fixed

	// ID contains source data_offer object
	ID ObjectID
}

// Opcode returns the event opcode for wl_data_device.enter in wayland
func (WlDataDeviceEnterEvent) Opcode() uint16 { return 1 }

// Ensure WlDataDeviceEnterEvent implements Message.
var _ Message = WlDataDeviceEnterEvent{}

// Scan scans the event from the socket.
func (e *WlDataDeviceEnterEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Serial = v
	}
	if v, err := s.ObjectID(); err != nil {
		return err
	} else {
		e.Surface = v
	}
	if v, err := s.Fixed(); err != nil {
		return err
	} else {
		e.X = v
	}
	if v, err := s.Fixed(); err != nil {
		return err
	} else {
		e.Y = v
	}
	if v, err := s.ObjectID(); err != nil {
		return err
	} else {
		e.ID = v
	}
	return nil
}

// Ensure WlDataDeviceEnterEvent implements Event.
var _ Event = &WlDataDeviceEnterEvent{}

// WlDataDeviceLeaveEvent signals when end drag-and-drop session
//
// This event is sent when the drag-and-drop pointer leaves the
// surface and the session ends.  The client must destroy the
// wl_data_offer introduced at enter time at this point.
type WlDataDeviceLeaveEvent struct {
}

// Opcode returns the event opcode for wl_data_device.leave in wayland
func (WlDataDeviceLeaveEvent) Opcode() uint16 { return 2 }

// Ensure WlDataDeviceLeaveEvent implements Message.
var _ Message = WlDataDeviceLeaveEvent{}

// Scan scans the event from the socket.
func (e *WlDataDeviceLeaveEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure WlDataDeviceLeaveEvent implements Event.
var _ Event = &WlDataDeviceLeaveEvent{}

// WlDataDeviceMotionEvent signals when drag-and-drop session motion
//
// This event is sent when the drag-and-drop pointer moves within
// the currently focused surface. The new position of the pointer
// is provided by the x and y arguments, in surface-local
// coordinates.
type WlDataDeviceMotionEvent struct {
	// Time contains timestamp with millisecond granularity
	Time uint32

	// X contains surface-local x coordinate
	X Fixed

	// Y contains surface-local y coordinate
	Y Fixed
}

// Opcode returns the event opcode for wl_data_device.motion in wayland
func (WlDataDeviceMotionEvent) Opcode() uint16 { return 3 }

// Ensure WlDataDeviceMotionEvent implements Message.
var _ Message = WlDataDeviceMotionEvent{}

// Scan scans the event from the socket.
func (e *WlDataDeviceMotionEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Time = v
	}
	if v, err := s.Fixed(); err != nil {
		return err
	} else {
		e.X = v
	}
	if v, err := s.Fixed(); err != nil {
		return err
	} else {
		e.Y = v
	}
	return nil
}

// Ensure WlDataDeviceMotionEvent implements Event.
var _ Event = &WlDataDeviceMotionEvent{}

// WlDataDeviceDropEvent signals when end drag-and-drop session successfully
//
// The event is sent when a drag-and-drop operation is ended
// because the implicit grab is removed.
//
// The drag-and-drop destination is expected to honor the last action
// received through wl_data_offer.action, if the resulting action is
// "copy" or "move", the destination can still perform
// wl_data_offer.receive requests, and is expected to end all
// transfers with a wl_data_offer.finish request.
//
// If the resulting action is "ask", the action will not be considered
// final. The drag-and-drop destination is expected to perform one last
// wl_data_offer.set_actions request, or wl_data_offer.destroy in order
// to cancel the operation.
type WlDataDeviceDropEvent struct {
}

// Opcode returns the event opcode for wl_data_device.drop in wayland
func (WlDataDeviceDropEvent) Opcode() uint16 { return 4 }

// Ensure WlDataDeviceDropEvent implements Message.
var _ Message = WlDataDeviceDropEvent{}

// Scan scans the event from the socket.
func (e *WlDataDeviceDropEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure WlDataDeviceDropEvent implements Event.
var _ Event = &WlDataDeviceDropEvent{}

// WlDataDeviceSelectionEvent signals when advertise new selection
//
// The selection event is sent out to notify the client of a new
// wl_data_offer for the selection for this device.  The
// data_device.data_offer and the data_offer.offer events are
// sent out immediately before this event to introduce the data
// offer object.  The selection event is sent to a client
// immediately before receiving keyboard focus and when a new
// selection is set while the client has keyboard focus.  The
// data_offer is valid until a new data_offer or NULL is received
// or until the client loses keyboard focus.  The client must
// destroy the previous selection data_offer, if any, upon receiving
// this event.
type WlDataDeviceSelectionEvent struct {
	// ID contains selection data_offer object
	ID ObjectID
}

// Opcode returns the event opcode for wl_data_device.selection in wayland
func (WlDataDeviceSelectionEvent) Opcode() uint16 { return 5 }

// Ensure WlDataDeviceSelectionEvent implements Message.
var _ Message = WlDataDeviceSelectionEvent{}

// Scan scans the event from the socket.
func (e *WlDataDeviceSelectionEvent) Scan(s *EventScanner) error {
	if v, err := s.ObjectID(); err != nil {
		return err
	} else {
		e.ID = v
	}
	return nil
}

// Ensure WlDataDeviceSelectionEvent implements Event.
var _ Event = &WlDataDeviceSelectionEvent{}

// #endregion Interface wayland.wl_data_device

// ----------------------------------------------------------------------------
// #region Interface wayland.wl_data_device_manager

// WlDataDeviceManagerDndAction represents drag and drop actions
//
// This is a bitmask of the available/preferred actions in a
// drag-and-drop operation.
//
// In the compositor, the selected action is a result of matching the
// actions offered by the source and destination sides.  "action" events
// with a "none" action will be sent to both source and destination if
// there is no match. All further checks will effectively happen on
// (source actions  destination actions).
//
// In addition, compositors may also pick different actions in
// reaction to key modifiers being pressed. One common design that
// is used in major toolkits (and the behavior recommended for
// compositors) is:
//
// - If no modifiers are pressed, the first match (in bit order)
// will be used.
// - Pressing Shift selects "move", if enabled in the mask.
// - Pressing Control selects "copy", if enabled in the mask.
//
// Behavior beyond that is considered implementation-dependent.
// Compositors may for example bind other modifiers (like Alt/Meta)
// or drags initiated with other buttons than BTN_LEFT to specific
// actions (e.g. "ask").
type WlDataDeviceManagerDndAction uint

const (
	// WlDataDeviceManagerDndActionNone corresponds to no action
	WlDataDeviceManagerDndActionNone WlDataDeviceManagerDndAction = 0

	// WlDataDeviceManagerDndActionCopy corresponds to copy action
	WlDataDeviceManagerDndActionCopy WlDataDeviceManagerDndAction = 1

	// WlDataDeviceManagerDndActionMove corresponds to move action
	WlDataDeviceManagerDndActionMove WlDataDeviceManagerDndAction = 2

	// WlDataDeviceManagerDndActionAsk corresponds to ask action
	WlDataDeviceManagerDndActionAsk WlDataDeviceManagerDndAction = 4
)

// WlDataDeviceManagerCreateDataSourceRequest requests to create a new data source
//
// Create a new data source.
type WlDataDeviceManagerCreateDataSourceRequest struct {
	// ID contains data source to create
	ID ObjectID
}

// Opcode returns the request opcode for wl_data_device_manager.create_data_source in wayland
func (WlDataDeviceManagerCreateDataSourceRequest) Opcode() uint16 { return 0 }

// Ensure WlDataDeviceManagerCreateDataSourceRequest implements Message.
var _ Message = WlDataDeviceManagerCreateDataSourceRequest{}

// WlDataDeviceManagerGetDataDeviceRequest requests to create a new data device
//
// Create a new data device for a given seat.
type WlDataDeviceManagerGetDataDeviceRequest struct {
	// ID contains data device to create
	ID ObjectID

	// Seat contains seat associated with the data device
	Seat ObjectID
}

// Opcode returns the request opcode for wl_data_device_manager.get_data_device in wayland
func (WlDataDeviceManagerGetDataDeviceRequest) Opcode() uint16 { return 1 }

// Ensure WlDataDeviceManagerGetDataDeviceRequest implements Message.
var _ Message = WlDataDeviceManagerGetDataDeviceRequest{}

// #endregion Interface wayland.wl_data_device_manager

// ----------------------------------------------------------------------------
// #region Interface wayland.wl_shell

type WlShellError int

const (
	// WlShellErrorRole corresponds to given wl_surface has another role
	WlShellErrorRole WlShellError = 0
)

// WlShellGetShellSurfaceRequest requests to create a shell surface from a surface
//
// Create a shell surface for an existing surface. This gives
// the wl_surface the role of a shell surface. If the wl_surface
// already has another role, it raises a protocol error.
//
// Only one shell surface can be associated with a given surface.
type WlShellGetShellSurfaceRequest struct {
	// ID contains shell surface to create
	ID ObjectID

	// Surface contains surface to be given the shell surface role
	Surface ObjectID
}

// Opcode returns the request opcode for wl_shell.get_shell_surface in wayland
func (WlShellGetShellSurfaceRequest) Opcode() uint16 { return 0 }

// Ensure WlShellGetShellSurfaceRequest implements Message.
var _ Message = WlShellGetShellSurfaceRequest{}

// #endregion Interface wayland.wl_shell

// ----------------------------------------------------------------------------
// #region Interface wayland.wl_shell_surface

// WlShellSurfaceResize represents edge values for resizing
//
// These values are used to indicate which edge of a surface
// is being dragged in a resize operation. The server may
// use this information to adapt its behavior, e.g. choose
// an appropriate cursor image.
type WlShellSurfaceResize uint

const (
	// WlShellSurfaceResizeNone corresponds to no edge
	WlShellSurfaceResizeNone WlShellSurfaceResize = 0

	// WlShellSurfaceResizeTop corresponds to top edge
	WlShellSurfaceResizeTop WlShellSurfaceResize = 1

	// WlShellSurfaceResizeBottom corresponds to bottom edge
	WlShellSurfaceResizeBottom WlShellSurfaceResize = 2

	// WlShellSurfaceResizeLeft corresponds to left edge
	WlShellSurfaceResizeLeft WlShellSurfaceResize = 4

	// WlShellSurfaceResizeTopLeft corresponds to top and left edges
	WlShellSurfaceResizeTopLeft WlShellSurfaceResize = 5

	// WlShellSurfaceResizeBottomLeft corresponds to bottom and left edges
	WlShellSurfaceResizeBottomLeft WlShellSurfaceResize = 6

	// WlShellSurfaceResizeRight corresponds to right edge
	WlShellSurfaceResizeRight WlShellSurfaceResize = 8

	// WlShellSurfaceResizeTopRight corresponds to top and right edges
	WlShellSurfaceResizeTopRight WlShellSurfaceResize = 9

	// WlShellSurfaceResizeBottomRight corresponds to bottom and right edges
	WlShellSurfaceResizeBottomRight WlShellSurfaceResize = 10
)

// WlShellSurfaceTransient represents details of transient behaviour
//
// These flags specify details of the expected behaviour
// of transient surfaces. Used in the set_transient request.
type WlShellSurfaceTransient uint

const (
	// WlShellSurfaceTransientInactive corresponds to do not set keyboard focus
	WlShellSurfaceTransientInactive WlShellSurfaceTransient = 0x1
)

// WlShellSurfaceFullscreenMethod represents different method to set the surface fullscreen
//
// Hints to indicate to the compositor how to deal with a conflict
// between the dimensions of the surface and the dimensions of the
// output. The compositor is free to ignore this parameter.
type WlShellSurfaceFullscreenMethod int

const (
	// WlShellSurfaceFullscreenMethodDefault corresponds to no preference, apply default policy
	WlShellSurfaceFullscreenMethodDefault WlShellSurfaceFullscreenMethod = 0

	// WlShellSurfaceFullscreenMethodScale corresponds to scale, preserve the surface's aspect ratio and center on output
	WlShellSurfaceFullscreenMethodScale WlShellSurfaceFullscreenMethod = 1

	// WlShellSurfaceFullscreenMethodDriver corresponds to switch output mode to the smallest mode that can fit the surface, add black borders to compensate size mismatch
	WlShellSurfaceFullscreenMethodDriver WlShellSurfaceFullscreenMethod = 2

	// WlShellSurfaceFullscreenMethodFill corresponds to no upscaling, center on output and add black borders to compensate size mismatch
	WlShellSurfaceFullscreenMethodFill WlShellSurfaceFullscreenMethod = 3
)

// WlShellSurfacePongRequest requests to respond to a ping event
//
// A client must respond to a ping event with a pong request or
// the client may be deemed unresponsive.
type WlShellSurfacePongRequest struct {
	// Serial contains serial number of the ping event
	Serial uint32
}

// Opcode returns the request opcode for wl_shell_surface.pong in wayland
func (WlShellSurfacePongRequest) Opcode() uint16 { return 0 }

// Ensure WlShellSurfacePongRequest implements Message.
var _ Message = WlShellSurfacePongRequest{}

// WlShellSurfaceMoveRequest requests to start an interactive move
//
// Start a pointer-driven move of the surface.
//
// This request must be used in response to a button press event.
// The server may ignore move requests depending on the state of
// the surface (e.g. fullscreen or maximized).
type WlShellSurfaceMoveRequest struct {
	// Seat contains seat whose pointer is used
	Seat ObjectID

	// Serial contains serial number of the implicit grab on the pointer
	Serial uint32
}

// Opcode returns the request opcode for wl_shell_surface.move in wayland
func (WlShellSurfaceMoveRequest) Opcode() uint16 { return 1 }

// Ensure WlShellSurfaceMoveRequest implements Message.
var _ Message = WlShellSurfaceMoveRequest{}

// WlShellSurfaceResizeRequest requests to start an interactive resize
//
// Start a pointer-driven resizing of the surface.
//
// This request must be used in response to a button press event.
// The server may ignore resize requests depending on the state of
// the surface (e.g. fullscreen or maximized).
type WlShellSurfaceResizeRequest struct {
	// Seat contains seat whose pointer is used
	Seat ObjectID

	// Serial contains serial number of the implicit grab on the pointer
	Serial uint32

	// Edges contains which edge or corner is being dragged
	Edges uint32
}

// Opcode returns the request opcode for wl_shell_surface.resize in wayland
func (WlShellSurfaceResizeRequest) Opcode() uint16 { return 2 }

// Ensure WlShellSurfaceResizeRequest implements Message.
var _ Message = WlShellSurfaceResizeRequest{}

// WlShellSurfaceSetToplevelRequest requests to make the surface a toplevel surface
//
// Map the surface as a toplevel surface.
//
// A toplevel surface is not fullscreen, maximized or transient.
type WlShellSurfaceSetToplevelRequest struct {
}

// Opcode returns the request opcode for wl_shell_surface.set_toplevel in wayland
func (WlShellSurfaceSetToplevelRequest) Opcode() uint16 { return 3 }

// Ensure WlShellSurfaceSetToplevelRequest implements Message.
var _ Message = WlShellSurfaceSetToplevelRequest{}

// WlShellSurfaceSetTransientRequest requests to make the surface a transient surface
//
// Map the surface relative to an existing surface.
//
// The x and y arguments specify the location of the upper left
// corner of the surface relative to the upper left corner of the
// parent surface, in surface-local coordinates.
//
// The flags argument controls details of the transient behaviour.
type WlShellSurfaceSetTransientRequest struct {
	// Parent contains parent surface
	Parent ObjectID

	// X contains surface-local x coordinate
	X int32

	// Y contains surface-local y coordinate
	Y int32

	// Flags contains transient surface behavior
	Flags uint32
}

// Opcode returns the request opcode for wl_shell_surface.set_transient in wayland
func (WlShellSurfaceSetTransientRequest) Opcode() uint16 { return 4 }

// Ensure WlShellSurfaceSetTransientRequest implements Message.
var _ Message = WlShellSurfaceSetTransientRequest{}

// WlShellSurfaceSetFullscreenRequest requests to make the surface a fullscreen surface
//
// Map the surface as a fullscreen surface.
//
// If an output parameter is given then the surface will be made
// fullscreen on that output. If the client does not specify the
// output then the compositor will apply its policy - usually
// choosing the output on which the surface has the biggest surface
// area.
//
// The client may specify a method to resolve a size conflict
// between the output size and the surface size - this is provided
// through the method parameter.
//
// The framerate parameter is used only when the method is set
// to "driver", to indicate the preferred framerate. A value of 0
// indicates that the client does not care about framerate.  The
// framerate is specified in mHz, that is framerate of 60000 is 60Hz.
//
// A method of "scale" or "driver" implies a scaling operation of
// the surface, either via a direct scaling operation or a change of
// the output mode. This will override any kind of output scaling, so
// that mapping a surface with a buffer size equal to the mode can
// fill the screen independent of buffer_scale.
//
// A method of "fill" means we don't scale up the buffer, however
// any output scale is applied. This means that you may run into
// an edge case where the application maps a buffer with the same
// size of the output mode but buffer_scale 1 (thus making a
// surface larger than the output). In this case it is allowed to
// downscale the results to fit the screen.
//
// The compositor must reply to this request with a configure event
// with the dimensions for the output on which the surface will
// be made fullscreen.
type WlShellSurfaceSetFullscreenRequest struct {
	// Method contains method for resolving size conflict
	Method uint32

	// Framerate contains framerate in mHz
	Framerate uint32

	// Output contains output on which the surface is to be fullscreen
	Output ObjectID
}

// Opcode returns the request opcode for wl_shell_surface.set_fullscreen in wayland
func (WlShellSurfaceSetFullscreenRequest) Opcode() uint16 { return 5 }

// Ensure WlShellSurfaceSetFullscreenRequest implements Message.
var _ Message = WlShellSurfaceSetFullscreenRequest{}

// WlShellSurfaceSetPopupRequest requests to make the surface a popup surface
//
// Map the surface as a popup.
//
// A popup surface is a transient surface with an added pointer
// grab.
//
// An existing implicit grab will be changed to owner-events mode,
// and the popup grab will continue after the implicit grab ends
// (i.e. releasing the mouse button does not cause the popup to
// be unmapped).
//
// The popup grab continues until the window is destroyed or a
// mouse button is pressed in any other client's window. A click
// in any of the client's surfaces is reported as normal, however,
// clicks in other clients' surfaces will be discarded and trigger
// the callback.
//
// The x and y arguments specify the location of the upper left
// corner of the surface relative to the upper left corner of the
// parent surface, in surface-local coordinates.
type WlShellSurfaceSetPopupRequest struct {
	// Seat contains seat whose pointer is used
	Seat ObjectID

	// Serial contains serial number of the implicit grab on the pointer
	Serial uint32

	// Parent contains parent surface
	Parent ObjectID

	// X contains surface-local x coordinate
	X int32

	// Y contains surface-local y coordinate
	Y int32

	// Flags contains transient surface behavior
	Flags uint32
}

// Opcode returns the request opcode for wl_shell_surface.set_popup in wayland
func (WlShellSurfaceSetPopupRequest) Opcode() uint16 { return 6 }

// Ensure WlShellSurfaceSetPopupRequest implements Message.
var _ Message = WlShellSurfaceSetPopupRequest{}

// WlShellSurfaceSetMaximizedRequest requests to make the surface a maximized surface
//
// Map the surface as a maximized surface.
//
// If an output parameter is given then the surface will be
// maximized on that output. If the client does not specify the
// output then the compositor will apply its policy - usually
// choosing the output on which the surface has the biggest surface
// area.
//
// The compositor will reply with a configure event telling
// the expected new surface size. The operation is completed
// on the next buffer attach to this surface.
//
// A maximized surface typically fills the entire output it is
// bound to, except for desktop elements such as panels. This is
// the main difference between a maximized shell surface and a
// fullscreen shell surface.
//
// The details depend on the compositor implementation.
type WlShellSurfaceSetMaximizedRequest struct {
	// Output contains output on which the surface is to be maximized
	Output ObjectID
}

// Opcode returns the request opcode for wl_shell_surface.set_maximized in wayland
func (WlShellSurfaceSetMaximizedRequest) Opcode() uint16 { return 7 }

// Ensure WlShellSurfaceSetMaximizedRequest implements Message.
var _ Message = WlShellSurfaceSetMaximizedRequest{}

// WlShellSurfaceSetTitleRequest requests to set surface title
//
// Set a short title for the surface.
//
// This string may be used to identify the surface in a task bar,
// window list, or other user interface elements provided by the
// compositor.
//
// The string must be encoded in UTF-8.
type WlShellSurfaceSetTitleRequest struct {
	// Title contains surface title
	Title string
}

// Opcode returns the request opcode for wl_shell_surface.set_title in wayland
func (WlShellSurfaceSetTitleRequest) Opcode() uint16 { return 8 }

// Ensure WlShellSurfaceSetTitleRequest implements Message.
var _ Message = WlShellSurfaceSetTitleRequest{}

// WlShellSurfaceSetClassRequest requests to set surface class
//
// Set a class for the surface.
//
// The surface class identifies the general class of applications
// to which the surface belongs. A common convention is to use the
// file name (or the full path if it is a non-standard location) of
// the application's .desktop file as the class.
type WlShellSurfaceSetClassRequest struct {
	// Class contains surface class
	Class string
}

// Opcode returns the request opcode for wl_shell_surface.set_class in wayland
func (WlShellSurfaceSetClassRequest) Opcode() uint16 { return 9 }

// Ensure WlShellSurfaceSetClassRequest implements Message.
var _ Message = WlShellSurfaceSetClassRequest{}

// WlShellSurfacePingEvent signals when ping client
//
// Ping a client to check if it is receiving events and sending
// requests. A client is expected to reply with a pong request.
type WlShellSurfacePingEvent struct {
	// Serial contains serial number of the ping
	Serial uint32
}

// Opcode returns the event opcode for wl_shell_surface.ping in wayland
func (WlShellSurfacePingEvent) Opcode() uint16 { return 0 }

// Ensure WlShellSurfacePingEvent implements Message.
var _ Message = WlShellSurfacePingEvent{}

// Scan scans the event from the socket.
func (e *WlShellSurfacePingEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Serial = v
	}
	return nil
}

// Ensure WlShellSurfacePingEvent implements Event.
var _ Event = &WlShellSurfacePingEvent{}

// WlShellSurfaceConfigureEvent signals when suggest resize
//
// The configure event asks the client to resize its surface.
//
// The size is a hint, in the sense that the client is free to
// ignore it if it doesn't resize, pick a smaller size (to
// satisfy aspect ratio or resize in steps of NxM pixels).
//
// The edges parameter provides a hint about how the surface
// was resized. The client may use this information to decide
// how to adjust its content to the new size (e.g. a scrolling
// area might adjust its content position to leave the viewable
// content unmoved).
//
// The client is free to dismiss all but the last configure
// event it received.
//
// The width and height arguments specify the size of the window
// in surface-local coordinates.
type WlShellSurfaceConfigureEvent struct {
	// Edges contains how the surface was resized
	Edges uint32

	// Width contains new width of the surface
	Width int32

	// Height contains new height of the surface
	Height int32
}

// Opcode returns the event opcode for wl_shell_surface.configure in wayland
func (WlShellSurfaceConfigureEvent) Opcode() uint16 { return 1 }

// Ensure WlShellSurfaceConfigureEvent implements Message.
var _ Message = WlShellSurfaceConfigureEvent{}

// Scan scans the event from the socket.
func (e *WlShellSurfaceConfigureEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Edges = v
	}
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.Width = v
	}
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.Height = v
	}
	return nil
}

// Ensure WlShellSurfaceConfigureEvent implements Event.
var _ Event = &WlShellSurfaceConfigureEvent{}

// WlShellSurfacePopupDoneEvent signals when popup interaction is done
//
// The popup_done event is sent out when a popup grab is broken,
// that is, when the user clicks a surface that doesn't belong
// to the client owning the popup surface.
type WlShellSurfacePopupDoneEvent struct {
}

// Opcode returns the event opcode for wl_shell_surface.popup_done in wayland
func (WlShellSurfacePopupDoneEvent) Opcode() uint16 { return 2 }

// Ensure WlShellSurfacePopupDoneEvent implements Message.
var _ Message = WlShellSurfacePopupDoneEvent{}

// Scan scans the event from the socket.
func (e *WlShellSurfacePopupDoneEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure WlShellSurfacePopupDoneEvent implements Event.
var _ Event = &WlShellSurfacePopupDoneEvent{}

// #endregion Interface wayland.wl_shell_surface

// ----------------------------------------------------------------------------
// #region Interface wayland.wl_surface

// WlSurfaceError represents wl_surface error values
//
// These errors can be emitted in response to wl_surface requests.
type WlSurfaceError int

const (
	// WlSurfaceErrorInvalidScale corresponds to buffer scale value is invalid
	WlSurfaceErrorInvalidScale WlSurfaceError = 0

	// WlSurfaceErrorInvalidTransform corresponds to buffer transform value is invalid
	WlSurfaceErrorInvalidTransform WlSurfaceError = 1

	// WlSurfaceErrorInvalidSize corresponds to buffer size is invalid
	WlSurfaceErrorInvalidSize WlSurfaceError = 2
)

// WlSurfaceDestroyRequest requests to delete surface
//
// Deletes the surface and invalidates its object ID.
type WlSurfaceDestroyRequest struct {
}

// Opcode returns the request opcode for wl_surface.destroy in wayland
func (WlSurfaceDestroyRequest) Opcode() uint16 { return 0 }

// Ensure WlSurfaceDestroyRequest implements Message.
var _ Message = WlSurfaceDestroyRequest{}

// WlSurfaceAttachRequest requests to set the surface contents
//
// Set a buffer as the content of this surface.
//
// The new size of the surface is calculated based on the buffer
// size transformed by the inverse buffer_transform and the
// inverse buffer_scale. This means that at commit time the supplied
// buffer size must be an integer multiple of the buffer_scale. If
// that's not the case, an invalid_size error is sent.
//
// The x and y arguments specify the location of the new pending
// buffer's upper left corner, relative to the current buffer's upper
// left corner, in surface-local coordinates. In other words, the
// x and y, combined with the new surface size define in which
// directions the surface's size changes.
//
// Surface contents are double-buffered state, see wl_surface.commit.
//
// The initial surface contents are void; there is no content.
// wl_surface.attach assigns the given wl_buffer as the pending
// wl_buffer. wl_surface.commit makes the pending wl_buffer the new
// surface contents, and the size of the surface becomes the size
// calculated from the wl_buffer, as described above. After commit,
// there is no pending buffer until the next attach.
//
// Committing a pending wl_buffer allows the compositor to read the
// pixels in the wl_buffer. The compositor may access the pixels at
// any time after the wl_surface.commit request. When the compositor
// will not access the pixels anymore, it will send the
// wl_buffer.release event. Only after receiving wl_buffer.release,
// the client may reuse the wl_buffer. A wl_buffer that has been
// attached and then replaced by another attach instead of committed
// will not receive a release event, and is not used by the
// compositor.
//
// If a pending wl_buffer has been committed to more than one wl_surface,
// the delivery of wl_buffer.release events becomes undefined. A well
// behaved client should not rely on wl_buffer.release events in this
// case. Alternatively, a client could create multiple wl_buffer objects
// from the same backing storage or use wp_linux_buffer_release.
//
// Destroying the wl_buffer after wl_buffer.release does not change
// the surface contents. Destroying the wl_buffer before wl_buffer.release
// is allowed as long as the underlying buffer storage isn't re-used (this
// can happen e.g. on client process termination). However, if the client
// destroys the wl_buffer before receiving the wl_buffer.release event and
// mutates the underlying buffer storage, the surface contents become
// undefined immediately.
//
// If wl_surface.attach is sent with a NULL wl_buffer, the
// following wl_surface.commit will remove the surface content.
type WlSurfaceAttachRequest struct {
	// Buffer contains buffer of surface contents
	Buffer ObjectID

	// X contains surface-local x coordinate
	X int32

	// Y contains surface-local y coordinate
	Y int32
}

// Opcode returns the request opcode for wl_surface.attach in wayland
func (WlSurfaceAttachRequest) Opcode() uint16 { return 1 }

// Ensure WlSurfaceAttachRequest implements Message.
var _ Message = WlSurfaceAttachRequest{}

// WlSurfaceDamageRequest requests to mark part of the surface damaged
//
// This request is used to describe the regions where the pending
// buffer is different from the current surface contents, and where
// the surface therefore needs to be repainted. The compositor
// ignores the parts of the damage that fall outside of the surface.
//
// Damage is double-buffered state, see wl_surface.commit.
//
// The damage rectangle is specified in surface-local coordinates,
// where x and y specify the upper left corner of the damage rectangle.
//
// The initial value for pending damage is empty: no damage.
// wl_surface.damage adds pending damage: the new pending damage
// is the union of old pending damage and the given rectangle.
//
// wl_surface.commit assigns pending damage as the current damage,
// and clears pending damage. The server will clear the current
// damage as it repaints the surface.
//
// Note! New clients should not use this request. Instead damage can be
// posted with wl_surface.damage_buffer which uses buffer coordinates
// instead of surface coordinates.
type WlSurfaceDamageRequest struct {
	// X contains surface-local x coordinate
	X int32

	// Y contains surface-local y coordinate
	Y int32

	// Width contains width of damage rectangle
	Width int32

	// Height contains height of damage rectangle
	Height int32
}

// Opcode returns the request opcode for wl_surface.damage in wayland
func (WlSurfaceDamageRequest) Opcode() uint16 { return 2 }

// Ensure WlSurfaceDamageRequest implements Message.
var _ Message = WlSurfaceDamageRequest{}

// WlSurfaceFrameRequest requests to request a frame throttling hint
//
// Request a notification when it is a good time to start drawing a new
// frame, by creating a frame callback. This is useful for throttling
// redrawing operations, and driving animations.
//
// When a client is animating on a wl_surface, it can use the 'frame'
// request to get notified when it is a good time to draw and commit the
// next frame of animation. If the client commits an update earlier than
// that, it is likely that some updates will not make it to the display,
// and the client is wasting resources by drawing too often.
//
// The frame request will take effect on the next wl_surface.commit.
// The notification will only be posted for one frame unless
// requested again. For a wl_surface, the notifications are posted in
// the order the frame requests were committed.
//
// The server must send the notifications so that a client
// will not send excessive updates, while still allowing
// the highest possible update rate for clients that wait for the reply
// before drawing again. The server should give some time for the client
// to draw and commit after sending the frame callback events to let it
// hit the next output refresh.
//
// A server should avoid signaling the frame callbacks if the
// surface is not visible in any way, e.g. the surface is off-screen,
// or completely obscured by other opaque surfaces.
//
// The object returned by this request will be destroyed by the
// compositor after the callback is fired and as such the client must not
// attempt to use it after that point.
//
// The callback_data passed in the callback is the current time, in
// milliseconds, with an undefined base.
type WlSurfaceFrameRequest struct {
	// Callback contains callback object for the frame request
	Callback ObjectID
}

// Opcode returns the request opcode for wl_surface.frame in wayland
func (WlSurfaceFrameRequest) Opcode() uint16 { return 3 }

// Ensure WlSurfaceFrameRequest implements Message.
var _ Message = WlSurfaceFrameRequest{}

// WlSurfaceSetOpaqueRegionRequest requests to set opaque region
//
// This request sets the region of the surface that contains
// opaque content.
//
// The opaque region is an optimization hint for the compositor
// that lets it optimize the redrawing of content behind opaque
// regions.  Setting an opaque region is not required for correct
// behaviour, but marking transparent content as opaque will result
// in repaint artifacts.
//
// The opaque region is specified in surface-local coordinates.
//
// The compositor ignores the parts of the opaque region that fall
// outside of the surface.
//
// Opaque region is double-buffered state, see wl_surface.commit.
//
// wl_surface.set_opaque_region changes the pending opaque region.
// wl_surface.commit copies the pending region to the current region.
// Otherwise, the pending and current regions are never changed.
//
// The initial value for an opaque region is empty. Setting the pending
// opaque region has copy semantics, and the wl_region object can be
// destroyed immediately. A NULL wl_region causes the pending opaque
// region to be set to empty.
type WlSurfaceSetOpaqueRegionRequest struct {
	// Region contains opaque region of the surface
	Region ObjectID
}

// Opcode returns the request opcode for wl_surface.set_opaque_region in wayland
func (WlSurfaceSetOpaqueRegionRequest) Opcode() uint16 { return 4 }

// Ensure WlSurfaceSetOpaqueRegionRequest implements Message.
var _ Message = WlSurfaceSetOpaqueRegionRequest{}

// WlSurfaceSetInputRegionRequest requests to set input region
//
// This request sets the region of the surface that can receive
// pointer and touch events.
//
// Input events happening outside of this region will try the next
// surface in the server surface stack. The compositor ignores the
// parts of the input region that fall outside of the surface.
//
// The input region is specified in surface-local coordinates.
//
// Input region is double-buffered state, see wl_surface.commit.
//
// wl_surface.set_input_region changes the pending input region.
// wl_surface.commit copies the pending region to the current region.
// Otherwise the pending and current regions are never changed,
// except cursor and icon surfaces are special cases, see
// wl_pointer.set_cursor and wl_data_device.start_drag.
//
// The initial value for an input region is infinite. That means the
// whole surface will accept input. Setting the pending input region
// has copy semantics, and the wl_region object can be destroyed
// immediately. A NULL wl_region causes the input region to be set
// to infinite.
type WlSurfaceSetInputRegionRequest struct {
	// Region contains input region of the surface
	Region ObjectID
}

// Opcode returns the request opcode for wl_surface.set_input_region in wayland
func (WlSurfaceSetInputRegionRequest) Opcode() uint16 { return 5 }

// Ensure WlSurfaceSetInputRegionRequest implements Message.
var _ Message = WlSurfaceSetInputRegionRequest{}

// WlSurfaceCommitRequest requests to commit pending surface state
//
// Surface state (input, opaque, and damage regions, attached buffers,
// etc.) is double-buffered. Protocol requests modify the pending state,
// as opposed to the current state in use by the compositor. A commit
// request atomically applies all pending state, replacing the current
// state. After commit, the new pending state is as documented for each
// related request.
//
// On commit, a pending wl_buffer is applied first, and all other state
// second. This means that all coordinates in double-buffered state are
// relative to the new wl_buffer coming into use, except for
// wl_surface.attach itself. If there is no pending wl_buffer, the
// coordinates are relative to the current surface contents.
//
// All requests that need a commit to become effective are documented
// to affect double-buffered state.
//
// Other interfaces may add further double-buffered surface state.
type WlSurfaceCommitRequest struct {
}

// Opcode returns the request opcode for wl_surface.commit in wayland
func (WlSurfaceCommitRequest) Opcode() uint16 { return 6 }

// Ensure WlSurfaceCommitRequest implements Message.
var _ Message = WlSurfaceCommitRequest{}

// WlSurfaceSetBufferTransformRequest requests to sets the buffer transformation
//
// This request sets an optional transformation on how the compositor
// interprets the contents of the buffer attached to the surface. The
// accepted values for the transform parameter are the values for
// wl_output.transform.
//
// Buffer transform is double-buffered state, see wl_surface.commit.
//
// A newly created surface has its buffer transformation set to normal.
//
// wl_surface.set_buffer_transform changes the pending buffer
// transformation. wl_surface.commit copies the pending buffer
// transformation to the current one. Otherwise, the pending and current
// values are never changed.
//
// The purpose of this request is to allow clients to render content
// according to the output transform, thus permitting the compositor to
// use certain optimizations even if the display is rotated. Using
// hardware overlays and scanning out a client buffer for fullscreen
// surfaces are examples of such optimizations. Those optimizations are
// highly dependent on the compositor implementation, so the use of this
// request should be considered on a case-by-case basis.
//
// Note that if the transform value includes 90 or 270 degree rotation,
// the width of the buffer will become the surface height and the height
// of the buffer will become the surface width.
//
// If transform is not one of the values from the
// wl_output.transform enum the invalid_transform protocol error
// is raised.
type WlSurfaceSetBufferTransformRequest struct {
	// Transform contains transform for interpreting buffer contents
	Transform int32
}

// Opcode returns the request opcode for wl_surface.set_buffer_transform in wayland
func (WlSurfaceSetBufferTransformRequest) Opcode() uint16 { return 7 }

// Ensure WlSurfaceSetBufferTransformRequest implements Message.
var _ Message = WlSurfaceSetBufferTransformRequest{}

// WlSurfaceSetBufferScaleRequest requests to sets the buffer scaling factor
//
// This request sets an optional scaling factor on how the compositor
// interprets the contents of the buffer attached to the window.
//
// Buffer scale is double-buffered state, see wl_surface.commit.
//
// A newly created surface has its buffer scale set to 1.
//
// wl_surface.set_buffer_scale changes the pending buffer scale.
// wl_surface.commit copies the pending buffer scale to the current one.
// Otherwise, the pending and current values are never changed.
//
// The purpose of this request is to allow clients to supply higher
// resolution buffer data for use on high resolution outputs. It is
// intended that you pick the same buffer scale as the scale of the
// output that the surface is displayed on. This means the compositor
// can avoid scaling when rendering the surface on that output.
//
// Note that if the scale is larger than 1, then you have to attach
// a buffer that is larger (by a factor of scale in each dimension)
// than the desired surface size.
//
// If scale is not positive the invalid_scale protocol error is
// raised.
type WlSurfaceSetBufferScaleRequest struct {
	// Scale contains positive scale for interpreting buffer contents
	Scale int32
}

// Opcode returns the request opcode for wl_surface.set_buffer_scale in wayland
func (WlSurfaceSetBufferScaleRequest) Opcode() uint16 { return 8 }

// Ensure WlSurfaceSetBufferScaleRequest implements Message.
var _ Message = WlSurfaceSetBufferScaleRequest{}

// WlSurfaceDamageBufferRequest requests to mark part of the surface damaged using buffer coordinates
//
// This request is used to describe the regions where the pending
// buffer is different from the current surface contents, and where
// the surface therefore needs to be repainted. The compositor
// ignores the parts of the damage that fall outside of the surface.
//
// Damage is double-buffered state, see wl_surface.commit.
//
// The damage rectangle is specified in buffer coordinates,
// where x and y specify the upper left corner of the damage rectangle.
//
// The initial value for pending damage is empty: no damage.
// wl_surface.damage_buffer adds pending damage: the new pending
// damage is the union of old pending damage and the given rectangle.
//
// wl_surface.commit assigns pending damage as the current damage,
// and clears pending damage. The server will clear the current
// damage as it repaints the surface.
//
// This request differs from wl_surface.damage in only one way - it
// takes damage in buffer coordinates instead of surface-local
// coordinates. While this generally is more intuitive than surface
// coordinates, it is especially desirable when using wp_viewport
// or when a drawing library (like EGL) is unaware of buffer scale
// and buffer transform.
//
// Note: Because buffer transformation changes and damage requests may
// be interleaved in the protocol stream, it is impossible to determine
// the actual mapping between surface and buffer damage until
// wl_surface.commit time. Therefore, compositors wishing to take both
// kinds of damage into account will have to accumulate damage from the
// two requests separately and only transform from one to the other
// after receiving the wl_surface.commit.
type WlSurfaceDamageBufferRequest struct {
	// X contains buffer-local x coordinate
	X int32

	// Y contains buffer-local y coordinate
	Y int32

	// Width contains width of damage rectangle
	Width int32

	// Height contains height of damage rectangle
	Height int32
}

// Opcode returns the request opcode for wl_surface.damage_buffer in wayland
func (WlSurfaceDamageBufferRequest) Opcode() uint16 { return 9 }

// Ensure WlSurfaceDamageBufferRequest implements Message.
var _ Message = WlSurfaceDamageBufferRequest{}

// WlSurfaceEnterEvent signals when surface enters an output
//
// This is emitted whenever a surface's creation, movement, or resizing
// results in some part of it being within the scanout region of an
// output.
//
// Note that a surface may be overlapping with zero or more outputs.
type WlSurfaceEnterEvent struct {
	// Output contains output entered by the surface
	Output ObjectID
}

// Opcode returns the event opcode for wl_surface.enter in wayland
func (WlSurfaceEnterEvent) Opcode() uint16 { return 0 }

// Ensure WlSurfaceEnterEvent implements Message.
var _ Message = WlSurfaceEnterEvent{}

// Scan scans the event from the socket.
func (e *WlSurfaceEnterEvent) Scan(s *EventScanner) error {
	if v, err := s.ObjectID(); err != nil {
		return err
	} else {
		e.Output = v
	}
	return nil
}

// Ensure WlSurfaceEnterEvent implements Event.
var _ Event = &WlSurfaceEnterEvent{}

// WlSurfaceLeaveEvent signals when surface leaves an output
//
// This is emitted whenever a surface's creation, movement, or resizing
// results in it no longer having any part of it within the scanout region
// of an output.
//
// Clients should not use the number of outputs the surface is on for frame
// throttling purposes. The surface might be hidden even if no leave event
// has been sent, and the compositor might expect new surface content
// updates even if no enter event has been sent. The frame event should be
// used instead.
type WlSurfaceLeaveEvent struct {
	// Output contains output left by the surface
	Output ObjectID
}

// Opcode returns the event opcode for wl_surface.leave in wayland
func (WlSurfaceLeaveEvent) Opcode() uint16 { return 1 }

// Ensure WlSurfaceLeaveEvent implements Message.
var _ Message = WlSurfaceLeaveEvent{}

// Scan scans the event from the socket.
func (e *WlSurfaceLeaveEvent) Scan(s *EventScanner) error {
	if v, err := s.ObjectID(); err != nil {
		return err
	} else {
		e.Output = v
	}
	return nil
}

// Ensure WlSurfaceLeaveEvent implements Event.
var _ Event = &WlSurfaceLeaveEvent{}

// #endregion Interface wayland.wl_surface

// ----------------------------------------------------------------------------
// #region Interface wayland.wl_seat

// WlSeatCapability represents seat capability bitmask
//
// This is a bitmask of capabilities this seat has; if a member is
// set, then it is present on the seat.
type WlSeatCapability uint

const (
	// WlSeatCapabilityPointer corresponds to the seat has pointer devices
	WlSeatCapabilityPointer WlSeatCapability = 1

	// WlSeatCapabilityKeyboard corresponds to the seat has one or more keyboards
	WlSeatCapabilityKeyboard WlSeatCapability = 2

	// WlSeatCapabilityTouch corresponds to the seat has touch devices
	WlSeatCapabilityTouch WlSeatCapability = 4
)

// WlSeatError represents wl_seat error values
//
// These errors can be emitted in response to wl_seat requests.
type WlSeatError int

const (
	// WlSeatErrorMissingCapability corresponds to get_pointer, get_keyboard or get_touch called on seat without the matching capability
	WlSeatErrorMissingCapability WlSeatError = 0
)

// WlSeatGetPointerRequest requests to return pointer object
//
// The ID provided will be initialized to the wl_pointer interface
// for this seat.
//
// This request only takes effect if the seat has the pointer
// capability, or has had the pointer capability in the past.
// It is a protocol violation to issue this request on a seat that has
// never had the pointer capability. The missing_capability error will
// be sent in this case.
type WlSeatGetPointerRequest struct {
	// ID contains seat pointer
	ID ObjectID
}

// Opcode returns the request opcode for wl_seat.get_pointer in wayland
func (WlSeatGetPointerRequest) Opcode() uint16 { return 0 }

// Ensure WlSeatGetPointerRequest implements Message.
var _ Message = WlSeatGetPointerRequest{}

// WlSeatGetKeyboardRequest requests to return keyboard object
//
// The ID provided will be initialized to the wl_keyboard interface
// for this seat.
//
// This request only takes effect if the seat has the keyboard
// capability, or has had the keyboard capability in the past.
// It is a protocol violation to issue this request on a seat that has
// never had the keyboard capability. The missing_capability error will
// be sent in this case.
type WlSeatGetKeyboardRequest struct {
	// ID contains seat keyboard
	ID ObjectID
}

// Opcode returns the request opcode for wl_seat.get_keyboard in wayland
func (WlSeatGetKeyboardRequest) Opcode() uint16 { return 1 }

// Ensure WlSeatGetKeyboardRequest implements Message.
var _ Message = WlSeatGetKeyboardRequest{}

// WlSeatGetTouchRequest requests to return touch object
//
// The ID provided will be initialized to the wl_touch interface
// for this seat.
//
// This request only takes effect if the seat has the touch
// capability, or has had the touch capability in the past.
// It is a protocol violation to issue this request on a seat that has
// never had the touch capability. The missing_capability error will
// be sent in this case.
type WlSeatGetTouchRequest struct {
	// ID contains seat touch interface
	ID ObjectID
}

// Opcode returns the request opcode for wl_seat.get_touch in wayland
func (WlSeatGetTouchRequest) Opcode() uint16 { return 2 }

// Ensure WlSeatGetTouchRequest implements Message.
var _ Message = WlSeatGetTouchRequest{}

// WlSeatReleaseRequest requests to release the seat object
//
// Using this request a client can tell the server that it is not going to
// use the seat object anymore.
type WlSeatReleaseRequest struct {
}

// Opcode returns the request opcode for wl_seat.release in wayland
func (WlSeatReleaseRequest) Opcode() uint16 { return 3 }

// Ensure WlSeatReleaseRequest implements Message.
var _ Message = WlSeatReleaseRequest{}

// WlSeatCapabilitiesEvent signals when seat capabilities changed
//
// This is emitted whenever a seat gains or loses the pointer,
// keyboard or touch capabilities.  The argument is a capability
// enum containing the complete set of capabilities this seat has.
//
// When the pointer capability is added, a client may create a
// wl_pointer object using the wl_seat.get_pointer request. This object
// will receive pointer events until the capability is removed in the
// future.
//
// When the pointer capability is removed, a client should destroy the
// wl_pointer objects associated with the seat where the capability was
// removed, using the wl_pointer.release request. No further pointer
// events will be received on these objects.
//
// In some compositors, if a seat regains the pointer capability and a
// client has a previously obtained wl_pointer object of version 4 or
// less, that object may start sending pointer events again. This
// behavior is considered a misinterpretation of the intended behavior
// and must not be relied upon by the client. wl_pointer objects of
// version 5 or later must not send events if created before the most
// recent event notifying the client of an added pointer capability.
//
// The above behavior also applies to wl_keyboard and wl_touch with the
// keyboard and touch capabilities, respectively.
type WlSeatCapabilitiesEvent struct {
	// Capabilities contains capabilities of the seat
	Capabilities uint32
}

// Opcode returns the event opcode for wl_seat.capabilities in wayland
func (WlSeatCapabilitiesEvent) Opcode() uint16 { return 0 }

// Ensure WlSeatCapabilitiesEvent implements Message.
var _ Message = WlSeatCapabilitiesEvent{}

// Scan scans the event from the socket.
func (e *WlSeatCapabilitiesEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Capabilities = v
	}
	return nil
}

// Ensure WlSeatCapabilitiesEvent implements Event.
var _ Event = &WlSeatCapabilitiesEvent{}

// WlSeatNameEvent signals when unique identifier for this seat
//
// In a multi-seat configuration the seat name can be used by clients to
// help identify which physical devices the seat represents.
//
// The seat name is a UTF-8 string with no convention defined for its
// contents. Each name is unique among all wl_seat globals. The name is
// only guaranteed to be unique for the current compositor instance.
//
// The same seat names are used for all clients. Thus, the name can be
// shared across processes to refer to a specific wl_seat global.
//
// The name event is sent after binding to the seat global. This event is
// only sent once per seat object, and the name does not change over the
// lifetime of the wl_seat global.
//
// Compositors may re-use the same seat name if the wl_seat global is
// destroyed and re-created later.
type WlSeatNameEvent struct {
	// Name contains seat identifier
	Name string
}

// Opcode returns the event opcode for wl_seat.name in wayland
func (WlSeatNameEvent) Opcode() uint16 { return 1 }

// Ensure WlSeatNameEvent implements Message.
var _ Message = WlSeatNameEvent{}

// Scan scans the event from the socket.
func (e *WlSeatNameEvent) Scan(s *EventScanner) error {
	if v, err := s.String(); err != nil {
		return err
	} else {
		e.Name = v
	}
	return nil
}

// Ensure WlSeatNameEvent implements Event.
var _ Event = &WlSeatNameEvent{}

// #endregion Interface wayland.wl_seat

// ----------------------------------------------------------------------------
// #region Interface wayland.wl_pointer

type WlPointerError int

const (
	// WlPointerErrorRole corresponds to given wl_surface has another role
	WlPointerErrorRole WlPointerError = 0
)

// WlPointerButtonState represents physical button state
//
// Describes the physical state of a button that produced the button
// event.
type WlPointerButtonState int

const (
	// WlPointerButtonStateReleased corresponds to the button is not pressed
	WlPointerButtonStateReleased WlPointerButtonState = 0

	// WlPointerButtonStatePressed corresponds to the button is pressed
	WlPointerButtonStatePressed WlPointerButtonState = 1
)

// WlPointerAxis represents axis types
//
// Describes the axis types of scroll events.
type WlPointerAxis int

const (
	// WlPointerAxisVerticalScroll corresponds to vertical axis
	WlPointerAxisVerticalScroll WlPointerAxis = 0

	// WlPointerAxisHorizontalScroll corresponds to horizontal axis
	WlPointerAxisHorizontalScroll WlPointerAxis = 1
)

// WlPointerAxisSource represents axis source types
//
// Describes the source types for axis events. This indicates to the
// client how an axis event was physically generated; a client may
// adjust the user interface accordingly. For example, scroll events
// from a "finger" source may be in a smooth coordinate space with
// kinetic scrolling whereas a "wheel" source may be in discrete steps
// of a number of lines.
//
// The "continuous" axis source is a device generating events in a
// continuous coordinate space, but using something other than a
// finger. One example for this source is button-based scrolling where
// the vertical motion of a device is converted to scroll events while
// a button is held down.
//
// The "wheel tilt" axis source indicates that the actual device is a
// wheel but the scroll event is not caused by a rotation but a
// (usually sideways) tilt of the wheel.
type WlPointerAxisSource int

const (
	// WlPointerAxisSourceWheel corresponds to a physical wheel rotation
	WlPointerAxisSourceWheel WlPointerAxisSource = 0

	// WlPointerAxisSourceFinger corresponds to finger on a touch surface
	WlPointerAxisSourceFinger WlPointerAxisSource = 1

	// WlPointerAxisSourceContinuous corresponds to continuous coordinate space
	WlPointerAxisSourceContinuous WlPointerAxisSource = 2

	// WlPointerAxisSourceWheelTilt corresponds to a physical wheel tilt
	WlPointerAxisSourceWheelTilt WlPointerAxisSource = 3
)

// WlPointerSetCursorRequest requests to set the pointer surface
//
// Set the pointer surface, i.e., the surface that contains the
// pointer image (cursor). This request gives the surface the role
// of a cursor. If the surface already has another role, it raises
// a protocol error.
//
// The cursor actually changes only if the pointer
// focus for this device is one of the requesting client's surfaces
// or the surface parameter is the current pointer surface. If
// there was a previous surface set with this request it is
// replaced. If surface is NULL, the pointer image is hidden.
//
// The parameters hotspot_x and hotspot_y define the position of
// the pointer surface relative to the pointer location. Its
// top-left corner is always at (x, y) - (hotspot_x, hotspot_y),
// where (x, y) are the coordinates of the pointer location, in
// surface-local coordinates.
//
// On surface.attach requests to the pointer surface, hotspot_x
// and hotspot_y are decremented by the x and y parameters
// passed to the request. Attach must be confirmed by
// wl_surface.commit as usual.
//
// The hotspot can also be updated by passing the currently set
// pointer surface to this request with new values for hotspot_x
// and hotspot_y.
//
// The current and pending input regions of the wl_surface are
// cleared, and wl_surface.set_input_region is ignored until the
// wl_surface is no longer used as the cursor. When the use as a
// cursor ends, the current and pending input regions become
// undefined, and the wl_surface is unmapped.
//
// The serial parameter must match the latest wl_pointer.enter
// serial number sent to the client. Otherwise the request will be
// ignored.
type WlPointerSetCursorRequest struct {
	// Serial contains serial number of the enter event
	Serial uint32

	// Surface contains pointer surface
	Surface ObjectID

	// HotspotX contains surface-local x coordinate
	HotspotX int32

	// HotspotY contains surface-local y coordinate
	HotspotY int32
}

// Opcode returns the request opcode for wl_pointer.set_cursor in wayland
func (WlPointerSetCursorRequest) Opcode() uint16 { return 0 }

// Ensure WlPointerSetCursorRequest implements Message.
var _ Message = WlPointerSetCursorRequest{}

// WlPointerReleaseRequest requests to release the pointer object
//
// Using this request a client can tell the server that it is not going to
// use the pointer object anymore.
//
// This request destroys the pointer proxy object, so clients must not call
// wl_pointer_destroy() after using this request.
type WlPointerReleaseRequest struct {
}

// Opcode returns the request opcode for wl_pointer.release in wayland
func (WlPointerReleaseRequest) Opcode() uint16 { return 1 }

// Ensure WlPointerReleaseRequest implements Message.
var _ Message = WlPointerReleaseRequest{}

// WlPointerEnterEvent signals when enter event
//
// Notification that this seat's pointer is focused on a certain
// surface.
//
// When a seat's focus enters a surface, the pointer image
// is undefined and a client should respond to this event by setting
// an appropriate pointer image with the set_cursor request.
type WlPointerEnterEvent struct {
	// Serial contains serial number of the enter event
	Serial uint32

	// Surface contains surface entered by the pointer
	Surface ObjectID

	// SurfaceX contains surface-local x coordinate
	SurfaceX Fixed

	// SurfaceY contains surface-local y coordinate
	SurfaceY Fixed
}

// Opcode returns the event opcode for wl_pointer.enter in wayland
func (WlPointerEnterEvent) Opcode() uint16 { return 0 }

// Ensure WlPointerEnterEvent implements Message.
var _ Message = WlPointerEnterEvent{}

// Scan scans the event from the socket.
func (e *WlPointerEnterEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Serial = v
	}
	if v, err := s.ObjectID(); err != nil {
		return err
	} else {
		e.Surface = v
	}
	if v, err := s.Fixed(); err != nil {
		return err
	} else {
		e.SurfaceX = v
	}
	if v, err := s.Fixed(); err != nil {
		return err
	} else {
		e.SurfaceY = v
	}
	return nil
}

// Ensure WlPointerEnterEvent implements Event.
var _ Event = &WlPointerEnterEvent{}

// WlPointerLeaveEvent signals when leave event
//
// Notification that this seat's pointer is no longer focused on
// a certain surface.
//
// The leave notification is sent before the enter notification
// for the new focus.
type WlPointerLeaveEvent struct {
	// Serial contains serial number of the leave event
	Serial uint32

	// Surface contains surface left by the pointer
	Surface ObjectID
}

// Opcode returns the event opcode for wl_pointer.leave in wayland
func (WlPointerLeaveEvent) Opcode() uint16 { return 1 }

// Ensure WlPointerLeaveEvent implements Message.
var _ Message = WlPointerLeaveEvent{}

// Scan scans the event from the socket.
func (e *WlPointerLeaveEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Serial = v
	}
	if v, err := s.ObjectID(); err != nil {
		return err
	} else {
		e.Surface = v
	}
	return nil
}

// Ensure WlPointerLeaveEvent implements Event.
var _ Event = &WlPointerLeaveEvent{}

// WlPointerMotionEvent signals when pointer motion event
//
// Notification of pointer location change. The arguments
// surface_x and surface_y are the location relative to the
// focused surface.
type WlPointerMotionEvent struct {
	// Time contains timestamp with millisecond granularity
	Time uint32

	// SurfaceX contains surface-local x coordinate
	SurfaceX Fixed

	// SurfaceY contains surface-local y coordinate
	SurfaceY Fixed
}

// Opcode returns the event opcode for wl_pointer.motion in wayland
func (WlPointerMotionEvent) Opcode() uint16 { return 2 }

// Ensure WlPointerMotionEvent implements Message.
var _ Message = WlPointerMotionEvent{}

// Scan scans the event from the socket.
func (e *WlPointerMotionEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Time = v
	}
	if v, err := s.Fixed(); err != nil {
		return err
	} else {
		e.SurfaceX = v
	}
	if v, err := s.Fixed(); err != nil {
		return err
	} else {
		e.SurfaceY = v
	}
	return nil
}

// Ensure WlPointerMotionEvent implements Event.
var _ Event = &WlPointerMotionEvent{}

// WlPointerButtonEvent signals when pointer button event
//
// Mouse button click and release notifications.
//
// The location of the click is given by the last motion or
// enter event.
// The time argument is a timestamp with millisecond
// granularity, with an undefined base.
//
// The button is a button code as defined in the Linux kernel's
// linux/input-event-codes.h header file, e.g. BTN_LEFT.
//
// Any 16-bit button code value is reserved for future additions to the
// kernel's event code list. All other button codes above 0xFFFF are
// currently undefined but may be used in future versions of this
// protocol.
type WlPointerButtonEvent struct {
	// Serial contains serial number of the button event
	Serial uint32

	// Time contains timestamp with millisecond granularity
	Time uint32

	// Button contains button that produced the event
	Button uint32

	// State contains physical state of the button
	State uint32
}

// Opcode returns the event opcode for wl_pointer.button in wayland
func (WlPointerButtonEvent) Opcode() uint16 { return 3 }

// Ensure WlPointerButtonEvent implements Message.
var _ Message = WlPointerButtonEvent{}

// Scan scans the event from the socket.
func (e *WlPointerButtonEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Serial = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Time = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Button = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.State = v
	}
	return nil
}

// Ensure WlPointerButtonEvent implements Event.
var _ Event = &WlPointerButtonEvent{}

// WlPointerAxisEvent signals when axis event
//
// Scroll and other axis notifications.
//
// For scroll events (vertical and horizontal scroll axes), the
// value parameter is the length of a vector along the specified
// axis in a coordinate space identical to those of motion events,
// representing a relative movement along the specified axis.
//
// For devices that support movements non-parallel to axes multiple
// axis events will be emitted.
//
// When applicable, for example for touch pads, the server can
// choose to emit scroll events where the motion vector is
// equivalent to a motion event vector.
//
// When applicable, a client can transform its content relative to the
// scroll distance.
type WlPointerAxisEvent struct {
	// Time contains timestamp with millisecond granularity
	Time uint32

	// Axis contains axis type
	Axis uint32

	// Value contains length of vector in surface-local coordinate space
	Value Fixed
}

// Opcode returns the event opcode for wl_pointer.axis in wayland
func (WlPointerAxisEvent) Opcode() uint16 { return 4 }

// Ensure WlPointerAxisEvent implements Message.
var _ Message = WlPointerAxisEvent{}

// Scan scans the event from the socket.
func (e *WlPointerAxisEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Time = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Axis = v
	}
	if v, err := s.Fixed(); err != nil {
		return err
	} else {
		e.Value = v
	}
	return nil
}

// Ensure WlPointerAxisEvent implements Event.
var _ Event = &WlPointerAxisEvent{}

// WlPointerFrameEvent signals when end of a pointer event sequence
//
// Indicates the end of a set of events that logically belong together.
// A client is expected to accumulate the data in all events within the
// frame before proceeding.
//
// All wl_pointer events before a wl_pointer.frame event belong
// logically together. For example, in a diagonal scroll motion the
// compositor will send an optional wl_pointer.axis_source event, two
// wl_pointer.axis events (horizontal and vertical) and finally a
// wl_pointer.frame event. The client may use this information to
// calculate a diagonal vector for scrolling.
//
// When multiple wl_pointer.axis events occur within the same frame,
// the motion vector is the combined motion of all events.
// When a wl_pointer.axis and a wl_pointer.axis_stop event occur within
// the same frame, this indicates that axis movement in one axis has
// stopped but continues in the other axis.
// When multiple wl_pointer.axis_stop events occur within the same
// frame, this indicates that these axes stopped in the same instance.
//
// A wl_pointer.frame event is sent for every logical event group,
// even if the group only contains a single wl_pointer event.
// Specifically, a client may get a sequence: motion, frame, button,
// frame, axis, frame, axis_stop, frame.
//
// The wl_pointer.enter and wl_pointer.leave events are logical events
// generated by the compositor and not the hardware. These events are
// also grouped by a wl_pointer.frame. When a pointer moves from one
// surface to another, a compositor should group the
// wl_pointer.leave event within the same wl_pointer.frame.
// However, a client must not rely on wl_pointer.leave and
// wl_pointer.enter being in the same wl_pointer.frame.
// Compositor-specific policies may require the wl_pointer.leave and
// wl_pointer.enter event being split across multiple wl_pointer.frame
// groups.
type WlPointerFrameEvent struct {
}

// Opcode returns the event opcode for wl_pointer.frame in wayland
func (WlPointerFrameEvent) Opcode() uint16 { return 5 }

// Ensure WlPointerFrameEvent implements Message.
var _ Message = WlPointerFrameEvent{}

// Scan scans the event from the socket.
func (e *WlPointerFrameEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure WlPointerFrameEvent implements Event.
var _ Event = &WlPointerFrameEvent{}

// WlPointerAxisSourceEvent signals when axis source event
//
// Source information for scroll and other axes.
//
// This event does not occur on its own. It is sent before a
// wl_pointer.frame event and carries the source information for
// all events within that frame.
//
// The source specifies how this event was generated. If the source is
// wl_pointer.axis_source.finger, a wl_pointer.axis_stop event will be
// sent when the user lifts the finger off the device.
//
// If the source is wl_pointer.axis_source.wheel,
// wl_pointer.axis_source.wheel_tilt or
// wl_pointer.axis_source.continuous, a wl_pointer.axis_stop event may
// or may not be sent. Whether a compositor sends an axis_stop event
// for these sources is hardware-specific and implementation-dependent;
// clients must not rely on receiving an axis_stop event for these
// scroll sources and should treat scroll sequences from these scroll
// sources as unterminated by default.
//
// This event is optional. If the source is unknown for a particular
// axis event sequence, no event is sent.
// Only one wl_pointer.axis_source event is permitted per frame.
//
// The order of wl_pointer.axis_discrete and wl_pointer.axis_source is
// not guaranteed.
type WlPointerAxisSourceEvent struct {
	// AxisSource contains source of the axis event
	AxisSource uint32
}

// Opcode returns the event opcode for wl_pointer.axis_source in wayland
func (WlPointerAxisSourceEvent) Opcode() uint16 { return 6 }

// Ensure WlPointerAxisSourceEvent implements Message.
var _ Message = WlPointerAxisSourceEvent{}

// Scan scans the event from the socket.
func (e *WlPointerAxisSourceEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.AxisSource = v
	}
	return nil
}

// Ensure WlPointerAxisSourceEvent implements Event.
var _ Event = &WlPointerAxisSourceEvent{}

// WlPointerAxisStopEvent signals when axis stop event
//
// Stop notification for scroll and other axes.
//
// For some wl_pointer.axis_source types, a wl_pointer.axis_stop event
// is sent to notify a client that the axis sequence has terminated.
// This enables the client to implement kinetic scrolling.
// See the wl_pointer.axis_source documentation for information on when
// this event may be generated.
//
// Any wl_pointer.axis events with the same axis_source after this
// event should be considered as the start of a new axis motion.
//
// The timestamp is to be interpreted identical to the timestamp in the
// wl_pointer.axis event. The timestamp value may be the same as a
// preceding wl_pointer.axis event.
type WlPointerAxisStopEvent struct {
	// Time contains timestamp with millisecond granularity
	Time uint32

	// Axis contains the axis stopped with this event
	Axis uint32
}

// Opcode returns the event opcode for wl_pointer.axis_stop in wayland
func (WlPointerAxisStopEvent) Opcode() uint16 { return 7 }

// Ensure WlPointerAxisStopEvent implements Message.
var _ Message = WlPointerAxisStopEvent{}

// Scan scans the event from the socket.
func (e *WlPointerAxisStopEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Time = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Axis = v
	}
	return nil
}

// Ensure WlPointerAxisStopEvent implements Event.
var _ Event = &WlPointerAxisStopEvent{}

// WlPointerAxisDiscreteEvent signals when axis click event
//
// Discrete step information for scroll and other axes.
//
// This event carries the axis value of the wl_pointer.axis event in
// discrete steps (e.g. mouse wheel clicks).
//
// This event does not occur on its own, it is coupled with a
// wl_pointer.axis event that represents this axis value on a
// continuous scale. The protocol guarantees that each axis_discrete
// event is always followed by exactly one axis event with the same
// axis number within the same wl_pointer.frame. Note that the protocol
// allows for other events to occur between the axis_discrete and
// its coupled axis event, including other axis_discrete or axis
// events.
//
// This event is optional; continuous scrolling devices
// like two-finger scrolling on touchpads do not have discrete
// steps and do not generate this event.
//
// The discrete value carries the directional information. e.g. a value
// of -2 is two steps towards the negative direction of this axis.
//
// The axis number is identical to the axis number in the associated
// axis event.
//
// The order of wl_pointer.axis_discrete and wl_pointer.axis_source is
// not guaranteed.
type WlPointerAxisDiscreteEvent struct {
	// Axis contains axis type
	Axis uint32

	// Discrete contains number of steps
	Discrete int32
}

// Opcode returns the event opcode for wl_pointer.axis_discrete in wayland
func (WlPointerAxisDiscreteEvent) Opcode() uint16 { return 8 }

// Ensure WlPointerAxisDiscreteEvent implements Message.
var _ Message = WlPointerAxisDiscreteEvent{}

// Scan scans the event from the socket.
func (e *WlPointerAxisDiscreteEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Axis = v
	}
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.Discrete = v
	}
	return nil
}

// Ensure WlPointerAxisDiscreteEvent implements Event.
var _ Event = &WlPointerAxisDiscreteEvent{}

// #endregion Interface wayland.wl_pointer

// ----------------------------------------------------------------------------
// #region Interface wayland.wl_keyboard

// WlKeyboardKeymapFormat represents keyboard mapping format
//
// This specifies the format of the keymap provided to the
// client with the wl_keyboard.keymap event.
type WlKeyboardKeymapFormat int

const (
	// WlKeyboardKeymapFormatNoKeymap corresponds to no keymap; client must understand how to interpret the raw keycode
	WlKeyboardKeymapFormatNoKeymap WlKeyboardKeymapFormat = 0

	// WlKeyboardKeymapFormatXkbV1 corresponds to libxkbcommon compatible; to determine the xkb keycode, clients must add 8 to the key event keycode
	WlKeyboardKeymapFormatXkbV1 WlKeyboardKeymapFormat = 1
)

// WlKeyboardKeyState represents physical key state
//
// Describes the physical state of a key that produced the key event.
type WlKeyboardKeyState int

const (
	// WlKeyboardKeyStateReleased corresponds to key is not pressed
	WlKeyboardKeyStateReleased WlKeyboardKeyState = 0

	// WlKeyboardKeyStatePressed corresponds to key is pressed
	WlKeyboardKeyStatePressed WlKeyboardKeyState = 1
)

// WlKeyboardReleaseRequest requests to release the keyboard object
type WlKeyboardReleaseRequest struct {
}

// Opcode returns the request opcode for wl_keyboard.release in wayland
func (WlKeyboardReleaseRequest) Opcode() uint16 { return 0 }

// Ensure WlKeyboardReleaseRequest implements Message.
var _ Message = WlKeyboardReleaseRequest{}

// WlKeyboardKeymapEvent signals when keyboard mapping
//
// This event provides a file descriptor to the client which can be
// memory-mapped in read-only mode to provide a keyboard mapping
// description.
//
// From version 7 onwards, the fd must be mapped with MAP_PRIVATE by
// the recipient, as MAP_SHARED may fail.
type WlKeyboardKeymapEvent struct {
	// Format contains keymap format
	Format uint32

	// FD contains keymap file descriptor
	FD FD

	// Size contains keymap size, in bytes
	Size uint32
}

// Opcode returns the event opcode for wl_keyboard.keymap in wayland
func (WlKeyboardKeymapEvent) Opcode() uint16 { return 0 }

// Ensure WlKeyboardKeymapEvent implements Message.
var _ Message = WlKeyboardKeymapEvent{}

// Scan scans the event from the socket.
func (e *WlKeyboardKeymapEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Format = v
	}
	if v, err := s.FD(); err != nil {
		return err
	} else {
		e.FD = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Size = v
	}
	return nil
}

// Ensure WlKeyboardKeymapEvent implements Event.
var _ Event = &WlKeyboardKeymapEvent{}

// WlKeyboardEnterEvent signals when enter event
//
// Notification that this seat's keyboard focus is on a certain
// surface.
//
// The compositor must send the wl_keyboard.modifiers event after this
// event.
type WlKeyboardEnterEvent struct {
	// Serial contains serial number of the enter event
	Serial uint32

	// Surface contains surface gaining keyboard focus
	Surface ObjectID

	// Keys contains the currently pressed keys
	Keys []byte
}

// Opcode returns the event opcode for wl_keyboard.enter in wayland
func (WlKeyboardEnterEvent) Opcode() uint16 { return 1 }

// Ensure WlKeyboardEnterEvent implements Message.
var _ Message = WlKeyboardEnterEvent{}

// Scan scans the event from the socket.
func (e *WlKeyboardEnterEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Serial = v
	}
	if v, err := s.ObjectID(); err != nil {
		return err
	} else {
		e.Surface = v
	}
	if v, err := s.Array(); err != nil {
		return err
	} else {
		e.Keys = v
	}
	return nil
}

// Ensure WlKeyboardEnterEvent implements Event.
var _ Event = &WlKeyboardEnterEvent{}

// WlKeyboardLeaveEvent signals when leave event
//
// Notification that this seat's keyboard focus is no longer on
// a certain surface.
//
// The leave notification is sent before the enter notification
// for the new focus.
//
// After this event client must assume that all keys, including modifiers,
// are lifted and also it must stop key repeating if there's some going on.
type WlKeyboardLeaveEvent struct {
	// Serial contains serial number of the leave event
	Serial uint32

	// Surface contains surface that lost keyboard focus
	Surface ObjectID
}

// Opcode returns the event opcode for wl_keyboard.leave in wayland
func (WlKeyboardLeaveEvent) Opcode() uint16 { return 2 }

// Ensure WlKeyboardLeaveEvent implements Message.
var _ Message = WlKeyboardLeaveEvent{}

// Scan scans the event from the socket.
func (e *WlKeyboardLeaveEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Serial = v
	}
	if v, err := s.ObjectID(); err != nil {
		return err
	} else {
		e.Surface = v
	}
	return nil
}

// Ensure WlKeyboardLeaveEvent implements Event.
var _ Event = &WlKeyboardLeaveEvent{}

// WlKeyboardKeyEvent signals when key event
//
// A key was pressed or released.
// The time argument is a timestamp with millisecond
// granularity, with an undefined base.
//
// The key is a platform-specific key code that can be interpreted
// by feeding it to the keyboard mapping (see the keymap event).
//
// If this event produces a change in modifiers, then the resulting
// wl_keyboard.modifiers event must be sent after this event.
type WlKeyboardKeyEvent struct {
	// Serial contains serial number of the key event
	Serial uint32

	// Time contains timestamp with millisecond granularity
	Time uint32

	// Key contains key that produced the event
	Key uint32

	// State contains physical state of the key
	State uint32
}

// Opcode returns the event opcode for wl_keyboard.key in wayland
func (WlKeyboardKeyEvent) Opcode() uint16 { return 3 }

// Ensure WlKeyboardKeyEvent implements Message.
var _ Message = WlKeyboardKeyEvent{}

// Scan scans the event from the socket.
func (e *WlKeyboardKeyEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Serial = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Time = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Key = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.State = v
	}
	return nil
}

// Ensure WlKeyboardKeyEvent implements Event.
var _ Event = &WlKeyboardKeyEvent{}

// WlKeyboardModifiersEvent signals when modifier and group state
//
// Notifies clients that the modifier and/or group state has
// changed, and it should update its local state.
type WlKeyboardModifiersEvent struct {
	// Serial contains serial number of the modifiers event
	Serial uint32

	// ModsDepressed contains depressed modifiers
	ModsDepressed uint32

	// ModsLatched contains latched modifiers
	ModsLatched uint32

	// ModsLocked contains locked modifiers
	ModsLocked uint32

	// Group contains keyboard layout
	Group uint32
}

// Opcode returns the event opcode for wl_keyboard.modifiers in wayland
func (WlKeyboardModifiersEvent) Opcode() uint16 { return 4 }

// Ensure WlKeyboardModifiersEvent implements Message.
var _ Message = WlKeyboardModifiersEvent{}

// Scan scans the event from the socket.
func (e *WlKeyboardModifiersEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Serial = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.ModsDepressed = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.ModsLatched = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.ModsLocked = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Group = v
	}
	return nil
}

// Ensure WlKeyboardModifiersEvent implements Event.
var _ Event = &WlKeyboardModifiersEvent{}

// WlKeyboardRepeatInfoEvent signals when repeat rate and delay
//
// Informs the client about the keyboard's repeat rate and delay.
//
// This event is sent as soon as the wl_keyboard object has been created,
// and is guaranteed to be received by the client before any key press
// event.
//
// Negative values for either rate or delay are illegal. A rate of zero
// will disable any repeating (regardless of the value of delay).
//
// This event can be sent later on as well with a new value if necessary,
// so clients should continue listening for the event past the creation
// of wl_keyboard.
type WlKeyboardRepeatInfoEvent struct {
	// Rate contains the rate of repeating keys in characters per second
	Rate int32

	// Delay contains delay in milliseconds since key down until repeating starts
	Delay int32
}

// Opcode returns the event opcode for wl_keyboard.repeat_info in wayland
func (WlKeyboardRepeatInfoEvent) Opcode() uint16 { return 5 }

// Ensure WlKeyboardRepeatInfoEvent implements Message.
var _ Message = WlKeyboardRepeatInfoEvent{}

// Scan scans the event from the socket.
func (e *WlKeyboardRepeatInfoEvent) Scan(s *EventScanner) error {
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.Rate = v
	}
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.Delay = v
	}
	return nil
}

// Ensure WlKeyboardRepeatInfoEvent implements Event.
var _ Event = &WlKeyboardRepeatInfoEvent{}

// #endregion Interface wayland.wl_keyboard

// ----------------------------------------------------------------------------
// #region Interface wayland.wl_touch

// WlTouchReleaseRequest requests to release the touch object
type WlTouchReleaseRequest struct {
}

// Opcode returns the request opcode for wl_touch.release in wayland
func (WlTouchReleaseRequest) Opcode() uint16 { return 0 }

// Ensure WlTouchReleaseRequest implements Message.
var _ Message = WlTouchReleaseRequest{}

// WlTouchDownEvent signals when touch down event and beginning of a touch sequence
//
// A new touch point has appeared on the surface. This touch point is
// assigned a unique ID. Future events from this touch point reference
// this ID. The ID ceases to be valid after a touch up event and may be
// reused in the future.
type WlTouchDownEvent struct {
	// Serial contains serial number of the touch down event
	Serial uint32

	// Time contains timestamp with millisecond granularity
	Time uint32

	// Surface contains surface touched
	Surface ObjectID

	// ID contains the unique ID of this touch point
	ID int32

	// X contains surface-local x coordinate
	X Fixed

	// Y contains surface-local y coordinate
	Y Fixed
}

// Opcode returns the event opcode for wl_touch.down in wayland
func (WlTouchDownEvent) Opcode() uint16 { return 0 }

// Ensure WlTouchDownEvent implements Message.
var _ Message = WlTouchDownEvent{}

// Scan scans the event from the socket.
func (e *WlTouchDownEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Serial = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Time = v
	}
	if v, err := s.ObjectID(); err != nil {
		return err
	} else {
		e.Surface = v
	}
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.ID = v
	}
	if v, err := s.Fixed(); err != nil {
		return err
	} else {
		e.X = v
	}
	if v, err := s.Fixed(); err != nil {
		return err
	} else {
		e.Y = v
	}
	return nil
}

// Ensure WlTouchDownEvent implements Event.
var _ Event = &WlTouchDownEvent{}

// WlTouchUpEvent signals when end of a touch event sequence
//
// The touch point has disappeared. No further events will be sent for
// this touch point and the touch point's ID is released and may be
// reused in a future touch down event.
type WlTouchUpEvent struct {
	// Serial contains serial number of the touch up event
	Serial uint32

	// Time contains timestamp with millisecond granularity
	Time uint32

	// ID contains the unique ID of this touch point
	ID int32
}

// Opcode returns the event opcode for wl_touch.up in wayland
func (WlTouchUpEvent) Opcode() uint16 { return 1 }

// Ensure WlTouchUpEvent implements Message.
var _ Message = WlTouchUpEvent{}

// Scan scans the event from the socket.
func (e *WlTouchUpEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Serial = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Time = v
	}
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.ID = v
	}
	return nil
}

// Ensure WlTouchUpEvent implements Event.
var _ Event = &WlTouchUpEvent{}

// WlTouchMotionEvent signals when update of touch point coordinates
//
// A touch point has changed coordinates.
type WlTouchMotionEvent struct {
	// Time contains timestamp with millisecond granularity
	Time uint32

	// ID contains the unique ID of this touch point
	ID int32

	// X contains surface-local x coordinate
	X Fixed

	// Y contains surface-local y coordinate
	Y Fixed
}

// Opcode returns the event opcode for wl_touch.motion in wayland
func (WlTouchMotionEvent) Opcode() uint16 { return 2 }

// Ensure WlTouchMotionEvent implements Message.
var _ Message = WlTouchMotionEvent{}

// Scan scans the event from the socket.
func (e *WlTouchMotionEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Time = v
	}
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.ID = v
	}
	if v, err := s.Fixed(); err != nil {
		return err
	} else {
		e.X = v
	}
	if v, err := s.Fixed(); err != nil {
		return err
	} else {
		e.Y = v
	}
	return nil
}

// Ensure WlTouchMotionEvent implements Event.
var _ Event = &WlTouchMotionEvent{}

// WlTouchFrameEvent signals when end of touch frame event
//
// Indicates the end of a set of events that logically belong together.
// A client is expected to accumulate the data in all events within the
// frame before proceeding.
//
// A wl_touch.frame terminates at least one event but otherwise no
// guarantee is provided about the set of events within a frame. A client
// must assume that any state not updated in a frame is unchanged from the
// previously known state.
type WlTouchFrameEvent struct {
}

// Opcode returns the event opcode for wl_touch.frame in wayland
func (WlTouchFrameEvent) Opcode() uint16 { return 3 }

// Ensure WlTouchFrameEvent implements Message.
var _ Message = WlTouchFrameEvent{}

// Scan scans the event from the socket.
func (e *WlTouchFrameEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure WlTouchFrameEvent implements Event.
var _ Event = &WlTouchFrameEvent{}

// WlTouchCancelEvent signals when touch session cancelled
//
// Sent if the compositor decides the touch stream is a global
// gesture. No further events are sent to the clients from that
// particular gesture. Touch cancellation applies to all touch points
// currently active on this client's surface. The client is
// responsible for finalizing the touch points, future touch points on
// this surface may reuse the touch point ID.
type WlTouchCancelEvent struct {
}

// Opcode returns the event opcode for wl_touch.cancel in wayland
func (WlTouchCancelEvent) Opcode() uint16 { return 4 }

// Ensure WlTouchCancelEvent implements Message.
var _ Message = WlTouchCancelEvent{}

// Scan scans the event from the socket.
func (e *WlTouchCancelEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure WlTouchCancelEvent implements Event.
var _ Event = &WlTouchCancelEvent{}

// WlTouchShapeEvent signals when update shape of touch point
//
// Sent when a touchpoint has changed its shape.
//
// This event does not occur on its own. It is sent before a
// wl_touch.frame event and carries the new shape information for
// any previously reported, or new touch points of that frame.
//
// Other events describing the touch point such as wl_touch.down,
// wl_touch.motion or wl_touch.orientation may be sent within the
// same wl_touch.frame. A client should treat these events as a single
// logical touch point update. The order of wl_touch.shape,
// wl_touch.orientation and wl_touch.motion is not guaranteed.
// A wl_touch.down event is guaranteed to occur before the first
// wl_touch.shape event for this touch ID but both events may occur within
// the same wl_touch.frame.
//
// A touchpoint shape is approximated by an ellipse through the major and
// minor axis length. The major axis length describes the longer diameter
// of the ellipse, while the minor axis length describes the shorter
// diameter. Major and minor are orthogonal and both are specified in
// surface-local coordinates. The center of the ellipse is always at the
// touchpoint location as reported by wl_touch.down or wl_touch.move.
//
// This event is only sent by the compositor if the touch device supports
// shape reports. The client has to make reasonable assumptions about the
// shape if it did not receive this event.
type WlTouchShapeEvent struct {
	// ID contains the unique ID of this touch point
	ID int32

	// Major contains length of the major axis in surface-local coordinates
	Major Fixed

	// Minor contains length of the minor axis in surface-local coordinates
	Minor Fixed
}

// Opcode returns the event opcode for wl_touch.shape in wayland
func (WlTouchShapeEvent) Opcode() uint16 { return 5 }

// Ensure WlTouchShapeEvent implements Message.
var _ Message = WlTouchShapeEvent{}

// Scan scans the event from the socket.
func (e *WlTouchShapeEvent) Scan(s *EventScanner) error {
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.ID = v
	}
	if v, err := s.Fixed(); err != nil {
		return err
	} else {
		e.Major = v
	}
	if v, err := s.Fixed(); err != nil {
		return err
	} else {
		e.Minor = v
	}
	return nil
}

// Ensure WlTouchShapeEvent implements Event.
var _ Event = &WlTouchShapeEvent{}

// WlTouchOrientationEvent signals when update orientation of touch point
//
// Sent when a touchpoint has changed its orientation.
//
// This event does not occur on its own. It is sent before a
// wl_touch.frame event and carries the new shape information for
// any previously reported, or new touch points of that frame.
//
// Other events describing the touch point such as wl_touch.down,
// wl_touch.motion or wl_touch.shape may be sent within the
// same wl_touch.frame. A client should treat these events as a single
// logical touch point update. The order of wl_touch.shape,
// wl_touch.orientation and wl_touch.motion is not guaranteed.
// A wl_touch.down event is guaranteed to occur before the first
// wl_touch.orientation event for this touch ID but both events may occur
// within the same wl_touch.frame.
//
// The orientation describes the clockwise angle of a touchpoint's major
// axis to the positive surface y-axis and is normalized to the -180 to
// +180 degree range. The granularity of orientation depends on the touch
// device, some devices only support binary rotation values between 0 and
// 90 degrees.
//
// This event is only sent by the compositor if the touch device supports
// orientation reports.
type WlTouchOrientationEvent struct {
	// ID contains the unique ID of this touch point
	ID int32

	// Orientation contains angle between major axis and positive surface y-axis in degrees
	Orientation Fixed
}

// Opcode returns the event opcode for wl_touch.orientation in wayland
func (WlTouchOrientationEvent) Opcode() uint16 { return 6 }

// Ensure WlTouchOrientationEvent implements Message.
var _ Message = WlTouchOrientationEvent{}

// Scan scans the event from the socket.
func (e *WlTouchOrientationEvent) Scan(s *EventScanner) error {
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.ID = v
	}
	if v, err := s.Fixed(); err != nil {
		return err
	} else {
		e.Orientation = v
	}
	return nil
}

// Ensure WlTouchOrientationEvent implements Event.
var _ Event = &WlTouchOrientationEvent{}

// #endregion Interface wayland.wl_touch

// ----------------------------------------------------------------------------
// #region Interface wayland.wl_output

// WlOutputSubpixel represents subpixel geometry information
//
// This enumeration describes how the physical
// pixels on an output are laid out.
type WlOutputSubpixel int

const (
	// WlOutputSubpixelUnknown corresponds to unknown geometry
	WlOutputSubpixelUnknown WlOutputSubpixel = 0

	// WlOutputSubpixelNone corresponds to no geometry
	WlOutputSubpixelNone WlOutputSubpixel = 1

	// WlOutputSubpixelHorizontalRgb corresponds to horizontal RGB
	WlOutputSubpixelHorizontalRgb WlOutputSubpixel = 2

	// WlOutputSubpixelHorizontalBgr corresponds to horizontal BGR
	WlOutputSubpixelHorizontalBgr WlOutputSubpixel = 3

	// WlOutputSubpixelVerticalRgb corresponds to vertical RGB
	WlOutputSubpixelVerticalRgb WlOutputSubpixel = 4

	// WlOutputSubpixelVerticalBgr corresponds to vertical BGR
	WlOutputSubpixelVerticalBgr WlOutputSubpixel = 5
)

// WlOutputTransform represents transform from framebuffer to output
//
// This describes the transform that a compositor will apply to a
// surface to compensate for the rotation or mirroring of an
// output device.
//
// The flipped values correspond to an initial flip around a
// vertical axis followed by rotation.
//
// The purpose is mainly to allow clients to render accordingly and
// tell the compositor, so that for fullscreen surfaces, the
// compositor will still be able to scan out directly from client
// surfaces.
type WlOutputTransform int

const (
	// WlOutputTransformNormal corresponds to no transform
	WlOutputTransformNormal WlOutputTransform = 0

	// WlOutputTransform90 corresponds to 90 degrees counter-clockwise
	WlOutputTransform90 WlOutputTransform = 1

	// WlOutputTransform180 corresponds to 180 degrees counter-clockwise
	WlOutputTransform180 WlOutputTransform = 2

	// WlOutputTransform270 corresponds to 270 degrees counter-clockwise
	WlOutputTransform270 WlOutputTransform = 3

	// WlOutputTransformFlipped corresponds to 180 degree flip around a vertical axis
	WlOutputTransformFlipped WlOutputTransform = 4

	// WlOutputTransformFlipped90 corresponds to flip and rotate 90 degrees counter-clockwise
	WlOutputTransformFlipped90 WlOutputTransform = 5

	// WlOutputTransformFlipped180 corresponds to flip and rotate 180 degrees counter-clockwise
	WlOutputTransformFlipped180 WlOutputTransform = 6

	// WlOutputTransformFlipped270 corresponds to flip and rotate 270 degrees counter-clockwise
	WlOutputTransformFlipped270 WlOutputTransform = 7
)

// WlOutputMode represents mode information
//
// These flags describe properties of an output mode.
// They are used in the flags bitfield of the mode event.
type WlOutputMode uint

const (
	// WlOutputModeCurrent corresponds to indicates this is the current mode
	WlOutputModeCurrent WlOutputMode = 0x1

	// WlOutputModePreferred corresponds to indicates this is the preferred mode
	WlOutputModePreferred WlOutputMode = 0x2
)

// WlOutputReleaseRequest requests to release the output object
//
// Using this request a client can tell the server that it is not going to
// use the output object anymore.
type WlOutputReleaseRequest struct {
}

// Opcode returns the request opcode for wl_output.release in wayland
func (WlOutputReleaseRequest) Opcode() uint16 { return 0 }

// Ensure WlOutputReleaseRequest implements Message.
var _ Message = WlOutputReleaseRequest{}

// WlOutputGeometryEvent signals when properties of the output
//
// The geometry event describes geometric properties of the output.
// The event is sent when binding to the output object and whenever
// any of the properties change.
//
// The physical size can be set to zero if it doesn't make sense for this
// output (e.g. for projectors or virtual outputs).
//
// Note: wl_output only advertises partial information about the output
// position and identification. Some compositors, for instance those not
// implementing a desktop-style output layout or those exposing virtual
// outputs, might fake this information. Instead of using x and y, clients
// should use xdg_output.logical_position. Instead of using make and model,
// clients should use xdg_output.name and xdg_output.description.
type WlOutputGeometryEvent struct {
	// X contains x position within the global compositor space
	X int32

	// Y contains y position within the global compositor space
	Y int32

	// PhysicalWidth contains width in millimeters of the output
	PhysicalWidth int32

	// PhysicalHeight contains height in millimeters of the output
	PhysicalHeight int32

	// Subpixel contains subpixel orientation of the output
	Subpixel int32

	// Make contains textual description of the manufacturer
	Make string

	// Model contains textual description of the model
	Model string

	// Transform contains transform that maps framebuffer to output
	Transform int32
}

// Opcode returns the event opcode for wl_output.geometry in wayland
func (WlOutputGeometryEvent) Opcode() uint16 { return 0 }

// Ensure WlOutputGeometryEvent implements Message.
var _ Message = WlOutputGeometryEvent{}

// Scan scans the event from the socket.
func (e *WlOutputGeometryEvent) Scan(s *EventScanner) error {
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.X = v
	}
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.Y = v
	}
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.PhysicalWidth = v
	}
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.PhysicalHeight = v
	}
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.Subpixel = v
	}
	if v, err := s.String(); err != nil {
		return err
	} else {
		e.Make = v
	}
	if v, err := s.String(); err != nil {
		return err
	} else {
		e.Model = v
	}
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.Transform = v
	}
	return nil
}

// Ensure WlOutputGeometryEvent implements Event.
var _ Event = &WlOutputGeometryEvent{}

// WlOutputModeEvent signals when advertise available modes for the output
//
// The mode event describes an available mode for the output.
//
// The event is sent when binding to the output object and there
// will always be one mode, the current mode.  The event is sent
// again if an output changes mode, for the mode that is now
// current.  In other words, the current mode is always the last
// mode that was received with the current flag set.
//
// Non-current modes are deprecated. A compositor can decide to only
// advertise the current mode and never send other modes. Clients
// should not rely on non-current modes.
//
// The size of a mode is given in physical hardware units of
// the output device. This is not necessarily the same as
// the output size in the global compositor space. For instance,
// the output may be scaled, as described in wl_output.scale,
// or transformed, as described in wl_output.transform. Clients
// willing to retrieve the output size in the global compositor
// space should use xdg_output.logical_size instead.
//
// The vertical refresh rate can be set to zero if it doesn't make
// sense for this output (e.g. for virtual outputs).
//
// Clients should not use the refresh rate to schedule frames. Instead,
// they should use the wl_surface.frame event or the presentation-time
// protocol.
//
// Note: this information is not always meaningful for all outputs. Some
// compositors, such as those exposing virtual outputs, might fake the
// refresh rate or the size.
type WlOutputModeEvent struct {
	// Flags contains bitfield of mode flags
	Flags uint32

	// Width contains width of the mode in hardware units
	Width int32

	// Height contains height of the mode in hardware units
	Height int32

	// Refresh contains vertical refresh rate in mHz
	Refresh int32
}

// Opcode returns the event opcode for wl_output.mode in wayland
func (WlOutputModeEvent) Opcode() uint16 { return 1 }

// Ensure WlOutputModeEvent implements Message.
var _ Message = WlOutputModeEvent{}

// Scan scans the event from the socket.
func (e *WlOutputModeEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Flags = v
	}
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.Width = v
	}
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.Height = v
	}
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.Refresh = v
	}
	return nil
}

// Ensure WlOutputModeEvent implements Event.
var _ Event = &WlOutputModeEvent{}

// WlOutputDoneEvent signals when sent all information about output
//
// This event is sent after all other properties have been
// sent after binding to the output object and after any
// other property changes done after that. This allows
// changes to the output properties to be seen as
// atomic, even if they happen via multiple events.
type WlOutputDoneEvent struct {
}

// Opcode returns the event opcode for wl_output.done in wayland
func (WlOutputDoneEvent) Opcode() uint16 { return 2 }

// Ensure WlOutputDoneEvent implements Message.
var _ Message = WlOutputDoneEvent{}

// Scan scans the event from the socket.
func (e *WlOutputDoneEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure WlOutputDoneEvent implements Event.
var _ Event = &WlOutputDoneEvent{}

// WlOutputScaleEvent signals when output scaling properties
//
// This event contains scaling geometry information
// that is not in the geometry event. It may be sent after
// binding the output object or if the output scale changes
// later. If it is not sent, the client should assume a
// scale of 1.
//
// A scale larger than 1 means that the compositor will
// automatically scale surface buffers by this amount
// when rendering. This is used for very high resolution
// displays where applications rendering at the native
// resolution would be too small to be legible.
//
// It is intended that scaling aware clients track the
// current output of a surface, and if it is on a scaled
// output it should use wl_surface.set_buffer_scale with
// the scale of the output. That way the compositor can
// avoid scaling the surface, and the client can supply
// a higher detail image.
type WlOutputScaleEvent struct {
	// Factor contains scaling factor of output
	Factor int32
}

// Opcode returns the event opcode for wl_output.scale in wayland
func (WlOutputScaleEvent) Opcode() uint16 { return 3 }

// Ensure WlOutputScaleEvent implements Message.
var _ Message = WlOutputScaleEvent{}

// Scan scans the event from the socket.
func (e *WlOutputScaleEvent) Scan(s *EventScanner) error {
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.Factor = v
	}
	return nil
}

// Ensure WlOutputScaleEvent implements Event.
var _ Event = &WlOutputScaleEvent{}

// #endregion Interface wayland.wl_output

// ----------------------------------------------------------------------------
// #region Interface wayland.wl_region

// WlRegionDestroyRequest requests to destroy region
//
// Destroy the region.  This will invalidate the object ID.
type WlRegionDestroyRequest struct {
}

// Opcode returns the request opcode for wl_region.destroy in wayland
func (WlRegionDestroyRequest) Opcode() uint16 { return 0 }

// Ensure WlRegionDestroyRequest implements Message.
var _ Message = WlRegionDestroyRequest{}

// WlRegionAddRequest requests to add rectangle to region
//
// Add the specified rectangle to the region.
type WlRegionAddRequest struct {
	// X contains region-local x coordinate
	X int32

	// Y contains region-local y coordinate
	Y int32

	// Width contains rectangle width
	Width int32

	// Height contains rectangle height
	Height int32
}

// Opcode returns the request opcode for wl_region.add in wayland
func (WlRegionAddRequest) Opcode() uint16 { return 1 }

// Ensure WlRegionAddRequest implements Message.
var _ Message = WlRegionAddRequest{}

// WlRegionSubtractRequest requests to subtract rectangle from region
//
// Subtract the specified rectangle from the region.
type WlRegionSubtractRequest struct {
	// X contains region-local x coordinate
	X int32

	// Y contains region-local y coordinate
	Y int32

	// Width contains rectangle width
	Width int32

	// Height contains rectangle height
	Height int32
}

// Opcode returns the request opcode for wl_region.subtract in wayland
func (WlRegionSubtractRequest) Opcode() uint16 { return 2 }

// Ensure WlRegionSubtractRequest implements Message.
var _ Message = WlRegionSubtractRequest{}

// #endregion Interface wayland.wl_region

// ----------------------------------------------------------------------------
// #region Interface wayland.wl_subcompositor

type WlSubcompositorError int

const (
	// WlSubcompositorErrorBadSurface corresponds to the to-be sub-surface is invalid
	WlSubcompositorErrorBadSurface WlSubcompositorError = 0
)

// WlSubcompositorDestroyRequest requests to unbind from the subcompositor interface
//
// Informs the server that the client will not be using this
// protocol object anymore. This does not affect any other
// objects, wl_subsurface objects included.
type WlSubcompositorDestroyRequest struct {
}

// Opcode returns the request opcode for wl_subcompositor.destroy in wayland
func (WlSubcompositorDestroyRequest) Opcode() uint16 { return 0 }

// Ensure WlSubcompositorDestroyRequest implements Message.
var _ Message = WlSubcompositorDestroyRequest{}

// WlSubcompositorGetSubsurfaceRequest requests to give a surface the role sub-surface
//
// Create a sub-surface interface for the given surface, and
// associate it with the given parent surface. This turns a
// plain wl_surface into a sub-surface.
//
// The to-be sub-surface must not already have another role, and it
// must not have an existing wl_subsurface object. Otherwise a protocol
// error is raised.
//
// Adding sub-surfaces to a parent is a double-buffered operation on the
// parent (see wl_surface.commit). The effect of adding a sub-surface
// becomes visible on the next time the state of the parent surface is
// applied.
//
// This request modifies the behaviour of wl_surface.commit request on
// the sub-surface, see the documentation on wl_subsurface interface.
type WlSubcompositorGetSubsurfaceRequest struct {
	// ID contains the new sub-surface object ID
	ID ObjectID

	// Surface contains the surface to be turned into a sub-surface
	Surface ObjectID

	// Parent contains the parent surface
	Parent ObjectID
}

// Opcode returns the request opcode for wl_subcompositor.get_subsurface in wayland
func (WlSubcompositorGetSubsurfaceRequest) Opcode() uint16 { return 1 }

// Ensure WlSubcompositorGetSubsurfaceRequest implements Message.
var _ Message = WlSubcompositorGetSubsurfaceRequest{}

// #endregion Interface wayland.wl_subcompositor

// ----------------------------------------------------------------------------
// #region Interface wayland.wl_subsurface

type WlSubsurfaceError int

const (
	// WlSubsurfaceErrorBadSurface corresponds to wl_surface is not a sibling or the parent
	WlSubsurfaceErrorBadSurface WlSubsurfaceError = 0
)

// WlSubsurfaceDestroyRequest requests to remove sub-surface interface
//
// The sub-surface interface is removed from the wl_surface object
// that was turned into a sub-surface with a
// wl_subcompositor.get_subsurface request. The wl_surface's association
// to the parent is deleted, and the wl_surface loses its role as
// a sub-surface. The wl_surface is unmapped immediately.
type WlSubsurfaceDestroyRequest struct {
}

// Opcode returns the request opcode for wl_subsurface.destroy in wayland
func (WlSubsurfaceDestroyRequest) Opcode() uint16 { return 0 }

// Ensure WlSubsurfaceDestroyRequest implements Message.
var _ Message = WlSubsurfaceDestroyRequest{}

// WlSubsurfaceSetPositionRequest requests to reposition the sub-surface
//
// This schedules a sub-surface position change.
// The sub-surface will be moved so that its origin (top left
// corner pixel) will be at the location x, y of the parent surface
// coordinate system. The coordinates are not restricted to the parent
// surface area. Negative values are allowed.
//
// The scheduled coordinates will take effect whenever the state of the
// parent surface is applied. When this happens depends on whether the
// parent surface is in synchronized mode or not. See
// wl_subsurface.set_sync and wl_subsurface.set_desync for details.
//
// If more than one set_position request is invoked by the client before
// the commit of the parent surface, the position of a new request always
// replaces the scheduled position from any previous request.
//
// The initial position is 0, 0.
type WlSubsurfaceSetPositionRequest struct {
	// X contains x coordinate in the parent surface
	X int32

	// Y contains y coordinate in the parent surface
	Y int32
}

// Opcode returns the request opcode for wl_subsurface.set_position in wayland
func (WlSubsurfaceSetPositionRequest) Opcode() uint16 { return 1 }

// Ensure WlSubsurfaceSetPositionRequest implements Message.
var _ Message = WlSubsurfaceSetPositionRequest{}

// WlSubsurfacePlaceAboveRequest requests to restack the sub-surface
//
// This sub-surface is taken from the stack, and put back just
// above the reference surface, changing the z-order of the sub-surfaces.
// The reference surface must be one of the sibling surfaces, or the
// parent surface. Using any other surface, including this sub-surface,
// will cause a protocol error.
//
// The z-order is double-buffered. Requests are handled in order and
// applied immediately to a pending state. The final pending state is
// copied to the active state the next time the state of the parent
// surface is applied. When this happens depends on whether the parent
// surface is in synchronized mode or not. See wl_subsurface.set_sync and
// wl_subsurface.set_desync for details.
//
// A new sub-surface is initially added as the top-most in the stack
// of its siblings and parent.
type WlSubsurfacePlaceAboveRequest struct {
	// Sibling contains the reference surface
	Sibling ObjectID
}

// Opcode returns the request opcode for wl_subsurface.place_above in wayland
func (WlSubsurfacePlaceAboveRequest) Opcode() uint16 { return 2 }

// Ensure WlSubsurfacePlaceAboveRequest implements Message.
var _ Message = WlSubsurfacePlaceAboveRequest{}

// WlSubsurfacePlaceBelowRequest requests to restack the sub-surface
//
// The sub-surface is placed just below the reference surface.
// See wl_subsurface.place_above.
type WlSubsurfacePlaceBelowRequest struct {
	// Sibling contains the reference surface
	Sibling ObjectID
}

// Opcode returns the request opcode for wl_subsurface.place_below in wayland
func (WlSubsurfacePlaceBelowRequest) Opcode() uint16 { return 3 }

// Ensure WlSubsurfacePlaceBelowRequest implements Message.
var _ Message = WlSubsurfacePlaceBelowRequest{}

// WlSubsurfaceSetSyncRequest requests to set sub-surface to synchronized mode
//
// Change the commit behaviour of the sub-surface to synchronized
// mode, also described as the parent dependent mode.
//
// In synchronized mode, wl_surface.commit on a sub-surface will
// accumulate the committed state in a cache, but the state will
// not be applied and hence will not change the compositor output.
// The cached state is applied to the sub-surface immediately after
// the parent surface's state is applied. This ensures atomic
// updates of the parent and all its synchronized sub-surfaces.
// Applying the cached state will invalidate the cache, so further
// parent surface commits do not (re-)apply old state.
//
// See wl_subsurface for the recursive effect of this mode.
type WlSubsurfaceSetSyncRequest struct {
}

// Opcode returns the request opcode for wl_subsurface.set_sync in wayland
func (WlSubsurfaceSetSyncRequest) Opcode() uint16 { return 4 }

// Ensure WlSubsurfaceSetSyncRequest implements Message.
var _ Message = WlSubsurfaceSetSyncRequest{}

// WlSubsurfaceSetDesyncRequest requests to set sub-surface to desynchronized mode
//
// Change the commit behaviour of the sub-surface to desynchronized
// mode, also described as independent or freely running mode.
//
// In desynchronized mode, wl_surface.commit on a sub-surface will
// apply the pending state directly, without caching, as happens
// normally with a wl_surface. Calling wl_surface.commit on the
// parent surface has no effect on the sub-surface's wl_surface
// state. This mode allows a sub-surface to be updated on its own.
//
// If cached state exists when wl_surface.commit is called in
// desynchronized mode, the pending state is added to the cached
// state, and applied as a whole. This invalidates the cache.
//
// Note: even if a sub-surface is set to desynchronized, a parent
// sub-surface may override it to behave as synchronized. For details,
// see wl_subsurface.
//
// If a surface's parent surface behaves as desynchronized, then
// the cached state is applied on set_desync.
type WlSubsurfaceSetDesyncRequest struct {
}

// Opcode returns the request opcode for wl_subsurface.set_desync in wayland
func (WlSubsurfaceSetDesyncRequest) Opcode() uint16 { return 5 }

// Ensure WlSubsurfaceSetDesyncRequest implements Message.
var _ Message = WlSubsurfaceSetDesyncRequest{}

// #endregion Interface wayland.wl_subsurface

////////////////////////////////////////////////////////////////////////////////
// #endregion Protocol wayland

////////////////////////////////////////////////////////////////////////////////
// #region Protocol wp_primary_selection_unstable_v1

// ----------------------------------------------------------------------------
// #region Interface wp_primary_selection_unstable_v1.zwp_primary_selection_device_manager_v1

// ZwpPrimarySelectionDeviceManagerV1CreateSourceRequest requests to create a new primary selection source
//
// Create a new primary selection source.
type ZwpPrimarySelectionDeviceManagerV1CreateSourceRequest struct {
	ID ObjectID
}

// Opcode returns the request opcode for zwp_primary_selection_device_manager_v1.create_source in wp_primary_selection_unstable_v1
func (ZwpPrimarySelectionDeviceManagerV1CreateSourceRequest) Opcode() uint16 { return 0 }

// Ensure ZwpPrimarySelectionDeviceManagerV1CreateSourceRequest implements Message.
var _ Message = ZwpPrimarySelectionDeviceManagerV1CreateSourceRequest{}

// ZwpPrimarySelectionDeviceManagerV1GetDeviceRequest requests to create a new primary selection device
//
// Create a new data device for a given seat.
type ZwpPrimarySelectionDeviceManagerV1GetDeviceRequest struct {
	ID ObjectID

	Seat ObjectID
}

// Opcode returns the request opcode for zwp_primary_selection_device_manager_v1.get_device in wp_primary_selection_unstable_v1
func (ZwpPrimarySelectionDeviceManagerV1GetDeviceRequest) Opcode() uint16 { return 1 }

// Ensure ZwpPrimarySelectionDeviceManagerV1GetDeviceRequest implements Message.
var _ Message = ZwpPrimarySelectionDeviceManagerV1GetDeviceRequest{}

// ZwpPrimarySelectionDeviceManagerV1DestroyRequest requests to destroy the primary selection device manager
//
// Destroy the primary selection device manager.
type ZwpPrimarySelectionDeviceManagerV1DestroyRequest struct {
}

// Opcode returns the request opcode for zwp_primary_selection_device_manager_v1.destroy in wp_primary_selection_unstable_v1
func (ZwpPrimarySelectionDeviceManagerV1DestroyRequest) Opcode() uint16 { return 2 }

// Ensure ZwpPrimarySelectionDeviceManagerV1DestroyRequest implements Message.
var _ Message = ZwpPrimarySelectionDeviceManagerV1DestroyRequest{}

// #endregion Interface wp_primary_selection_unstable_v1.zwp_primary_selection_device_manager_v1

// ----------------------------------------------------------------------------
// #region Interface wp_primary_selection_unstable_v1.zwp_primary_selection_device_v1

// ZwpPrimarySelectionDeviceV1SetSelectionRequest requests to set the primary selection
//
// Replaces the current selection. The previous owner of the primary
// selection will receive a wp_primary_selection_source.cancelled event.
//
// To unset the selection, set the source to NULL.
type ZwpPrimarySelectionDeviceV1SetSelectionRequest struct {
	Source ObjectID

	// Serial contains serial of the event that triggered this request
	Serial uint32
}

// Opcode returns the request opcode for zwp_primary_selection_device_v1.set_selection in wp_primary_selection_unstable_v1
func (ZwpPrimarySelectionDeviceV1SetSelectionRequest) Opcode() uint16 { return 0 }

// Ensure ZwpPrimarySelectionDeviceV1SetSelectionRequest implements Message.
var _ Message = ZwpPrimarySelectionDeviceV1SetSelectionRequest{}

// ZwpPrimarySelectionDeviceV1DestroyRequest requests to destroy the primary selection device
//
// Destroy the primary selection device.
type ZwpPrimarySelectionDeviceV1DestroyRequest struct {
}

// Opcode returns the request opcode for zwp_primary_selection_device_v1.destroy in wp_primary_selection_unstable_v1
func (ZwpPrimarySelectionDeviceV1DestroyRequest) Opcode() uint16 { return 1 }

// Ensure ZwpPrimarySelectionDeviceV1DestroyRequest implements Message.
var _ Message = ZwpPrimarySelectionDeviceV1DestroyRequest{}

// ZwpPrimarySelectionDeviceV1DataOfferEvent signals when introduce a new wp_primary_selection_offer
//
// Introduces a new wp_primary_selection_offer object that may be used
// to receive the current primary selection. Immediately following this
// event, the new wp_primary_selection_offer object will send
// wp_primary_selection_offer.offer events to describe the offered mime
// types.
type ZwpPrimarySelectionDeviceV1DataOfferEvent struct {
	Offer ObjectID
}

// Opcode returns the event opcode for zwp_primary_selection_device_v1.data_offer in wp_primary_selection_unstable_v1
func (ZwpPrimarySelectionDeviceV1DataOfferEvent) Opcode() uint16 { return 0 }

// Ensure ZwpPrimarySelectionDeviceV1DataOfferEvent implements Message.
var _ Message = ZwpPrimarySelectionDeviceV1DataOfferEvent{}

// Scan scans the event from the socket.
func (e *ZwpPrimarySelectionDeviceV1DataOfferEvent) Scan(s *EventScanner) error {
	if v, err := s.ObjectID(); err != nil {
		return err
	} else {
		e.Offer = v
	}
	return nil
}

// Ensure ZwpPrimarySelectionDeviceV1DataOfferEvent implements Event.
var _ Event = &ZwpPrimarySelectionDeviceV1DataOfferEvent{}

// ZwpPrimarySelectionDeviceV1SelectionEvent signals when advertise a new primary selection
//
// The wp_primary_selection_device.selection event is sent to notify the
// client of a new primary selection. This event is sent after the
// wp_primary_selection.data_offer event introducing this object, and after
// the offer has announced its mimetypes through
// wp_primary_selection_offer.offer.
//
// The data_offer is valid until a new offer or NULL is received
// or until the client loses keyboard focus. The client must destroy the
// previous selection data_offer, if any, upon receiving this event.
type ZwpPrimarySelectionDeviceV1SelectionEvent struct {
	ID ObjectID
}

// Opcode returns the event opcode for zwp_primary_selection_device_v1.selection in wp_primary_selection_unstable_v1
func (ZwpPrimarySelectionDeviceV1SelectionEvent) Opcode() uint16 { return 1 }

// Ensure ZwpPrimarySelectionDeviceV1SelectionEvent implements Message.
var _ Message = ZwpPrimarySelectionDeviceV1SelectionEvent{}

// Scan scans the event from the socket.
func (e *ZwpPrimarySelectionDeviceV1SelectionEvent) Scan(s *EventScanner) error {
	if v, err := s.ObjectID(); err != nil {
		return err
	} else {
		e.ID = v
	}
	return nil
}

// Ensure ZwpPrimarySelectionDeviceV1SelectionEvent implements Event.
var _ Event = &ZwpPrimarySelectionDeviceV1SelectionEvent{}

// #endregion Interface wp_primary_selection_unstable_v1.zwp_primary_selection_device_v1

// ----------------------------------------------------------------------------
// #region Interface wp_primary_selection_unstable_v1.zwp_primary_selection_offer_v1

// ZwpPrimarySelectionOfferV1ReceiveRequest requests to request that the data is transferred
//
// To transfer the contents of the primary selection clipboard, the client
// issues this request and indicates the mime type that it wants to
// receive. The transfer happens through the passed file descriptor
// (typically created with the pipe system call). The source client writes
// the data in the mime type representation requested and then closes the
// file descriptor.
//
// The receiving client reads from the read end of the pipe until EOF and
// closes its end, at which point the transfer is complete.
type ZwpPrimarySelectionOfferV1ReceiveRequest struct {
	MimeType string

	FD FD
}

// Opcode returns the request opcode for zwp_primary_selection_offer_v1.receive in wp_primary_selection_unstable_v1
func (ZwpPrimarySelectionOfferV1ReceiveRequest) Opcode() uint16 { return 0 }

// Ensure ZwpPrimarySelectionOfferV1ReceiveRequest implements Message.
var _ Message = ZwpPrimarySelectionOfferV1ReceiveRequest{}

// ZwpPrimarySelectionOfferV1DestroyRequest requests to destroy the primary selection offer
//
// Destroy the primary selection offer.
type ZwpPrimarySelectionOfferV1DestroyRequest struct {
}

// Opcode returns the request opcode for zwp_primary_selection_offer_v1.destroy in wp_primary_selection_unstable_v1
func (ZwpPrimarySelectionOfferV1DestroyRequest) Opcode() uint16 { return 1 }

// Ensure ZwpPrimarySelectionOfferV1DestroyRequest implements Message.
var _ Message = ZwpPrimarySelectionOfferV1DestroyRequest{}

// ZwpPrimarySelectionOfferV1OfferEvent signals when advertise offered mime type
//
// Sent immediately after creating announcing the
// wp_primary_selection_offer through
// wp_primary_selection_device.data_offer. One event is sent per offered
// mime type.
type ZwpPrimarySelectionOfferV1OfferEvent struct {
	MimeType string
}

// Opcode returns the event opcode for zwp_primary_selection_offer_v1.offer in wp_primary_selection_unstable_v1
func (ZwpPrimarySelectionOfferV1OfferEvent) Opcode() uint16 { return 0 }

// Ensure ZwpPrimarySelectionOfferV1OfferEvent implements Message.
var _ Message = ZwpPrimarySelectionOfferV1OfferEvent{}

// Scan scans the event from the socket.
func (e *ZwpPrimarySelectionOfferV1OfferEvent) Scan(s *EventScanner) error {
	if v, err := s.String(); err != nil {
		return err
	} else {
		e.MimeType = v
	}
	return nil
}

// Ensure ZwpPrimarySelectionOfferV1OfferEvent implements Event.
var _ Event = &ZwpPrimarySelectionOfferV1OfferEvent{}

// #endregion Interface wp_primary_selection_unstable_v1.zwp_primary_selection_offer_v1

// ----------------------------------------------------------------------------
// #region Interface wp_primary_selection_unstable_v1.zwp_primary_selection_source_v1

// ZwpPrimarySelectionSourceV1OfferRequest requests to add an offered mime type
//
// This request adds a mime type to the set of mime types advertised to
// targets. Can be called several times to offer multiple types.
type ZwpPrimarySelectionSourceV1OfferRequest struct {
	MimeType string
}

// Opcode returns the request opcode for zwp_primary_selection_source_v1.offer in wp_primary_selection_unstable_v1
func (ZwpPrimarySelectionSourceV1OfferRequest) Opcode() uint16 { return 0 }

// Ensure ZwpPrimarySelectionSourceV1OfferRequest implements Message.
var _ Message = ZwpPrimarySelectionSourceV1OfferRequest{}

// ZwpPrimarySelectionSourceV1DestroyRequest requests to destroy the primary selection source
//
// Destroy the primary selection source.
type ZwpPrimarySelectionSourceV1DestroyRequest struct {
}

// Opcode returns the request opcode for zwp_primary_selection_source_v1.destroy in wp_primary_selection_unstable_v1
func (ZwpPrimarySelectionSourceV1DestroyRequest) Opcode() uint16 { return 1 }

// Ensure ZwpPrimarySelectionSourceV1DestroyRequest implements Message.
var _ Message = ZwpPrimarySelectionSourceV1DestroyRequest{}

// ZwpPrimarySelectionSourceV1SendEvent signals when send the primary selection contents
//
// Request for the current primary selection contents from the client.
// Send the specified mime type over the passed file descriptor, then
// close it.
type ZwpPrimarySelectionSourceV1SendEvent struct {
	MimeType string

	FD FD
}

// Opcode returns the event opcode for zwp_primary_selection_source_v1.send in wp_primary_selection_unstable_v1
func (ZwpPrimarySelectionSourceV1SendEvent) Opcode() uint16 { return 0 }

// Ensure ZwpPrimarySelectionSourceV1SendEvent implements Message.
var _ Message = ZwpPrimarySelectionSourceV1SendEvent{}

// Scan scans the event from the socket.
func (e *ZwpPrimarySelectionSourceV1SendEvent) Scan(s *EventScanner) error {
	if v, err := s.String(); err != nil {
		return err
	} else {
		e.MimeType = v
	}
	if v, err := s.FD(); err != nil {
		return err
	} else {
		e.FD = v
	}
	return nil
}

// Ensure ZwpPrimarySelectionSourceV1SendEvent implements Event.
var _ Event = &ZwpPrimarySelectionSourceV1SendEvent{}

// ZwpPrimarySelectionSourceV1CancelledEvent signals when request for primary selection contents was canceled
//
// This primary selection source is no longer valid. The client should
// clean up and destroy this primary selection source.
type ZwpPrimarySelectionSourceV1CancelledEvent struct {
}

// Opcode returns the event opcode for zwp_primary_selection_source_v1.cancelled in wp_primary_selection_unstable_v1
func (ZwpPrimarySelectionSourceV1CancelledEvent) Opcode() uint16 { return 1 }

// Ensure ZwpPrimarySelectionSourceV1CancelledEvent implements Message.
var _ Message = ZwpPrimarySelectionSourceV1CancelledEvent{}

// Scan scans the event from the socket.
func (e *ZwpPrimarySelectionSourceV1CancelledEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure ZwpPrimarySelectionSourceV1CancelledEvent implements Event.
var _ Event = &ZwpPrimarySelectionSourceV1CancelledEvent{}

// #endregion Interface wp_primary_selection_unstable_v1.zwp_primary_selection_source_v1

////////////////////////////////////////////////////////////////////////////////
// #endregion Protocol wp_primary_selection_unstable_v1

////////////////////////////////////////////////////////////////////////////////
// #region Protocol xdg_activation_v1

// ----------------------------------------------------------------------------
// #region Interface xdg_activation_v1.xdg_activation_v1

// XdgActivationV1DestroyRequest requests to destroy the xdg_activation object
//
// Notify the compositor that the xdg_activation object will no longer be
// used.
//
// The child objects created via this interface are unaffected and should
// be destroyed separately.
type XdgActivationV1DestroyRequest struct {
}

// Opcode returns the request opcode for xdg_activation_v1.destroy in xdg_activation_v1
func (XdgActivationV1DestroyRequest) Opcode() uint16 { return 0 }

// Ensure XdgActivationV1DestroyRequest implements Message.
var _ Message = XdgActivationV1DestroyRequest{}

// XdgActivationV1GetActivationTokenRequest requests to requests a token
//
// Creates an xdg_activation_token_v1 object that will provide
// the initiating client with a unique token for this activation. This
// token should be offered to the clients to be activated.
type XdgActivationV1GetActivationTokenRequest struct {
	ID ObjectID
}

// Opcode returns the request opcode for xdg_activation_v1.get_activation_token in xdg_activation_v1
func (XdgActivationV1GetActivationTokenRequest) Opcode() uint16 { return 1 }

// Ensure XdgActivationV1GetActivationTokenRequest implements Message.
var _ Message = XdgActivationV1GetActivationTokenRequest{}

// XdgActivationV1ActivateRequest requests to notify new interaction being available
//
// Requests surface activation. It's up to the compositor to display
// this information as desired, for example by placing the surface above
// the rest.
//
// The compositor may know who requested this by checking the activation
// token and might decide not to follow through with the activation if it's
// considered unwanted.
//
// Compositors can ignore unknown activation tokens when an invalid
// token is passed.
type XdgActivationV1ActivateRequest struct {
	// Token contains the activation token of the initiating client
	Token string

	// Surface contains the wl_surface to activate
	Surface ObjectID
}

// Opcode returns the request opcode for xdg_activation_v1.activate in xdg_activation_v1
func (XdgActivationV1ActivateRequest) Opcode() uint16 { return 2 }

// Ensure XdgActivationV1ActivateRequest implements Message.
var _ Message = XdgActivationV1ActivateRequest{}

// #endregion Interface xdg_activation_v1.xdg_activation_v1

// ----------------------------------------------------------------------------
// #region Interface xdg_activation_v1.xdg_activation_token_v1

type XdgActivationTokenV1Error int

const (
	// XdgActivationTokenV1ErrorAlreadyUsed corresponds to The token has already been used previously
	XdgActivationTokenV1ErrorAlreadyUsed XdgActivationTokenV1Error = 0
)

// XdgActivationTokenV1SetSerialRequest requests to specifies the seat and serial of the activating event
//
// Provides information about the seat and serial event that requested the
// token.
//
// The serial can come from an input or focus event. For instance, if a
// click triggers the launch of a third-party client, the launcher client
// should send a set_serial request with the serial and seat from the
// wl_pointer.button event.
//
// Some compositors might refuse to activate toplevels when the token
// doesn't have a valid and recent enough event serial.
//
// Must be sent before commit. This information is optional.
type XdgActivationTokenV1SetSerialRequest struct {
	// Serial contains the serial of the event that triggered the activation
	Serial uint32

	// Seat contains the wl_seat of the event
	Seat ObjectID
}

// Opcode returns the request opcode for xdg_activation_token_v1.set_serial in xdg_activation_v1
func (XdgActivationTokenV1SetSerialRequest) Opcode() uint16 { return 0 }

// Ensure XdgActivationTokenV1SetSerialRequest implements Message.
var _ Message = XdgActivationTokenV1SetSerialRequest{}

// XdgActivationTokenV1SetAppIDRequest requests to specifies the application being activated
//
// The requesting client can specify an app_id to associate the token
// being created with it.
//
// Must be sent before commit. This information is optional.
type XdgActivationTokenV1SetAppIDRequest struct {
	// AppID contains the application id of the client being activated.
	AppID string
}

// Opcode returns the request opcode for xdg_activation_token_v1.set_app_id in xdg_activation_v1
func (XdgActivationTokenV1SetAppIDRequest) Opcode() uint16 { return 1 }

// Ensure XdgActivationTokenV1SetAppIDRequest implements Message.
var _ Message = XdgActivationTokenV1SetAppIDRequest{}

// XdgActivationTokenV1SetSurfaceRequest requests to specifies the surface requesting activation
//
// This request sets the surface requesting the activation. Note, this is
// different from the surface that will be activated.
//
// Some compositors might refuse to activate toplevels when the token
// doesn't have a requesting surface.
//
// Must be sent before commit. This information is optional.
type XdgActivationTokenV1SetSurfaceRequest struct {
	// Surface contains the requesting surface
	Surface ObjectID
}

// Opcode returns the request opcode for xdg_activation_token_v1.set_surface in xdg_activation_v1
func (XdgActivationTokenV1SetSurfaceRequest) Opcode() uint16 { return 2 }

// Ensure XdgActivationTokenV1SetSurfaceRequest implements Message.
var _ Message = XdgActivationTokenV1SetSurfaceRequest{}

// XdgActivationTokenV1CommitRequest requests to issues the token request
//
// Requests an activation token based on the different parameters that
// have been offered through set_serial, set_surface and set_app_id.
type XdgActivationTokenV1CommitRequest struct {
}

// Opcode returns the request opcode for xdg_activation_token_v1.commit in xdg_activation_v1
func (XdgActivationTokenV1CommitRequest) Opcode() uint16 { return 3 }

// Ensure XdgActivationTokenV1CommitRequest implements Message.
var _ Message = XdgActivationTokenV1CommitRequest{}

// XdgActivationTokenV1DestroyRequest requests to destroy the xdg_activation_token_v1 object
//
// Notify the compositor that the xdg_activation_token_v1 object will no
// longer be used.
type XdgActivationTokenV1DestroyRequest struct {
}

// Opcode returns the request opcode for xdg_activation_token_v1.destroy in xdg_activation_v1
func (XdgActivationTokenV1DestroyRequest) Opcode() uint16 { return 4 }

// Ensure XdgActivationTokenV1DestroyRequest implements Message.
var _ Message = XdgActivationTokenV1DestroyRequest{}

// XdgActivationTokenV1DoneEvent signals when the exported activation token
//
// The 'done' event contains the unique token of this activation request
// and notifies that the provider is done.
type XdgActivationTokenV1DoneEvent struct {
	// Token contains the exported activation token
	Token string
}

// Opcode returns the event opcode for xdg_activation_token_v1.done in xdg_activation_v1
func (XdgActivationTokenV1DoneEvent) Opcode() uint16 { return 0 }

// Ensure XdgActivationTokenV1DoneEvent implements Message.
var _ Message = XdgActivationTokenV1DoneEvent{}

// Scan scans the event from the socket.
func (e *XdgActivationTokenV1DoneEvent) Scan(s *EventScanner) error {
	if v, err := s.String(); err != nil {
		return err
	} else {
		e.Token = v
	}
	return nil
}

// Ensure XdgActivationTokenV1DoneEvent implements Event.
var _ Event = &XdgActivationTokenV1DoneEvent{}

// #endregion Interface xdg_activation_v1.xdg_activation_token_v1

////////////////////////////////////////////////////////////////////////////////
// #endregion Protocol xdg_activation_v1

////////////////////////////////////////////////////////////////////////////////
// #region Protocol xdg_decoration_unstable_v1

// ----------------------------------------------------------------------------
// #region Interface xdg_decoration_unstable_v1.zxdg_decoration_manager_v1

// ZxdgDecorationManagerV1DestroyRequest requests to destroy the decoration manager object
//
// Destroy the decoration manager. This doesn't destroy objects created
// with the manager.
type ZxdgDecorationManagerV1DestroyRequest struct {
}

// Opcode returns the request opcode for zxdg_decoration_manager_v1.destroy in xdg_decoration_unstable_v1
func (ZxdgDecorationManagerV1DestroyRequest) Opcode() uint16 { return 0 }

// Ensure ZxdgDecorationManagerV1DestroyRequest implements Message.
var _ Message = ZxdgDecorationManagerV1DestroyRequest{}

// ZxdgDecorationManagerV1GetToplevelDecorationRequest requests to create a new toplevel decoration object
//
// Create a new decoration object associated with the given toplevel.
//
// Creating an xdg_toplevel_decoration from an xdg_toplevel which has a
// buffer attached or committed is a client error, and any attempts by a
// client to attach or manipulate a buffer prior to the first
// xdg_toplevel_decoration.configure event must also be treated as
// errors.
type ZxdgDecorationManagerV1GetToplevelDecorationRequest struct {
	ID ObjectID

	Toplevel ObjectID
}

// Opcode returns the request opcode for zxdg_decoration_manager_v1.get_toplevel_decoration in xdg_decoration_unstable_v1
func (ZxdgDecorationManagerV1GetToplevelDecorationRequest) Opcode() uint16 { return 1 }

// Ensure ZxdgDecorationManagerV1GetToplevelDecorationRequest implements Message.
var _ Message = ZxdgDecorationManagerV1GetToplevelDecorationRequest{}

// #endregion Interface xdg_decoration_unstable_v1.zxdg_decoration_manager_v1

// ----------------------------------------------------------------------------
// #region Interface xdg_decoration_unstable_v1.zxdg_toplevel_decoration_v1

type ZxdgToplevelDecorationV1Error int

const (
	// ZxdgToplevelDecorationV1ErrorUnconfiguredBuffer corresponds to xdg_toplevel has a buffer attached before configure
	ZxdgToplevelDecorationV1ErrorUnconfiguredBuffer ZxdgToplevelDecorationV1Error = 0

	// ZxdgToplevelDecorationV1ErrorAlreadyConstructed corresponds to xdg_toplevel already has a decoration object
	ZxdgToplevelDecorationV1ErrorAlreadyConstructed ZxdgToplevelDecorationV1Error = 1

	// ZxdgToplevelDecorationV1ErrorOrphaned corresponds to xdg_toplevel destroyed before the decoration object
	ZxdgToplevelDecorationV1ErrorOrphaned ZxdgToplevelDecorationV1Error = 2
)

// ZxdgToplevelDecorationV1Mode represents window decoration modes
//
// These values describe window decoration modes.
type ZxdgToplevelDecorationV1Mode int

const (
	// ZxdgToplevelDecorationV1ModeClientSide corresponds to no server-side window decoration
	ZxdgToplevelDecorationV1ModeClientSide ZxdgToplevelDecorationV1Mode = 1

	// ZxdgToplevelDecorationV1ModeServerSide corresponds to server-side window decoration
	ZxdgToplevelDecorationV1ModeServerSide ZxdgToplevelDecorationV1Mode = 2
)

// ZxdgToplevelDecorationV1DestroyRequest requests to destroy the decoration object
//
// Switch back to a mode without any server-side decorations at the next
// commit.
type ZxdgToplevelDecorationV1DestroyRequest struct {
}

// Opcode returns the request opcode for zxdg_toplevel_decoration_v1.destroy in xdg_decoration_unstable_v1
func (ZxdgToplevelDecorationV1DestroyRequest) Opcode() uint16 { return 0 }

// Ensure ZxdgToplevelDecorationV1DestroyRequest implements Message.
var _ Message = ZxdgToplevelDecorationV1DestroyRequest{}

// ZxdgToplevelDecorationV1SetModeRequest requests to set the decoration mode
//
// Set the toplevel surface decoration mode. This informs the compositor
// that the client prefers the provided decoration mode.
//
// After requesting a decoration mode, the compositor will respond by
// emitting an xdg_surface.configure event. The client should then update
// its content, drawing it without decorations if the received mode is
// server-side decorations. The client must also acknowledge the configure
// when committing the new content (see xdg_surface.ack_configure).
//
// The compositor can decide not to use the client's mode and enforce a
// different mode instead.
//
// Clients whose decoration mode depend on the xdg_toplevel state may send
// a set_mode request in response to an xdg_surface.configure event and wait
// for the next xdg_surface.configure event to prevent unwanted state.
// Such clients are responsible for preventing configure loops and must
// make sure not to send multiple successive set_mode requests with the
// same decoration mode.
type ZxdgToplevelDecorationV1SetModeRequest struct {
	// Mode contains the decoration mode
	Mode uint32
}

// Opcode returns the request opcode for zxdg_toplevel_decoration_v1.set_mode in xdg_decoration_unstable_v1
func (ZxdgToplevelDecorationV1SetModeRequest) Opcode() uint16 { return 1 }

// Ensure ZxdgToplevelDecorationV1SetModeRequest implements Message.
var _ Message = ZxdgToplevelDecorationV1SetModeRequest{}

// ZxdgToplevelDecorationV1UnsetModeRequest requests to unset the decoration mode
//
// Unset the toplevel surface decoration mode. This informs the compositor
// that the client doesn't prefer a particular decoration mode.
//
// This request has the same semantics as set_mode.
type ZxdgToplevelDecorationV1UnsetModeRequest struct {
}

// Opcode returns the request opcode for zxdg_toplevel_decoration_v1.unset_mode in xdg_decoration_unstable_v1
func (ZxdgToplevelDecorationV1UnsetModeRequest) Opcode() uint16 { return 2 }

// Ensure ZxdgToplevelDecorationV1UnsetModeRequest implements Message.
var _ Message = ZxdgToplevelDecorationV1UnsetModeRequest{}

// ZxdgToplevelDecorationV1ConfigureEvent signals when suggest a surface change
//
// The configure event asks the client to change its decoration mode. The
// configured state should not be applied immediately. Clients must send an
// ack_configure in response to this event. See xdg_surface.configure and
// xdg_surface.ack_configure for details.
//
// A configure event can be sent at any time. The specified mode must be
// obeyed by the client.
type ZxdgToplevelDecorationV1ConfigureEvent struct {
	// Mode contains the decoration mode
	Mode uint32
}

// Opcode returns the event opcode for zxdg_toplevel_decoration_v1.configure in xdg_decoration_unstable_v1
func (ZxdgToplevelDecorationV1ConfigureEvent) Opcode() uint16 { return 0 }

// Ensure ZxdgToplevelDecorationV1ConfigureEvent implements Message.
var _ Message = ZxdgToplevelDecorationV1ConfigureEvent{}

// Scan scans the event from the socket.
func (e *ZxdgToplevelDecorationV1ConfigureEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Mode = v
	}
	return nil
}

// Ensure ZxdgToplevelDecorationV1ConfigureEvent implements Event.
var _ Event = &ZxdgToplevelDecorationV1ConfigureEvent{}

// #endregion Interface xdg_decoration_unstable_v1.zxdg_toplevel_decoration_v1

////////////////////////////////////////////////////////////////////////////////
// #endregion Protocol xdg_decoration_unstable_v1

////////////////////////////////////////////////////////////////////////////////
// #region Protocol xdg_foreign_unstable_v1

// ----------------------------------------------------------------------------
// #region Interface xdg_foreign_unstable_v1.zxdg_exporter_v1

// ZxdgExporterV1DestroyRequest requests to destroy the xdg_exporter object
//
// Notify the compositor that the xdg_exporter object will no longer be
// used.
type ZxdgExporterV1DestroyRequest struct {
}

// Opcode returns the request opcode for zxdg_exporter_v1.destroy in xdg_foreign_unstable_v1
func (ZxdgExporterV1DestroyRequest) Opcode() uint16 { return 0 }

// Ensure ZxdgExporterV1DestroyRequest implements Message.
var _ Message = ZxdgExporterV1DestroyRequest{}

// ZxdgExporterV1ExportRequest requests to export a surface
//
// The export request exports the passed surface so that it can later be
// imported via xdg_importer. When called, a new xdg_exported object will
// be created and xdg_exported.handle will be sent immediately. See the
// corresponding interface and event for details.
//
// A surface may be exported multiple times, and each exported handle may
// be used to create an xdg_imported multiple times. Only xdg_surface
// surfaces may be exported.
type ZxdgExporterV1ExportRequest struct {
	// ID contains the new xdg_exported object
	ID ObjectID

	// Surface contains the surface to export
	Surface ObjectID
}

// Opcode returns the request opcode for zxdg_exporter_v1.export in xdg_foreign_unstable_v1
func (ZxdgExporterV1ExportRequest) Opcode() uint16 { return 1 }

// Ensure ZxdgExporterV1ExportRequest implements Message.
var _ Message = ZxdgExporterV1ExportRequest{}

// #endregion Interface xdg_foreign_unstable_v1.zxdg_exporter_v1

// ----------------------------------------------------------------------------
// #region Interface xdg_foreign_unstable_v1.zxdg_importer_v1

// ZxdgImporterV1DestroyRequest requests to destroy the xdg_importer object
//
// Notify the compositor that the xdg_importer object will no longer be
// used.
type ZxdgImporterV1DestroyRequest struct {
}

// Opcode returns the request opcode for zxdg_importer_v1.destroy in xdg_foreign_unstable_v1
func (ZxdgImporterV1DestroyRequest) Opcode() uint16 { return 0 }

// Ensure ZxdgImporterV1DestroyRequest implements Message.
var _ Message = ZxdgImporterV1DestroyRequest{}

// ZxdgImporterV1ImportRequest requests to import a surface
//
// The import request imports a surface from any client given a handle
// retrieved by exporting said surface using xdg_exporter.export. When
// called, a new xdg_imported object will be created. This new object
// represents the imported surface, and the importing client can
// manipulate its relationship using it. See xdg_imported for details.
type ZxdgImporterV1ImportRequest struct {
	// ID contains the new xdg_imported object
	ID ObjectID

	// Handle contains the exported surface handle
	Handle string
}

// Opcode returns the request opcode for zxdg_importer_v1.import in xdg_foreign_unstable_v1
func (ZxdgImporterV1ImportRequest) Opcode() uint16 { return 1 }

// Ensure ZxdgImporterV1ImportRequest implements Message.
var _ Message = ZxdgImporterV1ImportRequest{}

// #endregion Interface xdg_foreign_unstable_v1.zxdg_importer_v1

// ----------------------------------------------------------------------------
// #region Interface xdg_foreign_unstable_v1.zxdg_exported_v1

// ZxdgExportedV1DestroyRequest requests to unexport the exported surface
//
// Revoke the previously exported surface. This invalidates any
// relationship the importer may have set up using the xdg_imported created
// given the handle sent via xdg_exported.handle.
type ZxdgExportedV1DestroyRequest struct {
}

// Opcode returns the request opcode for zxdg_exported_v1.destroy in xdg_foreign_unstable_v1
func (ZxdgExportedV1DestroyRequest) Opcode() uint16 { return 0 }

// Ensure ZxdgExportedV1DestroyRequest implements Message.
var _ Message = ZxdgExportedV1DestroyRequest{}

// ZxdgExportedV1HandleEvent signals when the exported surface handle
//
// The handle event contains the unique handle of this exported surface
// reference. It may be shared with any client, which then can use it to
// import the surface by calling xdg_importer.import. A handle may be
// used to import the surface multiple times.
type ZxdgExportedV1HandleEvent struct {
	// Handle contains the exported surface handle
	Handle string
}

// Opcode returns the event opcode for zxdg_exported_v1.handle in xdg_foreign_unstable_v1
func (ZxdgExportedV1HandleEvent) Opcode() uint16 { return 0 }

// Ensure ZxdgExportedV1HandleEvent implements Message.
var _ Message = ZxdgExportedV1HandleEvent{}

// Scan scans the event from the socket.
func (e *ZxdgExportedV1HandleEvent) Scan(s *EventScanner) error {
	if v, err := s.String(); err != nil {
		return err
	} else {
		e.Handle = v
	}
	return nil
}

// Ensure ZxdgExportedV1HandleEvent implements Event.
var _ Event = &ZxdgExportedV1HandleEvent{}

// #endregion Interface xdg_foreign_unstable_v1.zxdg_exported_v1

// ----------------------------------------------------------------------------
// #region Interface xdg_foreign_unstable_v1.zxdg_imported_v1

// ZxdgImportedV1DestroyRequest requests to destroy the xdg_imported object
//
// Notify the compositor that it will no longer use the xdg_imported
// object. Any relationship that may have been set up will at this point
// be invalidated.
type ZxdgImportedV1DestroyRequest struct {
}

// Opcode returns the request opcode for zxdg_imported_v1.destroy in xdg_foreign_unstable_v1
func (ZxdgImportedV1DestroyRequest) Opcode() uint16 { return 0 }

// Ensure ZxdgImportedV1DestroyRequest implements Message.
var _ Message = ZxdgImportedV1DestroyRequest{}

// ZxdgImportedV1SetParentOfRequest requests to set as the parent of some surface
//
// Set the imported surface as the parent of some surface of the client.
// The passed surface must be a toplevel xdg_surface. Calling this function
// sets up a surface to surface relation with the same stacking and positioning
// semantics as xdg_surface.set_parent.
type ZxdgImportedV1SetParentOfRequest struct {
	// Surface contains the child surface
	Surface ObjectID
}

// Opcode returns the request opcode for zxdg_imported_v1.set_parent_of in xdg_foreign_unstable_v1
func (ZxdgImportedV1SetParentOfRequest) Opcode() uint16 { return 1 }

// Ensure ZxdgImportedV1SetParentOfRequest implements Message.
var _ Message = ZxdgImportedV1SetParentOfRequest{}

// ZxdgImportedV1DestroyedEvent signals when the imported surface handle has been destroyed
//
// The imported surface handle has been destroyed and any relationship set
// up has been invalidated. This may happen for various reasons, for
// example if the exported surface or the exported surface handle has been
// destroyed, if the handle used for importing was invalid.
type ZxdgImportedV1DestroyedEvent struct {
}

// Opcode returns the event opcode for zxdg_imported_v1.destroyed in xdg_foreign_unstable_v1
func (ZxdgImportedV1DestroyedEvent) Opcode() uint16 { return 0 }

// Ensure ZxdgImportedV1DestroyedEvent implements Message.
var _ Message = ZxdgImportedV1DestroyedEvent{}

// Scan scans the event from the socket.
func (e *ZxdgImportedV1DestroyedEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure ZxdgImportedV1DestroyedEvent implements Event.
var _ Event = &ZxdgImportedV1DestroyedEvent{}

// #endregion Interface xdg_foreign_unstable_v1.zxdg_imported_v1

////////////////////////////////////////////////////////////////////////////////
// #endregion Protocol xdg_foreign_unstable_v1

////////////////////////////////////////////////////////////////////////////////
// #region Protocol xdg_foreign_unstable_v2

// ----------------------------------------------------------------------------
// #region Interface xdg_foreign_unstable_v2.zxdg_exporter_v2

// ZxdgExporterV2Error represents error values
//
// These errors can be emitted in response to invalid xdg_exporter
// requests.
type ZxdgExporterV2Error int

const (
	// ZxdgExporterV2ErrorInvalidSurface corresponds to surface is not an xdg_toplevel
	ZxdgExporterV2ErrorInvalidSurface ZxdgExporterV2Error = 0
)

// ZxdgExporterV2DestroyRequest requests to destroy the xdg_exporter object
//
// Notify the compositor that the xdg_exporter object will no longer be
// used.
type ZxdgExporterV2DestroyRequest struct {
}

// Opcode returns the request opcode for zxdg_exporter_v2.destroy in xdg_foreign_unstable_v2
func (ZxdgExporterV2DestroyRequest) Opcode() uint16 { return 0 }

// Ensure ZxdgExporterV2DestroyRequest implements Message.
var _ Message = ZxdgExporterV2DestroyRequest{}

// ZxdgExporterV2ExportToplevelRequest requests to export a toplevel surface
//
// The export_toplevel request exports the passed surface so that it can later be
// imported via xdg_importer. When called, a new xdg_exported object will
// be created and xdg_exported.handle will be sent immediately. See the
// corresponding interface and event for details.
//
// A surface may be exported multiple times, and each exported handle may
// be used to create an xdg_imported multiple times. Only xdg_toplevel
// equivalent surfaces may be exported, otherwise an invalid_surface
// protocol error is sent.
type ZxdgExporterV2ExportToplevelRequest struct {
	// ID contains the new xdg_exported object
	ID ObjectID

	// Surface contains the surface to export
	Surface ObjectID
}

// Opcode returns the request opcode for zxdg_exporter_v2.export_toplevel in xdg_foreign_unstable_v2
func (ZxdgExporterV2ExportToplevelRequest) Opcode() uint16 { return 1 }

// Ensure ZxdgExporterV2ExportToplevelRequest implements Message.
var _ Message = ZxdgExporterV2ExportToplevelRequest{}

// #endregion Interface xdg_foreign_unstable_v2.zxdg_exporter_v2

// ----------------------------------------------------------------------------
// #region Interface xdg_foreign_unstable_v2.zxdg_importer_v2

// ZxdgImporterV2DestroyRequest requests to destroy the xdg_importer object
//
// Notify the compositor that the xdg_importer object will no longer be
// used.
type ZxdgImporterV2DestroyRequest struct {
}

// Opcode returns the request opcode for zxdg_importer_v2.destroy in xdg_foreign_unstable_v2
func (ZxdgImporterV2DestroyRequest) Opcode() uint16 { return 0 }

// Ensure ZxdgImporterV2DestroyRequest implements Message.
var _ Message = ZxdgImporterV2DestroyRequest{}

// ZxdgImporterV2ImportToplevelRequest requests to import a toplevel surface
//
// The import_toplevel request imports a surface from any client given a handle
// retrieved by exporting said surface using xdg_exporter.export_toplevel.
// When called, a new xdg_imported object will be created. This new object
// represents the imported surface, and the importing client can
// manipulate its relationship using it. See xdg_imported for details.
type ZxdgImporterV2ImportToplevelRequest struct {
	// ID contains the new xdg_imported object
	ID ObjectID

	// Handle contains the exported surface handle
	Handle string
}

// Opcode returns the request opcode for zxdg_importer_v2.import_toplevel in xdg_foreign_unstable_v2
func (ZxdgImporterV2ImportToplevelRequest) Opcode() uint16 { return 1 }

// Ensure ZxdgImporterV2ImportToplevelRequest implements Message.
var _ Message = ZxdgImporterV2ImportToplevelRequest{}

// #endregion Interface xdg_foreign_unstable_v2.zxdg_importer_v2

// ----------------------------------------------------------------------------
// #region Interface xdg_foreign_unstable_v2.zxdg_exported_v2

// ZxdgExportedV2DestroyRequest requests to unexport the exported surface
//
// Revoke the previously exported surface. This invalidates any
// relationship the importer may have set up using the xdg_imported created
// given the handle sent via xdg_exported.handle.
type ZxdgExportedV2DestroyRequest struct {
}

// Opcode returns the request opcode for zxdg_exported_v2.destroy in xdg_foreign_unstable_v2
func (ZxdgExportedV2DestroyRequest) Opcode() uint16 { return 0 }

// Ensure ZxdgExportedV2DestroyRequest implements Message.
var _ Message = ZxdgExportedV2DestroyRequest{}

// ZxdgExportedV2HandleEvent signals when the exported surface handle
//
// The handle event contains the unique handle of this exported surface
// reference. It may be shared with any client, which then can use it to
// import the surface by calling xdg_importer.import_toplevel. A handle
// may be used to import the surface multiple times.
type ZxdgExportedV2HandleEvent struct {
	// Handle contains the exported surface handle
	Handle string
}

// Opcode returns the event opcode for zxdg_exported_v2.handle in xdg_foreign_unstable_v2
func (ZxdgExportedV2HandleEvent) Opcode() uint16 { return 0 }

// Ensure ZxdgExportedV2HandleEvent implements Message.
var _ Message = ZxdgExportedV2HandleEvent{}

// Scan scans the event from the socket.
func (e *ZxdgExportedV2HandleEvent) Scan(s *EventScanner) error {
	if v, err := s.String(); err != nil {
		return err
	} else {
		e.Handle = v
	}
	return nil
}

// Ensure ZxdgExportedV2HandleEvent implements Event.
var _ Event = &ZxdgExportedV2HandleEvent{}

// #endregion Interface xdg_foreign_unstable_v2.zxdg_exported_v2

// ----------------------------------------------------------------------------
// #region Interface xdg_foreign_unstable_v2.zxdg_imported_v2

// ZxdgImportedV2Error represents error values
//
// These errors can be emitted in response to invalid xdg_imported
// requests.
type ZxdgImportedV2Error int

const (
	// ZxdgImportedV2ErrorInvalidSurface corresponds to surface is not an xdg_toplevel
	ZxdgImportedV2ErrorInvalidSurface ZxdgImportedV2Error = 0
)

// ZxdgImportedV2DestroyRequest requests to destroy the xdg_imported object
//
// Notify the compositor that it will no longer use the xdg_imported
// object. Any relationship that may have been set up will at this point
// be invalidated.
type ZxdgImportedV2DestroyRequest struct {
}

// Opcode returns the request opcode for zxdg_imported_v2.destroy in xdg_foreign_unstable_v2
func (ZxdgImportedV2DestroyRequest) Opcode() uint16 { return 0 }

// Ensure ZxdgImportedV2DestroyRequest implements Message.
var _ Message = ZxdgImportedV2DestroyRequest{}

// ZxdgImportedV2SetParentOfRequest requests to set as the parent of some surface
//
// Set the imported surface as the parent of some surface of the client.
// The passed surface must be an xdg_toplevel equivalent, otherwise an
// invalid_surface protocol error is sent. Calling this function sets up
// a surface to surface relation with the same stacking and positioning
// semantics as xdg_toplevel.set_parent.
type ZxdgImportedV2SetParentOfRequest struct {
	// Surface contains the child surface
	Surface ObjectID
}

// Opcode returns the request opcode for zxdg_imported_v2.set_parent_of in xdg_foreign_unstable_v2
func (ZxdgImportedV2SetParentOfRequest) Opcode() uint16 { return 1 }

// Ensure ZxdgImportedV2SetParentOfRequest implements Message.
var _ Message = ZxdgImportedV2SetParentOfRequest{}

// ZxdgImportedV2DestroyedEvent signals when the imported surface handle has been destroyed
//
// The imported surface handle has been destroyed and any relationship set
// up has been invalidated. This may happen for various reasons, for
// example if the exported surface or the exported surface handle has been
// destroyed, if the handle used for importing was invalid.
type ZxdgImportedV2DestroyedEvent struct {
}

// Opcode returns the event opcode for zxdg_imported_v2.destroyed in xdg_foreign_unstable_v2
func (ZxdgImportedV2DestroyedEvent) Opcode() uint16 { return 0 }

// Ensure ZxdgImportedV2DestroyedEvent implements Message.
var _ Message = ZxdgImportedV2DestroyedEvent{}

// Scan scans the event from the socket.
func (e *ZxdgImportedV2DestroyedEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure ZxdgImportedV2DestroyedEvent implements Event.
var _ Event = &ZxdgImportedV2DestroyedEvent{}

// #endregion Interface xdg_foreign_unstable_v2.zxdg_imported_v2

////////////////////////////////////////////////////////////////////////////////
// #endregion Protocol xdg_foreign_unstable_v2

////////////////////////////////////////////////////////////////////////////////
// #region Protocol xdg_output_unstable_v1

// ----------------------------------------------------------------------------
// #region Interface xdg_output_unstable_v1.zxdg_output_manager_v1

// ZxdgOutputManagerV1DestroyRequest requests to destroy the xdg_output_manager object
//
// Using this request a client can tell the server that it is not
// going to use the xdg_output_manager object anymore.
//
// Any objects already created through this instance are not affected.
type ZxdgOutputManagerV1DestroyRequest struct {
}

// Opcode returns the request opcode for zxdg_output_manager_v1.destroy in xdg_output_unstable_v1
func (ZxdgOutputManagerV1DestroyRequest) Opcode() uint16 { return 0 }

// Ensure ZxdgOutputManagerV1DestroyRequest implements Message.
var _ Message = ZxdgOutputManagerV1DestroyRequest{}

// ZxdgOutputManagerV1GetXdgOutputRequest requests to create an xdg output from a wl_output
//
// This creates a new xdg_output object for the given wl_output.
type ZxdgOutputManagerV1GetXdgOutputRequest struct {
	ID ObjectID

	Output ObjectID
}

// Opcode returns the request opcode for zxdg_output_manager_v1.get_xdg_output in xdg_output_unstable_v1
func (ZxdgOutputManagerV1GetXdgOutputRequest) Opcode() uint16 { return 1 }

// Ensure ZxdgOutputManagerV1GetXdgOutputRequest implements Message.
var _ Message = ZxdgOutputManagerV1GetXdgOutputRequest{}

// #endregion Interface xdg_output_unstable_v1.zxdg_output_manager_v1

// ----------------------------------------------------------------------------
// #region Interface xdg_output_unstable_v1.zxdg_output_v1

// ZxdgOutputV1DestroyRequest requests to destroy the xdg_output object
//
// Using this request a client can tell the server that it is not
// going to use the xdg_output object anymore.
type ZxdgOutputV1DestroyRequest struct {
}

// Opcode returns the request opcode for zxdg_output_v1.destroy in xdg_output_unstable_v1
func (ZxdgOutputV1DestroyRequest) Opcode() uint16 { return 0 }

// Ensure ZxdgOutputV1DestroyRequest implements Message.
var _ Message = ZxdgOutputV1DestroyRequest{}

// ZxdgOutputV1LogicalPositionEvent signals when position of the output within the global compositor space
//
// The position event describes the location of the wl_output within
// the global compositor space.
//
// The logical_position event is sent after creating an xdg_output
// (see xdg_output_manager.get_xdg_output) and whenever the location
// of the output changes within the global compositor space.
type ZxdgOutputV1LogicalPositionEvent struct {
	// X contains x position within the global compositor space
	X int32

	// Y contains y position within the global compositor space
	Y int32
}

// Opcode returns the event opcode for zxdg_output_v1.logical_position in xdg_output_unstable_v1
func (ZxdgOutputV1LogicalPositionEvent) Opcode() uint16 { return 0 }

// Ensure ZxdgOutputV1LogicalPositionEvent implements Message.
var _ Message = ZxdgOutputV1LogicalPositionEvent{}

// Scan scans the event from the socket.
func (e *ZxdgOutputV1LogicalPositionEvent) Scan(s *EventScanner) error {
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.X = v
	}
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.Y = v
	}
	return nil
}

// Ensure ZxdgOutputV1LogicalPositionEvent implements Event.
var _ Event = &ZxdgOutputV1LogicalPositionEvent{}

// ZxdgOutputV1LogicalSizeEvent signals when size of the output in the global compositor space
//
// The logical_size event describes the size of the output in the
// global compositor space.
//
// For example, a surface without any buffer scale, transformation
// nor rotation set, with the size matching the logical_size will
// have the same size as the corresponding output when displayed.
//
// Most regular Wayland clients should not pay attention to the
// logical size and would rather rely on xdg_shell interfaces.
//
// Some clients such as Xwayland, however, need this to configure
// their surfaces in the global compositor space as the compositor
// may apply a different scale from what is advertised by the output
// scaling property (to achieve fractional scaling, for example).
//
// For example, for a wl_output mode 38402160 and a scale factor 2:
//
// - A compositor not scaling the surface buffers will advertise a
// logical size of 38402160,
//
// - A compositor automatically scaling the surface buffers will
// advertise a logical size of 19201080,
//
// - A compositor using a fractional scale of 1.5 will advertise a
// logical size of 25601440.
//
// For example, for a wl_output mode 19201080 and a 90 degree rotation,
// the compositor will advertise a logical size of 1080x1920.
//
// The logical_size event is sent after creating an xdg_output
// (see xdg_output_manager.get_xdg_output) and whenever the logical
// size of the output changes, either as a result of a change in the
// applied scale or because of a change in the corresponding output
// mode(see wl_output.mode) or transform (see wl_output.transform).
type ZxdgOutputV1LogicalSizeEvent struct {
	// Width contains width in global compositor space
	Width int32

	// Height contains height in global compositor space
	Height int32
}

// Opcode returns the event opcode for zxdg_output_v1.logical_size in xdg_output_unstable_v1
func (ZxdgOutputV1LogicalSizeEvent) Opcode() uint16 { return 1 }

// Ensure ZxdgOutputV1LogicalSizeEvent implements Message.
var _ Message = ZxdgOutputV1LogicalSizeEvent{}

// Scan scans the event from the socket.
func (e *ZxdgOutputV1LogicalSizeEvent) Scan(s *EventScanner) error {
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.Width = v
	}
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.Height = v
	}
	return nil
}

// Ensure ZxdgOutputV1LogicalSizeEvent implements Event.
var _ Event = &ZxdgOutputV1LogicalSizeEvent{}

// ZxdgOutputV1DoneEvent signals when all information about the output have been sent
//
// This event is sent after all other properties of an xdg_output
// have been sent.
//
// This allows changes to the xdg_output properties to be seen as
// atomic, even if they happen via multiple events.
//
// For objects version 3 onwards, this event is deprecated. Compositors
// are not required to send it anymore and must send wl_output.done
// instead.
type ZxdgOutputV1DoneEvent struct {
}

// Opcode returns the event opcode for zxdg_output_v1.done in xdg_output_unstable_v1
func (ZxdgOutputV1DoneEvent) Opcode() uint16 { return 2 }

// Ensure ZxdgOutputV1DoneEvent implements Message.
var _ Message = ZxdgOutputV1DoneEvent{}

// Scan scans the event from the socket.
func (e *ZxdgOutputV1DoneEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure ZxdgOutputV1DoneEvent implements Event.
var _ Event = &ZxdgOutputV1DoneEvent{}

// ZxdgOutputV1NameEvent signals when name of this output
//
// Many compositors will assign names to their outputs, show them to the
// user, allow them to be configured by name, etc. The client may wish to
// know this name as well to offer the user similar behaviors.
//
// The naming convention is compositor defined, but limited to
// alphanumeric characters and dashes (-). Each name is unique among all
// wl_output globals, but if a wl_output global is destroyed the same name
// may be reused later. The names will also remain consistent across
// sessions with the same hardware and software configuration.
//
// Examples of names include 'HDMI-A-1', 'WL-1', 'X11-1', etc. However, do
// not assume that the name is a reflection of an underlying DRM
// connector, X11 connection, etc.
//
// The name event is sent after creating an xdg_output (see
// xdg_output_manager.get_xdg_output). This event is only sent once per
// xdg_output, and the name does not change over the lifetime of the
// wl_output global.
type ZxdgOutputV1NameEvent struct {
	// Name contains output name
	Name string
}

// Opcode returns the event opcode for zxdg_output_v1.name in xdg_output_unstable_v1
func (ZxdgOutputV1NameEvent) Opcode() uint16 { return 3 }

// Ensure ZxdgOutputV1NameEvent implements Message.
var _ Message = ZxdgOutputV1NameEvent{}

// Scan scans the event from the socket.
func (e *ZxdgOutputV1NameEvent) Scan(s *EventScanner) error {
	if v, err := s.String(); err != nil {
		return err
	} else {
		e.Name = v
	}
	return nil
}

// Ensure ZxdgOutputV1NameEvent implements Event.
var _ Event = &ZxdgOutputV1NameEvent{}

// ZxdgOutputV1DescriptionEvent signals when human-readable description of this output
//
// Many compositors can produce human-readable descriptions of their
// outputs.  The client may wish to know this description as well, to
// communicate the user for various purposes.
//
// The description is a UTF-8 string with no convention defined for its
// contents. Examples might include 'Foocorp 11" Display' or 'Virtual X11
// output via :1'.
//
// The description event is sent after creating an xdg_output (see
// xdg_output_manager.get_xdg_output) and whenever the description
// changes. The description is optional, and may not be sent at all.
//
// For objects of version 2 and lower, this event is only sent once per
// xdg_output, and the description does not change over the lifetime of
// the wl_output global.
type ZxdgOutputV1DescriptionEvent struct {
	// Description contains output description
	Description string
}

// Opcode returns the event opcode for zxdg_output_v1.description in xdg_output_unstable_v1
func (ZxdgOutputV1DescriptionEvent) Opcode() uint16 { return 4 }

// Ensure ZxdgOutputV1DescriptionEvent implements Message.
var _ Message = ZxdgOutputV1DescriptionEvent{}

// Scan scans the event from the socket.
func (e *ZxdgOutputV1DescriptionEvent) Scan(s *EventScanner) error {
	if v, err := s.String(); err != nil {
		return err
	} else {
		e.Description = v
	}
	return nil
}

// Ensure ZxdgOutputV1DescriptionEvent implements Event.
var _ Event = &ZxdgOutputV1DescriptionEvent{}

// #endregion Interface xdg_output_unstable_v1.zxdg_output_v1

////////////////////////////////////////////////////////////////////////////////
// #endregion Protocol xdg_output_unstable_v1

////////////////////////////////////////////////////////////////////////////////
// #region Protocol xdg_shell

// ----------------------------------------------------------------------------
// #region Interface xdg_shell.xdg_wm_base

type XdgWmBaseError int

const (
	// XdgWmBaseErrorRole corresponds to given wl_surface has another role
	XdgWmBaseErrorRole XdgWmBaseError = 0

	// XdgWmBaseErrorDefunctSurfaces corresponds to xdg_wm_base was destroyed before children
	XdgWmBaseErrorDefunctSurfaces XdgWmBaseError = 1

	// XdgWmBaseErrorNotTheTopmostPopup corresponds to the client tried to map or destroy a non-topmost popup
	XdgWmBaseErrorNotTheTopmostPopup XdgWmBaseError = 2

	// XdgWmBaseErrorInvalidPopupParent corresponds to the client specified an invalid popup parent surface
	XdgWmBaseErrorInvalidPopupParent XdgWmBaseError = 3

	// XdgWmBaseErrorInvalidSurfaceState corresponds to the client provided an invalid surface state
	XdgWmBaseErrorInvalidSurfaceState XdgWmBaseError = 4

	// XdgWmBaseErrorInvalidPositioner corresponds to the client provided an invalid positioner
	XdgWmBaseErrorInvalidPositioner XdgWmBaseError = 5
)

// XdgWmBaseDestroyRequest requests to destroy xdg_wm_base
//
// Destroy this xdg_wm_base object.
//
// Destroying a bound xdg_wm_base object while there are surfaces
// still alive created by this xdg_wm_base object instance is illegal
// and will result in a protocol error.
type XdgWmBaseDestroyRequest struct {
}

// Opcode returns the request opcode for xdg_wm_base.destroy in xdg_shell
func (XdgWmBaseDestroyRequest) Opcode() uint16 { return 0 }

// Ensure XdgWmBaseDestroyRequest implements Message.
var _ Message = XdgWmBaseDestroyRequest{}

// XdgWmBaseCreatePositionerRequest requests to create a positioner object
//
// Create a positioner object. A positioner object is used to position
// surfaces relative to some parent surface. See the interface description
// and xdg_surface.get_popup for details.
type XdgWmBaseCreatePositionerRequest struct {
	ID ObjectID
}

// Opcode returns the request opcode for xdg_wm_base.create_positioner in xdg_shell
func (XdgWmBaseCreatePositionerRequest) Opcode() uint16 { return 1 }

// Ensure XdgWmBaseCreatePositionerRequest implements Message.
var _ Message = XdgWmBaseCreatePositionerRequest{}

// XdgWmBaseGetXdgSurfaceRequest requests to create a shell surface from a surface
//
// This creates an xdg_surface for the given surface. While xdg_surface
// itself is not a role, the corresponding surface may only be assigned
// a role extending xdg_surface, such as xdg_toplevel or xdg_popup. It is
// illegal to create an xdg_surface for a wl_surface which already has an
// assigned role and this will result in a protocol error.
//
// This creates an xdg_surface for the given surface. An xdg_surface is
// used as basis to define a role to a given surface, such as xdg_toplevel
// or xdg_popup. It also manages functionality shared between xdg_surface
// based surface roles.
//
// See the documentation of xdg_surface for more details about what an
// xdg_surface is and how it is used.
type XdgWmBaseGetXdgSurfaceRequest struct {
	ID ObjectID

	Surface ObjectID
}

// Opcode returns the request opcode for xdg_wm_base.get_xdg_surface in xdg_shell
func (XdgWmBaseGetXdgSurfaceRequest) Opcode() uint16 { return 2 }

// Ensure XdgWmBaseGetXdgSurfaceRequest implements Message.
var _ Message = XdgWmBaseGetXdgSurfaceRequest{}

// XdgWmBasePongRequest requests to respond to a ping event
//
// A client must respond to a ping event with a pong request or
// the client may be deemed unresponsive. See xdg_wm_base.ping.
type XdgWmBasePongRequest struct {
	// Serial contains serial of the ping event
	Serial uint32
}

// Opcode returns the request opcode for xdg_wm_base.pong in xdg_shell
func (XdgWmBasePongRequest) Opcode() uint16 { return 3 }

// Ensure XdgWmBasePongRequest implements Message.
var _ Message = XdgWmBasePongRequest{}

// XdgWmBasePingEvent signals when check if the client is alive
//
// The ping event asks the client if it's still alive. Pass the
// serial specified in the event back to the compositor by sending
// a "pong" request back with the specified serial. See xdg_wm_base.pong.
//
// Compositors can use this to determine if the client is still
// alive. It's unspecified what will happen if the client doesn't
// respond to the ping request, or in what timeframe. Clients should
// try to respond in a reasonable amount of time.
//
// A compositor is free to ping in any way it wants, but a client must
// always respond to any xdg_wm_base object it created.
type XdgWmBasePingEvent struct {
	// Serial contains pass this to the pong request
	Serial uint32
}

// Opcode returns the event opcode for xdg_wm_base.ping in xdg_shell
func (XdgWmBasePingEvent) Opcode() uint16 { return 0 }

// Ensure XdgWmBasePingEvent implements Message.
var _ Message = XdgWmBasePingEvent{}

// Scan scans the event from the socket.
func (e *XdgWmBasePingEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Serial = v
	}
	return nil
}

// Ensure XdgWmBasePingEvent implements Event.
var _ Event = &XdgWmBasePingEvent{}

// #endregion Interface xdg_shell.xdg_wm_base

// ----------------------------------------------------------------------------
// #region Interface xdg_shell.xdg_positioner

type XdgPositionerError int

const (
	// XdgPositionerErrorInvalidInput corresponds to invalid input provided
	XdgPositionerErrorInvalidInput XdgPositionerError = 0
)

type XdgPositionerAnchor int

const (
	XdgPositionerAnchorNone XdgPositionerAnchor = 0

	XdgPositionerAnchorTop XdgPositionerAnchor = 1

	XdgPositionerAnchorBottom XdgPositionerAnchor = 2

	XdgPositionerAnchorLeft XdgPositionerAnchor = 3

	XdgPositionerAnchorRight XdgPositionerAnchor = 4

	XdgPositionerAnchorTopLeft XdgPositionerAnchor = 5

	XdgPositionerAnchorBottomLeft XdgPositionerAnchor = 6

	XdgPositionerAnchorTopRight XdgPositionerAnchor = 7

	XdgPositionerAnchorBottomRight XdgPositionerAnchor = 8
)

type XdgPositionerGravity int

const (
	XdgPositionerGravityNone XdgPositionerGravity = 0

	XdgPositionerGravityTop XdgPositionerGravity = 1

	XdgPositionerGravityBottom XdgPositionerGravity = 2

	XdgPositionerGravityLeft XdgPositionerGravity = 3

	XdgPositionerGravityRight XdgPositionerGravity = 4

	XdgPositionerGravityTopLeft XdgPositionerGravity = 5

	XdgPositionerGravityBottomLeft XdgPositionerGravity = 6

	XdgPositionerGravityTopRight XdgPositionerGravity = 7

	XdgPositionerGravityBottomRight XdgPositionerGravity = 8
)

// XdgPositionerConstraintAdjustment represents constraint adjustments
//
// The constraint adjustment value define ways the compositor will adjust
// the position of the surface, if the unadjusted position would result
// in the surface being partly constrained.
//
// Whether a surface is considered 'constrained' is left to the compositor
// to determine. For example, the surface may be partly outside the
// compositor's defined 'work area', thus necessitating the child surface's
// position be adjusted until it is entirely inside the work area.
//
// The adjustments can be combined, according to a defined precedence: 1)
// Flip, 2) Slide, 3) Resize.
type XdgPositionerConstraintAdjustment uint

const (
	XdgPositionerConstraintAdjustmentNone XdgPositionerConstraintAdjustment = 0

	XdgPositionerConstraintAdjustmentSlideX XdgPositionerConstraintAdjustment = 1

	XdgPositionerConstraintAdjustmentSlideY XdgPositionerConstraintAdjustment = 2

	XdgPositionerConstraintAdjustmentFlipX XdgPositionerConstraintAdjustment = 4

	XdgPositionerConstraintAdjustmentFlipY XdgPositionerConstraintAdjustment = 8

	XdgPositionerConstraintAdjustmentResizeX XdgPositionerConstraintAdjustment = 16

	XdgPositionerConstraintAdjustmentResizeY XdgPositionerConstraintAdjustment = 32
)

// XdgPositionerDestroyRequest requests to destroy the xdg_positioner object
//
// Notify the compositor that the xdg_positioner will no longer be used.
type XdgPositionerDestroyRequest struct {
}

// Opcode returns the request opcode for xdg_positioner.destroy in xdg_shell
func (XdgPositionerDestroyRequest) Opcode() uint16 { return 0 }

// Ensure XdgPositionerDestroyRequest implements Message.
var _ Message = XdgPositionerDestroyRequest{}

// XdgPositionerSetSizeRequest requests to set the size of the to-be positioned rectangle
//
// Set the size of the surface that is to be positioned with the positioner
// object. The size is in surface-local coordinates and corresponds to the
// window geometry. See xdg_surface.set_window_geometry.
//
// If a zero or negative size is set the invalid_input error is raised.
type XdgPositionerSetSizeRequest struct {
	// Width contains width of positioned rectangle
	Width int32

	// Height contains height of positioned rectangle
	Height int32
}

// Opcode returns the request opcode for xdg_positioner.set_size in xdg_shell
func (XdgPositionerSetSizeRequest) Opcode() uint16 { return 1 }

// Ensure XdgPositionerSetSizeRequest implements Message.
var _ Message = XdgPositionerSetSizeRequest{}

// XdgPositionerSetAnchorRectRequest requests to set the anchor rectangle within the parent surface
//
// Specify the anchor rectangle within the parent surface that the child
// surface will be placed relative to. The rectangle is relative to the
// window geometry as defined by xdg_surface.set_window_geometry of the
// parent surface.
//
// When the xdg_positioner object is used to position a child surface, the
// anchor rectangle may not extend outside the window geometry of the
// positioned child's parent surface.
//
// If a negative size is set the invalid_input error is raised.
type XdgPositionerSetAnchorRectRequest struct {
	// X contains x position of anchor rectangle
	X int32

	// Y contains y position of anchor rectangle
	Y int32

	// Width contains width of anchor rectangle
	Width int32

	// Height contains height of anchor rectangle
	Height int32
}

// Opcode returns the request opcode for xdg_positioner.set_anchor_rect in xdg_shell
func (XdgPositionerSetAnchorRectRequest) Opcode() uint16 { return 2 }

// Ensure XdgPositionerSetAnchorRectRequest implements Message.
var _ Message = XdgPositionerSetAnchorRectRequest{}

// XdgPositionerSetAnchorRequest requests to set anchor rectangle anchor
//
// Defines the anchor point for the anchor rectangle. The specified anchor
// is used derive an anchor point that the child surface will be
// positioned relative to. If a corner anchor is set (e.g. 'top_left' or
// 'bottom_right'), the anchor point will be at the specified corner;
// otherwise, the derived anchor point will be centered on the specified
// edge, or in the center of the anchor rectangle if no edge is specified.
type XdgPositionerSetAnchorRequest struct {
	// Anchor contains anchor
	Anchor uint32
}

// Opcode returns the request opcode for xdg_positioner.set_anchor in xdg_shell
func (XdgPositionerSetAnchorRequest) Opcode() uint16 { return 3 }

// Ensure XdgPositionerSetAnchorRequest implements Message.
var _ Message = XdgPositionerSetAnchorRequest{}

// XdgPositionerSetGravityRequest requests to set child surface gravity
//
// Defines in what direction a surface should be positioned, relative to
// the anchor point of the parent surface. If a corner gravity is
// specified (e.g. 'bottom_right' or 'top_left'), then the child surface
// will be placed towards the specified gravity; otherwise, the child
// surface will be centered over the anchor point on any axis that had no
// gravity specified.
type XdgPositionerSetGravityRequest struct {
	// Gravity contains gravity direction
	Gravity uint32
}

// Opcode returns the request opcode for xdg_positioner.set_gravity in xdg_shell
func (XdgPositionerSetGravityRequest) Opcode() uint16 { return 4 }

// Ensure XdgPositionerSetGravityRequest implements Message.
var _ Message = XdgPositionerSetGravityRequest{}

// XdgPositionerSetConstraintAdjustmentRequest requests to set the adjustment to be done when constrained
//
// Specify how the window should be positioned if the originally intended
// position caused the surface to be constrained, meaning at least
// partially outside positioning boundaries set by the compositor. The
// adjustment is set by constructing a bitmask describing the adjustment to
// be made when the surface is constrained on that axis.
//
// If no bit for one axis is set, the compositor will assume that the child
// surface should not change its position on that axis when constrained.
//
// If more than one bit for one axis is set, the order of how adjustments
// are applied is specified in the corresponding adjustment descriptions.
//
// The default adjustment is none.
type XdgPositionerSetConstraintAdjustmentRequest struct {
	// ConstraintAdjustment contains bit mask of constraint adjustments
	ConstraintAdjustment uint32
}

// Opcode returns the request opcode for xdg_positioner.set_constraint_adjustment in xdg_shell
func (XdgPositionerSetConstraintAdjustmentRequest) Opcode() uint16 { return 5 }

// Ensure XdgPositionerSetConstraintAdjustmentRequest implements Message.
var _ Message = XdgPositionerSetConstraintAdjustmentRequest{}

// XdgPositionerSetOffsetRequest requests to set surface position offset
//
// Specify the surface position offset relative to the position of the
// anchor on the anchor rectangle and the anchor on the surface. For
// example if the anchor of the anchor rectangle is at (x, y), the surface
// has the gravity bottom|right, and the offset is (ox, oy), the calculated
// surface position will be (x + ox, y + oy). The offset position of the
// surface is the one used for constraint testing. See
// set_constraint_adjustment.
//
// An example use case is placing a popup menu on top of a user interface
// element, while aligning the user interface element of the parent surface
// with some user interface element placed somewhere in the popup surface.
type XdgPositionerSetOffsetRequest struct {
	// X contains surface position x offset
	X int32

	// Y contains surface position y offset
	Y int32
}

// Opcode returns the request opcode for xdg_positioner.set_offset in xdg_shell
func (XdgPositionerSetOffsetRequest) Opcode() uint16 { return 6 }

// Ensure XdgPositionerSetOffsetRequest implements Message.
var _ Message = XdgPositionerSetOffsetRequest{}

// XdgPositionerSetReactiveRequest requests to continuously reconstrain the surface
//
// When set reactive, the surface is reconstrained if the conditions used
// for constraining changed, e.g. the parent window moved.
//
// If the conditions changed and the popup was reconstrained, an
// xdg_popup.configure event is sent with updated geometry, followed by an
// xdg_surface.configure event.
type XdgPositionerSetReactiveRequest struct {
}

// Opcode returns the request opcode for xdg_positioner.set_reactive in xdg_shell
func (XdgPositionerSetReactiveRequest) Opcode() uint16 { return 7 }

// Ensure XdgPositionerSetReactiveRequest implements Message.
var _ Message = XdgPositionerSetReactiveRequest{}

type XdgPositionerSetParentSizeRequest struct {
	// ParentWidth contains future window geometry width of parent
	ParentWidth int32

	// ParentHeight contains future window geometry height of parent
	ParentHeight int32
}

// Opcode returns the request opcode for xdg_positioner.set_parent_size in xdg_shell
func (XdgPositionerSetParentSizeRequest) Opcode() uint16 { return 8 }

// Ensure XdgPositionerSetParentSizeRequest implements Message.
var _ Message = XdgPositionerSetParentSizeRequest{}

// XdgPositionerSetParentConfigureRequest requests to set parent configure this is a response to
//
// Set the serial of an xdg_surface.configure event this positioner will be
// used in response to. The compositor may use this information together
// with set_parent_size to determine what future state the popup should be
// constrained using.
type XdgPositionerSetParentConfigureRequest struct {
	// Serial contains serial of parent configure event
	Serial uint32
}

// Opcode returns the request opcode for xdg_positioner.set_parent_configure in xdg_shell
func (XdgPositionerSetParentConfigureRequest) Opcode() uint16 { return 9 }

// Ensure XdgPositionerSetParentConfigureRequest implements Message.
var _ Message = XdgPositionerSetParentConfigureRequest{}

// #endregion Interface xdg_shell.xdg_positioner

// ----------------------------------------------------------------------------
// #region Interface xdg_shell.xdg_surface

type XdgSurfaceError int

const (
	XdgSurfaceErrorNotConstructed XdgSurfaceError = 1

	XdgSurfaceErrorAlreadyConstructed XdgSurfaceError = 2

	XdgSurfaceErrorUnconfiguredBuffer XdgSurfaceError = 3
)

// XdgSurfaceDestroyRequest requests to destroy the xdg_surface
//
// Destroy the xdg_surface object. An xdg_surface must only be destroyed
// after its role object has been destroyed.
type XdgSurfaceDestroyRequest struct {
}

// Opcode returns the request opcode for xdg_surface.destroy in xdg_shell
func (XdgSurfaceDestroyRequest) Opcode() uint16 { return 0 }

// Ensure XdgSurfaceDestroyRequest implements Message.
var _ Message = XdgSurfaceDestroyRequest{}

// XdgSurfaceGetToplevelRequest requests to assign the xdg_toplevel surface role
//
// This creates an xdg_toplevel object for the given xdg_surface and gives
// the associated wl_surface the xdg_toplevel role.
//
// See the documentation of xdg_toplevel for more details about what an
// xdg_toplevel is and how it is used.
type XdgSurfaceGetToplevelRequest struct {
	ID ObjectID
}

// Opcode returns the request opcode for xdg_surface.get_toplevel in xdg_shell
func (XdgSurfaceGetToplevelRequest) Opcode() uint16 { return 1 }

// Ensure XdgSurfaceGetToplevelRequest implements Message.
var _ Message = XdgSurfaceGetToplevelRequest{}

// XdgSurfaceGetPopupRequest requests to assign the xdg_popup surface role
//
// This creates an xdg_popup object for the given xdg_surface and gives
// the associated wl_surface the xdg_popup role.
//
// If null is passed as a parent, a parent surface must be specified using
// some other protocol, before committing the initial state.
//
// See the documentation of xdg_popup for more details about what an
// xdg_popup is and how it is used.
type XdgSurfaceGetPopupRequest struct {
	ID ObjectID

	Parent ObjectID

	Positioner ObjectID
}

// Opcode returns the request opcode for xdg_surface.get_popup in xdg_shell
func (XdgSurfaceGetPopupRequest) Opcode() uint16 { return 2 }

// Ensure XdgSurfaceGetPopupRequest implements Message.
var _ Message = XdgSurfaceGetPopupRequest{}

// XdgSurfaceSetWindowGeometryRequest requests to set the new window geometry
//
// The window geometry of a surface is its "visible bounds" from the
// user's perspective. Client-side decorations often have invisible
// portions like drop-shadows which should be ignored for the
// purposes of aligning, placing and constraining windows.
//
// The window geometry is double buffered, and will be applied at the
// time wl_surface.commit of the corresponding wl_surface is called.
//
// When maintaining a position, the compositor should treat the (x, y)
// coordinate of the window geometry as the top left corner of the window.
// A client changing the (x, y) window geometry coordinate should in
// general not alter the position of the window.
//
// Once the window geometry of the surface is set, it is not possible to
// unset it, and it will remain the same until set_window_geometry is
// called again, even if a new subsurface or buffer is attached.
//
// If never set, the value is the full bounds of the surface,
// including any subsurfaces. This updates dynamically on every
// commit. This unset is meant for extremely simple clients.
//
// The arguments are given in the surface-local coordinate space of
// the wl_surface associated with this xdg_surface.
//
// The width and height must be greater than zero. Setting an invalid size
// will raise an error. When applied, the effective window geometry will be
// the set window geometry clamped to the bounding rectangle of the
// combined geometry of the surface of the xdg_surface and the associated
// subsurfaces.
type XdgSurfaceSetWindowGeometryRequest struct {
	X int32

	Y int32

	Width int32

	Height int32
}

// Opcode returns the request opcode for xdg_surface.set_window_geometry in xdg_shell
func (XdgSurfaceSetWindowGeometryRequest) Opcode() uint16 { return 3 }

// Ensure XdgSurfaceSetWindowGeometryRequest implements Message.
var _ Message = XdgSurfaceSetWindowGeometryRequest{}

// XdgSurfaceAckConfigureRequest requests to ack a configure event
//
// When a configure event is received, if a client commits the
// surface in response to the configure event, then the client
// must make an ack_configure request sometime before the commit
// request, passing along the serial of the configure event.
//
// For instance, for toplevel surfaces the compositor might use this
// information to move a surface to the top left only when the client has
// drawn itself for the maximized or fullscreen state.
//
// If the client receives multiple configure events before it
// can respond to one, it only has to ack the last configure event.
//
// A client is not required to commit immediately after sending
// an ack_configure request - it may even ack_configure several times
// before its next surface commit.
//
// A client may send multiple ack_configure requests before committing, but
// only the last request sent before a commit indicates which configure
// event the client really is responding to.
type XdgSurfaceAckConfigureRequest struct {
	// Serial contains the serial from the configure event
	Serial uint32
}

// Opcode returns the request opcode for xdg_surface.ack_configure in xdg_shell
func (XdgSurfaceAckConfigureRequest) Opcode() uint16 { return 4 }

// Ensure XdgSurfaceAckConfigureRequest implements Message.
var _ Message = XdgSurfaceAckConfigureRequest{}

// XdgSurfaceConfigureEvent signals when suggest a surface change
//
// The configure event marks the end of a configure sequence. A configure
// sequence is a set of one or more events configuring the state of the
// xdg_surface, including the final xdg_surface.configure event.
//
// Where applicable, xdg_surface surface roles will during a configure
// sequence extend this event as a latched state sent as events before the
// xdg_surface.configure event. Such events should be considered to make up
// a set of atomically applied configuration states, where the
// xdg_surface.configure commits the accumulated state.
//
// Clients should arrange their surface for the new states, and then send
// an ack_configure request with the serial sent in this configure event at
// some point before committing the new surface.
//
// If the client receives multiple configure events before it can respond
// to one, it is free to discard all but the last event it received.
type XdgSurfaceConfigureEvent struct {
	// Serial contains serial of the configure event
	Serial uint32
}

// Opcode returns the event opcode for xdg_surface.configure in xdg_shell
func (XdgSurfaceConfigureEvent) Opcode() uint16 { return 0 }

// Ensure XdgSurfaceConfigureEvent implements Message.
var _ Message = XdgSurfaceConfigureEvent{}

// Scan scans the event from the socket.
func (e *XdgSurfaceConfigureEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Serial = v
	}
	return nil
}

// Ensure XdgSurfaceConfigureEvent implements Event.
var _ Event = &XdgSurfaceConfigureEvent{}

// #endregion Interface xdg_shell.xdg_surface

// ----------------------------------------------------------------------------
// #region Interface xdg_shell.xdg_toplevel

// XdgToplevelResizeEdge represents edge values for resizing
//
// These values are used to indicate which edge of a surface
// is being dragged in a resize operation.
type XdgToplevelResizeEdge int

const (
	XdgToplevelResizeEdgeNone XdgToplevelResizeEdge = 0

	XdgToplevelResizeEdgeTop XdgToplevelResizeEdge = 1

	XdgToplevelResizeEdgeBottom XdgToplevelResizeEdge = 2

	XdgToplevelResizeEdgeLeft XdgToplevelResizeEdge = 4

	XdgToplevelResizeEdgeTopLeft XdgToplevelResizeEdge = 5

	XdgToplevelResizeEdgeBottomLeft XdgToplevelResizeEdge = 6

	XdgToplevelResizeEdgeRight XdgToplevelResizeEdge = 8

	XdgToplevelResizeEdgeTopRight XdgToplevelResizeEdge = 9

	XdgToplevelResizeEdgeBottomRight XdgToplevelResizeEdge = 10
)

// XdgToplevelState represents types of state on the surface
//
// The different state values used on the surface. This is designed for
// state values like maximized, fullscreen. It is paired with the
// configure event to ensure that both the client and the compositor
// setting the state can be synchronized.
//
// States set in this way are double-buffered. They will get applied on
// the next commit.
type XdgToplevelState int

const (
	// XdgToplevelStateMaximized corresponds to the surface is maximized
	XdgToplevelStateMaximized XdgToplevelState = 1

	// XdgToplevelStateFullscreen corresponds to the surface is fullscreen
	XdgToplevelStateFullscreen XdgToplevelState = 2

	// XdgToplevelStateResizing corresponds to the surface is being resized
	XdgToplevelStateResizing XdgToplevelState = 3

	// XdgToplevelStateActivated corresponds to the surface is now activated
	XdgToplevelStateActivated XdgToplevelState = 4

	XdgToplevelStateTiledLeft XdgToplevelState = 5

	XdgToplevelStateTiledRight XdgToplevelState = 6

	XdgToplevelStateTiledTop XdgToplevelState = 7

	XdgToplevelStateTiledBottom XdgToplevelState = 8
)

// XdgToplevelDestroyRequest requests to destroy the xdg_toplevel
//
// This request destroys the role surface and unmaps the surface;
// see "Unmapping" behavior in interface section for details.
type XdgToplevelDestroyRequest struct {
}

// Opcode returns the request opcode for xdg_toplevel.destroy in xdg_shell
func (XdgToplevelDestroyRequest) Opcode() uint16 { return 0 }

// Ensure XdgToplevelDestroyRequest implements Message.
var _ Message = XdgToplevelDestroyRequest{}

// XdgToplevelSetParentRequest requests to set the parent of this surface
//
// Set the "parent" of this surface. This surface should be stacked
// above the parent surface and all other ancestor surfaces.
//
// Parent windows should be set on dialogs, toolboxes, or other
// "auxiliary" surfaces, so that the parent is raised when the dialog
// is raised.
//
// Setting a null parent for a child window removes any parent-child
// relationship for the child. Setting a null parent for a window which
// currently has no parent is a no-op.
//
// If the parent is unmapped then its children are managed as
// though the parent of the now-unmapped parent has become the
// parent of this surface. If no parent exists for the now-unmapped
// parent then the children are managed as though they have no
// parent surface.
type XdgToplevelSetParentRequest struct {
	Parent ObjectID
}

// Opcode returns the request opcode for xdg_toplevel.set_parent in xdg_shell
func (XdgToplevelSetParentRequest) Opcode() uint16 { return 1 }

// Ensure XdgToplevelSetParentRequest implements Message.
var _ Message = XdgToplevelSetParentRequest{}

// XdgToplevelSetTitleRequest requests to set surface title
//
// Set a short title for the surface.
//
// This string may be used to identify the surface in a task bar,
// window list, or other user interface elements provided by the
// compositor.
//
// The string must be encoded in UTF-8.
type XdgToplevelSetTitleRequest struct {
	Title string
}

// Opcode returns the request opcode for xdg_toplevel.set_title in xdg_shell
func (XdgToplevelSetTitleRequest) Opcode() uint16 { return 2 }

// Ensure XdgToplevelSetTitleRequest implements Message.
var _ Message = XdgToplevelSetTitleRequest{}

// XdgToplevelSetAppIDRequest requests to set application ID
//
// Set an application identifier for the surface.
//
// The app ID identifies the general class of applications to which
// the surface belongs. The compositor can use this to group multiple
// surfaces together, or to determine how to launch a new application.
//
// For D-Bus activatable applications, the app ID is used as the D-Bus
// service name.
//
// The compositor shell will try to group application surfaces together
// by their app ID. As a best practice, it is suggested to select app
// ID's that match the basename of the application's .desktop file.
// For example, "org.freedesktop.FooViewer" where the .desktop file is
// "org.freedesktop.FooViewer.desktop".
//
// Like other properties, a set_app_id request can be sent after the
// xdg_toplevel has been mapped to update the property.
//
// See the desktop-entry specification [0] for more details on
// application identifiers and how they relate to well-known D-Bus
// names and .desktop files.
//
// [0] http://standards.freedesktop.org/desktop-entry-spec/
type XdgToplevelSetAppIDRequest struct {
	AppID string
}

// Opcode returns the request opcode for xdg_toplevel.set_app_id in xdg_shell
func (XdgToplevelSetAppIDRequest) Opcode() uint16 { return 3 }

// Ensure XdgToplevelSetAppIDRequest implements Message.
var _ Message = XdgToplevelSetAppIDRequest{}

// XdgToplevelShowWindowMenuRequest requests to show the window menu
//
// Clients implementing client-side decorations might want to show
// a context menu when right-clicking on the decorations, giving the
// user a menu that they can use to maximize or minimize the window.
//
// This request asks the compositor to pop up such a window menu at
// the given position, relative to the local surface coordinates of
// the parent surface. There are no guarantees as to what menu items
// the window menu contains.
//
// This request must be used in response to some sort of user action
// like a button press, key press, or touch down event.
type XdgToplevelShowWindowMenuRequest struct {
	// Seat contains the wl_seat of the user event
	Seat ObjectID

	// Serial contains the serial of the user event
	Serial uint32

	// X contains the x position to pop up the window menu at
	X int32

	// Y contains the y position to pop up the window menu at
	Y int32
}

// Opcode returns the request opcode for xdg_toplevel.show_window_menu in xdg_shell
func (XdgToplevelShowWindowMenuRequest) Opcode() uint16 { return 4 }

// Ensure XdgToplevelShowWindowMenuRequest implements Message.
var _ Message = XdgToplevelShowWindowMenuRequest{}

// XdgToplevelMoveRequest requests to start an interactive move
//
// Start an interactive, user-driven move of the surface.
//
// This request must be used in response to some sort of user action
// like a button press, key press, or touch down event. The passed
// serial is used to determine the type of interactive move (touch,
// pointer, etc).
//
// The server may ignore move requests depending on the state of
// the surface (e.g. fullscreen or maximized), or if the passed serial
// is no longer valid.
//
// If triggered, the surface will lose the focus of the device
// (wl_pointer, wl_touch, etc) used for the move. It is up to the
// compositor to visually indicate that the move is taking place, such as
// updating a pointer cursor, during the move. There is no guarantee
// that the device focus will return when the move is completed.
type XdgToplevelMoveRequest struct {
	// Seat contains the wl_seat of the user event
	Seat ObjectID

	// Serial contains the serial of the user event
	Serial uint32
}

// Opcode returns the request opcode for xdg_toplevel.move in xdg_shell
func (XdgToplevelMoveRequest) Opcode() uint16 { return 5 }

// Ensure XdgToplevelMoveRequest implements Message.
var _ Message = XdgToplevelMoveRequest{}

// XdgToplevelResizeRequest requests to start an interactive resize
//
// Start a user-driven, interactive resize of the surface.
//
// This request must be used in response to some sort of user action
// like a button press, key press, or touch down event. The passed
// serial is used to determine the type of interactive resize (touch,
// pointer, etc).
//
// The server may ignore resize requests depending on the state of
// the surface (e.g. fullscreen or maximized).
//
// If triggered, the client will receive configure events with the
// "resize" state enum value and the expected sizes. See the "resize"
// enum value for more details about what is required. The client
// must also acknowledge configure events using "ack_configure". After
// the resize is completed, the client will receive another "configure"
// event without the resize state.
//
// If triggered, the surface also will lose the focus of the device
// (wl_pointer, wl_touch, etc) used for the resize. It is up to the
// compositor to visually indicate that the resize is taking place,
// such as updating a pointer cursor, during the resize. There is no
// guarantee that the device focus will return when the resize is
// completed.
//
// The edges parameter specifies how the surface should be resized,
// and is one of the values of the resize_edge enum. The compositor
// may use this information to update the surface position for
// example when dragging the top left corner. The compositor may also
// use this information to adapt its behavior, e.g. choose an
// appropriate cursor image.
type XdgToplevelResizeRequest struct {
	// Seat contains the wl_seat of the user event
	Seat ObjectID

	// Serial contains the serial of the user event
	Serial uint32

	// Edges contains which edge or corner is being dragged
	Edges uint32
}

// Opcode returns the request opcode for xdg_toplevel.resize in xdg_shell
func (XdgToplevelResizeRequest) Opcode() uint16 { return 6 }

// Ensure XdgToplevelResizeRequest implements Message.
var _ Message = XdgToplevelResizeRequest{}

// XdgToplevelSetMaxSizeRequest requests to set the maximum size
//
// Set a maximum size for the window.
//
// The client can specify a maximum size so that the compositor does
// not try to configure the window beyond this size.
//
// The width and height arguments are in window geometry coordinates.
// See xdg_surface.set_window_geometry.
//
// Values set in this way are double-buffered. They will get applied
// on the next commit.
//
// The compositor can use this information to allow or disallow
// different states like maximize or fullscreen and draw accurate
// animations.
//
// Similarly, a tiling window manager may use this information to
// place and resize client windows in a more effective way.
//
// The client should not rely on the compositor to obey the maximum
// size. The compositor may decide to ignore the values set by the
// client and request a larger size.
//
// If never set, or a value of zero in the request, means that the
// client has no expected maximum size in the given dimension.
// As a result, a client wishing to reset the maximum size
// to an unspecified state can use zero for width and height in the
// request.
//
// Requesting a maximum size to be smaller than the minimum size of
// a surface is illegal and will result in a protocol error.
//
// The width and height must be greater than or equal to zero. Using
// strictly negative values for width and height will result in a
// protocol error.
type XdgToplevelSetMaxSizeRequest struct {
	Width int32

	Height int32
}

// Opcode returns the request opcode for xdg_toplevel.set_max_size in xdg_shell
func (XdgToplevelSetMaxSizeRequest) Opcode() uint16 { return 7 }

// Ensure XdgToplevelSetMaxSizeRequest implements Message.
var _ Message = XdgToplevelSetMaxSizeRequest{}

// XdgToplevelSetMinSizeRequest requests to set the minimum size
//
// Set a minimum size for the window.
//
// The client can specify a minimum size so that the compositor does
// not try to configure the window below this size.
//
// The width and height arguments are in window geometry coordinates.
// See xdg_surface.set_window_geometry.
//
// Values set in this way are double-buffered. They will get applied
// on the next commit.
//
// The compositor can use this information to allow or disallow
// different states like maximize or fullscreen and draw accurate
// animations.
//
// Similarly, a tiling window manager may use this information to
// place and resize client windows in a more effective way.
//
// The client should not rely on the compositor to obey the minimum
// size. The compositor may decide to ignore the values set by the
// client and request a smaller size.
//
// If never set, or a value of zero in the request, means that the
// client has no expected minimum size in the given dimension.
// As a result, a client wishing to reset the minimum size
// to an unspecified state can use zero for width and height in the
// request.
//
// Requesting a minimum size to be larger than the maximum size of
// a surface is illegal and will result in a protocol error.
//
// The width and height must be greater than or equal to zero. Using
// strictly negative values for width and height will result in a
// protocol error.
type XdgToplevelSetMinSizeRequest struct {
	Width int32

	Height int32
}

// Opcode returns the request opcode for xdg_toplevel.set_min_size in xdg_shell
func (XdgToplevelSetMinSizeRequest) Opcode() uint16 { return 8 }

// Ensure XdgToplevelSetMinSizeRequest implements Message.
var _ Message = XdgToplevelSetMinSizeRequest{}

// XdgToplevelSetMaximizedRequest requests to maximize the window
//
// Maximize the surface.
//
// After requesting that the surface should be maximized, the compositor
// will respond by emitting a configure event. Whether this configure
// actually sets the window maximized is subject to compositor policies.
// The client must then update its content, drawing in the configured
// state. The client must also acknowledge the configure when committing
// the new content (see ack_configure).
//
// It is up to the compositor to decide how and where to maximize the
// surface, for example which output and what region of the screen should
// be used.
//
// If the surface was already maximized, the compositor will still emit
// a configure event with the "maximized" state.
//
// If the surface is in a fullscreen state, this request has no direct
// effect. It may alter the state the surface is returned to when
// unmaximized unless overridden by the compositor.
type XdgToplevelSetMaximizedRequest struct {
}

// Opcode returns the request opcode for xdg_toplevel.set_maximized in xdg_shell
func (XdgToplevelSetMaximizedRequest) Opcode() uint16 { return 9 }

// Ensure XdgToplevelSetMaximizedRequest implements Message.
var _ Message = XdgToplevelSetMaximizedRequest{}

// XdgToplevelUnsetMaximizedRequest requests to unmaximize the window
//
// Unmaximize the surface.
//
// After requesting that the surface should be unmaximized, the compositor
// will respond by emitting a configure event. Whether this actually
// un-maximizes the window is subject to compositor policies.
// If available and applicable, the compositor will include the window
// geometry dimensions the window had prior to being maximized in the
// configure event. The client must then update its content, drawing it in
// the configured state. The client must also acknowledge the configure
// when committing the new content (see ack_configure).
//
// It is up to the compositor to position the surface after it was
// unmaximized; usually the position the surface had before maximizing, if
// applicable.
//
// If the surface was already not maximized, the compositor will still
// emit a configure event without the "maximized" state.
//
// If the surface is in a fullscreen state, this request has no direct
// effect. It may alter the state the surface is returned to when
// unmaximized unless overridden by the compositor.
type XdgToplevelUnsetMaximizedRequest struct {
}

// Opcode returns the request opcode for xdg_toplevel.unset_maximized in xdg_shell
func (XdgToplevelUnsetMaximizedRequest) Opcode() uint16 { return 10 }

// Ensure XdgToplevelUnsetMaximizedRequest implements Message.
var _ Message = XdgToplevelUnsetMaximizedRequest{}

// XdgToplevelSetFullscreenRequest requests to set the window as fullscreen on an output
//
// Make the surface fullscreen.
//
// After requesting that the surface should be fullscreened, the
// compositor will respond by emitting a configure event. Whether the
// client is actually put into a fullscreen state is subject to compositor
// policies. The client must also acknowledge the configure when
// committing the new content (see ack_configure).
//
// The output passed by the request indicates the client's preference as
// to which display it should be set fullscreen on. If this value is NULL,
// it's up to the compositor to choose which display will be used to map
// this surface.
//
// If the surface doesn't cover the whole output, the compositor will
// position the surface in the center of the output and compensate with
// with border fill covering the rest of the output. The content of the
// border fill is undefined, but should be assumed to be in some way that
// attempts to blend into the surrounding area (e.g. solid black).
//
// If the fullscreened surface is not opaque, the compositor must make
// sure that other screen content not part of the same surface tree (made
// up of subsurfaces, popups or similarly coupled surfaces) are not
// visible below the fullscreened surface.
type XdgToplevelSetFullscreenRequest struct {
	Output ObjectID
}

// Opcode returns the request opcode for xdg_toplevel.set_fullscreen in xdg_shell
func (XdgToplevelSetFullscreenRequest) Opcode() uint16 { return 11 }

// Ensure XdgToplevelSetFullscreenRequest implements Message.
var _ Message = XdgToplevelSetFullscreenRequest{}

// XdgToplevelUnsetFullscreenRequest requests to unset the window as fullscreen
//
// Make the surface no longer fullscreen.
//
// After requesting that the surface should be unfullscreened, the
// compositor will respond by emitting a configure event.
// Whether this actually removes the fullscreen state of the client is
// subject to compositor policies.
//
// Making a surface unfullscreen sets states for the surface based on the following:
// * the state(s) it may have had before becoming fullscreen
// * any state(s) decided by the compositor
// * any state(s) requested by the client while the surface was fullscreen
//
// The compositor may include the previous window geometry dimensions in
// the configure event, if applicable.
//
// The client must also acknowledge the configure when committing the new
// content (see ack_configure).
type XdgToplevelUnsetFullscreenRequest struct {
}

// Opcode returns the request opcode for xdg_toplevel.unset_fullscreen in xdg_shell
func (XdgToplevelUnsetFullscreenRequest) Opcode() uint16 { return 12 }

// Ensure XdgToplevelUnsetFullscreenRequest implements Message.
var _ Message = XdgToplevelUnsetFullscreenRequest{}

// XdgToplevelSetMinimizedRequest requests to set the window as minimized
//
// Request that the compositor minimize your surface. There is no
// way to know if the surface is currently minimized, nor is there
// any way to unset minimization on this surface.
//
// If you are looking to throttle redrawing when minimized, please
// instead use the wl_surface.frame event for this, as this will
// also work with live previews on windows in Alt-Tab, Expose or
// similar compositor features.
type XdgToplevelSetMinimizedRequest struct {
}

// Opcode returns the request opcode for xdg_toplevel.set_minimized in xdg_shell
func (XdgToplevelSetMinimizedRequest) Opcode() uint16 { return 13 }

// Ensure XdgToplevelSetMinimizedRequest implements Message.
var _ Message = XdgToplevelSetMinimizedRequest{}

// XdgToplevelConfigureEvent signals when suggest a surface change
//
// This configure event asks the client to resize its toplevel surface or
// to change its state. The configured state should not be applied
// immediately. See xdg_surface.configure for details.
//
// The width and height arguments specify a hint to the window
// about how its surface should be resized in window geometry
// coordinates. See set_window_geometry.
//
// If the width or height arguments are zero, it means the client
// should decide its own window dimension. This may happen when the
// compositor needs to configure the state of the surface but doesn't
// have any information about any previous or expected dimension.
//
// The states listed in the event specify how the width/height
// arguments should be interpreted, and possibly how it should be
// drawn.
//
// Clients must send an ack_configure in response to this event. See
// xdg_surface.configure and xdg_surface.ack_configure for details.
type XdgToplevelConfigureEvent struct {
	Width int32

	Height int32

	States []byte
}

// Opcode returns the event opcode for xdg_toplevel.configure in xdg_shell
func (XdgToplevelConfigureEvent) Opcode() uint16 { return 0 }

// Ensure XdgToplevelConfigureEvent implements Message.
var _ Message = XdgToplevelConfigureEvent{}

// Scan scans the event from the socket.
func (e *XdgToplevelConfigureEvent) Scan(s *EventScanner) error {
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.Width = v
	}
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.Height = v
	}
	if v, err := s.Array(); err != nil {
		return err
	} else {
		e.States = v
	}
	return nil
}

// Ensure XdgToplevelConfigureEvent implements Event.
var _ Event = &XdgToplevelConfigureEvent{}

// XdgToplevelCloseEvent signals when surface wants to be closed
//
// The close event is sent by the compositor when the user
// wants the surface to be closed. This should be equivalent to
// the user clicking the close button in client-side decorations,
// if your application has any.
//
// This is only a request that the user intends to close the
// window. The client may choose to ignore this request, or show
// a dialog to ask the user to save their data, etc.
type XdgToplevelCloseEvent struct {
}

// Opcode returns the event opcode for xdg_toplevel.close in xdg_shell
func (XdgToplevelCloseEvent) Opcode() uint16 { return 1 }

// Ensure XdgToplevelCloseEvent implements Message.
var _ Message = XdgToplevelCloseEvent{}

// Scan scans the event from the socket.
func (e *XdgToplevelCloseEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure XdgToplevelCloseEvent implements Event.
var _ Event = &XdgToplevelCloseEvent{}

// #endregion Interface xdg_shell.xdg_toplevel

// ----------------------------------------------------------------------------
// #region Interface xdg_shell.xdg_popup

type XdgPopupError int

const (
	// XdgPopupErrorInvalidGrab corresponds to tried to grab after being mapped
	XdgPopupErrorInvalidGrab XdgPopupError = 0
)

// XdgPopupDestroyRequest requests to remove xdg_popup interface
//
// This destroys the popup. Explicitly destroying the xdg_popup
// object will also dismiss the popup, and unmap the surface.
//
// If this xdg_popup is not the "topmost" popup, a protocol error
// will be sent.
type XdgPopupDestroyRequest struct {
}

// Opcode returns the request opcode for xdg_popup.destroy in xdg_shell
func (XdgPopupDestroyRequest) Opcode() uint16 { return 0 }

// Ensure XdgPopupDestroyRequest implements Message.
var _ Message = XdgPopupDestroyRequest{}

// XdgPopupGrabRequest requests to make the popup take an explicit grab
//
// This request makes the created popup take an explicit grab. An explicit
// grab will be dismissed when the user dismisses the popup, or when the
// client destroys the xdg_popup. This can be done by the user clicking
// outside the surface, using the keyboard, or even locking the screen
// through closing the lid or a timeout.
//
// If the compositor denies the grab, the popup will be immediately
// dismissed.
//
// This request must be used in response to some sort of user action like a
// button press, key press, or touch down event. The serial number of the
// event should be passed as 'serial'.
//
// The parent of a grabbing popup must either be an xdg_toplevel surface or
// another xdg_popup with an explicit grab. If the parent is another
// xdg_popup it means that the popups are nested, with this popup now being
// the topmost popup.
//
// Nested popups must be destroyed in the reverse order they were created
// in, e.g. the only popup you are allowed to destroy at all times is the
// topmost one.
//
// When compositors choose to dismiss a popup, they may dismiss every
// nested grabbing popup as well. When a compositor dismisses popups, it
// will follow the same dismissing order as required from the client.
//
// The parent of a grabbing popup must either be another xdg_popup with an
// active explicit grab, or an xdg_popup or xdg_toplevel, if there are no
// explicit grabs already taken.
//
// If the topmost grabbing popup is destroyed, the grab will be returned to
// the parent of the popup, if that parent previously had an explicit grab.
//
// If the parent is a grabbing popup which has already been dismissed, this
// popup will be immediately dismissed. If the parent is a popup that did
// not take an explicit grab, an error will be raised.
//
// During a popup grab, the client owning the grab will receive pointer
// and touch events for all their surfaces as normal (similar to an
// "owner-events" grab in X11 parlance), while the top most grabbing popup
// will always have keyboard focus.
type XdgPopupGrabRequest struct {
	// Seat contains the wl_seat of the user event
	Seat ObjectID

	// Serial contains the serial of the user event
	Serial uint32
}

// Opcode returns the request opcode for xdg_popup.grab in xdg_shell
func (XdgPopupGrabRequest) Opcode() uint16 { return 1 }

// Ensure XdgPopupGrabRequest implements Message.
var _ Message = XdgPopupGrabRequest{}

// XdgPopupRepositionRequest requests to recalculate the popup's location
//
// Reposition an already-mapped popup. The popup will be placed given the
// details in the passed xdg_positioner object, and a
// xdg_popup.repositioned followed by xdg_popup.configure and
// xdg_surface.configure will be emitted in response. Any parameters set
// by the previous positioner will be discarded.
//
// The passed token will be sent in the corresponding
// xdg_popup.repositioned event. The new popup position will not take
// effect until the corresponding configure event is acknowledged by the
// client. See xdg_popup.repositioned for details. The token itself is
// opaque, and has no other special meaning.
//
// If multiple reposition requests are sent, the compositor may skip all
// but the last one.
//
// If the popup is repositioned in response to a configure event for its
// parent, the client should send an xdg_positioner.set_parent_configure
// and possibly an xdg_positioner.set_parent_size request to allow the
// compositor to properly constrain the popup.
//
// If the popup is repositioned together with a parent that is being
// resized, but not in response to a configure event, the client should
// send an xdg_positioner.set_parent_size request.
type XdgPopupRepositionRequest struct {
	Positioner ObjectID

	// Token contains reposition request token
	Token uint32
}

// Opcode returns the request opcode for xdg_popup.reposition in xdg_shell
func (XdgPopupRepositionRequest) Opcode() uint16 { return 2 }

// Ensure XdgPopupRepositionRequest implements Message.
var _ Message = XdgPopupRepositionRequest{}

// XdgPopupConfigureEvent signals when configure the popup surface
//
// This event asks the popup surface to configure itself given the
// configuration. The configured state should not be applied immediately.
// See xdg_surface.configure for details.
//
// The x and y arguments represent the position the popup was placed at
// given the xdg_positioner rule, relative to the upper left corner of the
// window geometry of the parent surface.
//
// For version 2 or older, the configure event for an xdg_popup is only
// ever sent once for the initial configuration. Starting with version 3,
// it may be sent again if the popup is setup with an xdg_positioner with
// set_reactive requested, or in response to xdg_popup.reposition requests.
type XdgPopupConfigureEvent struct {
	// X contains x position relative to parent surface window geometry
	X int32

	// Y contains y position relative to parent surface window geometry
	Y int32

	// Width contains window geometry width
	Width int32

	// Height contains window geometry height
	Height int32
}

// Opcode returns the event opcode for xdg_popup.configure in xdg_shell
func (XdgPopupConfigureEvent) Opcode() uint16 { return 0 }

// Ensure XdgPopupConfigureEvent implements Message.
var _ Message = XdgPopupConfigureEvent{}

// Scan scans the event from the socket.
func (e *XdgPopupConfigureEvent) Scan(s *EventScanner) error {
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.X = v
	}
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.Y = v
	}
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.Width = v
	}
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.Height = v
	}
	return nil
}

// Ensure XdgPopupConfigureEvent implements Event.
var _ Event = &XdgPopupConfigureEvent{}

// XdgPopupPopupDoneEvent signals when popup interaction is done
//
// The popup_done event is sent out when a popup is dismissed by the
// compositor. The client should destroy the xdg_popup object at this
// point.
type XdgPopupPopupDoneEvent struct {
}

// Opcode returns the event opcode for xdg_popup.popup_done in xdg_shell
func (XdgPopupPopupDoneEvent) Opcode() uint16 { return 1 }

// Ensure XdgPopupPopupDoneEvent implements Message.
var _ Message = XdgPopupPopupDoneEvent{}

// Scan scans the event from the socket.
func (e *XdgPopupPopupDoneEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure XdgPopupPopupDoneEvent implements Event.
var _ Event = &XdgPopupPopupDoneEvent{}

// XdgPopupRepositionedEvent signals when signal the completion of a repositioned request
//
// The repositioned event is sent as part of a popup configuration
// sequence, together with xdg_popup.configure and lastly
// xdg_surface.configure to notify the completion of a reposition request.
//
// The repositioned event is to notify about the completion of a
// xdg_popup.reposition request. The token argument is the token passed
// in the xdg_popup.reposition request.
//
// Immediately after this event is emitted, xdg_popup.configure and
// xdg_surface.configure will be sent with the updated size and position,
// as well as a new configure serial.
//
// The client should optionally update the content of the popup, but must
// acknowledge the new popup configuration for the new position to take
// effect. See xdg_surface.ack_configure for details.
type XdgPopupRepositionedEvent struct {
	// Token contains reposition request token
	Token uint32
}

// Opcode returns the event opcode for xdg_popup.repositioned in xdg_shell
func (XdgPopupRepositionedEvent) Opcode() uint16 { return 2 }

// Ensure XdgPopupRepositionedEvent implements Message.
var _ Message = XdgPopupRepositionedEvent{}

// Scan scans the event from the socket.
func (e *XdgPopupRepositionedEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Token = v
	}
	return nil
}

// Ensure XdgPopupRepositionedEvent implements Event.
var _ Event = &XdgPopupRepositionedEvent{}

// #endregion Interface xdg_shell.xdg_popup

////////////////////////////////////////////////////////////////////////////////
// #endregion Protocol xdg_shell

////////////////////////////////////////////////////////////////////////////////
// #region Protocol xwayland_keyboard_grab_unstable_v1

// ----------------------------------------------------------------------------
// #region Interface xwayland_keyboard_grab_unstable_v1.zwp_xwayland_keyboard_grab_manager_v1

// ZwpXwaylandKeyboardGrabManagerV1DestroyRequest requests to destroy the keyboard grab manager
//
// Destroy the keyboard grab manager.
type ZwpXwaylandKeyboardGrabManagerV1DestroyRequest struct {
}

// Opcode returns the request opcode for zwp_xwayland_keyboard_grab_manager_v1.destroy in xwayland_keyboard_grab_unstable_v1
func (ZwpXwaylandKeyboardGrabManagerV1DestroyRequest) Opcode() uint16 { return 0 }

// Ensure ZwpXwaylandKeyboardGrabManagerV1DestroyRequest implements Message.
var _ Message = ZwpXwaylandKeyboardGrabManagerV1DestroyRequest{}

// ZwpXwaylandKeyboardGrabManagerV1GrabKeyboardRequest requests to grab the keyboard to a surface
//
// The grab_keyboard request asks for a grab of the keyboard, forcing
// the keyboard focus for the given seat upon the given surface.
//
// The protocol provides no guarantee that the grab is ever satisfied,
// and does not require the compositor to send an error if the grab
// cannot ever be satisfied. It is thus possible to request a keyboard
// grab that will never be effective.
//
// The protocol:
//
// * does not guarantee that the grab itself is applied for a surface,
// the grab request may be silently ignored by the compositor,
// * does not guarantee that any events are sent to this client even
// if the grab is applied to a surface,
// * does not guarantee that events sent to this client are exhaustive,
// a compositor may filter some events for its own consumption,
// * does not guarantee that events sent to this client are continuous,
// a compositor may change and reroute keyboard events while the grab
// is nominally active.
type ZwpXwaylandKeyboardGrabManagerV1GrabKeyboardRequest struct {
	ID ObjectID

	// Surface contains surface to report keyboard events to
	Surface ObjectID

	// Seat contains the seat for which the keyboard should be grabbed
	Seat ObjectID
}

// Opcode returns the request opcode for zwp_xwayland_keyboard_grab_manager_v1.grab_keyboard in xwayland_keyboard_grab_unstable_v1
func (ZwpXwaylandKeyboardGrabManagerV1GrabKeyboardRequest) Opcode() uint16 { return 1 }

// Ensure ZwpXwaylandKeyboardGrabManagerV1GrabKeyboardRequest implements Message.
var _ Message = ZwpXwaylandKeyboardGrabManagerV1GrabKeyboardRequest{}

// #endregion Interface xwayland_keyboard_grab_unstable_v1.zwp_xwayland_keyboard_grab_manager_v1

// ----------------------------------------------------------------------------
// #region Interface xwayland_keyboard_grab_unstable_v1.zwp_xwayland_keyboard_grab_v1

// ZwpXwaylandKeyboardGrabV1DestroyRequest requests to destroy the grabbed keyboard object
//
// Destroy the grabbed keyboard object. If applicable, the compositor
// will ungrab the keyboard.
type ZwpXwaylandKeyboardGrabV1DestroyRequest struct {
}

// Opcode returns the request opcode for zwp_xwayland_keyboard_grab_v1.destroy in xwayland_keyboard_grab_unstable_v1
func (ZwpXwaylandKeyboardGrabV1DestroyRequest) Opcode() uint16 { return 0 }

// Ensure ZwpXwaylandKeyboardGrabV1DestroyRequest implements Message.
var _ Message = ZwpXwaylandKeyboardGrabV1DestroyRequest{}

// #endregion Interface xwayland_keyboard_grab_unstable_v1.zwp_xwayland_keyboard_grab_v1

////////////////////////////////////////////////////////////////////////////////
// #endregion Protocol xwayland_keyboard_grab_unstable_v1

////////////////////////////////////////////////////////////////////////////////
// #region Protocol zwp_linux_explicit_synchronization_unstable_v1

// ----------------------------------------------------------------------------
// #region Interface zwp_linux_explicit_synchronization_unstable_v1.zwp_linux_explicit_synchronization_v1

type ZwpLinuxExplicitSynchronizationV1Error int

const (
	// ZwpLinuxExplicitSynchronizationV1ErrorSynchronizationExists corresponds to the surface already has a synchronization object associated
	ZwpLinuxExplicitSynchronizationV1ErrorSynchronizationExists ZwpLinuxExplicitSynchronizationV1Error = 0
)

// ZwpLinuxExplicitSynchronizationV1DestroyRequest requests to destroy explicit synchronization factory object
//
// Destroy this explicit synchronization factory object. Other objects,
// including zwp_linux_surface_synchronization_v1 objects created by this
// factory, shall not be affected by this request.
type ZwpLinuxExplicitSynchronizationV1DestroyRequest struct {
}

// Opcode returns the request opcode for zwp_linux_explicit_synchronization_v1.destroy in zwp_linux_explicit_synchronization_unstable_v1
func (ZwpLinuxExplicitSynchronizationV1DestroyRequest) Opcode() uint16 { return 0 }

// Ensure ZwpLinuxExplicitSynchronizationV1DestroyRequest implements Message.
var _ Message = ZwpLinuxExplicitSynchronizationV1DestroyRequest{}

// ZwpLinuxExplicitSynchronizationV1GetSynchronizationRequest requests to extend surface interface for explicit synchronization
//
// Instantiate an interface extension for the given wl_surface to provide
// explicit synchronization.
//
// If the given wl_surface already has an explicit synchronization object
// associated, the synchronization_exists protocol error is raised.
//
// Graphics APIs, like EGL or Vulkan, that manage the buffer queue and
// commits of a wl_surface themselves, are likely to be using this
// extension internally. If a client is using such an API for a
// wl_surface, it should not directly use this extension on that surface,
// to avoid raising a synchronization_exists protocol error.
type ZwpLinuxExplicitSynchronizationV1GetSynchronizationRequest struct {
	// ID contains the new synchronization interface id
	ID ObjectID

	// Surface contains the surface
	Surface ObjectID
}

// Opcode returns the request opcode for zwp_linux_explicit_synchronization_v1.get_synchronization in zwp_linux_explicit_synchronization_unstable_v1
func (ZwpLinuxExplicitSynchronizationV1GetSynchronizationRequest) Opcode() uint16 { return 1 }

// Ensure ZwpLinuxExplicitSynchronizationV1GetSynchronizationRequest implements Message.
var _ Message = ZwpLinuxExplicitSynchronizationV1GetSynchronizationRequest{}

// #endregion Interface zwp_linux_explicit_synchronization_unstable_v1.zwp_linux_explicit_synchronization_v1

// ----------------------------------------------------------------------------
// #region Interface zwp_linux_explicit_synchronization_unstable_v1.zwp_linux_surface_synchronization_v1

type ZwpLinuxSurfaceSynchronizationV1Error int

const (
	// ZwpLinuxSurfaceSynchronizationV1ErrorInvalidFence corresponds to the fence specified by the client could not be imported
	ZwpLinuxSurfaceSynchronizationV1ErrorInvalidFence ZwpLinuxSurfaceSynchronizationV1Error = 0

	// ZwpLinuxSurfaceSynchronizationV1ErrorDuplicateFence corresponds to multiple fences added for a single surface commit
	ZwpLinuxSurfaceSynchronizationV1ErrorDuplicateFence ZwpLinuxSurfaceSynchronizationV1Error = 1

	// ZwpLinuxSurfaceSynchronizationV1ErrorDuplicateRelease corresponds to multiple releases added for a single surface commit
	ZwpLinuxSurfaceSynchronizationV1ErrorDuplicateRelease ZwpLinuxSurfaceSynchronizationV1Error = 2

	// ZwpLinuxSurfaceSynchronizationV1ErrorNoSurface corresponds to the associated wl_surface was destroyed
	ZwpLinuxSurfaceSynchronizationV1ErrorNoSurface ZwpLinuxSurfaceSynchronizationV1Error = 3

	// ZwpLinuxSurfaceSynchronizationV1ErrorUnsupportedBuffer corresponds to the buffer does not support explicit synchronization
	ZwpLinuxSurfaceSynchronizationV1ErrorUnsupportedBuffer ZwpLinuxSurfaceSynchronizationV1Error = 4

	// ZwpLinuxSurfaceSynchronizationV1ErrorNoBuffer corresponds to no buffer was attached
	ZwpLinuxSurfaceSynchronizationV1ErrorNoBuffer ZwpLinuxSurfaceSynchronizationV1Error = 5
)

// ZwpLinuxSurfaceSynchronizationV1DestroyRequest requests to destroy synchronization object
//
// Destroy this explicit synchronization object.
//
// Any fence set by this object with set_acquire_fence since the last
// commit will be discarded by the server. Any fences set by this object
// before the last commit are not affected.
//
// zwp_linux_buffer_release_v1 objects created by this object are not
// affected by this request.
type ZwpLinuxSurfaceSynchronizationV1DestroyRequest struct {
}

// Opcode returns the request opcode for zwp_linux_surface_synchronization_v1.destroy in zwp_linux_explicit_synchronization_unstable_v1
func (ZwpLinuxSurfaceSynchronizationV1DestroyRequest) Opcode() uint16 { return 0 }

// Ensure ZwpLinuxSurfaceSynchronizationV1DestroyRequest implements Message.
var _ Message = ZwpLinuxSurfaceSynchronizationV1DestroyRequest{}

// ZwpLinuxSurfaceSynchronizationV1SetAcquireFenceRequest requests to set the acquire fence
//
// Set the acquire fence that must be signaled before the compositor
// may sample from the buffer attached with wl_surface.attach. The fence
// is a dma_fence kernel object.
//
// The acquire fence is double-buffered state, and will be applied on the
// next wl_surface.commit request for the associated surface. Thus, it
// applies only to the buffer that is attached to the surface at commit
// time.
//
// If the provided fd is not a valid dma_fence fd, then an INVALID_FENCE
// error is raised.
//
// If a fence has already been attached during the same commit cycle, a
// DUPLICATE_FENCE error is raised.
//
// If the associated wl_surface was destroyed, a NO_SURFACE error is
// raised.
//
// If at surface commit time the attached buffer does not support explicit
// synchronization, an UNSUPPORTED_BUFFER error is raised.
//
// If at surface commit time there is no buffer attached, a NO_BUFFER
// error is raised.
type ZwpLinuxSurfaceSynchronizationV1SetAcquireFenceRequest struct {
	// FD contains acquire fence fd
	FD FD
}

// Opcode returns the request opcode for zwp_linux_surface_synchronization_v1.set_acquire_fence in zwp_linux_explicit_synchronization_unstable_v1
func (ZwpLinuxSurfaceSynchronizationV1SetAcquireFenceRequest) Opcode() uint16 { return 1 }

// Ensure ZwpLinuxSurfaceSynchronizationV1SetAcquireFenceRequest implements Message.
var _ Message = ZwpLinuxSurfaceSynchronizationV1SetAcquireFenceRequest{}

// ZwpLinuxSurfaceSynchronizationV1GetReleaseRequest requests to release fence for last-attached buffer
//
// Create a listener for the release of the buffer attached by the
// client with wl_surface.attach. See zwp_linux_buffer_release_v1
// documentation for more information.
//
// The release object is double-buffered state, and will be associated
// with the buffer that is attached to the surface at wl_surface.commit
// time.
//
// If a zwp_linux_buffer_release_v1 object has already been requested for
// the surface in the same commit cycle, a DUPLICATE_RELEASE error is
// raised.
//
// If the associated wl_surface was destroyed, a NO_SURFACE error
// is raised.
//
// If at surface commit time there is no buffer attached, a NO_BUFFER
// error is raised.
type ZwpLinuxSurfaceSynchronizationV1GetReleaseRequest struct {
	// Release contains new zwp_linux_buffer_release_v1 object
	Release ObjectID
}

// Opcode returns the request opcode for zwp_linux_surface_synchronization_v1.get_release in zwp_linux_explicit_synchronization_unstable_v1
func (ZwpLinuxSurfaceSynchronizationV1GetReleaseRequest) Opcode() uint16 { return 2 }

// Ensure ZwpLinuxSurfaceSynchronizationV1GetReleaseRequest implements Message.
var _ Message = ZwpLinuxSurfaceSynchronizationV1GetReleaseRequest{}

// #endregion Interface zwp_linux_explicit_synchronization_unstable_v1.zwp_linux_surface_synchronization_v1

// ----------------------------------------------------------------------------
// #region Interface zwp_linux_explicit_synchronization_unstable_v1.zwp_linux_buffer_release_v1

// ZwpLinuxBufferReleaseV1FencedReleaseEvent signals when release buffer with fence
//
// Sent when the compositor has finalised its usage of the associated
// buffer for the relevant commit, providing a dma_fence which will be
// signaled when all operations by the compositor on that buffer for that
// commit have finished.
//
// Once the fence has signaled, and assuming the associated buffer is not
// pending release from other wl_surface.commit requests, no additional
// explicit or implicit synchronization is required to safely reuse or
// destroy the buffer.
//
// This event destroys the zwp_linux_buffer_release_v1 object.
type ZwpLinuxBufferReleaseV1FencedReleaseEvent struct {
	// Fence contains fence for last operation on buffer
	Fence FD
}

// Opcode returns the event opcode for zwp_linux_buffer_release_v1.fenced_release in zwp_linux_explicit_synchronization_unstable_v1
func (ZwpLinuxBufferReleaseV1FencedReleaseEvent) Opcode() uint16 { return 0 }

// Ensure ZwpLinuxBufferReleaseV1FencedReleaseEvent implements Message.
var _ Message = ZwpLinuxBufferReleaseV1FencedReleaseEvent{}

// Scan scans the event from the socket.
func (e *ZwpLinuxBufferReleaseV1FencedReleaseEvent) Scan(s *EventScanner) error {
	if v, err := s.FD(); err != nil {
		return err
	} else {
		e.Fence = v
	}
	return nil
}

// Ensure ZwpLinuxBufferReleaseV1FencedReleaseEvent implements Event.
var _ Event = &ZwpLinuxBufferReleaseV1FencedReleaseEvent{}

// ZwpLinuxBufferReleaseV1ImmediateReleaseEvent signals when release buffer immediately
//
// Sent when the compositor has finalised its usage of the associated
// buffer for the relevant commit, and either performed no operations
// using it, or has a guarantee that all its operations on that buffer for
// that commit have finished.
//
// Once this event is received, and assuming the associated buffer is not
// pending release from other wl_surface.commit requests, no additional
// explicit or implicit synchronization is required to safely reuse or
// destroy the buffer.
//
// This event destroys the zwp_linux_buffer_release_v1 object.
type ZwpLinuxBufferReleaseV1ImmediateReleaseEvent struct {
}

// Opcode returns the event opcode for zwp_linux_buffer_release_v1.immediate_release in zwp_linux_explicit_synchronization_unstable_v1
func (ZwpLinuxBufferReleaseV1ImmediateReleaseEvent) Opcode() uint16 { return 1 }

// Ensure ZwpLinuxBufferReleaseV1ImmediateReleaseEvent implements Message.
var _ Message = ZwpLinuxBufferReleaseV1ImmediateReleaseEvent{}

// Scan scans the event from the socket.
func (e *ZwpLinuxBufferReleaseV1ImmediateReleaseEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure ZwpLinuxBufferReleaseV1ImmediateReleaseEvent implements Event.
var _ Event = &ZwpLinuxBufferReleaseV1ImmediateReleaseEvent{}

// #endregion Interface zwp_linux_explicit_synchronization_unstable_v1.zwp_linux_buffer_release_v1

////////////////////////////////////////////////////////////////////////////////
// #endregion Protocol zwp_linux_explicit_synchronization_unstable_v1
