// THIS FILE IS GENERATED BY WAYGEN - DO NOT EDIT
// Generated with: waygen ../../third_party/wayland/protocol ../../third_party/wayland-protocols
package wayland

////////////////////////////////////////////////////////////////////////////////
// Interface Descriptors
var WpDrmLeaseDeviceV1Descriptor = InterfaceDescriptor{
	Name: "wp_drm_lease_device_v1",
	Events: []EventDescriptor{
		{Name: "drm_fd", Opcode: 0, Type: &WpDrmLeaseDeviceV1DrmFDEvent{}},
		{Name: "connector", Opcode: 1, Type: &WpDrmLeaseDeviceV1ConnectorEvent{}},
		{Name: "done", Opcode: 2, Type: &WpDrmLeaseDeviceV1DoneEvent{}},
		{Name: "released", Opcode: 3, Type: &WpDrmLeaseDeviceV1ReleasedEvent{}},
	},
	Requests: []RequestDescriptor{
		{Name: "create_lease_request", Opcode: 0, Type: &WpDrmLeaseDeviceV1CreateLeaseRequestRequest{}},
		{Name: "release", Opcode: 1, Type: &WpDrmLeaseDeviceV1ReleaseRequest{}},
	},
}
var WpDrmLeaseConnectorV1Descriptor = InterfaceDescriptor{
	Name: "wp_drm_lease_connector_v1",
	Events: []EventDescriptor{
		{Name: "name", Opcode: 0, Type: &WpDrmLeaseConnectorV1NameEvent{}},
		{Name: "description", Opcode: 1, Type: &WpDrmLeaseConnectorV1DescriptionEvent{}},
		{Name: "connector_id", Opcode: 2, Type: &WpDrmLeaseConnectorV1ConnectorIDEvent{}},
		{Name: "done", Opcode: 3, Type: &WpDrmLeaseConnectorV1DoneEvent{}},
		{Name: "withdrawn", Opcode: 4, Type: &WpDrmLeaseConnectorV1WithdrawnEvent{}},
	},
	Requests: []RequestDescriptor{
		{Name: "destroy", Opcode: 0, Type: &WpDrmLeaseConnectorV1DestroyRequest{}},
	},
}
var WpDrmLeaseRequestV1Descriptor = InterfaceDescriptor{
	Name:   "wp_drm_lease_request_v1",
	Events: []EventDescriptor{},
	Requests: []RequestDescriptor{
		{Name: "request_connector", Opcode: 0, Type: &WpDrmLeaseRequestV1RequestConnectorRequest{}},
		{Name: "submit", Opcode: 1, Type: &WpDrmLeaseRequestV1SubmitRequest{}},
	},
}
var WpDrmLeaseV1Descriptor = InterfaceDescriptor{
	Name: "wp_drm_lease_v1",
	Events: []EventDescriptor{
		{Name: "lease_fd", Opcode: 0, Type: &WpDrmLeaseV1LeaseFDEvent{}},
		{Name: "finished", Opcode: 1, Type: &WpDrmLeaseV1FinishedEvent{}},
	},
	Requests: []RequestDescriptor{
		{Name: "destroy", Opcode: 0, Type: &WpDrmLeaseV1DestroyRequest{}},
	},
}
var ZwpFullscreenShellV1Descriptor = InterfaceDescriptor{
	Name: "zwp_fullscreen_shell_v1",
	Events: []EventDescriptor{
		{Name: "capability", Opcode: 0, Type: &ZwpFullscreenShellV1CapabilityEvent{}},
	},
	Requests: []RequestDescriptor{
		{Name: "release", Opcode: 0, Type: &ZwpFullscreenShellV1ReleaseRequest{}},
		{Name: "present_surface", Opcode: 1, Type: &ZwpFullscreenShellV1PresentSurfaceRequest{}},
		{Name: "present_surface_for_mode", Opcode: 2, Type: &ZwpFullscreenShellV1PresentSurfaceForModeRequest{}},
	},
}
var ZwpFullscreenShellModeFeedbackV1Descriptor = InterfaceDescriptor{
	Name: "zwp_fullscreen_shell_mode_feedback_v1",
	Events: []EventDescriptor{
		{Name: "mode_successful", Opcode: 0, Type: &ZwpFullscreenShellModeFeedbackV1ModeSuccessfulEvent{}},
		{Name: "mode_failed", Opcode: 1, Type: &ZwpFullscreenShellModeFeedbackV1ModeFailedEvent{}},
		{Name: "present_cancelled", Opcode: 2, Type: &ZwpFullscreenShellModeFeedbackV1PresentCancelledEvent{}},
	},
	Requests: []RequestDescriptor{},
}
var ZwpIdleInhibitManagerV1Descriptor = InterfaceDescriptor{
	Name:   "zwp_idle_inhibit_manager_v1",
	Events: []EventDescriptor{},
	Requests: []RequestDescriptor{
		{Name: "destroy", Opcode: 0, Type: &ZwpIdleInhibitManagerV1DestroyRequest{}},
		{Name: "create_inhibitor", Opcode: 1, Type: &ZwpIdleInhibitManagerV1CreateInhibitorRequest{}},
	},
}
var ZwpIdleInhibitorV1Descriptor = InterfaceDescriptor{
	Name:   "zwp_idle_inhibitor_v1",
	Events: []EventDescriptor{},
	Requests: []RequestDescriptor{
		{Name: "destroy", Opcode: 0, Type: &ZwpIdleInhibitorV1DestroyRequest{}},
	},
}
var ZwpInputMethodContextV1Descriptor = InterfaceDescriptor{
	Name: "zwp_input_method_context_v1",
	Events: []EventDescriptor{
		{Name: "surrounding_text", Opcode: 0, Type: &ZwpInputMethodContextV1SurroundingTextEvent{}},
		{Name: "reset", Opcode: 1, Type: &ZwpInputMethodContextV1ResetEvent{}},
		{Name: "content_type", Opcode: 2, Type: &ZwpInputMethodContextV1ContentTypeEvent{}},
		{Name: "invoke_action", Opcode: 3, Type: &ZwpInputMethodContextV1InvokeActionEvent{}},
		{Name: "commit_state", Opcode: 4, Type: &ZwpInputMethodContextV1CommitStateEvent{}},
		{Name: "preferred_language", Opcode: 5, Type: &ZwpInputMethodContextV1PreferredLanguageEvent{}},
	},
	Requests: []RequestDescriptor{
		{Name: "destroy", Opcode: 0, Type: &ZwpInputMethodContextV1DestroyRequest{}},
		{Name: "commit_string", Opcode: 1, Type: &ZwpInputMethodContextV1CommitStringRequest{}},
		{Name: "preedit_string", Opcode: 2, Type: &ZwpInputMethodContextV1PreeditStringRequest{}},
		{Name: "preedit_styling", Opcode: 3, Type: &ZwpInputMethodContextV1PreeditStylingRequest{}},
		{Name: "preedit_cursor", Opcode: 4, Type: &ZwpInputMethodContextV1PreeditCursorRequest{}},
		{Name: "delete_surrounding_text", Opcode: 5, Type: &ZwpInputMethodContextV1DeleteSurroundingTextRequest{}},
		{Name: "cursor_position", Opcode: 6, Type: &ZwpInputMethodContextV1CursorPositionRequest{}},
		{Name: "modifiers_map", Opcode: 7, Type: &ZwpInputMethodContextV1ModifiersMapRequest{}},
		{Name: "keysym", Opcode: 8, Type: &ZwpInputMethodContextV1KeysymRequest{}},
		{Name: "grab_keyboard", Opcode: 9, Type: &ZwpInputMethodContextV1GrabKeyboardRequest{}},
		{Name: "key", Opcode: 10, Type: &ZwpInputMethodContextV1KeyRequest{}},
		{Name: "modifiers", Opcode: 11, Type: &ZwpInputMethodContextV1ModifiersRequest{}},
		{Name: "language", Opcode: 12, Type: &ZwpInputMethodContextV1LanguageRequest{}},
		{Name: "text_direction", Opcode: 13, Type: &ZwpInputMethodContextV1TextDirectionRequest{}},
	},
}
var ZwpInputMethodV1Descriptor = InterfaceDescriptor{
	Name: "zwp_input_method_v1",
	Events: []EventDescriptor{
		{Name: "activate", Opcode: 0, Type: &ZwpInputMethodV1ActivateEvent{}},
		{Name: "deactivate", Opcode: 1, Type: &ZwpInputMethodV1DeactivateEvent{}},
	},
	Requests: []RequestDescriptor{},
}
var ZwpInputPanelV1Descriptor = InterfaceDescriptor{
	Name:   "zwp_input_panel_v1",
	Events: []EventDescriptor{},
	Requests: []RequestDescriptor{
		{Name: "get_input_panel_surface", Opcode: 0, Type: &ZwpInputPanelV1GetInputPanelSurfaceRequest{}},
	},
}
var ZwpInputPanelSurfaceV1Descriptor = InterfaceDescriptor{
	Name:   "zwp_input_panel_surface_v1",
	Events: []EventDescriptor{},
	Requests: []RequestDescriptor{
		{Name: "set_toplevel", Opcode: 0, Type: &ZwpInputPanelSurfaceV1SetToplevelRequest{}},
		{Name: "set_overlay_panel", Opcode: 1, Type: &ZwpInputPanelSurfaceV1SetOverlayPanelRequest{}},
	},
}
var ZwpInputTimestampsManagerV1Descriptor = InterfaceDescriptor{
	Name:   "zwp_input_timestamps_manager_v1",
	Events: []EventDescriptor{},
	Requests: []RequestDescriptor{
		{Name: "destroy", Opcode: 0, Type: &ZwpInputTimestampsManagerV1DestroyRequest{}},
		{Name: "get_keyboard_timestamps", Opcode: 1, Type: &ZwpInputTimestampsManagerV1GetKeyboardTimestampsRequest{}},
		{Name: "get_pointer_timestamps", Opcode: 2, Type: &ZwpInputTimestampsManagerV1GetPointerTimestampsRequest{}},
		{Name: "get_touch_timestamps", Opcode: 3, Type: &ZwpInputTimestampsManagerV1GetTouchTimestampsRequest{}},
	},
}
var ZwpInputTimestampsV1Descriptor = InterfaceDescriptor{
	Name: "zwp_input_timestamps_v1",
	Events: []EventDescriptor{
		{Name: "timestamp", Opcode: 0, Type: &ZwpInputTimestampsV1TimestampEvent{}},
	},
	Requests: []RequestDescriptor{
		{Name: "destroy", Opcode: 0, Type: &ZwpInputTimestampsV1DestroyRequest{}},
	},
}
var ZwpKeyboardShortcutsInhibitManagerV1Descriptor = InterfaceDescriptor{
	Name:   "zwp_keyboard_shortcuts_inhibit_manager_v1",
	Events: []EventDescriptor{},
	Requests: []RequestDescriptor{
		{Name: "destroy", Opcode: 0, Type: &ZwpKeyboardShortcutsInhibitManagerV1DestroyRequest{}},
		{Name: "inhibit_shortcuts", Opcode: 1, Type: &ZwpKeyboardShortcutsInhibitManagerV1InhibitShortcutsRequest{}},
	},
}
var ZwpKeyboardShortcutsInhibitorV1Descriptor = InterfaceDescriptor{
	Name: "zwp_keyboard_shortcuts_inhibitor_v1",
	Events: []EventDescriptor{
		{Name: "active", Opcode: 0, Type: &ZwpKeyboardShortcutsInhibitorV1ActiveEvent{}},
		{Name: "inactive", Opcode: 1, Type: &ZwpKeyboardShortcutsInhibitorV1InactiveEvent{}},
	},
	Requests: []RequestDescriptor{
		{Name: "destroy", Opcode: 0, Type: &ZwpKeyboardShortcutsInhibitorV1DestroyRequest{}},
	},
}
var ZwpLinuxDmabufV1Descriptor = InterfaceDescriptor{
	Name: "zwp_linux_dmabuf_v1",
	Events: []EventDescriptor{
		{Name: "format", Opcode: 0, Type: &ZwpLinuxDmabufV1FormatEvent{}},
		{Name: "modifier", Opcode: 1, Type: &ZwpLinuxDmabufV1ModifierEvent{}},
	},
	Requests: []RequestDescriptor{
		{Name: "destroy", Opcode: 0, Type: &ZwpLinuxDmabufV1DestroyRequest{}},
		{Name: "create_params", Opcode: 1, Type: &ZwpLinuxDmabufV1CreateParamsRequest{}},
	},
}
var ZwpLinuxBufferParamsV1Descriptor = InterfaceDescriptor{
	Name: "zwp_linux_buffer_params_v1",
	Events: []EventDescriptor{
		{Name: "created", Opcode: 0, Type: &ZwpLinuxBufferParamsV1CreatedEvent{}},
		{Name: "failed", Opcode: 1, Type: &ZwpLinuxBufferParamsV1FailedEvent{}},
	},
	Requests: []RequestDescriptor{
		{Name: "destroy", Opcode: 0, Type: &ZwpLinuxBufferParamsV1DestroyRequest{}},
		{Name: "add", Opcode: 1, Type: &ZwpLinuxBufferParamsV1AddRequest{}},
		{Name: "create", Opcode: 2, Type: &ZwpLinuxBufferParamsV1CreateRequest{}},
		{Name: "create_immed", Opcode: 3, Type: &ZwpLinuxBufferParamsV1CreateImmedRequest{}},
	},
}
var ZwpPointerConstraintsV1Descriptor = InterfaceDescriptor{
	Name:   "zwp_pointer_constraints_v1",
	Events: []EventDescriptor{},
	Requests: []RequestDescriptor{
		{Name: "destroy", Opcode: 0, Type: &ZwpPointerConstraintsV1DestroyRequest{}},
		{Name: "lock_pointer", Opcode: 1, Type: &ZwpPointerConstraintsV1LockPointerRequest{}},
		{Name: "confine_pointer", Opcode: 2, Type: &ZwpPointerConstraintsV1ConfinePointerRequest{}},
	},
}
var ZwpLockedPointerV1Descriptor = InterfaceDescriptor{
	Name: "zwp_locked_pointer_v1",
	Events: []EventDescriptor{
		{Name: "locked", Opcode: 0, Type: &ZwpLockedPointerV1LockedEvent{}},
		{Name: "unlocked", Opcode: 1, Type: &ZwpLockedPointerV1UnlockedEvent{}},
	},
	Requests: []RequestDescriptor{
		{Name: "destroy", Opcode: 0, Type: &ZwpLockedPointerV1DestroyRequest{}},
		{Name: "set_cursor_position_hint", Opcode: 1, Type: &ZwpLockedPointerV1SetCursorPositionHintRequest{}},
		{Name: "set_region", Opcode: 2, Type: &ZwpLockedPointerV1SetRegionRequest{}},
	},
}
var ZwpConfinedPointerV1Descriptor = InterfaceDescriptor{
	Name: "zwp_confined_pointer_v1",
	Events: []EventDescriptor{
		{Name: "confined", Opcode: 0, Type: &ZwpConfinedPointerV1ConfinedEvent{}},
		{Name: "unconfined", Opcode: 1, Type: &ZwpConfinedPointerV1UnconfinedEvent{}},
	},
	Requests: []RequestDescriptor{
		{Name: "destroy", Opcode: 0, Type: &ZwpConfinedPointerV1DestroyRequest{}},
		{Name: "set_region", Opcode: 1, Type: &ZwpConfinedPointerV1SetRegionRequest{}},
	},
}
var ZwpPointerGesturesV1Descriptor = InterfaceDescriptor{
	Name:   "zwp_pointer_gestures_v1",
	Events: []EventDescriptor{},
	Requests: []RequestDescriptor{
		{Name: "get_swipe_gesture", Opcode: 0, Type: &ZwpPointerGesturesV1GetSwipeGestureRequest{}},
		{Name: "get_pinch_gesture", Opcode: 1, Type: &ZwpPointerGesturesV1GetPinchGestureRequest{}},
		{Name: "release", Opcode: 2, Type: &ZwpPointerGesturesV1ReleaseRequest{}},
		{Name: "get_hold_gesture", Opcode: 3, Type: &ZwpPointerGesturesV1GetHoldGestureRequest{}},
	},
}
var ZwpPointerGestureSwipeV1Descriptor = InterfaceDescriptor{
	Name: "zwp_pointer_gesture_swipe_v1",
	Events: []EventDescriptor{
		{Name: "begin", Opcode: 0, Type: &ZwpPointerGestureSwipeV1BeginEvent{}},
		{Name: "update", Opcode: 1, Type: &ZwpPointerGestureSwipeV1UpdateEvent{}},
		{Name: "end", Opcode: 2, Type: &ZwpPointerGestureSwipeV1EndEvent{}},
	},
	Requests: []RequestDescriptor{
		{Name: "destroy", Opcode: 0, Type: &ZwpPointerGestureSwipeV1DestroyRequest{}},
	},
}
var ZwpPointerGesturePinchV1Descriptor = InterfaceDescriptor{
	Name: "zwp_pointer_gesture_pinch_v1",
	Events: []EventDescriptor{
		{Name: "begin", Opcode: 0, Type: &ZwpPointerGesturePinchV1BeginEvent{}},
		{Name: "update", Opcode: 1, Type: &ZwpPointerGesturePinchV1UpdateEvent{}},
		{Name: "end", Opcode: 2, Type: &ZwpPointerGesturePinchV1EndEvent{}},
	},
	Requests: []RequestDescriptor{
		{Name: "destroy", Opcode: 0, Type: &ZwpPointerGesturePinchV1DestroyRequest{}},
	},
}
var ZwpPointerGestureHoldV1Descriptor = InterfaceDescriptor{
	Name: "zwp_pointer_gesture_hold_v1",
	Events: []EventDescriptor{
		{Name: "begin", Opcode: 0, Type: &ZwpPointerGestureHoldV1BeginEvent{}},
		{Name: "end", Opcode: 1, Type: &ZwpPointerGestureHoldV1EndEvent{}},
	},
	Requests: []RequestDescriptor{
		{Name: "destroy", Opcode: 0, Type: &ZwpPointerGestureHoldV1DestroyRequest{}},
	},
}
var WpPresentationDescriptor = InterfaceDescriptor{
	Name: "wp_presentation",
	Events: []EventDescriptor{
		{Name: "clock_id", Opcode: 0, Type: &WpPresentationClockIDEvent{}},
	},
	Requests: []RequestDescriptor{
		{Name: "destroy", Opcode: 0, Type: &WpPresentationDestroyRequest{}},
		{Name: "feedback", Opcode: 1, Type: &WpPresentationFeedbackRequest{}},
	},
}
var WpPresentationFeedbackDescriptor = InterfaceDescriptor{
	Name: "wp_presentation_feedback",
	Events: []EventDescriptor{
		{Name: "sync_output", Opcode: 0, Type: &WpPresentationFeedbackSyncOutputEvent{}},
		{Name: "presented", Opcode: 1, Type: &WpPresentationFeedbackPresentedEvent{}},
		{Name: "discarded", Opcode: 2, Type: &WpPresentationFeedbackDiscardedEvent{}},
	},
	Requests: []RequestDescriptor{},
}
var ZwpRelativePointerManagerV1Descriptor = InterfaceDescriptor{
	Name:   "zwp_relative_pointer_manager_v1",
	Events: []EventDescriptor{},
	Requests: []RequestDescriptor{
		{Name: "destroy", Opcode: 0, Type: &ZwpRelativePointerManagerV1DestroyRequest{}},
		{Name: "get_relative_pointer", Opcode: 1, Type: &ZwpRelativePointerManagerV1GetRelativePointerRequest{}},
	},
}
var ZwpRelativePointerV1Descriptor = InterfaceDescriptor{
	Name: "zwp_relative_pointer_v1",
	Events: []EventDescriptor{
		{Name: "relative_motion", Opcode: 0, Type: &ZwpRelativePointerV1RelativeMotionEvent{}},
	},
	Requests: []RequestDescriptor{
		{Name: "destroy", Opcode: 0, Type: &ZwpRelativePointerV1DestroyRequest{}},
	},
}
var ZwpTabletManagerV1Descriptor = InterfaceDescriptor{
	Name:   "zwp_tablet_manager_v1",
	Events: []EventDescriptor{},
	Requests: []RequestDescriptor{
		{Name: "get_tablet_seat", Opcode: 0, Type: &ZwpTabletManagerV1GetTabletSeatRequest{}},
		{Name: "destroy", Opcode: 1, Type: &ZwpTabletManagerV1DestroyRequest{}},
	},
}
var ZwpTabletSeatV1Descriptor = InterfaceDescriptor{
	Name: "zwp_tablet_seat_v1",
	Events: []EventDescriptor{
		{Name: "tablet_added", Opcode: 0, Type: &ZwpTabletSeatV1TabletAddedEvent{}},
		{Name: "tool_added", Opcode: 1, Type: &ZwpTabletSeatV1ToolAddedEvent{}},
	},
	Requests: []RequestDescriptor{
		{Name: "destroy", Opcode: 0, Type: &ZwpTabletSeatV1DestroyRequest{}},
	},
}
var ZwpTabletToolV1Descriptor = InterfaceDescriptor{
	Name: "zwp_tablet_tool_v1",
	Events: []EventDescriptor{
		{Name: "type", Opcode: 0, Type: &ZwpTabletToolV1TypeEvent{}},
		{Name: "hardware_serial", Opcode: 1, Type: &ZwpTabletToolV1HardwareSerialEvent{}},
		{Name: "hardware_id_wacom", Opcode: 2, Type: &ZwpTabletToolV1HardwareIDWacomEvent{}},
		{Name: "capability", Opcode: 3, Type: &ZwpTabletToolV1CapabilityEvent{}},
		{Name: "done", Opcode: 4, Type: &ZwpTabletToolV1DoneEvent{}},
		{Name: "removed", Opcode: 5, Type: &ZwpTabletToolV1RemovedEvent{}},
		{Name: "proximity_in", Opcode: 6, Type: &ZwpTabletToolV1ProximityInEvent{}},
		{Name: "proximity_out", Opcode: 7, Type: &ZwpTabletToolV1ProximityOutEvent{}},
		{Name: "down", Opcode: 8, Type: &ZwpTabletToolV1DownEvent{}},
		{Name: "up", Opcode: 9, Type: &ZwpTabletToolV1UpEvent{}},
		{Name: "motion", Opcode: 10, Type: &ZwpTabletToolV1MotionEvent{}},
		{Name: "pressure", Opcode: 11, Type: &ZwpTabletToolV1PressureEvent{}},
		{Name: "distance", Opcode: 12, Type: &ZwpTabletToolV1DistanceEvent{}},
		{Name: "tilt", Opcode: 13, Type: &ZwpTabletToolV1TiltEvent{}},
		{Name: "rotation", Opcode: 14, Type: &ZwpTabletToolV1RotationEvent{}},
		{Name: "slider", Opcode: 15, Type: &ZwpTabletToolV1SliderEvent{}},
		{Name: "wheel", Opcode: 16, Type: &ZwpTabletToolV1WheelEvent{}},
		{Name: "button", Opcode: 17, Type: &ZwpTabletToolV1ButtonEvent{}},
		{Name: "frame", Opcode: 18, Type: &ZwpTabletToolV1FrameEvent{}},
	},
	Requests: []RequestDescriptor{
		{Name: "set_cursor", Opcode: 0, Type: &ZwpTabletToolV1SetCursorRequest{}},
		{Name: "destroy", Opcode: 1, Type: &ZwpTabletToolV1DestroyRequest{}},
	},
}
var ZwpTabletV1Descriptor = InterfaceDescriptor{
	Name: "zwp_tablet_v1",
	Events: []EventDescriptor{
		{Name: "name", Opcode: 0, Type: &ZwpTabletV1NameEvent{}},
		{Name: "id", Opcode: 1, Type: &ZwpTabletV1IDEvent{}},
		{Name: "path", Opcode: 2, Type: &ZwpTabletV1PathEvent{}},
		{Name: "done", Opcode: 3, Type: &ZwpTabletV1DoneEvent{}},
		{Name: "removed", Opcode: 4, Type: &ZwpTabletV1RemovedEvent{}},
	},
	Requests: []RequestDescriptor{
		{Name: "destroy", Opcode: 0, Type: &ZwpTabletV1DestroyRequest{}},
	},
}
var ZwpTabletManagerV2Descriptor = InterfaceDescriptor{
	Name:   "zwp_tablet_manager_v2",
	Events: []EventDescriptor{},
	Requests: []RequestDescriptor{
		{Name: "get_tablet_seat", Opcode: 0, Type: &ZwpTabletManagerV2GetTabletSeatRequest{}},
		{Name: "destroy", Opcode: 1, Type: &ZwpTabletManagerV2DestroyRequest{}},
	},
}
var ZwpTabletSeatV2Descriptor = InterfaceDescriptor{
	Name: "zwp_tablet_seat_v2",
	Events: []EventDescriptor{
		{Name: "tablet_added", Opcode: 0, Type: &ZwpTabletSeatV2TabletAddedEvent{}},
		{Name: "tool_added", Opcode: 1, Type: &ZwpTabletSeatV2ToolAddedEvent{}},
		{Name: "pad_added", Opcode: 2, Type: &ZwpTabletSeatV2PadAddedEvent{}},
	},
	Requests: []RequestDescriptor{
		{Name: "destroy", Opcode: 0, Type: &ZwpTabletSeatV2DestroyRequest{}},
	},
}
var ZwpTabletToolV2Descriptor = InterfaceDescriptor{
	Name: "zwp_tablet_tool_v2",
	Events: []EventDescriptor{
		{Name: "type", Opcode: 0, Type: &ZwpTabletToolV2TypeEvent{}},
		{Name: "hardware_serial", Opcode: 1, Type: &ZwpTabletToolV2HardwareSerialEvent{}},
		{Name: "hardware_id_wacom", Opcode: 2, Type: &ZwpTabletToolV2HardwareIDWacomEvent{}},
		{Name: "capability", Opcode: 3, Type: &ZwpTabletToolV2CapabilityEvent{}},
		{Name: "done", Opcode: 4, Type: &ZwpTabletToolV2DoneEvent{}},
		{Name: "removed", Opcode: 5, Type: &ZwpTabletToolV2RemovedEvent{}},
		{Name: "proximity_in", Opcode: 6, Type: &ZwpTabletToolV2ProximityInEvent{}},
		{Name: "proximity_out", Opcode: 7, Type: &ZwpTabletToolV2ProximityOutEvent{}},
		{Name: "down", Opcode: 8, Type: &ZwpTabletToolV2DownEvent{}},
		{Name: "up", Opcode: 9, Type: &ZwpTabletToolV2UpEvent{}},
		{Name: "motion", Opcode: 10, Type: &ZwpTabletToolV2MotionEvent{}},
		{Name: "pressure", Opcode: 11, Type: &ZwpTabletToolV2PressureEvent{}},
		{Name: "distance", Opcode: 12, Type: &ZwpTabletToolV2DistanceEvent{}},
		{Name: "tilt", Opcode: 13, Type: &ZwpTabletToolV2TiltEvent{}},
		{Name: "rotation", Opcode: 14, Type: &ZwpTabletToolV2RotationEvent{}},
		{Name: "slider", Opcode: 15, Type: &ZwpTabletToolV2SliderEvent{}},
		{Name: "wheel", Opcode: 16, Type: &ZwpTabletToolV2WheelEvent{}},
		{Name: "button", Opcode: 17, Type: &ZwpTabletToolV2ButtonEvent{}},
		{Name: "frame", Opcode: 18, Type: &ZwpTabletToolV2FrameEvent{}},
	},
	Requests: []RequestDescriptor{
		{Name: "set_cursor", Opcode: 0, Type: &ZwpTabletToolV2SetCursorRequest{}},
		{Name: "destroy", Opcode: 1, Type: &ZwpTabletToolV2DestroyRequest{}},
	},
}
var ZwpTabletV2Descriptor = InterfaceDescriptor{
	Name: "zwp_tablet_v2",
	Events: []EventDescriptor{
		{Name: "name", Opcode: 0, Type: &ZwpTabletV2NameEvent{}},
		{Name: "id", Opcode: 1, Type: &ZwpTabletV2IDEvent{}},
		{Name: "path", Opcode: 2, Type: &ZwpTabletV2PathEvent{}},
		{Name: "done", Opcode: 3, Type: &ZwpTabletV2DoneEvent{}},
		{Name: "removed", Opcode: 4, Type: &ZwpTabletV2RemovedEvent{}},
	},
	Requests: []RequestDescriptor{
		{Name: "destroy", Opcode: 0, Type: &ZwpTabletV2DestroyRequest{}},
	},
}
var ZwpTabletPadRingV2Descriptor = InterfaceDescriptor{
	Name: "zwp_tablet_pad_ring_v2",
	Events: []EventDescriptor{
		{Name: "source", Opcode: 0, Type: &ZwpTabletPadRingV2SourceEvent{}},
		{Name: "angle", Opcode: 1, Type: &ZwpTabletPadRingV2AngleEvent{}},
		{Name: "stop", Opcode: 2, Type: &ZwpTabletPadRingV2StopEvent{}},
		{Name: "frame", Opcode: 3, Type: &ZwpTabletPadRingV2FrameEvent{}},
	},
	Requests: []RequestDescriptor{
		{Name: "set_feedback", Opcode: 0, Type: &ZwpTabletPadRingV2SetFeedbackRequest{}},
		{Name: "destroy", Opcode: 1, Type: &ZwpTabletPadRingV2DestroyRequest{}},
	},
}
var ZwpTabletPadStripV2Descriptor = InterfaceDescriptor{
	Name: "zwp_tablet_pad_strip_v2",
	Events: []EventDescriptor{
		{Name: "source", Opcode: 0, Type: &ZwpTabletPadStripV2SourceEvent{}},
		{Name: "position", Opcode: 1, Type: &ZwpTabletPadStripV2PositionEvent{}},
		{Name: "stop", Opcode: 2, Type: &ZwpTabletPadStripV2StopEvent{}},
		{Name: "frame", Opcode: 3, Type: &ZwpTabletPadStripV2FrameEvent{}},
	},
	Requests: []RequestDescriptor{
		{Name: "set_feedback", Opcode: 0, Type: &ZwpTabletPadStripV2SetFeedbackRequest{}},
		{Name: "destroy", Opcode: 1, Type: &ZwpTabletPadStripV2DestroyRequest{}},
	},
}
var ZwpTabletPadGroupV2Descriptor = InterfaceDescriptor{
	Name: "zwp_tablet_pad_group_v2",
	Events: []EventDescriptor{
		{Name: "buttons", Opcode: 0, Type: &ZwpTabletPadGroupV2ButtonsEvent{}},
		{Name: "ring", Opcode: 1, Type: &ZwpTabletPadGroupV2RingEvent{}},
		{Name: "strip", Opcode: 2, Type: &ZwpTabletPadGroupV2StripEvent{}},
		{Name: "modes", Opcode: 3, Type: &ZwpTabletPadGroupV2ModesEvent{}},
		{Name: "done", Opcode: 4, Type: &ZwpTabletPadGroupV2DoneEvent{}},
		{Name: "mode_switch", Opcode: 5, Type: &ZwpTabletPadGroupV2ModeSwitchEvent{}},
	},
	Requests: []RequestDescriptor{
		{Name: "destroy", Opcode: 0, Type: &ZwpTabletPadGroupV2DestroyRequest{}},
	},
}
var ZwpTabletPadV2Descriptor = InterfaceDescriptor{
	Name: "zwp_tablet_pad_v2",
	Events: []EventDescriptor{
		{Name: "group", Opcode: 0, Type: &ZwpTabletPadV2GroupEvent{}},
		{Name: "path", Opcode: 1, Type: &ZwpTabletPadV2PathEvent{}},
		{Name: "buttons", Opcode: 2, Type: &ZwpTabletPadV2ButtonsEvent{}},
		{Name: "done", Opcode: 3, Type: &ZwpTabletPadV2DoneEvent{}},
		{Name: "button", Opcode: 4, Type: &ZwpTabletPadV2ButtonEvent{}},
		{Name: "enter", Opcode: 5, Type: &ZwpTabletPadV2EnterEvent{}},
		{Name: "leave", Opcode: 6, Type: &ZwpTabletPadV2LeaveEvent{}},
		{Name: "removed", Opcode: 7, Type: &ZwpTabletPadV2RemovedEvent{}},
	},
	Requests: []RequestDescriptor{
		{Name: "set_feedback", Opcode: 0, Type: &ZwpTabletPadV2SetFeedbackRequest{}},
		{Name: "destroy", Opcode: 1, Type: &ZwpTabletPadV2DestroyRequest{}},
	},
}
var ZwpTextInputV1Descriptor = InterfaceDescriptor{
	Name: "zwp_text_input_v1",
	Events: []EventDescriptor{
		{Name: "enter", Opcode: 0, Type: &ZwpTextInputV1EnterEvent{}},
		{Name: "leave", Opcode: 1, Type: &ZwpTextInputV1LeaveEvent{}},
		{Name: "modifiers_map", Opcode: 2, Type: &ZwpTextInputV1ModifiersMapEvent{}},
		{Name: "input_panel_state", Opcode: 3, Type: &ZwpTextInputV1InputPanelStateEvent{}},
		{Name: "preedit_string", Opcode: 4, Type: &ZwpTextInputV1PreeditStringEvent{}},
		{Name: "preedit_styling", Opcode: 5, Type: &ZwpTextInputV1PreeditStylingEvent{}},
		{Name: "preedit_cursor", Opcode: 6, Type: &ZwpTextInputV1PreeditCursorEvent{}},
		{Name: "commit_string", Opcode: 7, Type: &ZwpTextInputV1CommitStringEvent{}},
		{Name: "cursor_position", Opcode: 8, Type: &ZwpTextInputV1CursorPositionEvent{}},
		{Name: "delete_surrounding_text", Opcode: 9, Type: &ZwpTextInputV1DeleteSurroundingTextEvent{}},
		{Name: "keysym", Opcode: 10, Type: &ZwpTextInputV1KeysymEvent{}},
		{Name: "language", Opcode: 11, Type: &ZwpTextInputV1LanguageEvent{}},
		{Name: "text_direction", Opcode: 12, Type: &ZwpTextInputV1TextDirectionEvent{}},
	},
	Requests: []RequestDescriptor{
		{Name: "activate", Opcode: 0, Type: &ZwpTextInputV1ActivateRequest{}},
		{Name: "deactivate", Opcode: 1, Type: &ZwpTextInputV1DeactivateRequest{}},
		{Name: "show_input_panel", Opcode: 2, Type: &ZwpTextInputV1ShowInputPanelRequest{}},
		{Name: "hide_input_panel", Opcode: 3, Type: &ZwpTextInputV1HideInputPanelRequest{}},
		{Name: "reset", Opcode: 4, Type: &ZwpTextInputV1ResetRequest{}},
		{Name: "set_surrounding_text", Opcode: 5, Type: &ZwpTextInputV1SetSurroundingTextRequest{}},
		{Name: "set_content_type", Opcode: 6, Type: &ZwpTextInputV1SetContentTypeRequest{}},
		{Name: "set_cursor_rectangle", Opcode: 7, Type: &ZwpTextInputV1SetCursorRectangleRequest{}},
		{Name: "set_preferred_language", Opcode: 8, Type: &ZwpTextInputV1SetPreferredLanguageRequest{}},
		{Name: "commit_state", Opcode: 9, Type: &ZwpTextInputV1CommitStateRequest{}},
		{Name: "invoke_action", Opcode: 10, Type: &ZwpTextInputV1InvokeActionRequest{}},
	},
}
var ZwpTextInputManagerV1Descriptor = InterfaceDescriptor{
	Name:   "zwp_text_input_manager_v1",
	Events: []EventDescriptor{},
	Requests: []RequestDescriptor{
		{Name: "create_text_input", Opcode: 0, Type: &ZwpTextInputManagerV1CreateTextInputRequest{}},
	},
}
var ZwpTextInputV3Descriptor = InterfaceDescriptor{
	Name: "zwp_text_input_v3",
	Events: []EventDescriptor{
		{Name: "enter", Opcode: 0, Type: &ZwpTextInputV3EnterEvent{}},
		{Name: "leave", Opcode: 1, Type: &ZwpTextInputV3LeaveEvent{}},
		{Name: "preedit_string", Opcode: 2, Type: &ZwpTextInputV3PreeditStringEvent{}},
		{Name: "commit_string", Opcode: 3, Type: &ZwpTextInputV3CommitStringEvent{}},
		{Name: "delete_surrounding_text", Opcode: 4, Type: &ZwpTextInputV3DeleteSurroundingTextEvent{}},
		{Name: "done", Opcode: 5, Type: &ZwpTextInputV3DoneEvent{}},
	},
	Requests: []RequestDescriptor{
		{Name: "destroy", Opcode: 0, Type: &ZwpTextInputV3DestroyRequest{}},
		{Name: "enable", Opcode: 1, Type: &ZwpTextInputV3EnableRequest{}},
		{Name: "disable", Opcode: 2, Type: &ZwpTextInputV3DisableRequest{}},
		{Name: "set_surrounding_text", Opcode: 3, Type: &ZwpTextInputV3SetSurroundingTextRequest{}},
		{Name: "set_text_change_cause", Opcode: 4, Type: &ZwpTextInputV3SetTextChangeCauseRequest{}},
		{Name: "set_content_type", Opcode: 5, Type: &ZwpTextInputV3SetContentTypeRequest{}},
		{Name: "set_cursor_rectangle", Opcode: 6, Type: &ZwpTextInputV3SetCursorRectangleRequest{}},
		{Name: "commit", Opcode: 7, Type: &ZwpTextInputV3CommitRequest{}},
	},
}
var ZwpTextInputManagerV3Descriptor = InterfaceDescriptor{
	Name:   "zwp_text_input_manager_v3",
	Events: []EventDescriptor{},
	Requests: []RequestDescriptor{
		{Name: "destroy", Opcode: 0, Type: &ZwpTextInputManagerV3DestroyRequest{}},
		{Name: "get_text_input", Opcode: 1, Type: &ZwpTextInputManagerV3GetTextInputRequest{}},
	},
}
var WpViewporterDescriptor = InterfaceDescriptor{
	Name:   "wp_viewporter",
	Events: []EventDescriptor{},
	Requests: []RequestDescriptor{
		{Name: "destroy", Opcode: 0, Type: &WpViewporterDestroyRequest{}},
		{Name: "get_viewport", Opcode: 1, Type: &WpViewporterGetViewportRequest{}},
	},
}
var WpViewportDescriptor = InterfaceDescriptor{
	Name:   "wp_viewport",
	Events: []EventDescriptor{},
	Requests: []RequestDescriptor{
		{Name: "destroy", Opcode: 0, Type: &WpViewportDestroyRequest{}},
		{Name: "set_source", Opcode: 1, Type: &WpViewportSetSourceRequest{}},
		{Name: "set_destination", Opcode: 2, Type: &WpViewportSetDestinationRequest{}},
	},
}
var WlDisplayDescriptor = InterfaceDescriptor{
	Name: "wl_display",
	Events: []EventDescriptor{
		{Name: "error", Opcode: 0, Type: &WlDisplayErrorEvent{}},
		{Name: "delete_id", Opcode: 1, Type: &WlDisplayDeleteIDEvent{}},
	},
	Requests: []RequestDescriptor{
		{Name: "sync", Opcode: 0, Type: &WlDisplaySyncRequest{}},
		{Name: "get_registry", Opcode: 1, Type: &WlDisplayGetRegistryRequest{}},
	},
}
var WlRegistryDescriptor = InterfaceDescriptor{
	Name: "wl_registry",
	Events: []EventDescriptor{
		{Name: "global", Opcode: 0, Type: &WlRegistryGlobalEvent{}},
		{Name: "global_remove", Opcode: 1, Type: &WlRegistryGlobalRemoveEvent{}},
	},
	Requests: []RequestDescriptor{
		{Name: "bind", Opcode: 0, Type: &WlRegistryBindRequest{}},
	},
}
var WlCallbackDescriptor = InterfaceDescriptor{
	Name: "wl_callback",
	Events: []EventDescriptor{
		{Name: "done", Opcode: 0, Type: &WlCallbackDoneEvent{}},
	},
	Requests: []RequestDescriptor{},
}
var WlCompositorDescriptor = InterfaceDescriptor{
	Name:   "wl_compositor",
	Events: []EventDescriptor{},
	Requests: []RequestDescriptor{
		{Name: "create_surface", Opcode: 0, Type: &WlCompositorCreateSurfaceRequest{}},
		{Name: "create_region", Opcode: 1, Type: &WlCompositorCreateRegionRequest{}},
	},
}
var WlShmPoolDescriptor = InterfaceDescriptor{
	Name:   "wl_shm_pool",
	Events: []EventDescriptor{},
	Requests: []RequestDescriptor{
		{Name: "create_buffer", Opcode: 0, Type: &WlShmPoolCreateBufferRequest{}},
		{Name: "destroy", Opcode: 1, Type: &WlShmPoolDestroyRequest{}},
		{Name: "resize", Opcode: 2, Type: &WlShmPoolResizeRequest{}},
	},
}
var WlShmDescriptor = InterfaceDescriptor{
	Name: "wl_shm",
	Events: []EventDescriptor{
		{Name: "format", Opcode: 0, Type: &WlShmFormatEvent{}},
	},
	Requests: []RequestDescriptor{
		{Name: "create_pool", Opcode: 0, Type: &WlShmCreatePoolRequest{}},
	},
}
var WlBufferDescriptor = InterfaceDescriptor{
	Name: "wl_buffer",
	Events: []EventDescriptor{
		{Name: "release", Opcode: 0, Type: &WlBufferReleaseEvent{}},
	},
	Requests: []RequestDescriptor{
		{Name: "destroy", Opcode: 0, Type: &WlBufferDestroyRequest{}},
	},
}
var WlDataOfferDescriptor = InterfaceDescriptor{
	Name: "wl_data_offer",
	Events: []EventDescriptor{
		{Name: "offer", Opcode: 0, Type: &WlDataOfferOfferEvent{}},
		{Name: "source_actions", Opcode: 1, Type: &WlDataOfferSourceActionsEvent{}},
		{Name: "action", Opcode: 2, Type: &WlDataOfferActionEvent{}},
	},
	Requests: []RequestDescriptor{
		{Name: "accept", Opcode: 0, Type: &WlDataOfferAcceptRequest{}},
		{Name: "receive", Opcode: 1, Type: &WlDataOfferReceiveRequest{}},
		{Name: "destroy", Opcode: 2, Type: &WlDataOfferDestroyRequest{}},
		{Name: "finish", Opcode: 3, Type: &WlDataOfferFinishRequest{}},
		{Name: "set_actions", Opcode: 4, Type: &WlDataOfferSetActionsRequest{}},
	},
}
var WlDataSourceDescriptor = InterfaceDescriptor{
	Name: "wl_data_source",
	Events: []EventDescriptor{
		{Name: "target", Opcode: 0, Type: &WlDataSourceTargetEvent{}},
		{Name: "send", Opcode: 1, Type: &WlDataSourceSendEvent{}},
		{Name: "cancelled", Opcode: 2, Type: &WlDataSourceCancelledEvent{}},
		{Name: "dnd_drop_performed", Opcode: 3, Type: &WlDataSourceDndDropPerformedEvent{}},
		{Name: "dnd_finished", Opcode: 4, Type: &WlDataSourceDndFinishedEvent{}},
		{Name: "action", Opcode: 5, Type: &WlDataSourceActionEvent{}},
	},
	Requests: []RequestDescriptor{
		{Name: "offer", Opcode: 0, Type: &WlDataSourceOfferRequest{}},
		{Name: "destroy", Opcode: 1, Type: &WlDataSourceDestroyRequest{}},
		{Name: "set_actions", Opcode: 2, Type: &WlDataSourceSetActionsRequest{}},
	},
}
var WlDataDeviceDescriptor = InterfaceDescriptor{
	Name: "wl_data_device",
	Events: []EventDescriptor{
		{Name: "data_offer", Opcode: 0, Type: &WlDataDeviceDataOfferEvent{}},
		{Name: "enter", Opcode: 1, Type: &WlDataDeviceEnterEvent{}},
		{Name: "leave", Opcode: 2, Type: &WlDataDeviceLeaveEvent{}},
		{Name: "motion", Opcode: 3, Type: &WlDataDeviceMotionEvent{}},
		{Name: "drop", Opcode: 4, Type: &WlDataDeviceDropEvent{}},
		{Name: "selection", Opcode: 5, Type: &WlDataDeviceSelectionEvent{}},
	},
	Requests: []RequestDescriptor{
		{Name: "start_drag", Opcode: 0, Type: &WlDataDeviceStartDragRequest{}},
		{Name: "set_selection", Opcode: 1, Type: &WlDataDeviceSetSelectionRequest{}},
		{Name: "release", Opcode: 2, Type: &WlDataDeviceReleaseRequest{}},
	},
}
var WlDataDeviceManagerDescriptor = InterfaceDescriptor{
	Name:   "wl_data_device_manager",
	Events: []EventDescriptor{},
	Requests: []RequestDescriptor{
		{Name: "create_data_source", Opcode: 0, Type: &WlDataDeviceManagerCreateDataSourceRequest{}},
		{Name: "get_data_device", Opcode: 1, Type: &WlDataDeviceManagerGetDataDeviceRequest{}},
	},
}
var WlShellDescriptor = InterfaceDescriptor{
	Name:   "wl_shell",
	Events: []EventDescriptor{},
	Requests: []RequestDescriptor{
		{Name: "get_shell_surface", Opcode: 0, Type: &WlShellGetShellSurfaceRequest{}},
	},
}
var WlShellSurfaceDescriptor = InterfaceDescriptor{
	Name: "wl_shell_surface",
	Events: []EventDescriptor{
		{Name: "ping", Opcode: 0, Type: &WlShellSurfacePingEvent{}},
		{Name: "configure", Opcode: 1, Type: &WlShellSurfaceConfigureEvent{}},
		{Name: "popup_done", Opcode: 2, Type: &WlShellSurfacePopupDoneEvent{}},
	},
	Requests: []RequestDescriptor{
		{Name: "pong", Opcode: 0, Type: &WlShellSurfacePongRequest{}},
		{Name: "move", Opcode: 1, Type: &WlShellSurfaceMoveRequest{}},
		{Name: "resize", Opcode: 2, Type: &WlShellSurfaceResizeRequest{}},
		{Name: "set_toplevel", Opcode: 3, Type: &WlShellSurfaceSetToplevelRequest{}},
		{Name: "set_transient", Opcode: 4, Type: &WlShellSurfaceSetTransientRequest{}},
		{Name: "set_fullscreen", Opcode: 5, Type: &WlShellSurfaceSetFullscreenRequest{}},
		{Name: "set_popup", Opcode: 6, Type: &WlShellSurfaceSetPopupRequest{}},
		{Name: "set_maximized", Opcode: 7, Type: &WlShellSurfaceSetMaximizedRequest{}},
		{Name: "set_title", Opcode: 8, Type: &WlShellSurfaceSetTitleRequest{}},
		{Name: "set_class", Opcode: 9, Type: &WlShellSurfaceSetClassRequest{}},
	},
}
var WlSurfaceDescriptor = InterfaceDescriptor{
	Name: "wl_surface",
	Events: []EventDescriptor{
		{Name: "enter", Opcode: 0, Type: &WlSurfaceEnterEvent{}},
		{Name: "leave", Opcode: 1, Type: &WlSurfaceLeaveEvent{}},
	},
	Requests: []RequestDescriptor{
		{Name: "destroy", Opcode: 0, Type: &WlSurfaceDestroyRequest{}},
		{Name: "attach", Opcode: 1, Type: &WlSurfaceAttachRequest{}},
		{Name: "damage", Opcode: 2, Type: &WlSurfaceDamageRequest{}},
		{Name: "frame", Opcode: 3, Type: &WlSurfaceFrameRequest{}},
		{Name: "set_opaque_region", Opcode: 4, Type: &WlSurfaceSetOpaqueRegionRequest{}},
		{Name: "set_input_region", Opcode: 5, Type: &WlSurfaceSetInputRegionRequest{}},
		{Name: "commit", Opcode: 6, Type: &WlSurfaceCommitRequest{}},
		{Name: "set_buffer_transform", Opcode: 7, Type: &WlSurfaceSetBufferTransformRequest{}},
		{Name: "set_buffer_scale", Opcode: 8, Type: &WlSurfaceSetBufferScaleRequest{}},
		{Name: "damage_buffer", Opcode: 9, Type: &WlSurfaceDamageBufferRequest{}},
	},
}
var WlSeatDescriptor = InterfaceDescriptor{
	Name: "wl_seat",
	Events: []EventDescriptor{
		{Name: "capabilities", Opcode: 0, Type: &WlSeatCapabilitiesEvent{}},
		{Name: "name", Opcode: 1, Type: &WlSeatNameEvent{}},
	},
	Requests: []RequestDescriptor{
		{Name: "get_pointer", Opcode: 0, Type: &WlSeatGetPointerRequest{}},
		{Name: "get_keyboard", Opcode: 1, Type: &WlSeatGetKeyboardRequest{}},
		{Name: "get_touch", Opcode: 2, Type: &WlSeatGetTouchRequest{}},
		{Name: "release", Opcode: 3, Type: &WlSeatReleaseRequest{}},
	},
}
var WlPointerDescriptor = InterfaceDescriptor{
	Name: "wl_pointer",
	Events: []EventDescriptor{
		{Name: "enter", Opcode: 0, Type: &WlPointerEnterEvent{}},
		{Name: "leave", Opcode: 1, Type: &WlPointerLeaveEvent{}},
		{Name: "motion", Opcode: 2, Type: &WlPointerMotionEvent{}},
		{Name: "button", Opcode: 3, Type: &WlPointerButtonEvent{}},
		{Name: "axis", Opcode: 4, Type: &WlPointerAxisEvent{}},
		{Name: "frame", Opcode: 5, Type: &WlPointerFrameEvent{}},
		{Name: "axis_source", Opcode: 6, Type: &WlPointerAxisSourceEvent{}},
		{Name: "axis_stop", Opcode: 7, Type: &WlPointerAxisStopEvent{}},
		{Name: "axis_discrete", Opcode: 8, Type: &WlPointerAxisDiscreteEvent{}},
	},
	Requests: []RequestDescriptor{
		{Name: "set_cursor", Opcode: 0, Type: &WlPointerSetCursorRequest{}},
		{Name: "release", Opcode: 1, Type: &WlPointerReleaseRequest{}},
	},
}
var WlKeyboardDescriptor = InterfaceDescriptor{
	Name: "wl_keyboard",
	Events: []EventDescriptor{
		{Name: "keymap", Opcode: 0, Type: &WlKeyboardKeymapEvent{}},
		{Name: "enter", Opcode: 1, Type: &WlKeyboardEnterEvent{}},
		{Name: "leave", Opcode: 2, Type: &WlKeyboardLeaveEvent{}},
		{Name: "key", Opcode: 3, Type: &WlKeyboardKeyEvent{}},
		{Name: "modifiers", Opcode: 4, Type: &WlKeyboardModifiersEvent{}},
		{Name: "repeat_info", Opcode: 5, Type: &WlKeyboardRepeatInfoEvent{}},
	},
	Requests: []RequestDescriptor{
		{Name: "release", Opcode: 0, Type: &WlKeyboardReleaseRequest{}},
	},
}
var WlTouchDescriptor = InterfaceDescriptor{
	Name: "wl_touch",
	Events: []EventDescriptor{
		{Name: "down", Opcode: 0, Type: &WlTouchDownEvent{}},
		{Name: "up", Opcode: 1, Type: &WlTouchUpEvent{}},
		{Name: "motion", Opcode: 2, Type: &WlTouchMotionEvent{}},
		{Name: "frame", Opcode: 3, Type: &WlTouchFrameEvent{}},
		{Name: "cancel", Opcode: 4, Type: &WlTouchCancelEvent{}},
		{Name: "shape", Opcode: 5, Type: &WlTouchShapeEvent{}},
		{Name: "orientation", Opcode: 6, Type: &WlTouchOrientationEvent{}},
	},
	Requests: []RequestDescriptor{
		{Name: "release", Opcode: 0, Type: &WlTouchReleaseRequest{}},
	},
}
var WlOutputDescriptor = InterfaceDescriptor{
	Name: "wl_output",
	Events: []EventDescriptor{
		{Name: "geometry", Opcode: 0, Type: &WlOutputGeometryEvent{}},
		{Name: "mode", Opcode: 1, Type: &WlOutputModeEvent{}},
		{Name: "done", Opcode: 2, Type: &WlOutputDoneEvent{}},
		{Name: "scale", Opcode: 3, Type: &WlOutputScaleEvent{}},
	},
	Requests: []RequestDescriptor{
		{Name: "release", Opcode: 0, Type: &WlOutputReleaseRequest{}},
	},
}
var WlRegionDescriptor = InterfaceDescriptor{
	Name:   "wl_region",
	Events: []EventDescriptor{},
	Requests: []RequestDescriptor{
		{Name: "destroy", Opcode: 0, Type: &WlRegionDestroyRequest{}},
		{Name: "add", Opcode: 1, Type: &WlRegionAddRequest{}},
		{Name: "subtract", Opcode: 2, Type: &WlRegionSubtractRequest{}},
	},
}
var WlSubcompositorDescriptor = InterfaceDescriptor{
	Name:   "wl_subcompositor",
	Events: []EventDescriptor{},
	Requests: []RequestDescriptor{
		{Name: "destroy", Opcode: 0, Type: &WlSubcompositorDestroyRequest{}},
		{Name: "get_subsurface", Opcode: 1, Type: &WlSubcompositorGetSubsurfaceRequest{}},
	},
}
var WlSubsurfaceDescriptor = InterfaceDescriptor{
	Name:   "wl_subsurface",
	Events: []EventDescriptor{},
	Requests: []RequestDescriptor{
		{Name: "destroy", Opcode: 0, Type: &WlSubsurfaceDestroyRequest{}},
		{Name: "set_position", Opcode: 1, Type: &WlSubsurfaceSetPositionRequest{}},
		{Name: "place_above", Opcode: 2, Type: &WlSubsurfacePlaceAboveRequest{}},
		{Name: "place_below", Opcode: 3, Type: &WlSubsurfacePlaceBelowRequest{}},
		{Name: "set_sync", Opcode: 4, Type: &WlSubsurfaceSetSyncRequest{}},
		{Name: "set_desync", Opcode: 5, Type: &WlSubsurfaceSetDesyncRequest{}},
	},
}
var ZwpPrimarySelectionDeviceManagerV1Descriptor = InterfaceDescriptor{
	Name:   "zwp_primary_selection_device_manager_v1",
	Events: []EventDescriptor{},
	Requests: []RequestDescriptor{
		{Name: "create_source", Opcode: 0, Type: &ZwpPrimarySelectionDeviceManagerV1CreateSourceRequest{}},
		{Name: "get_device", Opcode: 1, Type: &ZwpPrimarySelectionDeviceManagerV1GetDeviceRequest{}},
		{Name: "destroy", Opcode: 2, Type: &ZwpPrimarySelectionDeviceManagerV1DestroyRequest{}},
	},
}
var ZwpPrimarySelectionDeviceV1Descriptor = InterfaceDescriptor{
	Name: "zwp_primary_selection_device_v1",
	Events: []EventDescriptor{
		{Name: "data_offer", Opcode: 0, Type: &ZwpPrimarySelectionDeviceV1DataOfferEvent{}},
		{Name: "selection", Opcode: 1, Type: &ZwpPrimarySelectionDeviceV1SelectionEvent{}},
	},
	Requests: []RequestDescriptor{
		{Name: "set_selection", Opcode: 0, Type: &ZwpPrimarySelectionDeviceV1SetSelectionRequest{}},
		{Name: "destroy", Opcode: 1, Type: &ZwpPrimarySelectionDeviceV1DestroyRequest{}},
	},
}
var ZwpPrimarySelectionOfferV1Descriptor = InterfaceDescriptor{
	Name: "zwp_primary_selection_offer_v1",
	Events: []EventDescriptor{
		{Name: "offer", Opcode: 0, Type: &ZwpPrimarySelectionOfferV1OfferEvent{}},
	},
	Requests: []RequestDescriptor{
		{Name: "receive", Opcode: 0, Type: &ZwpPrimarySelectionOfferV1ReceiveRequest{}},
		{Name: "destroy", Opcode: 1, Type: &ZwpPrimarySelectionOfferV1DestroyRequest{}},
	},
}
var ZwpPrimarySelectionSourceV1Descriptor = InterfaceDescriptor{
	Name: "zwp_primary_selection_source_v1",
	Events: []EventDescriptor{
		{Name: "send", Opcode: 0, Type: &ZwpPrimarySelectionSourceV1SendEvent{}},
		{Name: "cancelled", Opcode: 1, Type: &ZwpPrimarySelectionSourceV1CancelledEvent{}},
	},
	Requests: []RequestDescriptor{
		{Name: "offer", Opcode: 0, Type: &ZwpPrimarySelectionSourceV1OfferRequest{}},
		{Name: "destroy", Opcode: 1, Type: &ZwpPrimarySelectionSourceV1DestroyRequest{}},
	},
}
var XdgActivationV1Descriptor = InterfaceDescriptor{
	Name:   "xdg_activation_v1",
	Events: []EventDescriptor{},
	Requests: []RequestDescriptor{
		{Name: "destroy", Opcode: 0, Type: &XdgActivationV1DestroyRequest{}},
		{Name: "get_activation_token", Opcode: 1, Type: &XdgActivationV1GetActivationTokenRequest{}},
		{Name: "activate", Opcode: 2, Type: &XdgActivationV1ActivateRequest{}},
	},
}
var XdgActivationTokenV1Descriptor = InterfaceDescriptor{
	Name: "xdg_activation_token_v1",
	Events: []EventDescriptor{
		{Name: "done", Opcode: 0, Type: &XdgActivationTokenV1DoneEvent{}},
	},
	Requests: []RequestDescriptor{
		{Name: "set_serial", Opcode: 0, Type: &XdgActivationTokenV1SetSerialRequest{}},
		{Name: "set_app_id", Opcode: 1, Type: &XdgActivationTokenV1SetAppIDRequest{}},
		{Name: "set_surface", Opcode: 2, Type: &XdgActivationTokenV1SetSurfaceRequest{}},
		{Name: "commit", Opcode: 3, Type: &XdgActivationTokenV1CommitRequest{}},
		{Name: "destroy", Opcode: 4, Type: &XdgActivationTokenV1DestroyRequest{}},
	},
}
var ZxdgDecorationManagerV1Descriptor = InterfaceDescriptor{
	Name:   "zxdg_decoration_manager_v1",
	Events: []EventDescriptor{},
	Requests: []RequestDescriptor{
		{Name: "destroy", Opcode: 0, Type: &ZxdgDecorationManagerV1DestroyRequest{}},
		{Name: "get_toplevel_decoration", Opcode: 1, Type: &ZxdgDecorationManagerV1GetToplevelDecorationRequest{}},
	},
}
var ZxdgToplevelDecorationV1Descriptor = InterfaceDescriptor{
	Name: "zxdg_toplevel_decoration_v1",
	Events: []EventDescriptor{
		{Name: "configure", Opcode: 0, Type: &ZxdgToplevelDecorationV1ConfigureEvent{}},
	},
	Requests: []RequestDescriptor{
		{Name: "destroy", Opcode: 0, Type: &ZxdgToplevelDecorationV1DestroyRequest{}},
		{Name: "set_mode", Opcode: 1, Type: &ZxdgToplevelDecorationV1SetModeRequest{}},
		{Name: "unset_mode", Opcode: 2, Type: &ZxdgToplevelDecorationV1UnsetModeRequest{}},
	},
}
var ZxdgExporterV1Descriptor = InterfaceDescriptor{
	Name:   "zxdg_exporter_v1",
	Events: []EventDescriptor{},
	Requests: []RequestDescriptor{
		{Name: "destroy", Opcode: 0, Type: &ZxdgExporterV1DestroyRequest{}},
		{Name: "export", Opcode: 1, Type: &ZxdgExporterV1ExportRequest{}},
	},
}
var ZxdgImporterV1Descriptor = InterfaceDescriptor{
	Name:   "zxdg_importer_v1",
	Events: []EventDescriptor{},
	Requests: []RequestDescriptor{
		{Name: "destroy", Opcode: 0, Type: &ZxdgImporterV1DestroyRequest{}},
		{Name: "import", Opcode: 1, Type: &ZxdgImporterV1ImportRequest{}},
	},
}
var ZxdgExportedV1Descriptor = InterfaceDescriptor{
	Name: "zxdg_exported_v1",
	Events: []EventDescriptor{
		{Name: "handle", Opcode: 0, Type: &ZxdgExportedV1HandleEvent{}},
	},
	Requests: []RequestDescriptor{
		{Name: "destroy", Opcode: 0, Type: &ZxdgExportedV1DestroyRequest{}},
	},
}
var ZxdgImportedV1Descriptor = InterfaceDescriptor{
	Name: "zxdg_imported_v1",
	Events: []EventDescriptor{
		{Name: "destroyed", Opcode: 0, Type: &ZxdgImportedV1DestroyedEvent{}},
	},
	Requests: []RequestDescriptor{
		{Name: "destroy", Opcode: 0, Type: &ZxdgImportedV1DestroyRequest{}},
		{Name: "set_parent_of", Opcode: 1, Type: &ZxdgImportedV1SetParentOfRequest{}},
	},
}
var ZxdgExporterV2Descriptor = InterfaceDescriptor{
	Name:   "zxdg_exporter_v2",
	Events: []EventDescriptor{},
	Requests: []RequestDescriptor{
		{Name: "destroy", Opcode: 0, Type: &ZxdgExporterV2DestroyRequest{}},
		{Name: "export_toplevel", Opcode: 1, Type: &ZxdgExporterV2ExportToplevelRequest{}},
	},
}
var ZxdgImporterV2Descriptor = InterfaceDescriptor{
	Name:   "zxdg_importer_v2",
	Events: []EventDescriptor{},
	Requests: []RequestDescriptor{
		{Name: "destroy", Opcode: 0, Type: &ZxdgImporterV2DestroyRequest{}},
		{Name: "import_toplevel", Opcode: 1, Type: &ZxdgImporterV2ImportToplevelRequest{}},
	},
}
var ZxdgExportedV2Descriptor = InterfaceDescriptor{
	Name: "zxdg_exported_v2",
	Events: []EventDescriptor{
		{Name: "handle", Opcode: 0, Type: &ZxdgExportedV2HandleEvent{}},
	},
	Requests: []RequestDescriptor{
		{Name: "destroy", Opcode: 0, Type: &ZxdgExportedV2DestroyRequest{}},
	},
}
var ZxdgImportedV2Descriptor = InterfaceDescriptor{
	Name: "zxdg_imported_v2",
	Events: []EventDescriptor{
		{Name: "destroyed", Opcode: 0, Type: &ZxdgImportedV2DestroyedEvent{}},
	},
	Requests: []RequestDescriptor{
		{Name: "destroy", Opcode: 0, Type: &ZxdgImportedV2DestroyRequest{}},
		{Name: "set_parent_of", Opcode: 1, Type: &ZxdgImportedV2SetParentOfRequest{}},
	},
}
var ZxdgOutputManagerV1Descriptor = InterfaceDescriptor{
	Name:   "zxdg_output_manager_v1",
	Events: []EventDescriptor{},
	Requests: []RequestDescriptor{
		{Name: "destroy", Opcode: 0, Type: &ZxdgOutputManagerV1DestroyRequest{}},
		{Name: "get_xdg_output", Opcode: 1, Type: &ZxdgOutputManagerV1GetXdgOutputRequest{}},
	},
}
var ZxdgOutputV1Descriptor = InterfaceDescriptor{
	Name: "zxdg_output_v1",
	Events: []EventDescriptor{
		{Name: "logical_position", Opcode: 0, Type: &ZxdgOutputV1LogicalPositionEvent{}},
		{Name: "logical_size", Opcode: 1, Type: &ZxdgOutputV1LogicalSizeEvent{}},
		{Name: "done", Opcode: 2, Type: &ZxdgOutputV1DoneEvent{}},
		{Name: "name", Opcode: 3, Type: &ZxdgOutputV1NameEvent{}},
		{Name: "description", Opcode: 4, Type: &ZxdgOutputV1DescriptionEvent{}},
	},
	Requests: []RequestDescriptor{
		{Name: "destroy", Opcode: 0, Type: &ZxdgOutputV1DestroyRequest{}},
	},
}
var XdgWmBaseDescriptor = InterfaceDescriptor{
	Name: "xdg_wm_base",
	Events: []EventDescriptor{
		{Name: "ping", Opcode: 0, Type: &XdgWmBasePingEvent{}},
	},
	Requests: []RequestDescriptor{
		{Name: "destroy", Opcode: 0, Type: &XdgWmBaseDestroyRequest{}},
		{Name: "create_positioner", Opcode: 1, Type: &XdgWmBaseCreatePositionerRequest{}},
		{Name: "get_xdg_surface", Opcode: 2, Type: &XdgWmBaseGetXdgSurfaceRequest{}},
		{Name: "pong", Opcode: 3, Type: &XdgWmBasePongRequest{}},
	},
}
var XdgPositionerDescriptor = InterfaceDescriptor{
	Name:   "xdg_positioner",
	Events: []EventDescriptor{},
	Requests: []RequestDescriptor{
		{Name: "destroy", Opcode: 0, Type: &XdgPositionerDestroyRequest{}},
		{Name: "set_size", Opcode: 1, Type: &XdgPositionerSetSizeRequest{}},
		{Name: "set_anchor_rect", Opcode: 2, Type: &XdgPositionerSetAnchorRectRequest{}},
		{Name: "set_anchor", Opcode: 3, Type: &XdgPositionerSetAnchorRequest{}},
		{Name: "set_gravity", Opcode: 4, Type: &XdgPositionerSetGravityRequest{}},
		{Name: "set_constraint_adjustment", Opcode: 5, Type: &XdgPositionerSetConstraintAdjustmentRequest{}},
		{Name: "set_offset", Opcode: 6, Type: &XdgPositionerSetOffsetRequest{}},
		{Name: "set_reactive", Opcode: 7, Type: &XdgPositionerSetReactiveRequest{}},
		{Name: "set_parent_size", Opcode: 8, Type: &XdgPositionerSetParentSizeRequest{}},
		{Name: "set_parent_configure", Opcode: 9, Type: &XdgPositionerSetParentConfigureRequest{}},
	},
}
var XdgSurfaceDescriptor = InterfaceDescriptor{
	Name: "xdg_surface",
	Events: []EventDescriptor{
		{Name: "configure", Opcode: 0, Type: &XdgSurfaceConfigureEvent{}},
	},
	Requests: []RequestDescriptor{
		{Name: "destroy", Opcode: 0, Type: &XdgSurfaceDestroyRequest{}},
		{Name: "get_toplevel", Opcode: 1, Type: &XdgSurfaceGetToplevelRequest{}},
		{Name: "get_popup", Opcode: 2, Type: &XdgSurfaceGetPopupRequest{}},
		{Name: "set_window_geometry", Opcode: 3, Type: &XdgSurfaceSetWindowGeometryRequest{}},
		{Name: "ack_configure", Opcode: 4, Type: &XdgSurfaceAckConfigureRequest{}},
	},
}
var XdgToplevelDescriptor = InterfaceDescriptor{
	Name: "xdg_toplevel",
	Events: []EventDescriptor{
		{Name: "configure", Opcode: 0, Type: &XdgToplevelConfigureEvent{}},
		{Name: "close", Opcode: 1, Type: &XdgToplevelCloseEvent{}},
	},
	Requests: []RequestDescriptor{
		{Name: "destroy", Opcode: 0, Type: &XdgToplevelDestroyRequest{}},
		{Name: "set_parent", Opcode: 1, Type: &XdgToplevelSetParentRequest{}},
		{Name: "set_title", Opcode: 2, Type: &XdgToplevelSetTitleRequest{}},
		{Name: "set_app_id", Opcode: 3, Type: &XdgToplevelSetAppIDRequest{}},
		{Name: "show_window_menu", Opcode: 4, Type: &XdgToplevelShowWindowMenuRequest{}},
		{Name: "move", Opcode: 5, Type: &XdgToplevelMoveRequest{}},
		{Name: "resize", Opcode: 6, Type: &XdgToplevelResizeRequest{}},
		{Name: "set_max_size", Opcode: 7, Type: &XdgToplevelSetMaxSizeRequest{}},
		{Name: "set_min_size", Opcode: 8, Type: &XdgToplevelSetMinSizeRequest{}},
		{Name: "set_maximized", Opcode: 9, Type: &XdgToplevelSetMaximizedRequest{}},
		{Name: "unset_maximized", Opcode: 10, Type: &XdgToplevelUnsetMaximizedRequest{}},
		{Name: "set_fullscreen", Opcode: 11, Type: &XdgToplevelSetFullscreenRequest{}},
		{Name: "unset_fullscreen", Opcode: 12, Type: &XdgToplevelUnsetFullscreenRequest{}},
		{Name: "set_minimized", Opcode: 13, Type: &XdgToplevelSetMinimizedRequest{}},
	},
}
var XdgPopupDescriptor = InterfaceDescriptor{
	Name: "xdg_popup",
	Events: []EventDescriptor{
		{Name: "configure", Opcode: 0, Type: &XdgPopupConfigureEvent{}},
		{Name: "popup_done", Opcode: 1, Type: &XdgPopupPopupDoneEvent{}},
		{Name: "repositioned", Opcode: 2, Type: &XdgPopupRepositionedEvent{}},
	},
	Requests: []RequestDescriptor{
		{Name: "destroy", Opcode: 0, Type: &XdgPopupDestroyRequest{}},
		{Name: "grab", Opcode: 1, Type: &XdgPopupGrabRequest{}},
		{Name: "reposition", Opcode: 2, Type: &XdgPopupRepositionRequest{}},
	},
}
var ZwpXwaylandKeyboardGrabManagerV1Descriptor = InterfaceDescriptor{
	Name:   "zwp_xwayland_keyboard_grab_manager_v1",
	Events: []EventDescriptor{},
	Requests: []RequestDescriptor{
		{Name: "destroy", Opcode: 0, Type: &ZwpXwaylandKeyboardGrabManagerV1DestroyRequest{}},
		{Name: "grab_keyboard", Opcode: 1, Type: &ZwpXwaylandKeyboardGrabManagerV1GrabKeyboardRequest{}},
	},
}
var ZwpXwaylandKeyboardGrabV1Descriptor = InterfaceDescriptor{
	Name:   "zwp_xwayland_keyboard_grab_v1",
	Events: []EventDescriptor{},
	Requests: []RequestDescriptor{
		{Name: "destroy", Opcode: 0, Type: &ZwpXwaylandKeyboardGrabV1DestroyRequest{}},
	},
}
var ZwpLinuxExplicitSynchronizationV1Descriptor = InterfaceDescriptor{
	Name:   "zwp_linux_explicit_synchronization_v1",
	Events: []EventDescriptor{},
	Requests: []RequestDescriptor{
		{Name: "destroy", Opcode: 0, Type: &ZwpLinuxExplicitSynchronizationV1DestroyRequest{}},
		{Name: "get_synchronization", Opcode: 1, Type: &ZwpLinuxExplicitSynchronizationV1GetSynchronizationRequest{}},
	},
}
var ZwpLinuxSurfaceSynchronizationV1Descriptor = InterfaceDescriptor{
	Name:   "zwp_linux_surface_synchronization_v1",
	Events: []EventDescriptor{},
	Requests: []RequestDescriptor{
		{Name: "destroy", Opcode: 0, Type: &ZwpLinuxSurfaceSynchronizationV1DestroyRequest{}},
		{Name: "set_acquire_fence", Opcode: 1, Type: &ZwpLinuxSurfaceSynchronizationV1SetAcquireFenceRequest{}},
		{Name: "get_release", Opcode: 2, Type: &ZwpLinuxSurfaceSynchronizationV1GetReleaseRequest{}},
	},
}
var ZwpLinuxBufferReleaseV1Descriptor = InterfaceDescriptor{
	Name: "zwp_linux_buffer_release_v1",
	Events: []EventDescriptor{
		{Name: "fenced_release", Opcode: 0, Type: &ZwpLinuxBufferReleaseV1FencedReleaseEvent{}},
		{Name: "immediate_release", Opcode: 1, Type: &ZwpLinuxBufferReleaseV1ImmediateReleaseEvent{}},
	},
	Requests: []RequestDescriptor{},
}

////////////////////////////////////////////////////////////////////////////////
// Protocol Map
var Protocols = map[string]ProtocolDescriptor{
	"drm_lease_v1": {
		Name: "drm_lease_v1",
		Interfaces: []*InterfaceDescriptor{
			&WpDrmLeaseDeviceV1Descriptor,
			&WpDrmLeaseConnectorV1Descriptor,
			&WpDrmLeaseRequestV1Descriptor,
			&WpDrmLeaseV1Descriptor,
		},
	},
	"fullscreen_shell_unstable_v1": {
		Name: "fullscreen_shell_unstable_v1",
		Interfaces: []*InterfaceDescriptor{
			&ZwpFullscreenShellV1Descriptor,
			&ZwpFullscreenShellModeFeedbackV1Descriptor,
		},
	},
	"idle_inhibit_unstable_v1": {
		Name: "idle_inhibit_unstable_v1",
		Interfaces: []*InterfaceDescriptor{
			&ZwpIdleInhibitManagerV1Descriptor,
			&ZwpIdleInhibitorV1Descriptor,
		},
	},
	"input_method_unstable_v1": {
		Name: "input_method_unstable_v1",
		Interfaces: []*InterfaceDescriptor{
			&ZwpInputMethodContextV1Descriptor,
			&ZwpInputMethodV1Descriptor,
			&ZwpInputPanelV1Descriptor,
			&ZwpInputPanelSurfaceV1Descriptor,
		},
	},
	"input_timestamps_unstable_v1": {
		Name: "input_timestamps_unstable_v1",
		Interfaces: []*InterfaceDescriptor{
			&ZwpInputTimestampsManagerV1Descriptor,
			&ZwpInputTimestampsV1Descriptor,
		},
	},
	"keyboard_shortcuts_inhibit_unstable_v1": {
		Name: "keyboard_shortcuts_inhibit_unstable_v1",
		Interfaces: []*InterfaceDescriptor{
			&ZwpKeyboardShortcutsInhibitManagerV1Descriptor,
			&ZwpKeyboardShortcutsInhibitorV1Descriptor,
		},
	},
	"linux_dmabuf_unstable_v1": {
		Name: "linux_dmabuf_unstable_v1",
		Interfaces: []*InterfaceDescriptor{
			&ZwpLinuxDmabufV1Descriptor,
			&ZwpLinuxBufferParamsV1Descriptor,
		},
	},
	"pointer_constraints_unstable_v1": {
		Name: "pointer_constraints_unstable_v1",
		Interfaces: []*InterfaceDescriptor{
			&ZwpPointerConstraintsV1Descriptor,
			&ZwpLockedPointerV1Descriptor,
			&ZwpConfinedPointerV1Descriptor,
		},
	},
	"pointer_gestures_unstable_v1": {
		Name: "pointer_gestures_unstable_v1",
		Interfaces: []*InterfaceDescriptor{
			&ZwpPointerGesturesV1Descriptor,
			&ZwpPointerGestureSwipeV1Descriptor,
			&ZwpPointerGesturePinchV1Descriptor,
			&ZwpPointerGestureHoldV1Descriptor,
		},
	},
	"presentation_time": {
		Name: "presentation_time",
		Interfaces: []*InterfaceDescriptor{
			&WpPresentationDescriptor,
			&WpPresentationFeedbackDescriptor,
		},
	},
	"relative_pointer_unstable_v1": {
		Name: "relative_pointer_unstable_v1",
		Interfaces: []*InterfaceDescriptor{
			&ZwpRelativePointerManagerV1Descriptor,
			&ZwpRelativePointerV1Descriptor,
		},
	},
	"tablet_unstable_v1": {
		Name: "tablet_unstable_v1",
		Interfaces: []*InterfaceDescriptor{
			&ZwpTabletManagerV1Descriptor,
			&ZwpTabletSeatV1Descriptor,
			&ZwpTabletToolV1Descriptor,
			&ZwpTabletV1Descriptor,
		},
	},
	"tablet_unstable_v2": {
		Name: "tablet_unstable_v2",
		Interfaces: []*InterfaceDescriptor{
			&ZwpTabletManagerV2Descriptor,
			&ZwpTabletSeatV2Descriptor,
			&ZwpTabletToolV2Descriptor,
			&ZwpTabletV2Descriptor,
			&ZwpTabletPadRingV2Descriptor,
			&ZwpTabletPadStripV2Descriptor,
			&ZwpTabletPadGroupV2Descriptor,
			&ZwpTabletPadV2Descriptor,
		},
	},
	"text_input_unstable_v1": {
		Name: "text_input_unstable_v1",
		Interfaces: []*InterfaceDescriptor{
			&ZwpTextInputV1Descriptor,
			&ZwpTextInputManagerV1Descriptor,
		},
	},
	"text_input_unstable_v3": {
		Name: "text_input_unstable_v3",
		Interfaces: []*InterfaceDescriptor{
			&ZwpTextInputV3Descriptor,
			&ZwpTextInputManagerV3Descriptor,
		},
	},
	"viewporter": {
		Name: "viewporter",
		Interfaces: []*InterfaceDescriptor{
			&WpViewporterDescriptor,
			&WpViewportDescriptor,
		},
	},
	"wayland": {
		Name: "wayland",
		Interfaces: []*InterfaceDescriptor{
			&WlDisplayDescriptor,
			&WlRegistryDescriptor,
			&WlCallbackDescriptor,
			&WlCompositorDescriptor,
			&WlShmPoolDescriptor,
			&WlShmDescriptor,
			&WlBufferDescriptor,
			&WlDataOfferDescriptor,
			&WlDataSourceDescriptor,
			&WlDataDeviceDescriptor,
			&WlDataDeviceManagerDescriptor,
			&WlShellDescriptor,
			&WlShellSurfaceDescriptor,
			&WlSurfaceDescriptor,
			&WlSeatDescriptor,
			&WlPointerDescriptor,
			&WlKeyboardDescriptor,
			&WlTouchDescriptor,
			&WlOutputDescriptor,
			&WlRegionDescriptor,
			&WlSubcompositorDescriptor,
			&WlSubsurfaceDescriptor,
		},
	},
	"wp_primary_selection_unstable_v1": {
		Name: "wp_primary_selection_unstable_v1",
		Interfaces: []*InterfaceDescriptor{
			&ZwpPrimarySelectionDeviceManagerV1Descriptor,
			&ZwpPrimarySelectionDeviceV1Descriptor,
			&ZwpPrimarySelectionOfferV1Descriptor,
			&ZwpPrimarySelectionSourceV1Descriptor,
		},
	},
	"xdg_activation_v1": {
		Name: "xdg_activation_v1",
		Interfaces: []*InterfaceDescriptor{
			&XdgActivationV1Descriptor,
			&XdgActivationTokenV1Descriptor,
		},
	},
	"xdg_decoration_unstable_v1": {
		Name: "xdg_decoration_unstable_v1",
		Interfaces: []*InterfaceDescriptor{
			&ZxdgDecorationManagerV1Descriptor,
			&ZxdgToplevelDecorationV1Descriptor,
		},
	},
	"xdg_foreign_unstable_v1": {
		Name: "xdg_foreign_unstable_v1",
		Interfaces: []*InterfaceDescriptor{
			&ZxdgExporterV1Descriptor,
			&ZxdgImporterV1Descriptor,
			&ZxdgExportedV1Descriptor,
			&ZxdgImportedV1Descriptor,
		},
	},
	"xdg_foreign_unstable_v2": {
		Name: "xdg_foreign_unstable_v2",
		Interfaces: []*InterfaceDescriptor{
			&ZxdgExporterV2Descriptor,
			&ZxdgImporterV2Descriptor,
			&ZxdgExportedV2Descriptor,
			&ZxdgImportedV2Descriptor,
		},
	},
	"xdg_output_unstable_v1": {
		Name: "xdg_output_unstable_v1",
		Interfaces: []*InterfaceDescriptor{
			&ZxdgOutputManagerV1Descriptor,
			&ZxdgOutputV1Descriptor,
		},
	},
	"xdg_shell": {
		Name: "xdg_shell",
		Interfaces: []*InterfaceDescriptor{
			&XdgWmBaseDescriptor,
			&XdgPositionerDescriptor,
			&XdgSurfaceDescriptor,
			&XdgToplevelDescriptor,
			&XdgPopupDescriptor,
		},
	},
	"xwayland_keyboard_grab_unstable_v1": {
		Name: "xwayland_keyboard_grab_unstable_v1",
		Interfaces: []*InterfaceDescriptor{
			&ZwpXwaylandKeyboardGrabManagerV1Descriptor,
			&ZwpXwaylandKeyboardGrabV1Descriptor,
		},
	},
	"zwp_linux_explicit_synchronization_unstable_v1": {
		Name: "zwp_linux_explicit_synchronization_unstable_v1",
		Interfaces: []*InterfaceDescriptor{
			&ZwpLinuxExplicitSynchronizationV1Descriptor,
			&ZwpLinuxSurfaceSynchronizationV1Descriptor,
			&ZwpLinuxBufferReleaseV1Descriptor,
		},
	},
}

////////////////////////////////////////////////////////////////////////////////
// #region Protocol drm_lease_v1

// ----------------------------------------------------------------------------
// #region Interface drm_lease_v1.wp_drm_lease_device_v1

// WpDrmLeaseDeviceV1CreateLeaseRequestRequest requests to create a lease request object
//
// Creates a lease request object.
//
// See the documentation for wp_drm_lease_request_v1 for details.
type WpDrmLeaseDeviceV1CreateLeaseRequestRequest struct {
	ID ObjectID
}

// Opcode returns the request opcode for wp_drm_lease_device_v1.create_lease_request in drm_lease_v1
func (WpDrmLeaseDeviceV1CreateLeaseRequestRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for wp_drm_lease_device_v1.create_lease_request in drm_lease_v1
func (WpDrmLeaseDeviceV1CreateLeaseRequestRequest) MessageName() string {
	return "create_lease_request"
}

// Ensure WpDrmLeaseDeviceV1CreateLeaseRequestRequest implements Message.
var _ Message = WpDrmLeaseDeviceV1CreateLeaseRequestRequest{}

// Emit emits the message to the emitter.
func (r *WpDrmLeaseDeviceV1CreateLeaseRequestRequest) Emit(e *RequestEmitter) error {
	if err := e.PutObjectID(r.ID); err != nil {
		return err
	}
	return nil
}

// Ensure WpDrmLeaseDeviceV1CreateLeaseRequestRequest implements Request.
var _ Request = &WpDrmLeaseDeviceV1CreateLeaseRequestRequest{}

// WpDrmLeaseDeviceV1ReleaseRequest requests to release this object
//
// Indicates the client no longer wishes to use this object. In response
// the compositor will immediately send the released event and destroy
// this object. It can however not guarantee that the client won't receive
// connector events before the released event. The client must not send any
// requests after this one, doing so will raise a wl_display error.
// Existing connectors, lease request and leases will not be affected.
type WpDrmLeaseDeviceV1ReleaseRequest struct {
}

// Opcode returns the request opcode for wp_drm_lease_device_v1.release in drm_lease_v1
func (WpDrmLeaseDeviceV1ReleaseRequest) Opcode() uint16 { return 1 }

// MessageName returns the request name for wp_drm_lease_device_v1.release in drm_lease_v1
func (WpDrmLeaseDeviceV1ReleaseRequest) MessageName() string { return "release" }

// Ensure WpDrmLeaseDeviceV1ReleaseRequest implements Message.
var _ Message = WpDrmLeaseDeviceV1ReleaseRequest{}

// Emit emits the message to the emitter.
func (r *WpDrmLeaseDeviceV1ReleaseRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure WpDrmLeaseDeviceV1ReleaseRequest implements Request.
var _ Request = &WpDrmLeaseDeviceV1ReleaseRequest{}

// WpDrmLeaseDeviceV1DrmFDEvent signals when open a non-master fd for this DRM node
//
// The compositor will send this event when the wp_drm_lease_device_v1
// global is bound, although there are no guarantees as to how long this
// takes - the compositor might need to wait until regaining DRM master.
// The included fd is a non-master DRM file descriptor opened for this
// device and the compositor must not authenticate it.
// The purpose of this event is to give the client the ability to
// query DRM and discover information which may help them pick the
// appropriate DRM device or select the appropriate connectors therein.
type WpDrmLeaseDeviceV1DrmFDEvent struct {
	// FD contains DRM file descriptor
	FD FD
}

// Opcode returns the event opcode for wp_drm_lease_device_v1.drm_fd in drm_lease_v1
func (WpDrmLeaseDeviceV1DrmFDEvent) Opcode() uint16 { return 0 }

// MessageName returns the event name for wp_drm_lease_device_v1.drm_fd in drm_lease_v1
func (WpDrmLeaseDeviceV1DrmFDEvent) MessageName() string { return "drm_fd" }

// Ensure WpDrmLeaseDeviceV1DrmFDEvent implements Message.
var _ Message = WpDrmLeaseDeviceV1DrmFDEvent{}

// Scan scans the event from the socket.
func (e *WpDrmLeaseDeviceV1DrmFDEvent) Scan(s *EventScanner) error {
	if v, err := s.FD(); err != nil {
		return err
	} else {
		e.FD = v
	}
	return nil
}

// Ensure WpDrmLeaseDeviceV1DrmFDEvent implements Event.
var _ Event = &WpDrmLeaseDeviceV1DrmFDEvent{}

// WpDrmLeaseDeviceV1ConnectorEvent signals when advertise connectors available for leases
//
// The compositor will use this event to advertise connectors available for
// lease by clients. This object may be passed into a lease request to
// indicate the client would like to lease that connector, see
// wp_drm_lease_request_v1.request_connector for details. While the
// compositor will make a best effort to not send disconnected connectors,
// no guarantees can be made.
//
// The compositor must send the drm_fd event before sending connectors.
// After the drm_fd event it will send all available connectors but may
// send additional connectors at any time.
type WpDrmLeaseDeviceV1ConnectorEvent struct {
	ID ObjectID
}

// Opcode returns the event opcode for wp_drm_lease_device_v1.connector in drm_lease_v1
func (WpDrmLeaseDeviceV1ConnectorEvent) Opcode() uint16 { return 1 }

// MessageName returns the event name for wp_drm_lease_device_v1.connector in drm_lease_v1
func (WpDrmLeaseDeviceV1ConnectorEvent) MessageName() string { return "connector" }

// Ensure WpDrmLeaseDeviceV1ConnectorEvent implements Message.
var _ Message = WpDrmLeaseDeviceV1ConnectorEvent{}

// Scan scans the event from the socket.
func (e *WpDrmLeaseDeviceV1ConnectorEvent) Scan(s *EventScanner) error {
	if v, err := s.ObjectID(); err != nil {
		return err
	} else {
		e.ID = v
	}
	return nil
}

// Ensure WpDrmLeaseDeviceV1ConnectorEvent implements Event.
var _ Event = &WpDrmLeaseDeviceV1ConnectorEvent{}

// WpDrmLeaseDeviceV1DoneEvent signals when signals grouping of connectors
//
// The compositor will send this event to indicate that it has sent all
// currently available connectors after the client binds to the global or
// when it updates the connector list, for example on hotplug, drm master
// change or when a leased connector becomes available again. It will
// similarly send this event to group wp_drm_lease_connector_v1.withdrawn
// events of connectors of this device.
type WpDrmLeaseDeviceV1DoneEvent struct {
}

// Opcode returns the event opcode for wp_drm_lease_device_v1.done in drm_lease_v1
func (WpDrmLeaseDeviceV1DoneEvent) Opcode() uint16 { return 2 }

// MessageName returns the event name for wp_drm_lease_device_v1.done in drm_lease_v1
func (WpDrmLeaseDeviceV1DoneEvent) MessageName() string { return "done" }

// Ensure WpDrmLeaseDeviceV1DoneEvent implements Message.
var _ Message = WpDrmLeaseDeviceV1DoneEvent{}

// Scan scans the event from the socket.
func (e *WpDrmLeaseDeviceV1DoneEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure WpDrmLeaseDeviceV1DoneEvent implements Event.
var _ Event = &WpDrmLeaseDeviceV1DoneEvent{}

// WpDrmLeaseDeviceV1ReleasedEvent signals when the compositor has finished using the device
//
// This event is sent in response to the release request and indicates
// that the compositor is done sending connector events.
// The compositor will destroy this object immediately after sending the
// event and it will become invalid. The client should release any
// resources associated with this device after receiving this event.
type WpDrmLeaseDeviceV1ReleasedEvent struct {
}

// Opcode returns the event opcode for wp_drm_lease_device_v1.released in drm_lease_v1
func (WpDrmLeaseDeviceV1ReleasedEvent) Opcode() uint16 { return 3 }

// MessageName returns the event name for wp_drm_lease_device_v1.released in drm_lease_v1
func (WpDrmLeaseDeviceV1ReleasedEvent) MessageName() string { return "released" }

// Ensure WpDrmLeaseDeviceV1ReleasedEvent implements Message.
var _ Message = WpDrmLeaseDeviceV1ReleasedEvent{}

// Scan scans the event from the socket.
func (e *WpDrmLeaseDeviceV1ReleasedEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure WpDrmLeaseDeviceV1ReleasedEvent implements Event.
var _ Event = &WpDrmLeaseDeviceV1ReleasedEvent{}

// WpDrmLeaseDeviceV1 lease device
//
// This protocol is used by Wayland compositors which act as Direct
// Renderering Manager (DRM) masters to lease DRM resources to Wayland
// clients.
//
// The compositor will advertise one wp_drm_lease_device_v1 global for each
// DRM node. Some time after a client binds to the wp_drm_lease_device_v1
// global, the compositor will send a drm_fd event followed by zero, one or
// more connector events. After all currently available connectors have been
// sent, the compositor will send a wp_drm_lease_device_v1.done event.
//
// When the list of connectors available for lease changes the compositor
// will send wp_drm_lease_device_v1.connector events for added connectors and
// wp_drm_lease_connector_v1.withdrawn events for removed connectors,
// followed by a wp_drm_lease_device_v1.done event.
//
// The compositor will indicate when a device is gone by removing the global
// via a wl_registry.global_remove event. Upon receiving this event, the
// client should destroy any matching wp_drm_lease_device_v1 object.
//
// To destroy a wp_drm_lease_device_v1 object, the client must first issue
// a release request. Upon receiving this request, the compositor will
// immediately send a released event and destroy the object. The client must
// continue to process and discard drm_fd and connector events until it
// receives the released event. Upon receiving the released event, the
// client can safely cleanup any client-side resources.
//
// Warning! The protocol described in this file is currently in the testing
// phase. Backward compatible changes may be added together with the
// corresponding interface version bump. Backward incompatible changes can
// only be done by creating a new major version of the extension.
type WpDrmLeaseDeviceV1 struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *WpDrmLeaseDeviceV1) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (WpDrmLeaseDeviceV1) Descriptor() *InterfaceDescriptor {
	return &WpDrmLeaseDeviceV1Descriptor
}

// Dispatch returns an Event object for a given opcode.
func (WpDrmLeaseDeviceV1) Dispatch(opcode uint16) Event {
	switch opcode {
	case 0:
		return &WpDrmLeaseDeviceV1DrmFDEvent{}
	case 1:
		return &WpDrmLeaseDeviceV1ConnectorEvent{}
	case 2:
		return &WpDrmLeaseDeviceV1DoneEvent{}
	case 3:
		return &WpDrmLeaseDeviceV1ReleasedEvent{}
	default:
		return nil
	}
}

// CreateLeaseRequest requests to create a lease request object
//
// Creates a lease request object.
//
// See the documentation for wp_drm_lease_request_v1 for details.
func (proxy *WpDrmLeaseDeviceV1) CreateLeaseRequest(connection Connection) (aID *WpDrmLeaseRequestV1, err error) {
	aID = &WpDrmLeaseRequestV1{connection.NewID()}
	request := WpDrmLeaseDeviceV1CreateLeaseRequestRequest{
		ID: aID.id,
	}
	err = connection.SendRequest(proxy.id, &request)
	if err == nil {
		connection.RegisterProxy(aID)
	}
	return
}

// Release requests to release this object
//
// Indicates the client no longer wishes to use this object. In response
// the compositor will immediately send the released event and destroy
// this object. It can however not guarantee that the client won't receive
// connector events before the released event. The client must not send any
// requests after this one, doing so will raise a wl_display error.
// Existing connectors, lease request and leases will not be affected.
func (proxy *WpDrmLeaseDeviceV1) Release(connection Connection) (err error) {
	request := WpDrmLeaseDeviceV1ReleaseRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Ensure WpDrmLeaseDeviceV1 implements Proxy.
var _ Proxy = &WpDrmLeaseDeviceV1{}

// #endregion Interface drm_lease_v1.wp_drm_lease_device_v1

// ----------------------------------------------------------------------------
// #region Interface drm_lease_v1.wp_drm_lease_connector_v1

// WpDrmLeaseConnectorV1DestroyRequest requests to destroy connector
//
// The client may send this request to indicate that it will not use this
// connector. Clients are encouraged to send this after receiving the
// "withdrawn" event so that the server can release the resources
// associated with this connector offer. Neither existing lease requests
// nor leases will be affected.
type WpDrmLeaseConnectorV1DestroyRequest struct {
}

// Opcode returns the request opcode for wp_drm_lease_connector_v1.destroy in drm_lease_v1
func (WpDrmLeaseConnectorV1DestroyRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for wp_drm_lease_connector_v1.destroy in drm_lease_v1
func (WpDrmLeaseConnectorV1DestroyRequest) MessageName() string { return "destroy" }

// Ensure WpDrmLeaseConnectorV1DestroyRequest implements Message.
var _ Message = WpDrmLeaseConnectorV1DestroyRequest{}

// Emit emits the message to the emitter.
func (r *WpDrmLeaseConnectorV1DestroyRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure WpDrmLeaseConnectorV1DestroyRequest implements Request.
var _ Request = &WpDrmLeaseConnectorV1DestroyRequest{}

// WpDrmLeaseConnectorV1NameEvent signals when name
//
// The compositor sends this event once the connector is created to
// indicate the name of this connector. This will not change for the
// duration of the Wayland session, but is not guaranteed to be consistent
// between sessions.
type WpDrmLeaseConnectorV1NameEvent struct {
	// Name contains connector name
	Name string
}

// Opcode returns the event opcode for wp_drm_lease_connector_v1.name in drm_lease_v1
func (WpDrmLeaseConnectorV1NameEvent) Opcode() uint16 { return 0 }

// MessageName returns the event name for wp_drm_lease_connector_v1.name in drm_lease_v1
func (WpDrmLeaseConnectorV1NameEvent) MessageName() string { return "name" }

// Ensure WpDrmLeaseConnectorV1NameEvent implements Message.
var _ Message = WpDrmLeaseConnectorV1NameEvent{}

// Scan scans the event from the socket.
func (e *WpDrmLeaseConnectorV1NameEvent) Scan(s *EventScanner) error {
	if v, err := s.String(); err != nil {
		return err
	} else {
		e.Name = v
	}
	return nil
}

// Ensure WpDrmLeaseConnectorV1NameEvent implements Event.
var _ Event = &WpDrmLeaseConnectorV1NameEvent{}

// WpDrmLeaseConnectorV1DescriptionEvent signals when description
//
// The compositor sends this event once the connector is created to provide
// a human-readable description for this connector, which may be presented
// to the user. The compositor may send this event multiple times over the
// lifetime of this object to reflect changes in the description.
type WpDrmLeaseConnectorV1DescriptionEvent struct {
	// Description contains connector description
	Description string
}

// Opcode returns the event opcode for wp_drm_lease_connector_v1.description in drm_lease_v1
func (WpDrmLeaseConnectorV1DescriptionEvent) Opcode() uint16 { return 1 }

// MessageName returns the event name for wp_drm_lease_connector_v1.description in drm_lease_v1
func (WpDrmLeaseConnectorV1DescriptionEvent) MessageName() string { return "description" }

// Ensure WpDrmLeaseConnectorV1DescriptionEvent implements Message.
var _ Message = WpDrmLeaseConnectorV1DescriptionEvent{}

// Scan scans the event from the socket.
func (e *WpDrmLeaseConnectorV1DescriptionEvent) Scan(s *EventScanner) error {
	if v, err := s.String(); err != nil {
		return err
	} else {
		e.Description = v
	}
	return nil
}

// Ensure WpDrmLeaseConnectorV1DescriptionEvent implements Event.
var _ Event = &WpDrmLeaseConnectorV1DescriptionEvent{}

// WpDrmLeaseConnectorV1ConnectorIDEvent signals when connector_id
//
// The compositor sends this event once the connector is created to
// indicate the DRM object ID which represents the underlying connector
// that is being offered. Note that the final lease may include additional
// object IDs, such as CRTCs and planes.
type WpDrmLeaseConnectorV1ConnectorIDEvent struct {
	// ConnectorID contains DRM connector ID
	ConnectorID uint32
}

// Opcode returns the event opcode for wp_drm_lease_connector_v1.connector_id in drm_lease_v1
func (WpDrmLeaseConnectorV1ConnectorIDEvent) Opcode() uint16 { return 2 }

// MessageName returns the event name for wp_drm_lease_connector_v1.connector_id in drm_lease_v1
func (WpDrmLeaseConnectorV1ConnectorIDEvent) MessageName() string { return "connector_id" }

// Ensure WpDrmLeaseConnectorV1ConnectorIDEvent implements Message.
var _ Message = WpDrmLeaseConnectorV1ConnectorIDEvent{}

// Scan scans the event from the socket.
func (e *WpDrmLeaseConnectorV1ConnectorIDEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.ConnectorID = v
	}
	return nil
}

// Ensure WpDrmLeaseConnectorV1ConnectorIDEvent implements Event.
var _ Event = &WpDrmLeaseConnectorV1ConnectorIDEvent{}

// WpDrmLeaseConnectorV1DoneEvent signals when all properties have been sent
//
// This event is sent after all properties of a connector have been sent.
// This allows changes to the properties to be seen as atomic even if they
// happen via multiple events.
type WpDrmLeaseConnectorV1DoneEvent struct {
}

// Opcode returns the event opcode for wp_drm_lease_connector_v1.done in drm_lease_v1
func (WpDrmLeaseConnectorV1DoneEvent) Opcode() uint16 { return 3 }

// MessageName returns the event name for wp_drm_lease_connector_v1.done in drm_lease_v1
func (WpDrmLeaseConnectorV1DoneEvent) MessageName() string { return "done" }

// Ensure WpDrmLeaseConnectorV1DoneEvent implements Message.
var _ Message = WpDrmLeaseConnectorV1DoneEvent{}

// Scan scans the event from the socket.
func (e *WpDrmLeaseConnectorV1DoneEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure WpDrmLeaseConnectorV1DoneEvent implements Event.
var _ Event = &WpDrmLeaseConnectorV1DoneEvent{}

// WpDrmLeaseConnectorV1WithdrawnEvent signals when lease offer withdrawn
//
// Sent to indicate that the compositor will no longer honor requests for
// DRM leases which include this connector. The client may still issue a
// lease request including this connector, but the compositor will send
// wp_drm_lease_v1.finished without issuing a lease fd. Compositors are
// encouraged to send this event when they lose access to connector, for
// example when the connector is hot-unplugged, when the connector gets
// leased to a client or when the compositor loses DRM master.
type WpDrmLeaseConnectorV1WithdrawnEvent struct {
}

// Opcode returns the event opcode for wp_drm_lease_connector_v1.withdrawn in drm_lease_v1
func (WpDrmLeaseConnectorV1WithdrawnEvent) Opcode() uint16 { return 4 }

// MessageName returns the event name for wp_drm_lease_connector_v1.withdrawn in drm_lease_v1
func (WpDrmLeaseConnectorV1WithdrawnEvent) MessageName() string { return "withdrawn" }

// Ensure WpDrmLeaseConnectorV1WithdrawnEvent implements Message.
var _ Message = WpDrmLeaseConnectorV1WithdrawnEvent{}

// Scan scans the event from the socket.
func (e *WpDrmLeaseConnectorV1WithdrawnEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure WpDrmLeaseConnectorV1WithdrawnEvent implements Event.
var _ Event = &WpDrmLeaseConnectorV1WithdrawnEvent{}

// WpDrmLeaseConnectorV1 a leasable DRM connector
//
// Represents a DRM connector which is available for lease. These objects are
// created via wp_drm_lease_device_v1.connector events, and should be passed
// to lease requests via wp_drm_lease_request_v1.request_connector.
// Immediately after the wp_drm_lease_connector_v1 object is created the
// compositor will send a name, a description, a connector_id and a done
// event. When the description is updated the compositor will send a
// description event followed by a done event.
type WpDrmLeaseConnectorV1 struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *WpDrmLeaseConnectorV1) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (WpDrmLeaseConnectorV1) Descriptor() *InterfaceDescriptor {
	return &WpDrmLeaseConnectorV1Descriptor
}

// Dispatch returns an Event object for a given opcode.
func (WpDrmLeaseConnectorV1) Dispatch(opcode uint16) Event {
	switch opcode {
	case 0:
		return &WpDrmLeaseConnectorV1NameEvent{}
	case 1:
		return &WpDrmLeaseConnectorV1DescriptionEvent{}
	case 2:
		return &WpDrmLeaseConnectorV1ConnectorIDEvent{}
	case 3:
		return &WpDrmLeaseConnectorV1DoneEvent{}
	case 4:
		return &WpDrmLeaseConnectorV1WithdrawnEvent{}
	default:
		return nil
	}
}

// Destroy requests to destroy connector
//
// The client may send this request to indicate that it will not use this
// connector. Clients are encouraged to send this after receiving the
// "withdrawn" event so that the server can release the resources
// associated with this connector offer. Neither existing lease requests
// nor leases will be affected.
func (proxy *WpDrmLeaseConnectorV1) Destroy(connection Connection) (err error) {
	request := WpDrmLeaseConnectorV1DestroyRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Ensure WpDrmLeaseConnectorV1 implements Proxy.
var _ Proxy = &WpDrmLeaseConnectorV1{}

// #endregion Interface drm_lease_v1.wp_drm_lease_connector_v1

// ----------------------------------------------------------------------------
// #region Interface drm_lease_v1.wp_drm_lease_request_v1

type WpDrmLeaseRequestV1Error int

const (
	// WpDrmLeaseRequestV1ErrorWrongDevice corresponds to requested a connector from a different lease device
	WpDrmLeaseRequestV1ErrorWrongDevice WpDrmLeaseRequestV1Error = 0

	// WpDrmLeaseRequestV1ErrorDuplicateConnector corresponds to requested a connector twice
	WpDrmLeaseRequestV1ErrorDuplicateConnector WpDrmLeaseRequestV1Error = 1

	// WpDrmLeaseRequestV1ErrorEmptyLease corresponds to requested a lease without requesting a connector
	WpDrmLeaseRequestV1ErrorEmptyLease WpDrmLeaseRequestV1Error = 2
)

// WpDrmLeaseRequestV1RequestConnectorRequest requests to request a connector for this lease
//
// Indicates that the client would like to lease the given connector.
// This is only used as a suggestion, the compositor may choose to
// include any resources in the lease it issues, or change the set of
// leased resources at any time. Compositors are however encouraged to
// include the requested connector and other resources necessary
// to drive the connected output in the lease.
//
// Requesting a connector that was created from a different lease device
// than this lease request raises the wrong_device error. Requesting a
// connector twice will raise the duplicate_connector error.
type WpDrmLeaseRequestV1RequestConnectorRequest struct {
	Connector ObjectID
}

// Opcode returns the request opcode for wp_drm_lease_request_v1.request_connector in drm_lease_v1
func (WpDrmLeaseRequestV1RequestConnectorRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for wp_drm_lease_request_v1.request_connector in drm_lease_v1
func (WpDrmLeaseRequestV1RequestConnectorRequest) MessageName() string { return "request_connector" }

// Ensure WpDrmLeaseRequestV1RequestConnectorRequest implements Message.
var _ Message = WpDrmLeaseRequestV1RequestConnectorRequest{}

// Emit emits the message to the emitter.
func (r *WpDrmLeaseRequestV1RequestConnectorRequest) Emit(e *RequestEmitter) error {
	if err := e.PutObjectID(r.Connector); err != nil {
		return err
	}
	return nil
}

// Ensure WpDrmLeaseRequestV1RequestConnectorRequest implements Request.
var _ Request = &WpDrmLeaseRequestV1RequestConnectorRequest{}

// WpDrmLeaseRequestV1SubmitRequest requests to submit the lease request
//
// Submits the lease request and creates a new wp_drm_lease_v1 object.
// After calling submit the compositor will immediately destroy this
// object, issuing any more requests will cause a wl_diplay error.
// The compositor doesn't make any guarantees about the events of the
// lease object, clients cannot expect an immediate response.
// Not requesting any connectors before submitting the lease request
// will raise the empty_lease error.
type WpDrmLeaseRequestV1SubmitRequest struct {
	ID ObjectID
}

// Opcode returns the request opcode for wp_drm_lease_request_v1.submit in drm_lease_v1
func (WpDrmLeaseRequestV1SubmitRequest) Opcode() uint16 { return 1 }

// MessageName returns the request name for wp_drm_lease_request_v1.submit in drm_lease_v1
func (WpDrmLeaseRequestV1SubmitRequest) MessageName() string { return "submit" }

// Ensure WpDrmLeaseRequestV1SubmitRequest implements Message.
var _ Message = WpDrmLeaseRequestV1SubmitRequest{}

// Emit emits the message to the emitter.
func (r *WpDrmLeaseRequestV1SubmitRequest) Emit(e *RequestEmitter) error {
	if err := e.PutObjectID(r.ID); err != nil {
		return err
	}
	return nil
}

// Ensure WpDrmLeaseRequestV1SubmitRequest implements Request.
var _ Request = &WpDrmLeaseRequestV1SubmitRequest{}

// WpDrmLeaseRequestV1 DRM lease request
//
// A client that wishes to lease DRM resources will attach the list of
// connectors advertised with wp_drm_lease_device_v1.connector that they
// wish to lease, then use wp_drm_lease_request_v1.submit to submit the
// request.
type WpDrmLeaseRequestV1 struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *WpDrmLeaseRequestV1) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (WpDrmLeaseRequestV1) Descriptor() *InterfaceDescriptor {
	return &WpDrmLeaseRequestV1Descriptor
}

// Dispatch returns an Event object for a given opcode.
func (WpDrmLeaseRequestV1) Dispatch(opcode uint16) Event {
	switch opcode {
	default:
		return nil
	}
}

// RequestConnector requests to request a connector for this lease
//
// Indicates that the client would like to lease the given connector.
// This is only used as a suggestion, the compositor may choose to
// include any resources in the lease it issues, or change the set of
// leased resources at any time. Compositors are however encouraged to
// include the requested connector and other resources necessary
// to drive the connected output in the lease.
//
// Requesting a connector that was created from a different lease device
// than this lease request raises the wrong_device error. Requesting a
// connector twice will raise the duplicate_connector error.
func (proxy *WpDrmLeaseRequestV1) RequestConnector(connection Connection, aConnector ObjectID) (err error) {
	request := WpDrmLeaseRequestV1RequestConnectorRequest{
		Connector: aConnector,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Submit requests to submit the lease request
//
// Submits the lease request and creates a new wp_drm_lease_v1 object.
// After calling submit the compositor will immediately destroy this
// object, issuing any more requests will cause a wl_diplay error.
// The compositor doesn't make any guarantees about the events of the
// lease object, clients cannot expect an immediate response.
// Not requesting any connectors before submitting the lease request
// will raise the empty_lease error.
func (proxy *WpDrmLeaseRequestV1) Submit(connection Connection) (aID *WpDrmLeaseV1, err error) {
	aID = &WpDrmLeaseV1{connection.NewID()}
	request := WpDrmLeaseRequestV1SubmitRequest{
		ID: aID.id,
	}
	err = connection.SendRequest(proxy.id, &request)
	if err == nil {
		connection.RegisterProxy(aID)
	}
	return
}

// Ensure WpDrmLeaseRequestV1 implements Proxy.
var _ Proxy = &WpDrmLeaseRequestV1{}

// #endregion Interface drm_lease_v1.wp_drm_lease_request_v1

// ----------------------------------------------------------------------------
// #region Interface drm_lease_v1.wp_drm_lease_v1

// WpDrmLeaseV1DestroyRequest requests to destroys the lease object
//
// The client should send this to indicate that it no longer wishes to use
// this lease. The compositor should use drmModeRevokeLease on the
// appropriate file descriptor, if necessary.
type WpDrmLeaseV1DestroyRequest struct {
}

// Opcode returns the request opcode for wp_drm_lease_v1.destroy in drm_lease_v1
func (WpDrmLeaseV1DestroyRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for wp_drm_lease_v1.destroy in drm_lease_v1
func (WpDrmLeaseV1DestroyRequest) MessageName() string { return "destroy" }

// Ensure WpDrmLeaseV1DestroyRequest implements Message.
var _ Message = WpDrmLeaseV1DestroyRequest{}

// Emit emits the message to the emitter.
func (r *WpDrmLeaseV1DestroyRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure WpDrmLeaseV1DestroyRequest implements Request.
var _ Request = &WpDrmLeaseV1DestroyRequest{}

// WpDrmLeaseV1LeaseFDEvent signals when shares the DRM file descriptor
//
// This event returns a file descriptor suitable for use with DRM-related
// ioctls. The client should use drmModeGetLease to enumerate the DRM
// objects which have been leased to them. The compositor guarantees it
// will not use the leased DRM objects itself until it sends the finished
// event. If the compositor cannot or will not grant a lease for the
// requested connectors, it will not send this event, instead sending the
// finished event.
//
// The compositor will send this event at most once during this objects
// lifetime.
type WpDrmLeaseV1LeaseFDEvent struct {
	// LeasedFD contains leased DRM file descriptor
	LeasedFD FD
}

// Opcode returns the event opcode for wp_drm_lease_v1.lease_fd in drm_lease_v1
func (WpDrmLeaseV1LeaseFDEvent) Opcode() uint16 { return 0 }

// MessageName returns the event name for wp_drm_lease_v1.lease_fd in drm_lease_v1
func (WpDrmLeaseV1LeaseFDEvent) MessageName() string { return "lease_fd" }

// Ensure WpDrmLeaseV1LeaseFDEvent implements Message.
var _ Message = WpDrmLeaseV1LeaseFDEvent{}

// Scan scans the event from the socket.
func (e *WpDrmLeaseV1LeaseFDEvent) Scan(s *EventScanner) error {
	if v, err := s.FD(); err != nil {
		return err
	} else {
		e.LeasedFD = v
	}
	return nil
}

// Ensure WpDrmLeaseV1LeaseFDEvent implements Event.
var _ Event = &WpDrmLeaseV1LeaseFDEvent{}

// WpDrmLeaseV1FinishedEvent signals when sent when the lease has been revoked
//
// The compositor uses this event to either reject a lease request, or if
// it previously sent a lease_fd, to notify the client that the lease has
// been revoked. If the client requires a new lease, they should destroy
// this object and submit a new lease request. The compositor will send
// no further events for this object after sending the finish event.
// Compositors should revoke the lease when any of the leased resources
// become unavailable, namely when a hot-unplug occurs or when the
// compositor loses DRM master.
type WpDrmLeaseV1FinishedEvent struct {
}

// Opcode returns the event opcode for wp_drm_lease_v1.finished in drm_lease_v1
func (WpDrmLeaseV1FinishedEvent) Opcode() uint16 { return 1 }

// MessageName returns the event name for wp_drm_lease_v1.finished in drm_lease_v1
func (WpDrmLeaseV1FinishedEvent) MessageName() string { return "finished" }

// Ensure WpDrmLeaseV1FinishedEvent implements Message.
var _ Message = WpDrmLeaseV1FinishedEvent{}

// Scan scans the event from the socket.
func (e *WpDrmLeaseV1FinishedEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure WpDrmLeaseV1FinishedEvent implements Event.
var _ Event = &WpDrmLeaseV1FinishedEvent{}

// WpDrmLeaseV1 a DRM lease
//
// A DRM lease object is used to transfer the DRM file descriptor to the
// client and manage the lifetime of the lease.
//
// Some time after the wp_drm_lease_v1 object is created, the compositor
// will reply with the lease request's result. If the lease request is
// granted, the compositor will send a lease_fd event. If the lease request
// is denied, the compositor will send a finished event without a lease_fd
// event.
type WpDrmLeaseV1 struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *WpDrmLeaseV1) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (WpDrmLeaseV1) Descriptor() *InterfaceDescriptor {
	return &WpDrmLeaseV1Descriptor
}

// Dispatch returns an Event object for a given opcode.
func (WpDrmLeaseV1) Dispatch(opcode uint16) Event {
	switch opcode {
	case 0:
		return &WpDrmLeaseV1LeaseFDEvent{}
	case 1:
		return &WpDrmLeaseV1FinishedEvent{}
	default:
		return nil
	}
}

// Destroy requests to destroys the lease object
//
// The client should send this to indicate that it no longer wishes to use
// this lease. The compositor should use drmModeRevokeLease on the
// appropriate file descriptor, if necessary.
func (proxy *WpDrmLeaseV1) Destroy(connection Connection) (err error) {
	request := WpDrmLeaseV1DestroyRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Ensure WpDrmLeaseV1 implements Proxy.
var _ Proxy = &WpDrmLeaseV1{}

// #endregion Interface drm_lease_v1.wp_drm_lease_v1

////////////////////////////////////////////////////////////////////////////////
// #endregion Protocol drm_lease_v1

////////////////////////////////////////////////////////////////////////////////
// #region Protocol fullscreen_shell_unstable_v1

// ----------------------------------------------------------------------------
// #region Interface fullscreen_shell_unstable_v1.zwp_fullscreen_shell_v1

// ZwpFullscreenShellV1Capability represents capabilities advertised by the compositor
//
// Various capabilities that can be advertised by the compositor.  They
// are advertised one-at-a-time when the wl_fullscreen_shell interface is
// bound.  See the wl_fullscreen_shell.capability event for more details.
//
// ARBITRARY_MODES:
// This is a hint to the client that indicates that the compositor is
// capable of setting practically any mode on its outputs.  If this
// capability is provided, wl_fullscreen_shell.present_surface_for_mode
// will almost never fail and clients should feel free to set whatever
// mode they like.  If the compositor does not advertise this, it may
// still support some modes that are not advertised through wl_global.mode
// but it is less likely.
//
// CURSOR_PLANE:
// This is a hint to the client that indicates that the compositor can
// handle a cursor surface from the client without actually compositing.
// This may be because of a hardware cursor plane or some other mechanism.
// If the compositor does not advertise this capability then setting
// wl_pointer.cursor may degrade performance or be ignored entirely.  If
// CURSOR_PLANE is not advertised, it is recommended that the client draw
// its own cursor and set wl_pointer.cursor(NULL).
type ZwpFullscreenShellV1Capability int

const (
	// ZwpFullscreenShellV1CapabilityArbitraryModes corresponds to compositor is capable of almost any output mode
	ZwpFullscreenShellV1CapabilityArbitraryModes ZwpFullscreenShellV1Capability = 1

	// ZwpFullscreenShellV1CapabilityCursorPlane corresponds to compositor has a separate cursor plane
	ZwpFullscreenShellV1CapabilityCursorPlane ZwpFullscreenShellV1Capability = 2
)

// ZwpFullscreenShellV1PresentMethod represents different method to set the surface fullscreen
//
// Hints to indicate to the compositor how to deal with a conflict
// between the dimensions of the surface and the dimensions of the
// output. The compositor is free to ignore this parameter.
type ZwpFullscreenShellV1PresentMethod int

const (
	// ZwpFullscreenShellV1PresentMethodDefault corresponds to no preference, apply default policy
	ZwpFullscreenShellV1PresentMethodDefault ZwpFullscreenShellV1PresentMethod = 0

	// ZwpFullscreenShellV1PresentMethodCenter corresponds to center the surface on the output
	ZwpFullscreenShellV1PresentMethodCenter ZwpFullscreenShellV1PresentMethod = 1

	// ZwpFullscreenShellV1PresentMethodZoom corresponds to scale the surface, preserving aspect ratio, to the largest size that will fit on the output
	ZwpFullscreenShellV1PresentMethodZoom ZwpFullscreenShellV1PresentMethod = 2

	// ZwpFullscreenShellV1PresentMethodZoomCrop corresponds to scale the surface, preserving aspect ratio, to fully fill the output cropping if needed
	ZwpFullscreenShellV1PresentMethodZoomCrop ZwpFullscreenShellV1PresentMethod = 3

	// ZwpFullscreenShellV1PresentMethodStretch corresponds to scale the surface to the size of the output ignoring aspect ratio
	ZwpFullscreenShellV1PresentMethodStretch ZwpFullscreenShellV1PresentMethod = 4
)

// ZwpFullscreenShellV1Error represents wl_fullscreen_shell error values
//
// These errors can be emitted in response to wl_fullscreen_shell requests.
type ZwpFullscreenShellV1Error int

const (
	// ZwpFullscreenShellV1ErrorInvalidMethod corresponds to present_method is not known
	ZwpFullscreenShellV1ErrorInvalidMethod ZwpFullscreenShellV1Error = 0

	// ZwpFullscreenShellV1ErrorRole corresponds to given wl_surface has another role
	ZwpFullscreenShellV1ErrorRole ZwpFullscreenShellV1Error = 1
)

// ZwpFullscreenShellV1ReleaseRequest requests to release the wl_fullscreen_shell interface
//
// Release the binding from the wl_fullscreen_shell interface.
//
// This destroys the server-side object and frees this binding.  If
// the client binds to wl_fullscreen_shell multiple times, it may wish
// to free some of those bindings.
type ZwpFullscreenShellV1ReleaseRequest struct {
}

// Opcode returns the request opcode for zwp_fullscreen_shell_v1.release in fullscreen_shell_unstable_v1
func (ZwpFullscreenShellV1ReleaseRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for zwp_fullscreen_shell_v1.release in fullscreen_shell_unstable_v1
func (ZwpFullscreenShellV1ReleaseRequest) MessageName() string { return "release" }

// Ensure ZwpFullscreenShellV1ReleaseRequest implements Message.
var _ Message = ZwpFullscreenShellV1ReleaseRequest{}

// Emit emits the message to the emitter.
func (r *ZwpFullscreenShellV1ReleaseRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure ZwpFullscreenShellV1ReleaseRequest implements Request.
var _ Request = &ZwpFullscreenShellV1ReleaseRequest{}

// ZwpFullscreenShellV1PresentSurfaceRequest requests to present surface for display
//
// Present a surface on the given output.
//
// If the output is null, the compositor will present the surface on
// whatever display (or displays) it thinks best.  In particular, this
// may replace any or all surfaces currently presented so it should
// not be used in combination with placing surfaces on specific
// outputs.
//
// The method parameter is a hint to the compositor for how the surface
// is to be presented.  In particular, it tells the compositor how to
// handle a size mismatch between the presented surface and the
// output.  The compositor is free to ignore this parameter.
//
// The "zoom", "zoom_crop", and "stretch" methods imply a scaling
// operation on the surface.  This will override any kind of output
// scaling, so the buffer_scale property of the surface is effectively
// ignored.
//
// This request gives the surface the role of a fullscreen shell surface.
// If the surface already has another role, it raises a role protocol
// error.
type ZwpFullscreenShellV1PresentSurfaceRequest struct {
	Surface ObjectID

	Method uint32

	Output ObjectID
}

// Opcode returns the request opcode for zwp_fullscreen_shell_v1.present_surface in fullscreen_shell_unstable_v1
func (ZwpFullscreenShellV1PresentSurfaceRequest) Opcode() uint16 { return 1 }

// MessageName returns the request name for zwp_fullscreen_shell_v1.present_surface in fullscreen_shell_unstable_v1
func (ZwpFullscreenShellV1PresentSurfaceRequest) MessageName() string { return "present_surface" }

// Ensure ZwpFullscreenShellV1PresentSurfaceRequest implements Message.
var _ Message = ZwpFullscreenShellV1PresentSurfaceRequest{}

// Emit emits the message to the emitter.
func (r *ZwpFullscreenShellV1PresentSurfaceRequest) Emit(e *RequestEmitter) error {
	if err := e.PutObjectID(r.Surface); err != nil {
		return err
	}
	if err := e.PutUint(r.Method); err != nil {
		return err
	}
	if err := e.PutObjectID(r.Output); err != nil {
		return err
	}
	return nil
}

// Ensure ZwpFullscreenShellV1PresentSurfaceRequest implements Request.
var _ Request = &ZwpFullscreenShellV1PresentSurfaceRequest{}

// ZwpFullscreenShellV1PresentSurfaceForModeRequest requests to present surface for display at a particular mode
//
// Presents a surface on the given output for a particular mode.
//
// If the current size of the output differs from that of the surface,
// the compositor will attempt to change the size of the output to
// match the surface.  The result of the mode-switch operation will be
// returned via the provided wl_fullscreen_shell_mode_feedback object.
//
// If the current output mode matches the one requested or if the
// compositor successfully switches the mode to match the surface,
// then the mode_successful event will be sent and the output will
// contain the contents of the given surface.  If the compositor
// cannot match the output size to the surface size, the mode_failed
// will be sent and the output will contain the contents of the
// previously presented surface (if any).  If another surface is
// presented on the given output before either of these has a chance
// to happen, the present_cancelled event will be sent.
//
// Due to race conditions and other issues unknown to the client, no
// mode-switch operation is guaranteed to succeed.  However, if the
// mode is one advertised by wl_output.mode or if the compositor
// advertises the ARBITRARY_MODES capability, then the client should
// expect that the mode-switch operation will usually succeed.
//
// If the size of the presented surface changes, the resulting output
// is undefined.  The compositor may attempt to change the output mode
// to compensate.  However, there is no guarantee that a suitable mode
// will be found and the client has no way to be notified of success
// or failure.
//
// The framerate parameter specifies the desired framerate for the
// output in mHz.  The compositor is free to ignore this parameter.  A
// value of 0 indicates that the client has no preference.
//
// If the value of wl_output.scale differs from wl_surface.buffer_scale,
// then the compositor may choose a mode that matches either the buffer
// size or the surface size.  In either case, the surface will fill the
// output.
//
// This request gives the surface the role of a fullscreen shell surface.
// If the surface already has another role, it raises a role protocol
// error.
type ZwpFullscreenShellV1PresentSurfaceForModeRequest struct {
	Surface ObjectID

	Output ObjectID

	Framerate int32

	Feedback ObjectID
}

// Opcode returns the request opcode for zwp_fullscreen_shell_v1.present_surface_for_mode in fullscreen_shell_unstable_v1
func (ZwpFullscreenShellV1PresentSurfaceForModeRequest) Opcode() uint16 { return 2 }

// MessageName returns the request name for zwp_fullscreen_shell_v1.present_surface_for_mode in fullscreen_shell_unstable_v1
func (ZwpFullscreenShellV1PresentSurfaceForModeRequest) MessageName() string {
	return "present_surface_for_mode"
}

// Ensure ZwpFullscreenShellV1PresentSurfaceForModeRequest implements Message.
var _ Message = ZwpFullscreenShellV1PresentSurfaceForModeRequest{}

// Emit emits the message to the emitter.
func (r *ZwpFullscreenShellV1PresentSurfaceForModeRequest) Emit(e *RequestEmitter) error {
	if err := e.PutObjectID(r.Surface); err != nil {
		return err
	}
	if err := e.PutObjectID(r.Output); err != nil {
		return err
	}
	if err := e.PutInt(r.Framerate); err != nil {
		return err
	}
	if err := e.PutObjectID(r.Feedback); err != nil {
		return err
	}
	return nil
}

// Ensure ZwpFullscreenShellV1PresentSurfaceForModeRequest implements Request.
var _ Request = &ZwpFullscreenShellV1PresentSurfaceForModeRequest{}

// ZwpFullscreenShellV1CapabilityEvent signals when advertises a capability of the compositor
//
// Advertises a single capability of the compositor.
//
// When the wl_fullscreen_shell interface is bound, this event is emitted
// once for each capability advertised.  Valid capabilities are given by
// the wl_fullscreen_shell.capability enum.  If clients want to take
// advantage of any of these capabilities, they should use a
// wl_display.sync request immediately after binding to ensure that they
// receive all the capability events.
type ZwpFullscreenShellV1CapabilityEvent struct {
	Capability uint32
}

// Opcode returns the event opcode for zwp_fullscreen_shell_v1.capability in fullscreen_shell_unstable_v1
func (ZwpFullscreenShellV1CapabilityEvent) Opcode() uint16 { return 0 }

// MessageName returns the event name for zwp_fullscreen_shell_v1.capability in fullscreen_shell_unstable_v1
func (ZwpFullscreenShellV1CapabilityEvent) MessageName() string { return "capability" }

// Ensure ZwpFullscreenShellV1CapabilityEvent implements Message.
var _ Message = ZwpFullscreenShellV1CapabilityEvent{}

// Scan scans the event from the socket.
func (e *ZwpFullscreenShellV1CapabilityEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Capability = v
	}
	return nil
}

// Ensure ZwpFullscreenShellV1CapabilityEvent implements Event.
var _ Event = &ZwpFullscreenShellV1CapabilityEvent{}

// ZwpFullscreenShellV1 displays a single surface per output
//
// Displays a single surface per output.
//
// This interface provides a mechanism for a single client to display
// simple full-screen surfaces.  While there technically may be multiple
// clients bound to this interface, only one of those clients should be
// shown at a time.
//
// To present a surface, the client uses either the present_surface or
// present_surface_for_mode requests.  Presenting a surface takes effect
// on the next wl_surface.commit.  See the individual requests for
// details about scaling and mode switches.
//
// The client can have at most one surface per output at any time.
// Requesting a surface to be presented on an output that already has a
// surface replaces the previously presented surface.  Presenting a null
// surface removes its content and effectively disables the output.
// Exactly what happens when an output is "disabled" is
// compositor-specific.  The same surface may be presented on multiple
// outputs simultaneously.
//
// Once a surface is presented on an output, it stays on that output
// until either the client removes it or the compositor destroys the
// output.  This way, the client can update the output's contents by
// simply attaching a new buffer.
//
// Warning! The protocol described in this file is experimental and
// backward incompatible changes may be made. Backward compatible changes
// may be added together with the corresponding interface version bump.
// Backward incompatible changes are done by bumping the version number in
// the protocol and interface names and resetting the interface version.
// Once the protocol is to be declared stable, the 'z' prefix and the
// version number in the protocol and interface names are removed and the
// interface version number is reset.
type ZwpFullscreenShellV1 struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *ZwpFullscreenShellV1) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (ZwpFullscreenShellV1) Descriptor() *InterfaceDescriptor {
	return &ZwpFullscreenShellV1Descriptor
}

// Dispatch returns an Event object for a given opcode.
func (ZwpFullscreenShellV1) Dispatch(opcode uint16) Event {
	switch opcode {
	case 0:
		return &ZwpFullscreenShellV1CapabilityEvent{}
	default:
		return nil
	}
}

// Release requests to release the wl_fullscreen_shell interface
//
// Release the binding from the wl_fullscreen_shell interface.
//
// This destroys the server-side object and frees this binding.  If
// the client binds to wl_fullscreen_shell multiple times, it may wish
// to free some of those bindings.
func (proxy *ZwpFullscreenShellV1) Release(connection Connection) (err error) {
	request := ZwpFullscreenShellV1ReleaseRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// PresentSurface requests to present surface for display
//
// Present a surface on the given output.
//
// If the output is null, the compositor will present the surface on
// whatever display (or displays) it thinks best.  In particular, this
// may replace any or all surfaces currently presented so it should
// not be used in combination with placing surfaces on specific
// outputs.
//
// The method parameter is a hint to the compositor for how the surface
// is to be presented.  In particular, it tells the compositor how to
// handle a size mismatch between the presented surface and the
// output.  The compositor is free to ignore this parameter.
//
// The "zoom", "zoom_crop", and "stretch" methods imply a scaling
// operation on the surface.  This will override any kind of output
// scaling, so the buffer_scale property of the surface is effectively
// ignored.
//
// This request gives the surface the role of a fullscreen shell surface.
// If the surface already has another role, it raises a role protocol
// error.
func (proxy *ZwpFullscreenShellV1) PresentSurface(connection Connection, aSurface ObjectID, aMethod uint32, aOutput ObjectID) (err error) {
	request := ZwpFullscreenShellV1PresentSurfaceRequest{
		Surface: aSurface,
		Method:  aMethod,
		Output:  aOutput,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// PresentSurfaceForMode requests to present surface for display at a particular mode
//
// Presents a surface on the given output for a particular mode.
//
// If the current size of the output differs from that of the surface,
// the compositor will attempt to change the size of the output to
// match the surface.  The result of the mode-switch operation will be
// returned via the provided wl_fullscreen_shell_mode_feedback object.
//
// If the current output mode matches the one requested or if the
// compositor successfully switches the mode to match the surface,
// then the mode_successful event will be sent and the output will
// contain the contents of the given surface.  If the compositor
// cannot match the output size to the surface size, the mode_failed
// will be sent and the output will contain the contents of the
// previously presented surface (if any).  If another surface is
// presented on the given output before either of these has a chance
// to happen, the present_cancelled event will be sent.
//
// Due to race conditions and other issues unknown to the client, no
// mode-switch operation is guaranteed to succeed.  However, if the
// mode is one advertised by wl_output.mode or if the compositor
// advertises the ARBITRARY_MODES capability, then the client should
// expect that the mode-switch operation will usually succeed.
//
// If the size of the presented surface changes, the resulting output
// is undefined.  The compositor may attempt to change the output mode
// to compensate.  However, there is no guarantee that a suitable mode
// will be found and the client has no way to be notified of success
// or failure.
//
// The framerate parameter specifies the desired framerate for the
// output in mHz.  The compositor is free to ignore this parameter.  A
// value of 0 indicates that the client has no preference.
//
// If the value of wl_output.scale differs from wl_surface.buffer_scale,
// then the compositor may choose a mode that matches either the buffer
// size or the surface size.  In either case, the surface will fill the
// output.
//
// This request gives the surface the role of a fullscreen shell surface.
// If the surface already has another role, it raises a role protocol
// error.
func (proxy *ZwpFullscreenShellV1) PresentSurfaceForMode(connection Connection, aSurface ObjectID, aOutput ObjectID, aFramerate int32) (aFeedback *ZwpFullscreenShellModeFeedbackV1, err error) {
	aFeedback = &ZwpFullscreenShellModeFeedbackV1{connection.NewID()}
	request := ZwpFullscreenShellV1PresentSurfaceForModeRequest{
		Surface:   aSurface,
		Output:    aOutput,
		Framerate: aFramerate,
		Feedback:  aFeedback.id,
	}
	err = connection.SendRequest(proxy.id, &request)
	if err == nil {
		connection.RegisterProxy(aFeedback)
	}
	return
}

// Ensure ZwpFullscreenShellV1 implements Proxy.
var _ Proxy = &ZwpFullscreenShellV1{}

// #endregion Interface fullscreen_shell_unstable_v1.zwp_fullscreen_shell_v1

// ----------------------------------------------------------------------------
// #region Interface fullscreen_shell_unstable_v1.zwp_fullscreen_shell_mode_feedback_v1

// ZwpFullscreenShellModeFeedbackV1ModeSuccessfulEvent signals when mode switch succeeded
//
// This event indicates that the attempted mode switch operation was
// successful.  A surface of the size requested in the mode switch
// will fill the output without scaling.
//
// Upon receiving this event, the client should destroy the
// wl_fullscreen_shell_mode_feedback object.
type ZwpFullscreenShellModeFeedbackV1ModeSuccessfulEvent struct {
}

// Opcode returns the event opcode for zwp_fullscreen_shell_mode_feedback_v1.mode_successful in fullscreen_shell_unstable_v1
func (ZwpFullscreenShellModeFeedbackV1ModeSuccessfulEvent) Opcode() uint16 { return 0 }

// MessageName returns the event name for zwp_fullscreen_shell_mode_feedback_v1.mode_successful in fullscreen_shell_unstable_v1
func (ZwpFullscreenShellModeFeedbackV1ModeSuccessfulEvent) MessageName() string {
	return "mode_successful"
}

// Ensure ZwpFullscreenShellModeFeedbackV1ModeSuccessfulEvent implements Message.
var _ Message = ZwpFullscreenShellModeFeedbackV1ModeSuccessfulEvent{}

// Scan scans the event from the socket.
func (e *ZwpFullscreenShellModeFeedbackV1ModeSuccessfulEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure ZwpFullscreenShellModeFeedbackV1ModeSuccessfulEvent implements Event.
var _ Event = &ZwpFullscreenShellModeFeedbackV1ModeSuccessfulEvent{}

// ZwpFullscreenShellModeFeedbackV1ModeFailedEvent signals when mode switch failed
//
// This event indicates that the attempted mode switch operation
// failed.  This may be because the requested output mode is not
// possible or it may mean that the compositor does not want to allow it.
//
// Upon receiving this event, the client should destroy the
// wl_fullscreen_shell_mode_feedback object.
type ZwpFullscreenShellModeFeedbackV1ModeFailedEvent struct {
}

// Opcode returns the event opcode for zwp_fullscreen_shell_mode_feedback_v1.mode_failed in fullscreen_shell_unstable_v1
func (ZwpFullscreenShellModeFeedbackV1ModeFailedEvent) Opcode() uint16 { return 1 }

// MessageName returns the event name for zwp_fullscreen_shell_mode_feedback_v1.mode_failed in fullscreen_shell_unstable_v1
func (ZwpFullscreenShellModeFeedbackV1ModeFailedEvent) MessageName() string { return "mode_failed" }

// Ensure ZwpFullscreenShellModeFeedbackV1ModeFailedEvent implements Message.
var _ Message = ZwpFullscreenShellModeFeedbackV1ModeFailedEvent{}

// Scan scans the event from the socket.
func (e *ZwpFullscreenShellModeFeedbackV1ModeFailedEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure ZwpFullscreenShellModeFeedbackV1ModeFailedEvent implements Event.
var _ Event = &ZwpFullscreenShellModeFeedbackV1ModeFailedEvent{}

// ZwpFullscreenShellModeFeedbackV1PresentCancelledEvent signals when mode switch cancelled
//
// This event indicates that the attempted mode switch operation was
// cancelled.  Most likely this is because the client requested a
// second mode switch before the first one completed.
//
// Upon receiving this event, the client should destroy the
// wl_fullscreen_shell_mode_feedback object.
type ZwpFullscreenShellModeFeedbackV1PresentCancelledEvent struct {
}

// Opcode returns the event opcode for zwp_fullscreen_shell_mode_feedback_v1.present_cancelled in fullscreen_shell_unstable_v1
func (ZwpFullscreenShellModeFeedbackV1PresentCancelledEvent) Opcode() uint16 { return 2 }

// MessageName returns the event name for zwp_fullscreen_shell_mode_feedback_v1.present_cancelled in fullscreen_shell_unstable_v1
func (ZwpFullscreenShellModeFeedbackV1PresentCancelledEvent) MessageName() string {
	return "present_cancelled"
}

// Ensure ZwpFullscreenShellModeFeedbackV1PresentCancelledEvent implements Message.
var _ Message = ZwpFullscreenShellModeFeedbackV1PresentCancelledEvent{}

// Scan scans the event from the socket.
func (e *ZwpFullscreenShellModeFeedbackV1PresentCancelledEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure ZwpFullscreenShellModeFeedbackV1PresentCancelledEvent implements Event.
var _ Event = &ZwpFullscreenShellModeFeedbackV1PresentCancelledEvent{}

type ZwpFullscreenShellModeFeedbackV1 struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *ZwpFullscreenShellModeFeedbackV1) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (ZwpFullscreenShellModeFeedbackV1) Descriptor() *InterfaceDescriptor {
	return &ZwpFullscreenShellModeFeedbackV1Descriptor
}

// Dispatch returns an Event object for a given opcode.
func (ZwpFullscreenShellModeFeedbackV1) Dispatch(opcode uint16) Event {
	switch opcode {
	case 0:
		return &ZwpFullscreenShellModeFeedbackV1ModeSuccessfulEvent{}
	case 1:
		return &ZwpFullscreenShellModeFeedbackV1ModeFailedEvent{}
	case 2:
		return &ZwpFullscreenShellModeFeedbackV1PresentCancelledEvent{}
	default:
		return nil
	}
}

// Ensure ZwpFullscreenShellModeFeedbackV1 implements Proxy.
var _ Proxy = &ZwpFullscreenShellModeFeedbackV1{}

// #endregion Interface fullscreen_shell_unstable_v1.zwp_fullscreen_shell_mode_feedback_v1

////////////////////////////////////////////////////////////////////////////////
// #endregion Protocol fullscreen_shell_unstable_v1

////////////////////////////////////////////////////////////////////////////////
// #region Protocol idle_inhibit_unstable_v1

// ----------------------------------------------------------------------------
// #region Interface idle_inhibit_unstable_v1.zwp_idle_inhibit_manager_v1

// ZwpIdleInhibitManagerV1DestroyRequest requests to destroy the idle inhibitor object
//
// Destroy the inhibit manager.
type ZwpIdleInhibitManagerV1DestroyRequest struct {
}

// Opcode returns the request opcode for zwp_idle_inhibit_manager_v1.destroy in idle_inhibit_unstable_v1
func (ZwpIdleInhibitManagerV1DestroyRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for zwp_idle_inhibit_manager_v1.destroy in idle_inhibit_unstable_v1
func (ZwpIdleInhibitManagerV1DestroyRequest) MessageName() string { return "destroy" }

// Ensure ZwpIdleInhibitManagerV1DestroyRequest implements Message.
var _ Message = ZwpIdleInhibitManagerV1DestroyRequest{}

// Emit emits the message to the emitter.
func (r *ZwpIdleInhibitManagerV1DestroyRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure ZwpIdleInhibitManagerV1DestroyRequest implements Request.
var _ Request = &ZwpIdleInhibitManagerV1DestroyRequest{}

// ZwpIdleInhibitManagerV1CreateInhibitorRequest requests to create a new inhibitor object
//
// Create a new inhibitor object associated with the given surface.
type ZwpIdleInhibitManagerV1CreateInhibitorRequest struct {
	ID ObjectID

	// Surface contains the surface that inhibits the idle behavior
	Surface ObjectID
}

// Opcode returns the request opcode for zwp_idle_inhibit_manager_v1.create_inhibitor in idle_inhibit_unstable_v1
func (ZwpIdleInhibitManagerV1CreateInhibitorRequest) Opcode() uint16 { return 1 }

// MessageName returns the request name for zwp_idle_inhibit_manager_v1.create_inhibitor in idle_inhibit_unstable_v1
func (ZwpIdleInhibitManagerV1CreateInhibitorRequest) MessageName() string { return "create_inhibitor" }

// Ensure ZwpIdleInhibitManagerV1CreateInhibitorRequest implements Message.
var _ Message = ZwpIdleInhibitManagerV1CreateInhibitorRequest{}

// Emit emits the message to the emitter.
func (r *ZwpIdleInhibitManagerV1CreateInhibitorRequest) Emit(e *RequestEmitter) error {
	if err := e.PutObjectID(r.ID); err != nil {
		return err
	}
	if err := e.PutObjectID(r.Surface); err != nil {
		return err
	}
	return nil
}

// Ensure ZwpIdleInhibitManagerV1CreateInhibitorRequest implements Request.
var _ Request = &ZwpIdleInhibitManagerV1CreateInhibitorRequest{}

// ZwpIdleInhibitManagerV1 control behavior when display idles
//
// This interface permits inhibiting the idle behavior such as screen
// blanking, locking, and screensaving.  The client binds the idle manager
// globally, then creates idle-inhibitor objects for each surface.
//
// Warning! The protocol described in this file is experimental and
// backward incompatible changes may be made. Backward compatible changes
// may be added together with the corresponding interface version bump.
// Backward incompatible changes are done by bumping the version number in
// the protocol and interface names and resetting the interface version.
// Once the protocol is to be declared stable, the 'z' prefix and the
// version number in the protocol and interface names are removed and the
// interface version number is reset.
type ZwpIdleInhibitManagerV1 struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *ZwpIdleInhibitManagerV1) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (ZwpIdleInhibitManagerV1) Descriptor() *InterfaceDescriptor {
	return &ZwpIdleInhibitManagerV1Descriptor
}

// Dispatch returns an Event object for a given opcode.
func (ZwpIdleInhibitManagerV1) Dispatch(opcode uint16) Event {
	switch opcode {
	default:
		return nil
	}
}

// Destroy requests to destroy the idle inhibitor object
//
// Destroy the inhibit manager.
func (proxy *ZwpIdleInhibitManagerV1) Destroy(connection Connection) (err error) {
	request := ZwpIdleInhibitManagerV1DestroyRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// CreateInhibitor requests to create a new inhibitor object
//
// Create a new inhibitor object associated with the given surface.
func (proxy *ZwpIdleInhibitManagerV1) CreateInhibitor(connection Connection, aSurface ObjectID) (aID *ZwpIdleInhibitorV1, err error) {
	aID = &ZwpIdleInhibitorV1{connection.NewID()}
	request := ZwpIdleInhibitManagerV1CreateInhibitorRequest{
		ID:      aID.id,
		Surface: aSurface,
	}
	err = connection.SendRequest(proxy.id, &request)
	if err == nil {
		connection.RegisterProxy(aID)
	}
	return
}

// Ensure ZwpIdleInhibitManagerV1 implements Proxy.
var _ Proxy = &ZwpIdleInhibitManagerV1{}

// #endregion Interface idle_inhibit_unstable_v1.zwp_idle_inhibit_manager_v1

// ----------------------------------------------------------------------------
// #region Interface idle_inhibit_unstable_v1.zwp_idle_inhibitor_v1

// ZwpIdleInhibitorV1DestroyRequest requests to destroy the idle inhibitor object
//
// Remove the inhibitor effect from the associated wl_surface.
type ZwpIdleInhibitorV1DestroyRequest struct {
}

// Opcode returns the request opcode for zwp_idle_inhibitor_v1.destroy in idle_inhibit_unstable_v1
func (ZwpIdleInhibitorV1DestroyRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for zwp_idle_inhibitor_v1.destroy in idle_inhibit_unstable_v1
func (ZwpIdleInhibitorV1DestroyRequest) MessageName() string { return "destroy" }

// Ensure ZwpIdleInhibitorV1DestroyRequest implements Message.
var _ Message = ZwpIdleInhibitorV1DestroyRequest{}

// Emit emits the message to the emitter.
func (r *ZwpIdleInhibitorV1DestroyRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure ZwpIdleInhibitorV1DestroyRequest implements Request.
var _ Request = &ZwpIdleInhibitorV1DestroyRequest{}

// ZwpIdleInhibitorV1 context object for inhibiting idle behavior
//
// An idle inhibitor prevents the output that the associated surface is
// visible on from being set to a state where it is not visually usable due
// to lack of user interaction (e.g. blanked, dimmed, locked, set to power
// save, etc.)  Any screensaver processes are also blocked from displaying.
//
// If the surface is destroyed, unmapped, becomes occluded, loses
// visibility, or otherwise becomes not visually relevant for the user, the
// idle inhibitor will not be honored by the compositor; if the surface
// subsequently regains visibility the inhibitor takes effect once again.
// Likewise, the inhibitor isn't honored if the system was already idled at
// the time the inhibitor was established, although if the system later
// de-idles and re-idles the inhibitor will take effect.
type ZwpIdleInhibitorV1 struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *ZwpIdleInhibitorV1) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (ZwpIdleInhibitorV1) Descriptor() *InterfaceDescriptor {
	return &ZwpIdleInhibitorV1Descriptor
}

// Dispatch returns an Event object for a given opcode.
func (ZwpIdleInhibitorV1) Dispatch(opcode uint16) Event {
	switch opcode {
	default:
		return nil
	}
}

// Destroy requests to destroy the idle inhibitor object
//
// Remove the inhibitor effect from the associated wl_surface.
func (proxy *ZwpIdleInhibitorV1) Destroy(connection Connection) (err error) {
	request := ZwpIdleInhibitorV1DestroyRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Ensure ZwpIdleInhibitorV1 implements Proxy.
var _ Proxy = &ZwpIdleInhibitorV1{}

// #endregion Interface idle_inhibit_unstable_v1.zwp_idle_inhibitor_v1

////////////////////////////////////////////////////////////////////////////////
// #endregion Protocol idle_inhibit_unstable_v1

////////////////////////////////////////////////////////////////////////////////
// #region Protocol input_method_unstable_v1

// ----------------------------------------------------------------------------
// #region Interface input_method_unstable_v1.zwp_input_method_context_v1

type ZwpInputMethodContextV1DestroyRequest struct {
}

// Opcode returns the request opcode for zwp_input_method_context_v1.destroy in input_method_unstable_v1
func (ZwpInputMethodContextV1DestroyRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for zwp_input_method_context_v1.destroy in input_method_unstable_v1
func (ZwpInputMethodContextV1DestroyRequest) MessageName() string { return "destroy" }

// Ensure ZwpInputMethodContextV1DestroyRequest implements Message.
var _ Message = ZwpInputMethodContextV1DestroyRequest{}

// Emit emits the message to the emitter.
func (r *ZwpInputMethodContextV1DestroyRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure ZwpInputMethodContextV1DestroyRequest implements Request.
var _ Request = &ZwpInputMethodContextV1DestroyRequest{}

// ZwpInputMethodContextV1CommitStringRequest requests to commit string
//
// Send the commit string text for insertion to the application.
//
// The text to commit could be either just a single character after a key
// press or the result of some composing (pre-edit). It could be also an
// empty text when some text should be removed (see
// delete_surrounding_text) or when the input cursor should be moved (see
// cursor_position).
//
// Any previously set composing text will be removed.
type ZwpInputMethodContextV1CommitStringRequest struct {
	// Serial contains serial of the latest known text input state
	Serial uint32

	Text string
}

// Opcode returns the request opcode for zwp_input_method_context_v1.commit_string in input_method_unstable_v1
func (ZwpInputMethodContextV1CommitStringRequest) Opcode() uint16 { return 1 }

// MessageName returns the request name for zwp_input_method_context_v1.commit_string in input_method_unstable_v1
func (ZwpInputMethodContextV1CommitStringRequest) MessageName() string { return "commit_string" }

// Ensure ZwpInputMethodContextV1CommitStringRequest implements Message.
var _ Message = ZwpInputMethodContextV1CommitStringRequest{}

// Emit emits the message to the emitter.
func (r *ZwpInputMethodContextV1CommitStringRequest) Emit(e *RequestEmitter) error {
	if err := e.PutUint(r.Serial); err != nil {
		return err
	}
	if err := e.PutString(r.Text); err != nil {
		return err
	}
	return nil
}

// Ensure ZwpInputMethodContextV1CommitStringRequest implements Request.
var _ Request = &ZwpInputMethodContextV1CommitStringRequest{}

// ZwpInputMethodContextV1PreeditStringRequest requests to pre-edit string
//
// Send the pre-edit string text to the application text input.
//
// The commit text can be used to replace the pre-edit text on reset (for
// example on unfocus).
//
// Previously sent preedit_style and preedit_cursor requests are also
// processed by the text_input.
type ZwpInputMethodContextV1PreeditStringRequest struct {
	// Serial contains serial of the latest known text input state
	Serial uint32

	Text string

	Commit string
}

// Opcode returns the request opcode for zwp_input_method_context_v1.preedit_string in input_method_unstable_v1
func (ZwpInputMethodContextV1PreeditStringRequest) Opcode() uint16 { return 2 }

// MessageName returns the request name for zwp_input_method_context_v1.preedit_string in input_method_unstable_v1
func (ZwpInputMethodContextV1PreeditStringRequest) MessageName() string { return "preedit_string" }

// Ensure ZwpInputMethodContextV1PreeditStringRequest implements Message.
var _ Message = ZwpInputMethodContextV1PreeditStringRequest{}

// Emit emits the message to the emitter.
func (r *ZwpInputMethodContextV1PreeditStringRequest) Emit(e *RequestEmitter) error {
	if err := e.PutUint(r.Serial); err != nil {
		return err
	}
	if err := e.PutString(r.Text); err != nil {
		return err
	}
	if err := e.PutString(r.Commit); err != nil {
		return err
	}
	return nil
}

// Ensure ZwpInputMethodContextV1PreeditStringRequest implements Request.
var _ Request = &ZwpInputMethodContextV1PreeditStringRequest{}

// ZwpInputMethodContextV1PreeditStylingRequest requests to pre-edit styling
//
// Set the styling information on composing text. The style is applied for
// length in bytes from index relative to the beginning of
// the composing text (as byte offset). Multiple styles can
// be applied to a composing text.
//
// This request should be sent before sending a preedit_string request.
type ZwpInputMethodContextV1PreeditStylingRequest struct {
	Index uint32

	Length uint32

	Style uint32
}

// Opcode returns the request opcode for zwp_input_method_context_v1.preedit_styling in input_method_unstable_v1
func (ZwpInputMethodContextV1PreeditStylingRequest) Opcode() uint16 { return 3 }

// MessageName returns the request name for zwp_input_method_context_v1.preedit_styling in input_method_unstable_v1
func (ZwpInputMethodContextV1PreeditStylingRequest) MessageName() string { return "preedit_styling" }

// Ensure ZwpInputMethodContextV1PreeditStylingRequest implements Message.
var _ Message = ZwpInputMethodContextV1PreeditStylingRequest{}

// Emit emits the message to the emitter.
func (r *ZwpInputMethodContextV1PreeditStylingRequest) Emit(e *RequestEmitter) error {
	if err := e.PutUint(r.Index); err != nil {
		return err
	}
	if err := e.PutUint(r.Length); err != nil {
		return err
	}
	if err := e.PutUint(r.Style); err != nil {
		return err
	}
	return nil
}

// Ensure ZwpInputMethodContextV1PreeditStylingRequest implements Request.
var _ Request = &ZwpInputMethodContextV1PreeditStylingRequest{}

// ZwpInputMethodContextV1PreeditCursorRequest requests to pre-edit cursor
//
// Set the cursor position inside the composing text (as byte offset)
// relative to the start of the composing text.
//
// When index is negative no cursor should be displayed.
//
// This request should be sent before sending a preedit_string request.
type ZwpInputMethodContextV1PreeditCursorRequest struct {
	Index int32
}

// Opcode returns the request opcode for zwp_input_method_context_v1.preedit_cursor in input_method_unstable_v1
func (ZwpInputMethodContextV1PreeditCursorRequest) Opcode() uint16 { return 4 }

// MessageName returns the request name for zwp_input_method_context_v1.preedit_cursor in input_method_unstable_v1
func (ZwpInputMethodContextV1PreeditCursorRequest) MessageName() string { return "preedit_cursor" }

// Ensure ZwpInputMethodContextV1PreeditCursorRequest implements Message.
var _ Message = ZwpInputMethodContextV1PreeditCursorRequest{}

// Emit emits the message to the emitter.
func (r *ZwpInputMethodContextV1PreeditCursorRequest) Emit(e *RequestEmitter) error {
	if err := e.PutInt(r.Index); err != nil {
		return err
	}
	return nil
}

// Ensure ZwpInputMethodContextV1PreeditCursorRequest implements Request.
var _ Request = &ZwpInputMethodContextV1PreeditCursorRequest{}

// ZwpInputMethodContextV1DeleteSurroundingTextRequest requests to delete text
//
// Remove the surrounding text.
//
// This request will be handled on the text_input side directly following
// a commit_string request.
type ZwpInputMethodContextV1DeleteSurroundingTextRequest struct {
	Index int32

	Length uint32
}

// Opcode returns the request opcode for zwp_input_method_context_v1.delete_surrounding_text in input_method_unstable_v1
func (ZwpInputMethodContextV1DeleteSurroundingTextRequest) Opcode() uint16 { return 5 }

// MessageName returns the request name for zwp_input_method_context_v1.delete_surrounding_text in input_method_unstable_v1
func (ZwpInputMethodContextV1DeleteSurroundingTextRequest) MessageName() string {
	return "delete_surrounding_text"
}

// Ensure ZwpInputMethodContextV1DeleteSurroundingTextRequest implements Message.
var _ Message = ZwpInputMethodContextV1DeleteSurroundingTextRequest{}

// Emit emits the message to the emitter.
func (r *ZwpInputMethodContextV1DeleteSurroundingTextRequest) Emit(e *RequestEmitter) error {
	if err := e.PutInt(r.Index); err != nil {
		return err
	}
	if err := e.PutUint(r.Length); err != nil {
		return err
	}
	return nil
}

// Ensure ZwpInputMethodContextV1DeleteSurroundingTextRequest implements Request.
var _ Request = &ZwpInputMethodContextV1DeleteSurroundingTextRequest{}

// ZwpInputMethodContextV1CursorPositionRequest requests to set cursor to a new position
//
// Set the cursor and anchor to a new position. Index is the new cursor
// position in bytes (when >= 0 this is relative to the end of the inserted text,
// otherwise it is relative to the beginning of the inserted text). Anchor is
// the new anchor position in bytes (when >= 0 this is relative to the end of the
// inserted text, otherwise it is relative to the beginning of the inserted
// text). When there should be no selected text, anchor should be the same
// as index.
//
// This request will be handled on the text_input side directly following
// a commit_string request.
type ZwpInputMethodContextV1CursorPositionRequest struct {
	Index int32

	Anchor int32
}

// Opcode returns the request opcode for zwp_input_method_context_v1.cursor_position in input_method_unstable_v1
func (ZwpInputMethodContextV1CursorPositionRequest) Opcode() uint16 { return 6 }

// MessageName returns the request name for zwp_input_method_context_v1.cursor_position in input_method_unstable_v1
func (ZwpInputMethodContextV1CursorPositionRequest) MessageName() string { return "cursor_position" }

// Ensure ZwpInputMethodContextV1CursorPositionRequest implements Message.
var _ Message = ZwpInputMethodContextV1CursorPositionRequest{}

// Emit emits the message to the emitter.
func (r *ZwpInputMethodContextV1CursorPositionRequest) Emit(e *RequestEmitter) error {
	if err := e.PutInt(r.Index); err != nil {
		return err
	}
	if err := e.PutInt(r.Anchor); err != nil {
		return err
	}
	return nil
}

// Ensure ZwpInputMethodContextV1CursorPositionRequest implements Request.
var _ Request = &ZwpInputMethodContextV1CursorPositionRequest{}

type ZwpInputMethodContextV1ModifiersMapRequest struct {
	Map []byte
}

// Opcode returns the request opcode for zwp_input_method_context_v1.modifiers_map in input_method_unstable_v1
func (ZwpInputMethodContextV1ModifiersMapRequest) Opcode() uint16 { return 7 }

// MessageName returns the request name for zwp_input_method_context_v1.modifiers_map in input_method_unstable_v1
func (ZwpInputMethodContextV1ModifiersMapRequest) MessageName() string { return "modifiers_map" }

// Ensure ZwpInputMethodContextV1ModifiersMapRequest implements Message.
var _ Message = ZwpInputMethodContextV1ModifiersMapRequest{}

// Emit emits the message to the emitter.
func (r *ZwpInputMethodContextV1ModifiersMapRequest) Emit(e *RequestEmitter) error {
	if err := e.PutArray(r.Map); err != nil {
		return err
	}
	return nil
}

// Ensure ZwpInputMethodContextV1ModifiersMapRequest implements Request.
var _ Request = &ZwpInputMethodContextV1ModifiersMapRequest{}

// ZwpInputMethodContextV1KeysymRequest requests to keysym
//
// Notify when a key event was sent. Key events should not be used for
// normal text input operations, which should be done with commit_string,
// delete_surrounding_text, etc. The key event follows the wl_keyboard key
// event convention. Sym is an XKB keysym, state is a wl_keyboard key_state.
type ZwpInputMethodContextV1KeysymRequest struct {
	// Serial contains serial of the latest known text input state
	Serial uint32

	Time uint32

	Sym uint32

	State uint32

	Modifiers uint32
}

// Opcode returns the request opcode for zwp_input_method_context_v1.keysym in input_method_unstable_v1
func (ZwpInputMethodContextV1KeysymRequest) Opcode() uint16 { return 8 }

// MessageName returns the request name for zwp_input_method_context_v1.keysym in input_method_unstable_v1
func (ZwpInputMethodContextV1KeysymRequest) MessageName() string { return "keysym" }

// Ensure ZwpInputMethodContextV1KeysymRequest implements Message.
var _ Message = ZwpInputMethodContextV1KeysymRequest{}

// Emit emits the message to the emitter.
func (r *ZwpInputMethodContextV1KeysymRequest) Emit(e *RequestEmitter) error {
	if err := e.PutUint(r.Serial); err != nil {
		return err
	}
	if err := e.PutUint(r.Time); err != nil {
		return err
	}
	if err := e.PutUint(r.Sym); err != nil {
		return err
	}
	if err := e.PutUint(r.State); err != nil {
		return err
	}
	if err := e.PutUint(r.Modifiers); err != nil {
		return err
	}
	return nil
}

// Ensure ZwpInputMethodContextV1KeysymRequest implements Request.
var _ Request = &ZwpInputMethodContextV1KeysymRequest{}

// ZwpInputMethodContextV1GrabKeyboardRequest requests to grab hardware keyboard
//
// Allow an input method to receive hardware keyboard input and process
// key events to generate text events (with pre-edit) over the wire. This
// allows input methods which compose multiple key events for inputting
// text like it is done for CJK languages.
type ZwpInputMethodContextV1GrabKeyboardRequest struct {
	Keyboard ObjectID
}

// Opcode returns the request opcode for zwp_input_method_context_v1.grab_keyboard in input_method_unstable_v1
func (ZwpInputMethodContextV1GrabKeyboardRequest) Opcode() uint16 { return 9 }

// MessageName returns the request name for zwp_input_method_context_v1.grab_keyboard in input_method_unstable_v1
func (ZwpInputMethodContextV1GrabKeyboardRequest) MessageName() string { return "grab_keyboard" }

// Ensure ZwpInputMethodContextV1GrabKeyboardRequest implements Message.
var _ Message = ZwpInputMethodContextV1GrabKeyboardRequest{}

// Emit emits the message to the emitter.
func (r *ZwpInputMethodContextV1GrabKeyboardRequest) Emit(e *RequestEmitter) error {
	if err := e.PutObjectID(r.Keyboard); err != nil {
		return err
	}
	return nil
}

// Ensure ZwpInputMethodContextV1GrabKeyboardRequest implements Request.
var _ Request = &ZwpInputMethodContextV1GrabKeyboardRequest{}

// ZwpInputMethodContextV1KeyRequest requests to forward key event
//
// Forward a wl_keyboard::key event to the client that was not processed
// by the input method itself. Should be used when filtering key events
// with grab_keyboard.  The arguments should be the ones from the
// wl_keyboard::key event.
//
// For generating custom key events use the keysym request instead.
type ZwpInputMethodContextV1KeyRequest struct {
	// Serial contains serial from wl_keyboard::key
	Serial uint32

	// Time contains time from wl_keyboard::key
	Time uint32

	// Key contains key from wl_keyboard::key
	Key uint32

	// State contains state from wl_keyboard::key
	State uint32
}

// Opcode returns the request opcode for zwp_input_method_context_v1.key in input_method_unstable_v1
func (ZwpInputMethodContextV1KeyRequest) Opcode() uint16 { return 10 }

// MessageName returns the request name for zwp_input_method_context_v1.key in input_method_unstable_v1
func (ZwpInputMethodContextV1KeyRequest) MessageName() string { return "key" }

// Ensure ZwpInputMethodContextV1KeyRequest implements Message.
var _ Message = ZwpInputMethodContextV1KeyRequest{}

// Emit emits the message to the emitter.
func (r *ZwpInputMethodContextV1KeyRequest) Emit(e *RequestEmitter) error {
	if err := e.PutUint(r.Serial); err != nil {
		return err
	}
	if err := e.PutUint(r.Time); err != nil {
		return err
	}
	if err := e.PutUint(r.Key); err != nil {
		return err
	}
	if err := e.PutUint(r.State); err != nil {
		return err
	}
	return nil
}

// Ensure ZwpInputMethodContextV1KeyRequest implements Request.
var _ Request = &ZwpInputMethodContextV1KeyRequest{}

// ZwpInputMethodContextV1ModifiersRequest requests to forward modifiers event
//
// Forward a wl_keyboard::modifiers event to the client that was not
// processed by the input method itself.  Should be used when filtering
// key events with grab_keyboard. The arguments should be the ones
// from the wl_keyboard::modifiers event.
type ZwpInputMethodContextV1ModifiersRequest struct {
	// Serial contains serial from wl_keyboard::modifiers
	Serial uint32

	// ModsDepressed contains mods_depressed from wl_keyboard::modifiers
	ModsDepressed uint32

	// ModsLatched contains mods_latched from wl_keyboard::modifiers
	ModsLatched uint32

	// ModsLocked contains mods_locked from wl_keyboard::modifiers
	ModsLocked uint32

	// Group contains group from wl_keyboard::modifiers
	Group uint32
}

// Opcode returns the request opcode for zwp_input_method_context_v1.modifiers in input_method_unstable_v1
func (ZwpInputMethodContextV1ModifiersRequest) Opcode() uint16 { return 11 }

// MessageName returns the request name for zwp_input_method_context_v1.modifiers in input_method_unstable_v1
func (ZwpInputMethodContextV1ModifiersRequest) MessageName() string { return "modifiers" }

// Ensure ZwpInputMethodContextV1ModifiersRequest implements Message.
var _ Message = ZwpInputMethodContextV1ModifiersRequest{}

// Emit emits the message to the emitter.
func (r *ZwpInputMethodContextV1ModifiersRequest) Emit(e *RequestEmitter) error {
	if err := e.PutUint(r.Serial); err != nil {
		return err
	}
	if err := e.PutUint(r.ModsDepressed); err != nil {
		return err
	}
	if err := e.PutUint(r.ModsLatched); err != nil {
		return err
	}
	if err := e.PutUint(r.ModsLocked); err != nil {
		return err
	}
	if err := e.PutUint(r.Group); err != nil {
		return err
	}
	return nil
}

// Ensure ZwpInputMethodContextV1ModifiersRequest implements Request.
var _ Request = &ZwpInputMethodContextV1ModifiersRequest{}

type ZwpInputMethodContextV1LanguageRequest struct {
	// Serial contains serial of the latest known text input state
	Serial uint32

	Language string
}

// Opcode returns the request opcode for zwp_input_method_context_v1.language in input_method_unstable_v1
func (ZwpInputMethodContextV1LanguageRequest) Opcode() uint16 { return 12 }

// MessageName returns the request name for zwp_input_method_context_v1.language in input_method_unstable_v1
func (ZwpInputMethodContextV1LanguageRequest) MessageName() string { return "language" }

// Ensure ZwpInputMethodContextV1LanguageRequest implements Message.
var _ Message = ZwpInputMethodContextV1LanguageRequest{}

// Emit emits the message to the emitter.
func (r *ZwpInputMethodContextV1LanguageRequest) Emit(e *RequestEmitter) error {
	if err := e.PutUint(r.Serial); err != nil {
		return err
	}
	if err := e.PutString(r.Language); err != nil {
		return err
	}
	return nil
}

// Ensure ZwpInputMethodContextV1LanguageRequest implements Request.
var _ Request = &ZwpInputMethodContextV1LanguageRequest{}

type ZwpInputMethodContextV1TextDirectionRequest struct {
	// Serial contains serial of the latest known text input state
	Serial uint32

	Direction uint32
}

// Opcode returns the request opcode for zwp_input_method_context_v1.text_direction in input_method_unstable_v1
func (ZwpInputMethodContextV1TextDirectionRequest) Opcode() uint16 { return 13 }

// MessageName returns the request name for zwp_input_method_context_v1.text_direction in input_method_unstable_v1
func (ZwpInputMethodContextV1TextDirectionRequest) MessageName() string { return "text_direction" }

// Ensure ZwpInputMethodContextV1TextDirectionRequest implements Message.
var _ Message = ZwpInputMethodContextV1TextDirectionRequest{}

// Emit emits the message to the emitter.
func (r *ZwpInputMethodContextV1TextDirectionRequest) Emit(e *RequestEmitter) error {
	if err := e.PutUint(r.Serial); err != nil {
		return err
	}
	if err := e.PutUint(r.Direction); err != nil {
		return err
	}
	return nil
}

// Ensure ZwpInputMethodContextV1TextDirectionRequest implements Request.
var _ Request = &ZwpInputMethodContextV1TextDirectionRequest{}

// ZwpInputMethodContextV1SurroundingTextEvent signals when surrounding text event
//
// The plain surrounding text around the input position. Cursor is the
// position in bytes within the surrounding text relative to the beginning
// of the text. Anchor is the position in bytes of the selection anchor
// within the surrounding text relative to the beginning of the text. If
// there is no selected text then anchor is the same as cursor.
type ZwpInputMethodContextV1SurroundingTextEvent struct {
	Text string

	Cursor uint32

	Anchor uint32
}

// Opcode returns the event opcode for zwp_input_method_context_v1.surrounding_text in input_method_unstable_v1
func (ZwpInputMethodContextV1SurroundingTextEvent) Opcode() uint16 { return 0 }

// MessageName returns the event name for zwp_input_method_context_v1.surrounding_text in input_method_unstable_v1
func (ZwpInputMethodContextV1SurroundingTextEvent) MessageName() string { return "surrounding_text" }

// Ensure ZwpInputMethodContextV1SurroundingTextEvent implements Message.
var _ Message = ZwpInputMethodContextV1SurroundingTextEvent{}

// Scan scans the event from the socket.
func (e *ZwpInputMethodContextV1SurroundingTextEvent) Scan(s *EventScanner) error {
	if v, err := s.String(); err != nil {
		return err
	} else {
		e.Text = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Cursor = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Anchor = v
	}
	return nil
}

// Ensure ZwpInputMethodContextV1SurroundingTextEvent implements Event.
var _ Event = &ZwpInputMethodContextV1SurroundingTextEvent{}

type ZwpInputMethodContextV1ResetEvent struct {
}

// Opcode returns the event opcode for zwp_input_method_context_v1.reset in input_method_unstable_v1
func (ZwpInputMethodContextV1ResetEvent) Opcode() uint16 { return 1 }

// MessageName returns the event name for zwp_input_method_context_v1.reset in input_method_unstable_v1
func (ZwpInputMethodContextV1ResetEvent) MessageName() string { return "reset" }

// Ensure ZwpInputMethodContextV1ResetEvent implements Message.
var _ Message = ZwpInputMethodContextV1ResetEvent{}

// Scan scans the event from the socket.
func (e *ZwpInputMethodContextV1ResetEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure ZwpInputMethodContextV1ResetEvent implements Event.
var _ Event = &ZwpInputMethodContextV1ResetEvent{}

type ZwpInputMethodContextV1ContentTypeEvent struct {
	Hint uint32

	Purpose uint32
}

// Opcode returns the event opcode for zwp_input_method_context_v1.content_type in input_method_unstable_v1
func (ZwpInputMethodContextV1ContentTypeEvent) Opcode() uint16 { return 2 }

// MessageName returns the event name for zwp_input_method_context_v1.content_type in input_method_unstable_v1
func (ZwpInputMethodContextV1ContentTypeEvent) MessageName() string { return "content_type" }

// Ensure ZwpInputMethodContextV1ContentTypeEvent implements Message.
var _ Message = ZwpInputMethodContextV1ContentTypeEvent{}

// Scan scans the event from the socket.
func (e *ZwpInputMethodContextV1ContentTypeEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Hint = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Purpose = v
	}
	return nil
}

// Ensure ZwpInputMethodContextV1ContentTypeEvent implements Event.
var _ Event = &ZwpInputMethodContextV1ContentTypeEvent{}

type ZwpInputMethodContextV1InvokeActionEvent struct {
	Button uint32

	Index uint32
}

// Opcode returns the event opcode for zwp_input_method_context_v1.invoke_action in input_method_unstable_v1
func (ZwpInputMethodContextV1InvokeActionEvent) Opcode() uint16 { return 3 }

// MessageName returns the event name for zwp_input_method_context_v1.invoke_action in input_method_unstable_v1
func (ZwpInputMethodContextV1InvokeActionEvent) MessageName() string { return "invoke_action" }

// Ensure ZwpInputMethodContextV1InvokeActionEvent implements Message.
var _ Message = ZwpInputMethodContextV1InvokeActionEvent{}

// Scan scans the event from the socket.
func (e *ZwpInputMethodContextV1InvokeActionEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Button = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Index = v
	}
	return nil
}

// Ensure ZwpInputMethodContextV1InvokeActionEvent implements Event.
var _ Event = &ZwpInputMethodContextV1InvokeActionEvent{}

type ZwpInputMethodContextV1CommitStateEvent struct {
	// Serial contains serial of text input state
	Serial uint32
}

// Opcode returns the event opcode for zwp_input_method_context_v1.commit_state in input_method_unstable_v1
func (ZwpInputMethodContextV1CommitStateEvent) Opcode() uint16 { return 4 }

// MessageName returns the event name for zwp_input_method_context_v1.commit_state in input_method_unstable_v1
func (ZwpInputMethodContextV1CommitStateEvent) MessageName() string { return "commit_state" }

// Ensure ZwpInputMethodContextV1CommitStateEvent implements Message.
var _ Message = ZwpInputMethodContextV1CommitStateEvent{}

// Scan scans the event from the socket.
func (e *ZwpInputMethodContextV1CommitStateEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Serial = v
	}
	return nil
}

// Ensure ZwpInputMethodContextV1CommitStateEvent implements Event.
var _ Event = &ZwpInputMethodContextV1CommitStateEvent{}

type ZwpInputMethodContextV1PreferredLanguageEvent struct {
	Language string
}

// Opcode returns the event opcode for zwp_input_method_context_v1.preferred_language in input_method_unstable_v1
func (ZwpInputMethodContextV1PreferredLanguageEvent) Opcode() uint16 { return 5 }

// MessageName returns the event name for zwp_input_method_context_v1.preferred_language in input_method_unstable_v1
func (ZwpInputMethodContextV1PreferredLanguageEvent) MessageName() string {
	return "preferred_language"
}

// Ensure ZwpInputMethodContextV1PreferredLanguageEvent implements Message.
var _ Message = ZwpInputMethodContextV1PreferredLanguageEvent{}

// Scan scans the event from the socket.
func (e *ZwpInputMethodContextV1PreferredLanguageEvent) Scan(s *EventScanner) error {
	if v, err := s.String(); err != nil {
		return err
	} else {
		e.Language = v
	}
	return nil
}

// Ensure ZwpInputMethodContextV1PreferredLanguageEvent implements Event.
var _ Event = &ZwpInputMethodContextV1PreferredLanguageEvent{}

// ZwpInputMethodContextV1 input method context
//
// Corresponds to a text input on the input method side. An input method context
// is created on text input activation on the input method side. It allows
// receiving information about the text input from the application via events.
// Input method contexts do not keep state after deactivation and should be
// destroyed after deactivation is handled.
//
// Text is generally UTF-8 encoded, indices and lengths are in bytes.
//
// Serials are used to synchronize the state between the text input and
// an input method. New serials are sent by the text input in the
// commit_state request and are used by the input method to indicate
// the known text input state in events like preedit_string, commit_string,
// and keysym. The text input can then ignore events from the input method
// which are based on an outdated state (for example after a reset).
//
// Warning! The protocol described in this file is experimental and
// backward incompatible changes may be made. Backward compatible changes
// may be added together with the corresponding interface version bump.
// Backward incompatible changes are done by bumping the version number in
// the protocol and interface names and resetting the interface version.
// Once the protocol is to be declared stable, the 'z' prefix and the
// version number in the protocol and interface names are removed and the
// interface version number is reset.
type ZwpInputMethodContextV1 struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *ZwpInputMethodContextV1) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (ZwpInputMethodContextV1) Descriptor() *InterfaceDescriptor {
	return &ZwpInputMethodContextV1Descriptor
}

// Dispatch returns an Event object for a given opcode.
func (ZwpInputMethodContextV1) Dispatch(opcode uint16) Event {
	switch opcode {
	case 0:
		return &ZwpInputMethodContextV1SurroundingTextEvent{}
	case 1:
		return &ZwpInputMethodContextV1ResetEvent{}
	case 2:
		return &ZwpInputMethodContextV1ContentTypeEvent{}
	case 3:
		return &ZwpInputMethodContextV1InvokeActionEvent{}
	case 4:
		return &ZwpInputMethodContextV1CommitStateEvent{}
	case 5:
		return &ZwpInputMethodContextV1PreferredLanguageEvent{}
	default:
		return nil
	}
}
func (proxy *ZwpInputMethodContextV1) Destroy(connection Connection) (err error) {
	request := ZwpInputMethodContextV1DestroyRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// CommitString requests to commit string
//
// Send the commit string text for insertion to the application.
//
// The text to commit could be either just a single character after a key
// press or the result of some composing (pre-edit). It could be also an
// empty text when some text should be removed (see
// delete_surrounding_text) or when the input cursor should be moved (see
// cursor_position).
//
// Any previously set composing text will be removed.
func (proxy *ZwpInputMethodContextV1) CommitString(connection Connection, aSerial uint32, aText string) (err error) {
	request := ZwpInputMethodContextV1CommitStringRequest{
		Serial: aSerial,
		Text:   aText,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// PreeditString requests to pre-edit string
//
// Send the pre-edit string text to the application text input.
//
// The commit text can be used to replace the pre-edit text on reset (for
// example on unfocus).
//
// Previously sent preedit_style and preedit_cursor requests are also
// processed by the text_input.
func (proxy *ZwpInputMethodContextV1) PreeditString(connection Connection, aSerial uint32, aText string, aCommit string) (err error) {
	request := ZwpInputMethodContextV1PreeditStringRequest{
		Serial: aSerial,
		Text:   aText,
		Commit: aCommit,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// PreeditStyling requests to pre-edit styling
//
// Set the styling information on composing text. The style is applied for
// length in bytes from index relative to the beginning of
// the composing text (as byte offset). Multiple styles can
// be applied to a composing text.
//
// This request should be sent before sending a preedit_string request.
func (proxy *ZwpInputMethodContextV1) PreeditStyling(connection Connection, aIndex uint32, aLength uint32, aStyle uint32) (err error) {
	request := ZwpInputMethodContextV1PreeditStylingRequest{
		Index:  aIndex,
		Length: aLength,
		Style:  aStyle,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// PreeditCursor requests to pre-edit cursor
//
// Set the cursor position inside the composing text (as byte offset)
// relative to the start of the composing text.
//
// When index is negative no cursor should be displayed.
//
// This request should be sent before sending a preedit_string request.
func (proxy *ZwpInputMethodContextV1) PreeditCursor(connection Connection, aIndex int32) (err error) {
	request := ZwpInputMethodContextV1PreeditCursorRequest{
		Index: aIndex,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// DeleteSurroundingText requests to delete text
//
// Remove the surrounding text.
//
// This request will be handled on the text_input side directly following
// a commit_string request.
func (proxy *ZwpInputMethodContextV1) DeleteSurroundingText(connection Connection, aIndex int32, aLength uint32) (err error) {
	request := ZwpInputMethodContextV1DeleteSurroundingTextRequest{
		Index:  aIndex,
		Length: aLength,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// CursorPosition requests to set cursor to a new position
//
// Set the cursor and anchor to a new position. Index is the new cursor
// position in bytes (when >= 0 this is relative to the end of the inserted text,
// otherwise it is relative to the beginning of the inserted text). Anchor is
// the new anchor position in bytes (when >= 0 this is relative to the end of the
// inserted text, otherwise it is relative to the beginning of the inserted
// text). When there should be no selected text, anchor should be the same
// as index.
//
// This request will be handled on the text_input side directly following
// a commit_string request.
func (proxy *ZwpInputMethodContextV1) CursorPosition(connection Connection, aIndex int32, aAnchor int32) (err error) {
	request := ZwpInputMethodContextV1CursorPositionRequest{
		Index:  aIndex,
		Anchor: aAnchor,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

func (proxy *ZwpInputMethodContextV1) ModifiersMap(connection Connection, aMap []byte) (err error) {
	request := ZwpInputMethodContextV1ModifiersMapRequest{
		Map: aMap,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Keysym requests to keysym
//
// Notify when a key event was sent. Key events should not be used for
// normal text input operations, which should be done with commit_string,
// delete_surrounding_text, etc. The key event follows the wl_keyboard key
// event convention. Sym is an XKB keysym, state is a wl_keyboard key_state.
func (proxy *ZwpInputMethodContextV1) Keysym(connection Connection, aSerial uint32, aTime uint32, aSym uint32, aState uint32, aModifiers uint32) (err error) {
	request := ZwpInputMethodContextV1KeysymRequest{
		Serial:    aSerial,
		Time:      aTime,
		Sym:       aSym,
		State:     aState,
		Modifiers: aModifiers,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// GrabKeyboard requests to grab hardware keyboard
//
// Allow an input method to receive hardware keyboard input and process
// key events to generate text events (with pre-edit) over the wire. This
// allows input methods which compose multiple key events for inputting
// text like it is done for CJK languages.
func (proxy *ZwpInputMethodContextV1) GrabKeyboard(connection Connection) (aKeyboard *WlKeyboard, err error) {
	aKeyboard = &WlKeyboard{connection.NewID()}
	request := ZwpInputMethodContextV1GrabKeyboardRequest{
		Keyboard: aKeyboard.id,
	}
	err = connection.SendRequest(proxy.id, &request)
	if err == nil {
		connection.RegisterProxy(aKeyboard)
	}
	return
}

// Key requests to forward key event
//
// Forward a wl_keyboard::key event to the client that was not processed
// by the input method itself. Should be used when filtering key events
// with grab_keyboard.  The arguments should be the ones from the
// wl_keyboard::key event.
//
// For generating custom key events use the keysym request instead.
func (proxy *ZwpInputMethodContextV1) Key(connection Connection, aSerial uint32, aTime uint32, aKey uint32, aState uint32) (err error) {
	request := ZwpInputMethodContextV1KeyRequest{
		Serial: aSerial,
		Time:   aTime,
		Key:    aKey,
		State:  aState,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Modifiers requests to forward modifiers event
//
// Forward a wl_keyboard::modifiers event to the client that was not
// processed by the input method itself.  Should be used when filtering
// key events with grab_keyboard. The arguments should be the ones
// from the wl_keyboard::modifiers event.
func (proxy *ZwpInputMethodContextV1) Modifiers(connection Connection, aSerial uint32, aModsDepressed uint32, aModsLatched uint32, aModsLocked uint32, aGroup uint32) (err error) {
	request := ZwpInputMethodContextV1ModifiersRequest{
		Serial:        aSerial,
		ModsDepressed: aModsDepressed,
		ModsLatched:   aModsLatched,
		ModsLocked:    aModsLocked,
		Group:         aGroup,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

func (proxy *ZwpInputMethodContextV1) Language(connection Connection, aSerial uint32, aLanguage string) (err error) {
	request := ZwpInputMethodContextV1LanguageRequest{
		Serial:   aSerial,
		Language: aLanguage,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

func (proxy *ZwpInputMethodContextV1) TextDirection(connection Connection, aSerial uint32, aDirection uint32) (err error) {
	request := ZwpInputMethodContextV1TextDirectionRequest{
		Serial:    aSerial,
		Direction: aDirection,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Ensure ZwpInputMethodContextV1 implements Proxy.
var _ Proxy = &ZwpInputMethodContextV1{}

// #endregion Interface input_method_unstable_v1.zwp_input_method_context_v1

// ----------------------------------------------------------------------------
// #region Interface input_method_unstable_v1.zwp_input_method_v1

// ZwpInputMethodV1ActivateEvent signals when activate event
//
// A text input was activated. Creates an input method context object
// which allows communication with the text input.
type ZwpInputMethodV1ActivateEvent struct {
	ID ObjectID
}

// Opcode returns the event opcode for zwp_input_method_v1.activate in input_method_unstable_v1
func (ZwpInputMethodV1ActivateEvent) Opcode() uint16 { return 0 }

// MessageName returns the event name for zwp_input_method_v1.activate in input_method_unstable_v1
func (ZwpInputMethodV1ActivateEvent) MessageName() string { return "activate" }

// Ensure ZwpInputMethodV1ActivateEvent implements Message.
var _ Message = ZwpInputMethodV1ActivateEvent{}

// Scan scans the event from the socket.
func (e *ZwpInputMethodV1ActivateEvent) Scan(s *EventScanner) error {
	if v, err := s.ObjectID(); err != nil {
		return err
	} else {
		e.ID = v
	}
	return nil
}

// Ensure ZwpInputMethodV1ActivateEvent implements Event.
var _ Event = &ZwpInputMethodV1ActivateEvent{}

// ZwpInputMethodV1DeactivateEvent signals when deactivate event
//
// The text input corresponding to the context argument was deactivated.
// The input method context should be destroyed after deactivation is
// handled.
type ZwpInputMethodV1DeactivateEvent struct {
	Context ObjectID
}

// Opcode returns the event opcode for zwp_input_method_v1.deactivate in input_method_unstable_v1
func (ZwpInputMethodV1DeactivateEvent) Opcode() uint16 { return 1 }

// MessageName returns the event name for zwp_input_method_v1.deactivate in input_method_unstable_v1
func (ZwpInputMethodV1DeactivateEvent) MessageName() string { return "deactivate" }

// Ensure ZwpInputMethodV1DeactivateEvent implements Message.
var _ Message = ZwpInputMethodV1DeactivateEvent{}

// Scan scans the event from the socket.
func (e *ZwpInputMethodV1DeactivateEvent) Scan(s *EventScanner) error {
	if v, err := s.ObjectID(); err != nil {
		return err
	} else {
		e.Context = v
	}
	return nil
}

// Ensure ZwpInputMethodV1DeactivateEvent implements Event.
var _ Event = &ZwpInputMethodV1DeactivateEvent{}

// ZwpInputMethodV1 input method
//
// An input method object is responsible for composing text in response to
// input from hardware or virtual keyboards. There is one input method
// object per seat. On activate there is a new input method context object
// created which allows the input method to communicate with the text input.
type ZwpInputMethodV1 struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *ZwpInputMethodV1) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (ZwpInputMethodV1) Descriptor() *InterfaceDescriptor {
	return &ZwpInputMethodV1Descriptor
}

// Dispatch returns an Event object for a given opcode.
func (ZwpInputMethodV1) Dispatch(opcode uint16) Event {
	switch opcode {
	case 0:
		return &ZwpInputMethodV1ActivateEvent{}
	case 1:
		return &ZwpInputMethodV1DeactivateEvent{}
	default:
		return nil
	}
}

// Ensure ZwpInputMethodV1 implements Proxy.
var _ Proxy = &ZwpInputMethodV1{}

// #endregion Interface input_method_unstable_v1.zwp_input_method_v1

// ----------------------------------------------------------------------------
// #region Interface input_method_unstable_v1.zwp_input_panel_v1

type ZwpInputPanelV1GetInputPanelSurfaceRequest struct {
	ID ObjectID

	Surface ObjectID
}

// Opcode returns the request opcode for zwp_input_panel_v1.get_input_panel_surface in input_method_unstable_v1
func (ZwpInputPanelV1GetInputPanelSurfaceRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for zwp_input_panel_v1.get_input_panel_surface in input_method_unstable_v1
func (ZwpInputPanelV1GetInputPanelSurfaceRequest) MessageName() string {
	return "get_input_panel_surface"
}

// Ensure ZwpInputPanelV1GetInputPanelSurfaceRequest implements Message.
var _ Message = ZwpInputPanelV1GetInputPanelSurfaceRequest{}

// Emit emits the message to the emitter.
func (r *ZwpInputPanelV1GetInputPanelSurfaceRequest) Emit(e *RequestEmitter) error {
	if err := e.PutObjectID(r.ID); err != nil {
		return err
	}
	if err := e.PutObjectID(r.Surface); err != nil {
		return err
	}
	return nil
}

// Ensure ZwpInputPanelV1GetInputPanelSurfaceRequest implements Request.
var _ Request = &ZwpInputPanelV1GetInputPanelSurfaceRequest{}

// ZwpInputPanelV1 interface for implementing keyboards
//
// Only one client can bind this interface at a time.
type ZwpInputPanelV1 struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *ZwpInputPanelV1) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (ZwpInputPanelV1) Descriptor() *InterfaceDescriptor {
	return &ZwpInputPanelV1Descriptor
}

// Dispatch returns an Event object for a given opcode.
func (ZwpInputPanelV1) Dispatch(opcode uint16) Event {
	switch opcode {
	default:
		return nil
	}
}
func (proxy *ZwpInputPanelV1) GetInputPanelSurface(connection Connection, aSurface ObjectID) (aID *ZwpInputPanelSurfaceV1, err error) {
	aID = &ZwpInputPanelSurfaceV1{connection.NewID()}
	request := ZwpInputPanelV1GetInputPanelSurfaceRequest{
		ID:      aID.id,
		Surface: aSurface,
	}
	err = connection.SendRequest(proxy.id, &request)
	if err == nil {
		connection.RegisterProxy(aID)
	}
	return
}

// Ensure ZwpInputPanelV1 implements Proxy.
var _ Proxy = &ZwpInputPanelV1{}

// #endregion Interface input_method_unstable_v1.zwp_input_panel_v1

// ----------------------------------------------------------------------------
// #region Interface input_method_unstable_v1.zwp_input_panel_surface_v1

type ZwpInputPanelSurfaceV1Position int

const (
	ZwpInputPanelSurfaceV1PositionCenterBottom ZwpInputPanelSurfaceV1Position = 0
)

// ZwpInputPanelSurfaceV1SetToplevelRequest requests to set the surface type as a keyboard
//
// Set the input_panel_surface type to keyboard.
//
// A keyboard surface is only shown when a text input is active.
type ZwpInputPanelSurfaceV1SetToplevelRequest struct {
	Output ObjectID

	Position uint32
}

// Opcode returns the request opcode for zwp_input_panel_surface_v1.set_toplevel in input_method_unstable_v1
func (ZwpInputPanelSurfaceV1SetToplevelRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for zwp_input_panel_surface_v1.set_toplevel in input_method_unstable_v1
func (ZwpInputPanelSurfaceV1SetToplevelRequest) MessageName() string { return "set_toplevel" }

// Ensure ZwpInputPanelSurfaceV1SetToplevelRequest implements Message.
var _ Message = ZwpInputPanelSurfaceV1SetToplevelRequest{}

// Emit emits the message to the emitter.
func (r *ZwpInputPanelSurfaceV1SetToplevelRequest) Emit(e *RequestEmitter) error {
	if err := e.PutObjectID(r.Output); err != nil {
		return err
	}
	if err := e.PutUint(r.Position); err != nil {
		return err
	}
	return nil
}

// Ensure ZwpInputPanelSurfaceV1SetToplevelRequest implements Request.
var _ Request = &ZwpInputPanelSurfaceV1SetToplevelRequest{}

// ZwpInputPanelSurfaceV1SetOverlayPanelRequest requests to set the surface type as an overlay panel
//
// Set the input_panel_surface to be an overlay panel.
//
// This is shown near the input cursor above the application window when
// a text input is active.
type ZwpInputPanelSurfaceV1SetOverlayPanelRequest struct {
}

// Opcode returns the request opcode for zwp_input_panel_surface_v1.set_overlay_panel in input_method_unstable_v1
func (ZwpInputPanelSurfaceV1SetOverlayPanelRequest) Opcode() uint16 { return 1 }

// MessageName returns the request name for zwp_input_panel_surface_v1.set_overlay_panel in input_method_unstable_v1
func (ZwpInputPanelSurfaceV1SetOverlayPanelRequest) MessageName() string { return "set_overlay_panel" }

// Ensure ZwpInputPanelSurfaceV1SetOverlayPanelRequest implements Message.
var _ Message = ZwpInputPanelSurfaceV1SetOverlayPanelRequest{}

// Emit emits the message to the emitter.
func (r *ZwpInputPanelSurfaceV1SetOverlayPanelRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure ZwpInputPanelSurfaceV1SetOverlayPanelRequest implements Request.
var _ Request = &ZwpInputPanelSurfaceV1SetOverlayPanelRequest{}

type ZwpInputPanelSurfaceV1 struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *ZwpInputPanelSurfaceV1) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (ZwpInputPanelSurfaceV1) Descriptor() *InterfaceDescriptor {
	return &ZwpInputPanelSurfaceV1Descriptor
}

// Dispatch returns an Event object for a given opcode.
func (ZwpInputPanelSurfaceV1) Dispatch(opcode uint16) Event {
	switch opcode {
	default:
		return nil
	}
}

// SetToplevel requests to set the surface type as a keyboard
//
// Set the input_panel_surface type to keyboard.
//
// A keyboard surface is only shown when a text input is active.
func (proxy *ZwpInputPanelSurfaceV1) SetToplevel(connection Connection, aOutput ObjectID, aPosition uint32) (err error) {
	request := ZwpInputPanelSurfaceV1SetToplevelRequest{
		Output:   aOutput,
		Position: aPosition,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// SetOverlayPanel requests to set the surface type as an overlay panel
//
// Set the input_panel_surface to be an overlay panel.
//
// This is shown near the input cursor above the application window when
// a text input is active.
func (proxy *ZwpInputPanelSurfaceV1) SetOverlayPanel(connection Connection) (err error) {
	request := ZwpInputPanelSurfaceV1SetOverlayPanelRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Ensure ZwpInputPanelSurfaceV1 implements Proxy.
var _ Proxy = &ZwpInputPanelSurfaceV1{}

// #endregion Interface input_method_unstable_v1.zwp_input_panel_surface_v1

////////////////////////////////////////////////////////////////////////////////
// #endregion Protocol input_method_unstable_v1

////////////////////////////////////////////////////////////////////////////////
// #region Protocol input_timestamps_unstable_v1

// ----------------------------------------------------------------------------
// #region Interface input_timestamps_unstable_v1.zwp_input_timestamps_manager_v1

// ZwpInputTimestampsManagerV1DestroyRequest requests to destroy the input timestamps manager object
//
// Informs the server that the client will no longer be using this
// protocol object. Existing objects created by this object are not
// affected.
type ZwpInputTimestampsManagerV1DestroyRequest struct {
}

// Opcode returns the request opcode for zwp_input_timestamps_manager_v1.destroy in input_timestamps_unstable_v1
func (ZwpInputTimestampsManagerV1DestroyRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for zwp_input_timestamps_manager_v1.destroy in input_timestamps_unstable_v1
func (ZwpInputTimestampsManagerV1DestroyRequest) MessageName() string { return "destroy" }

// Ensure ZwpInputTimestampsManagerV1DestroyRequest implements Message.
var _ Message = ZwpInputTimestampsManagerV1DestroyRequest{}

// Emit emits the message to the emitter.
func (r *ZwpInputTimestampsManagerV1DestroyRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure ZwpInputTimestampsManagerV1DestroyRequest implements Request.
var _ Request = &ZwpInputTimestampsManagerV1DestroyRequest{}

// ZwpInputTimestampsManagerV1GetKeyboardTimestampsRequest requests to subscribe to high-resolution keyboard timestamp events
//
// Creates a new input timestamps object that represents a subscription
// to high-resolution timestamp events for all wl_keyboard events that
// carry a timestamp.
//
// If the associated wl_keyboard object is invalidated, either through
// client action (e.g. release) or server-side changes, the input
// timestamps object becomes inert and the client should destroy it
// by calling zwp_input_timestamps_v1.destroy.
type ZwpInputTimestampsManagerV1GetKeyboardTimestampsRequest struct {
	ID ObjectID

	// Keyboard contains the wl_keyboard object for which to get timestamp events
	Keyboard ObjectID
}

// Opcode returns the request opcode for zwp_input_timestamps_manager_v1.get_keyboard_timestamps in input_timestamps_unstable_v1
func (ZwpInputTimestampsManagerV1GetKeyboardTimestampsRequest) Opcode() uint16 { return 1 }

// MessageName returns the request name for zwp_input_timestamps_manager_v1.get_keyboard_timestamps in input_timestamps_unstable_v1
func (ZwpInputTimestampsManagerV1GetKeyboardTimestampsRequest) MessageName() string {
	return "get_keyboard_timestamps"
}

// Ensure ZwpInputTimestampsManagerV1GetKeyboardTimestampsRequest implements Message.
var _ Message = ZwpInputTimestampsManagerV1GetKeyboardTimestampsRequest{}

// Emit emits the message to the emitter.
func (r *ZwpInputTimestampsManagerV1GetKeyboardTimestampsRequest) Emit(e *RequestEmitter) error {
	if err := e.PutObjectID(r.ID); err != nil {
		return err
	}
	if err := e.PutObjectID(r.Keyboard); err != nil {
		return err
	}
	return nil
}

// Ensure ZwpInputTimestampsManagerV1GetKeyboardTimestampsRequest implements Request.
var _ Request = &ZwpInputTimestampsManagerV1GetKeyboardTimestampsRequest{}

// ZwpInputTimestampsManagerV1GetPointerTimestampsRequest requests to subscribe to high-resolution pointer timestamp events
//
// Creates a new input timestamps object that represents a subscription
// to high-resolution timestamp events for all wl_pointer events that
// carry a timestamp.
//
// If the associated wl_pointer object is invalidated, either through
// client action (e.g. release) or server-side changes, the input
// timestamps object becomes inert and the client should destroy it
// by calling zwp_input_timestamps_v1.destroy.
type ZwpInputTimestampsManagerV1GetPointerTimestampsRequest struct {
	ID ObjectID

	// Pointer contains the wl_pointer object for which to get timestamp events
	Pointer ObjectID
}

// Opcode returns the request opcode for zwp_input_timestamps_manager_v1.get_pointer_timestamps in input_timestamps_unstable_v1
func (ZwpInputTimestampsManagerV1GetPointerTimestampsRequest) Opcode() uint16 { return 2 }

// MessageName returns the request name for zwp_input_timestamps_manager_v1.get_pointer_timestamps in input_timestamps_unstable_v1
func (ZwpInputTimestampsManagerV1GetPointerTimestampsRequest) MessageName() string {
	return "get_pointer_timestamps"
}

// Ensure ZwpInputTimestampsManagerV1GetPointerTimestampsRequest implements Message.
var _ Message = ZwpInputTimestampsManagerV1GetPointerTimestampsRequest{}

// Emit emits the message to the emitter.
func (r *ZwpInputTimestampsManagerV1GetPointerTimestampsRequest) Emit(e *RequestEmitter) error {
	if err := e.PutObjectID(r.ID); err != nil {
		return err
	}
	if err := e.PutObjectID(r.Pointer); err != nil {
		return err
	}
	return nil
}

// Ensure ZwpInputTimestampsManagerV1GetPointerTimestampsRequest implements Request.
var _ Request = &ZwpInputTimestampsManagerV1GetPointerTimestampsRequest{}

// ZwpInputTimestampsManagerV1GetTouchTimestampsRequest requests to subscribe to high-resolution touch timestamp events
//
// Creates a new input timestamps object that represents a subscription
// to high-resolution timestamp events for all wl_touch events that
// carry a timestamp.
//
// If the associated wl_touch object becomes invalid, either through
// client action (e.g. release) or server-side changes, the input
// timestamps object becomes inert and the client should destroy it
// by calling zwp_input_timestamps_v1.destroy.
type ZwpInputTimestampsManagerV1GetTouchTimestampsRequest struct {
	ID ObjectID

	// Touch contains the wl_touch object for which to get timestamp events
	Touch ObjectID
}

// Opcode returns the request opcode for zwp_input_timestamps_manager_v1.get_touch_timestamps in input_timestamps_unstable_v1
func (ZwpInputTimestampsManagerV1GetTouchTimestampsRequest) Opcode() uint16 { return 3 }

// MessageName returns the request name for zwp_input_timestamps_manager_v1.get_touch_timestamps in input_timestamps_unstable_v1
func (ZwpInputTimestampsManagerV1GetTouchTimestampsRequest) MessageName() string {
	return "get_touch_timestamps"
}

// Ensure ZwpInputTimestampsManagerV1GetTouchTimestampsRequest implements Message.
var _ Message = ZwpInputTimestampsManagerV1GetTouchTimestampsRequest{}

// Emit emits the message to the emitter.
func (r *ZwpInputTimestampsManagerV1GetTouchTimestampsRequest) Emit(e *RequestEmitter) error {
	if err := e.PutObjectID(r.ID); err != nil {
		return err
	}
	if err := e.PutObjectID(r.Touch); err != nil {
		return err
	}
	return nil
}

// Ensure ZwpInputTimestampsManagerV1GetTouchTimestampsRequest implements Request.
var _ Request = &ZwpInputTimestampsManagerV1GetTouchTimestampsRequest{}

// ZwpInputTimestampsManagerV1 context object for high-resolution input timestamps
//
// A global interface used for requesting high-resolution timestamps
// for input events.
type ZwpInputTimestampsManagerV1 struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *ZwpInputTimestampsManagerV1) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (ZwpInputTimestampsManagerV1) Descriptor() *InterfaceDescriptor {
	return &ZwpInputTimestampsManagerV1Descriptor
}

// Dispatch returns an Event object for a given opcode.
func (ZwpInputTimestampsManagerV1) Dispatch(opcode uint16) Event {
	switch opcode {
	default:
		return nil
	}
}

// Destroy requests to destroy the input timestamps manager object
//
// Informs the server that the client will no longer be using this
// protocol object. Existing objects created by this object are not
// affected.
func (proxy *ZwpInputTimestampsManagerV1) Destroy(connection Connection) (err error) {
	request := ZwpInputTimestampsManagerV1DestroyRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// GetKeyboardTimestamps requests to subscribe to high-resolution keyboard timestamp events
//
// Creates a new input timestamps object that represents a subscription
// to high-resolution timestamp events for all wl_keyboard events that
// carry a timestamp.
//
// If the associated wl_keyboard object is invalidated, either through
// client action (e.g. release) or server-side changes, the input
// timestamps object becomes inert and the client should destroy it
// by calling zwp_input_timestamps_v1.destroy.
func (proxy *ZwpInputTimestampsManagerV1) GetKeyboardTimestamps(connection Connection, aKeyboard ObjectID) (aID *ZwpInputTimestampsV1, err error) {
	aID = &ZwpInputTimestampsV1{connection.NewID()}
	request := ZwpInputTimestampsManagerV1GetKeyboardTimestampsRequest{
		ID:       aID.id,
		Keyboard: aKeyboard,
	}
	err = connection.SendRequest(proxy.id, &request)
	if err == nil {
		connection.RegisterProxy(aID)
	}
	return
}

// GetPointerTimestamps requests to subscribe to high-resolution pointer timestamp events
//
// Creates a new input timestamps object that represents a subscription
// to high-resolution timestamp events for all wl_pointer events that
// carry a timestamp.
//
// If the associated wl_pointer object is invalidated, either through
// client action (e.g. release) or server-side changes, the input
// timestamps object becomes inert and the client should destroy it
// by calling zwp_input_timestamps_v1.destroy.
func (proxy *ZwpInputTimestampsManagerV1) GetPointerTimestamps(connection Connection, aPointer ObjectID) (aID *ZwpInputTimestampsV1, err error) {
	aID = &ZwpInputTimestampsV1{connection.NewID()}
	request := ZwpInputTimestampsManagerV1GetPointerTimestampsRequest{
		ID:      aID.id,
		Pointer: aPointer,
	}
	err = connection.SendRequest(proxy.id, &request)
	if err == nil {
		connection.RegisterProxy(aID)
	}
	return
}

// GetTouchTimestamps requests to subscribe to high-resolution touch timestamp events
//
// Creates a new input timestamps object that represents a subscription
// to high-resolution timestamp events for all wl_touch events that
// carry a timestamp.
//
// If the associated wl_touch object becomes invalid, either through
// client action (e.g. release) or server-side changes, the input
// timestamps object becomes inert and the client should destroy it
// by calling zwp_input_timestamps_v1.destroy.
func (proxy *ZwpInputTimestampsManagerV1) GetTouchTimestamps(connection Connection, aTouch ObjectID) (aID *ZwpInputTimestampsV1, err error) {
	aID = &ZwpInputTimestampsV1{connection.NewID()}
	request := ZwpInputTimestampsManagerV1GetTouchTimestampsRequest{
		ID:    aID.id,
		Touch: aTouch,
	}
	err = connection.SendRequest(proxy.id, &request)
	if err == nil {
		connection.RegisterProxy(aID)
	}
	return
}

// Ensure ZwpInputTimestampsManagerV1 implements Proxy.
var _ Proxy = &ZwpInputTimestampsManagerV1{}

// #endregion Interface input_timestamps_unstable_v1.zwp_input_timestamps_manager_v1

// ----------------------------------------------------------------------------
// #region Interface input_timestamps_unstable_v1.zwp_input_timestamps_v1

// ZwpInputTimestampsV1DestroyRequest requests to destroy the input timestamps object
//
// Informs the server that the client will no longer be using this
// protocol object. After the server processes the request, no more
// timestamp events will be emitted.
type ZwpInputTimestampsV1DestroyRequest struct {
}

// Opcode returns the request opcode for zwp_input_timestamps_v1.destroy in input_timestamps_unstable_v1
func (ZwpInputTimestampsV1DestroyRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for zwp_input_timestamps_v1.destroy in input_timestamps_unstable_v1
func (ZwpInputTimestampsV1DestroyRequest) MessageName() string { return "destroy" }

// Ensure ZwpInputTimestampsV1DestroyRequest implements Message.
var _ Message = ZwpInputTimestampsV1DestroyRequest{}

// Emit emits the message to the emitter.
func (r *ZwpInputTimestampsV1DestroyRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure ZwpInputTimestampsV1DestroyRequest implements Request.
var _ Request = &ZwpInputTimestampsV1DestroyRequest{}

// ZwpInputTimestampsV1TimestampEvent signals when high-resolution timestamp event
//
// The timestamp event is associated with the first subsequent input event
// carrying a timestamp which belongs to the set of input events this
// object is subscribed to.
//
// The timestamp provided by this event is a high-resolution version of
// the timestamp argument of the associated input event. The provided
// timestamp is in the same clock domain and is at least as accurate as
// the associated input event timestamp.
//
// The timestamp is expressed as tv_sec_hi, tv_sec_lo, tv_nsec triples,
// each component being an unsigned 32-bit value. Whole seconds are in
// tv_sec which is a 64-bit value combined from tv_sec_hi and tv_sec_lo,
// and the additional fractional part in tv_nsec as nanoseconds. Hence,
// for valid timestamps tv_nsec must be in [0, 999999999].
type ZwpInputTimestampsV1TimestampEvent struct {
	// TvSecHi contains high 32 bits of the seconds part of the timestamp
	TvSecHi uint32

	// TvSecLo contains low 32 bits of the seconds part of the timestamp
	TvSecLo uint32

	// TvNsec contains nanoseconds part of the timestamp
	TvNsec uint32
}

// Opcode returns the event opcode for zwp_input_timestamps_v1.timestamp in input_timestamps_unstable_v1
func (ZwpInputTimestampsV1TimestampEvent) Opcode() uint16 { return 0 }

// MessageName returns the event name for zwp_input_timestamps_v1.timestamp in input_timestamps_unstable_v1
func (ZwpInputTimestampsV1TimestampEvent) MessageName() string { return "timestamp" }

// Ensure ZwpInputTimestampsV1TimestampEvent implements Message.
var _ Message = ZwpInputTimestampsV1TimestampEvent{}

// Scan scans the event from the socket.
func (e *ZwpInputTimestampsV1TimestampEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.TvSecHi = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.TvSecLo = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.TvNsec = v
	}
	return nil
}

// Ensure ZwpInputTimestampsV1TimestampEvent implements Event.
var _ Event = &ZwpInputTimestampsV1TimestampEvent{}

// ZwpInputTimestampsV1 context object for input timestamps
//
// Provides high-resolution timestamp events for a set of subscribed input
// events. The set of subscribed input events is determined by the
// zwp_input_timestamps_manager_v1 request used to create this object.
type ZwpInputTimestampsV1 struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *ZwpInputTimestampsV1) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (ZwpInputTimestampsV1) Descriptor() *InterfaceDescriptor {
	return &ZwpInputTimestampsV1Descriptor
}

// Dispatch returns an Event object for a given opcode.
func (ZwpInputTimestampsV1) Dispatch(opcode uint16) Event {
	switch opcode {
	case 0:
		return &ZwpInputTimestampsV1TimestampEvent{}
	default:
		return nil
	}
}

// Destroy requests to destroy the input timestamps object
//
// Informs the server that the client will no longer be using this
// protocol object. After the server processes the request, no more
// timestamp events will be emitted.
func (proxy *ZwpInputTimestampsV1) Destroy(connection Connection) (err error) {
	request := ZwpInputTimestampsV1DestroyRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Ensure ZwpInputTimestampsV1 implements Proxy.
var _ Proxy = &ZwpInputTimestampsV1{}

// #endregion Interface input_timestamps_unstable_v1.zwp_input_timestamps_v1

////////////////////////////////////////////////////////////////////////////////
// #endregion Protocol input_timestamps_unstable_v1

////////////////////////////////////////////////////////////////////////////////
// #region Protocol keyboard_shortcuts_inhibit_unstable_v1

// ----------------------------------------------------------------------------
// #region Interface keyboard_shortcuts_inhibit_unstable_v1.zwp_keyboard_shortcuts_inhibit_manager_v1

type ZwpKeyboardShortcutsInhibitManagerV1Error int

const (
	// ZwpKeyboardShortcutsInhibitManagerV1ErrorAlreadyInhibited corresponds to the shortcuts are already inhibited for this surface
	ZwpKeyboardShortcutsInhibitManagerV1ErrorAlreadyInhibited ZwpKeyboardShortcutsInhibitManagerV1Error = 0
)

// ZwpKeyboardShortcutsInhibitManagerV1DestroyRequest requests to destroy the keyboard shortcuts inhibitor object
//
// Destroy the keyboard shortcuts inhibitor manager.
type ZwpKeyboardShortcutsInhibitManagerV1DestroyRequest struct {
}

// Opcode returns the request opcode for zwp_keyboard_shortcuts_inhibit_manager_v1.destroy in keyboard_shortcuts_inhibit_unstable_v1
func (ZwpKeyboardShortcutsInhibitManagerV1DestroyRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for zwp_keyboard_shortcuts_inhibit_manager_v1.destroy in keyboard_shortcuts_inhibit_unstable_v1
func (ZwpKeyboardShortcutsInhibitManagerV1DestroyRequest) MessageName() string { return "destroy" }

// Ensure ZwpKeyboardShortcutsInhibitManagerV1DestroyRequest implements Message.
var _ Message = ZwpKeyboardShortcutsInhibitManagerV1DestroyRequest{}

// Emit emits the message to the emitter.
func (r *ZwpKeyboardShortcutsInhibitManagerV1DestroyRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure ZwpKeyboardShortcutsInhibitManagerV1DestroyRequest implements Request.
var _ Request = &ZwpKeyboardShortcutsInhibitManagerV1DestroyRequest{}

// ZwpKeyboardShortcutsInhibitManagerV1InhibitShortcutsRequest requests to create a new keyboard shortcuts inhibitor object
//
// Create a new keyboard shortcuts inhibitor object associated with
// the given surface for the given seat.
//
// If shortcuts are already inhibited for the specified seat and surface,
// a protocol error "already_inhibited" is raised by the compositor.
type ZwpKeyboardShortcutsInhibitManagerV1InhibitShortcutsRequest struct {
	ID ObjectID

	// Surface contains the surface that inhibits the keyboard shortcuts behavior
	Surface ObjectID

	// Seat contains the wl_seat for which keyboard shortcuts should be disabled
	Seat ObjectID
}

// Opcode returns the request opcode for zwp_keyboard_shortcuts_inhibit_manager_v1.inhibit_shortcuts in keyboard_shortcuts_inhibit_unstable_v1
func (ZwpKeyboardShortcutsInhibitManagerV1InhibitShortcutsRequest) Opcode() uint16 { return 1 }

// MessageName returns the request name for zwp_keyboard_shortcuts_inhibit_manager_v1.inhibit_shortcuts in keyboard_shortcuts_inhibit_unstable_v1
func (ZwpKeyboardShortcutsInhibitManagerV1InhibitShortcutsRequest) MessageName() string {
	return "inhibit_shortcuts"
}

// Ensure ZwpKeyboardShortcutsInhibitManagerV1InhibitShortcutsRequest implements Message.
var _ Message = ZwpKeyboardShortcutsInhibitManagerV1InhibitShortcutsRequest{}

// Emit emits the message to the emitter.
func (r *ZwpKeyboardShortcutsInhibitManagerV1InhibitShortcutsRequest) Emit(e *RequestEmitter) error {
	if err := e.PutObjectID(r.ID); err != nil {
		return err
	}
	if err := e.PutObjectID(r.Surface); err != nil {
		return err
	}
	if err := e.PutObjectID(r.Seat); err != nil {
		return err
	}
	return nil
}

// Ensure ZwpKeyboardShortcutsInhibitManagerV1InhibitShortcutsRequest implements Request.
var _ Request = &ZwpKeyboardShortcutsInhibitManagerV1InhibitShortcutsRequest{}

// ZwpKeyboardShortcutsInhibitManagerV1 context object for keyboard grab_manager
//
// A global interface used for inhibiting the compositor keyboard shortcuts.
type ZwpKeyboardShortcutsInhibitManagerV1 struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *ZwpKeyboardShortcutsInhibitManagerV1) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (ZwpKeyboardShortcutsInhibitManagerV1) Descriptor() *InterfaceDescriptor {
	return &ZwpKeyboardShortcutsInhibitManagerV1Descriptor
}

// Dispatch returns an Event object for a given opcode.
func (ZwpKeyboardShortcutsInhibitManagerV1) Dispatch(opcode uint16) Event {
	switch opcode {
	default:
		return nil
	}
}

// Destroy requests to destroy the keyboard shortcuts inhibitor object
//
// Destroy the keyboard shortcuts inhibitor manager.
func (proxy *ZwpKeyboardShortcutsInhibitManagerV1) Destroy(connection Connection) (err error) {
	request := ZwpKeyboardShortcutsInhibitManagerV1DestroyRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// InhibitShortcuts requests to create a new keyboard shortcuts inhibitor object
//
// Create a new keyboard shortcuts inhibitor object associated with
// the given surface for the given seat.
//
// If shortcuts are already inhibited for the specified seat and surface,
// a protocol error "already_inhibited" is raised by the compositor.
func (proxy *ZwpKeyboardShortcutsInhibitManagerV1) InhibitShortcuts(connection Connection, aSurface ObjectID, aSeat ObjectID) (aID *ZwpKeyboardShortcutsInhibitorV1, err error) {
	aID = &ZwpKeyboardShortcutsInhibitorV1{connection.NewID()}
	request := ZwpKeyboardShortcutsInhibitManagerV1InhibitShortcutsRequest{
		ID:      aID.id,
		Surface: aSurface,
		Seat:    aSeat,
	}
	err = connection.SendRequest(proxy.id, &request)
	if err == nil {
		connection.RegisterProxy(aID)
	}
	return
}

// Ensure ZwpKeyboardShortcutsInhibitManagerV1 implements Proxy.
var _ Proxy = &ZwpKeyboardShortcutsInhibitManagerV1{}

// #endregion Interface keyboard_shortcuts_inhibit_unstable_v1.zwp_keyboard_shortcuts_inhibit_manager_v1

// ----------------------------------------------------------------------------
// #region Interface keyboard_shortcuts_inhibit_unstable_v1.zwp_keyboard_shortcuts_inhibitor_v1

// ZwpKeyboardShortcutsInhibitorV1DestroyRequest requests to destroy the keyboard shortcuts inhibitor object
//
// Remove the keyboard shortcuts inhibitor from the associated wl_surface.
type ZwpKeyboardShortcutsInhibitorV1DestroyRequest struct {
}

// Opcode returns the request opcode for zwp_keyboard_shortcuts_inhibitor_v1.destroy in keyboard_shortcuts_inhibit_unstable_v1
func (ZwpKeyboardShortcutsInhibitorV1DestroyRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for zwp_keyboard_shortcuts_inhibitor_v1.destroy in keyboard_shortcuts_inhibit_unstable_v1
func (ZwpKeyboardShortcutsInhibitorV1DestroyRequest) MessageName() string { return "destroy" }

// Ensure ZwpKeyboardShortcutsInhibitorV1DestroyRequest implements Message.
var _ Message = ZwpKeyboardShortcutsInhibitorV1DestroyRequest{}

// Emit emits the message to the emitter.
func (r *ZwpKeyboardShortcutsInhibitorV1DestroyRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure ZwpKeyboardShortcutsInhibitorV1DestroyRequest implements Request.
var _ Request = &ZwpKeyboardShortcutsInhibitorV1DestroyRequest{}

// ZwpKeyboardShortcutsInhibitorV1ActiveEvent signals when shortcuts are inhibited
//
// This event indicates that the shortcut inhibitor is active.
//
// The compositor sends this event every time compositor shortcuts
// are inhibited on behalf of the surface. When active, the client
// may receive input events normally reserved by the compositor
// (see zwp_keyboard_shortcuts_inhibitor_v1).
//
// This occurs typically when the initial request "inhibit_shortcuts"
// first becomes active or when the user instructs the compositor to
// re-enable and existing shortcuts inhibitor using any mechanism
// offered by the compositor.
type ZwpKeyboardShortcutsInhibitorV1ActiveEvent struct {
}

// Opcode returns the event opcode for zwp_keyboard_shortcuts_inhibitor_v1.active in keyboard_shortcuts_inhibit_unstable_v1
func (ZwpKeyboardShortcutsInhibitorV1ActiveEvent) Opcode() uint16 { return 0 }

// MessageName returns the event name for zwp_keyboard_shortcuts_inhibitor_v1.active in keyboard_shortcuts_inhibit_unstable_v1
func (ZwpKeyboardShortcutsInhibitorV1ActiveEvent) MessageName() string { return "active" }

// Ensure ZwpKeyboardShortcutsInhibitorV1ActiveEvent implements Message.
var _ Message = ZwpKeyboardShortcutsInhibitorV1ActiveEvent{}

// Scan scans the event from the socket.
func (e *ZwpKeyboardShortcutsInhibitorV1ActiveEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure ZwpKeyboardShortcutsInhibitorV1ActiveEvent implements Event.
var _ Event = &ZwpKeyboardShortcutsInhibitorV1ActiveEvent{}

// ZwpKeyboardShortcutsInhibitorV1InactiveEvent signals when shortcuts are restored
//
// This event indicates that the shortcuts inhibitor is inactive,
// normal shortcuts processing is restored by the compositor.
type ZwpKeyboardShortcutsInhibitorV1InactiveEvent struct {
}

// Opcode returns the event opcode for zwp_keyboard_shortcuts_inhibitor_v1.inactive in keyboard_shortcuts_inhibit_unstable_v1
func (ZwpKeyboardShortcutsInhibitorV1InactiveEvent) Opcode() uint16 { return 1 }

// MessageName returns the event name for zwp_keyboard_shortcuts_inhibitor_v1.inactive in keyboard_shortcuts_inhibit_unstable_v1
func (ZwpKeyboardShortcutsInhibitorV1InactiveEvent) MessageName() string { return "inactive" }

// Ensure ZwpKeyboardShortcutsInhibitorV1InactiveEvent implements Message.
var _ Message = ZwpKeyboardShortcutsInhibitorV1InactiveEvent{}

// Scan scans the event from the socket.
func (e *ZwpKeyboardShortcutsInhibitorV1InactiveEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure ZwpKeyboardShortcutsInhibitorV1InactiveEvent implements Event.
var _ Event = &ZwpKeyboardShortcutsInhibitorV1InactiveEvent{}

// ZwpKeyboardShortcutsInhibitorV1 context object for keyboard shortcuts inhibitor
//
// A keyboard shortcuts inhibitor instructs the compositor to ignore
// its own keyboard shortcuts when the associated surface has keyboard
// focus. As a result, when the surface has keyboard focus on the given
// seat, it will receive all key events originating from the specified
// seat, even those which would normally be caught by the compositor for
// its own shortcuts.
//
// The Wayland compositor is however under no obligation to disable
// all of its shortcuts, and may keep some special key combo for its own
// use, including but not limited to one allowing the user to forcibly
// restore normal keyboard events routing in the case of an unwilling
// client. The compositor may also use the same key combo to reactivate
// an existing shortcut inhibitor that was previously deactivated on
// user request.
//
// When the compositor restores its own keyboard shortcuts, an
// "inactive" event is emitted to notify the client that the keyboard
// shortcuts inhibitor is not effectively active for the surface and
// seat any more, and the client should not expect to receive all
// keyboard events.
//
// When the keyboard shortcuts inhibitor is inactive, the client has
// no way to forcibly reactivate the keyboard shortcuts inhibitor.
//
// The user can chose to re-enable a previously deactivated keyboard
// shortcuts inhibitor using any mechanism the compositor may offer,
// in which case the compositor will send an "active" event to notify
// the client.
//
// If the surface is destroyed, unmapped, or loses the seat's keyboard
// focus, the keyboard shortcuts inhibitor becomes irrelevant and the
// compositor will restore its own keyboard shortcuts but no "inactive"
// event is emitted in this case.
type ZwpKeyboardShortcutsInhibitorV1 struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *ZwpKeyboardShortcutsInhibitorV1) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (ZwpKeyboardShortcutsInhibitorV1) Descriptor() *InterfaceDescriptor {
	return &ZwpKeyboardShortcutsInhibitorV1Descriptor
}

// Dispatch returns an Event object for a given opcode.
func (ZwpKeyboardShortcutsInhibitorV1) Dispatch(opcode uint16) Event {
	switch opcode {
	case 0:
		return &ZwpKeyboardShortcutsInhibitorV1ActiveEvent{}
	case 1:
		return &ZwpKeyboardShortcutsInhibitorV1InactiveEvent{}
	default:
		return nil
	}
}

// Destroy requests to destroy the keyboard shortcuts inhibitor object
//
// Remove the keyboard shortcuts inhibitor from the associated wl_surface.
func (proxy *ZwpKeyboardShortcutsInhibitorV1) Destroy(connection Connection) (err error) {
	request := ZwpKeyboardShortcutsInhibitorV1DestroyRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Ensure ZwpKeyboardShortcutsInhibitorV1 implements Proxy.
var _ Proxy = &ZwpKeyboardShortcutsInhibitorV1{}

// #endregion Interface keyboard_shortcuts_inhibit_unstable_v1.zwp_keyboard_shortcuts_inhibitor_v1

////////////////////////////////////////////////////////////////////////////////
// #endregion Protocol keyboard_shortcuts_inhibit_unstable_v1

////////////////////////////////////////////////////////////////////////////////
// #region Protocol linux_dmabuf_unstable_v1

// ----------------------------------------------------------------------------
// #region Interface linux_dmabuf_unstable_v1.zwp_linux_dmabuf_v1

// ZwpLinuxDmabufV1DestroyRequest requests to unbind the factory
//
// Objects created through this interface, especially wl_buffers, will
// remain valid.
type ZwpLinuxDmabufV1DestroyRequest struct {
}

// Opcode returns the request opcode for zwp_linux_dmabuf_v1.destroy in linux_dmabuf_unstable_v1
func (ZwpLinuxDmabufV1DestroyRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for zwp_linux_dmabuf_v1.destroy in linux_dmabuf_unstable_v1
func (ZwpLinuxDmabufV1DestroyRequest) MessageName() string { return "destroy" }

// Ensure ZwpLinuxDmabufV1DestroyRequest implements Message.
var _ Message = ZwpLinuxDmabufV1DestroyRequest{}

// Emit emits the message to the emitter.
func (r *ZwpLinuxDmabufV1DestroyRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure ZwpLinuxDmabufV1DestroyRequest implements Request.
var _ Request = &ZwpLinuxDmabufV1DestroyRequest{}

// ZwpLinuxDmabufV1CreateParamsRequest requests to create a temporary object for buffer parameters
//
// This temporary object is used to collect multiple dmabuf handles into
// a single batch to create a wl_buffer. It can only be used once and
// should be destroyed after a 'created' or 'failed' event has been
// received.
type ZwpLinuxDmabufV1CreateParamsRequest struct {
	// ParamsID contains the new temporary
	ParamsID ObjectID
}

// Opcode returns the request opcode for zwp_linux_dmabuf_v1.create_params in linux_dmabuf_unstable_v1
func (ZwpLinuxDmabufV1CreateParamsRequest) Opcode() uint16 { return 1 }

// MessageName returns the request name for zwp_linux_dmabuf_v1.create_params in linux_dmabuf_unstable_v1
func (ZwpLinuxDmabufV1CreateParamsRequest) MessageName() string { return "create_params" }

// Ensure ZwpLinuxDmabufV1CreateParamsRequest implements Message.
var _ Message = ZwpLinuxDmabufV1CreateParamsRequest{}

// Emit emits the message to the emitter.
func (r *ZwpLinuxDmabufV1CreateParamsRequest) Emit(e *RequestEmitter) error {
	if err := e.PutObjectID(r.ParamsID); err != nil {
		return err
	}
	return nil
}

// Ensure ZwpLinuxDmabufV1CreateParamsRequest implements Request.
var _ Request = &ZwpLinuxDmabufV1CreateParamsRequest{}

// ZwpLinuxDmabufV1FormatEvent signals when supported buffer format
//
// This event advertises one buffer format that the server supports.
// All the supported formats are advertised once when the client
// binds to this interface. A roundtrip after binding guarantees
// that the client has received all supported formats.
//
// For the definition of the format codes, see the
// zwp_linux_buffer_params_v1::create request.
//
// Warning: the 'format' event is likely to be deprecated and replaced
// with the 'modifier' event introduced in zwp_linux_dmabuf_v1
// version 3, described below. Please refrain from using the information
// received from this event.
type ZwpLinuxDmabufV1FormatEvent struct {
	// Format contains DRM_FORMAT code
	Format uint32
}

// Opcode returns the event opcode for zwp_linux_dmabuf_v1.format in linux_dmabuf_unstable_v1
func (ZwpLinuxDmabufV1FormatEvent) Opcode() uint16 { return 0 }

// MessageName returns the event name for zwp_linux_dmabuf_v1.format in linux_dmabuf_unstable_v1
func (ZwpLinuxDmabufV1FormatEvent) MessageName() string { return "format" }

// Ensure ZwpLinuxDmabufV1FormatEvent implements Message.
var _ Message = ZwpLinuxDmabufV1FormatEvent{}

// Scan scans the event from the socket.
func (e *ZwpLinuxDmabufV1FormatEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Format = v
	}
	return nil
}

// Ensure ZwpLinuxDmabufV1FormatEvent implements Event.
var _ Event = &ZwpLinuxDmabufV1FormatEvent{}

// ZwpLinuxDmabufV1ModifierEvent signals when supported buffer format modifier
//
// This event advertises the formats that the server supports, along with
// the modifiers supported for each format. All the supported modifiers
// for all the supported formats are advertised once when the client
// binds to this interface. A roundtrip after binding guarantees that
// the client has received all supported format-modifier pairs.
//
// For legacy support, DRM_FORMAT_MOD_INVALID (that is, modifier_hi ==
// 0x00ffffff and modifier_lo == 0xffffffff) is allowed in this event.
// It indicates that the server can support the format with an implicit
// modifier. When a plane has DRM_FORMAT_MOD_INVALID as its modifier, it
// is as if no explicit modifier is specified. The effective modifier
// will be derived from the dmabuf.
//
// A compositor that sends valid modifiers and DRM_FORMAT_MOD_INVALID for
// a given format supports both explicit modifiers and implicit modifiers.
//
// For the definition of the format and modifier codes, see the
// zwp_linux_buffer_params_v1::create and zwp_linux_buffer_params_v1::add
// requests.
type ZwpLinuxDmabufV1ModifierEvent struct {
	// Format contains DRM_FORMAT code
	Format uint32

	// ModifierHi contains high 32 bits of layout modifier
	ModifierHi uint32

	// ModifierLo contains low 32 bits of layout modifier
	ModifierLo uint32
}

// Opcode returns the event opcode for zwp_linux_dmabuf_v1.modifier in linux_dmabuf_unstable_v1
func (ZwpLinuxDmabufV1ModifierEvent) Opcode() uint16 { return 1 }

// MessageName returns the event name for zwp_linux_dmabuf_v1.modifier in linux_dmabuf_unstable_v1
func (ZwpLinuxDmabufV1ModifierEvent) MessageName() string { return "modifier" }

// Ensure ZwpLinuxDmabufV1ModifierEvent implements Message.
var _ Message = ZwpLinuxDmabufV1ModifierEvent{}

// Scan scans the event from the socket.
func (e *ZwpLinuxDmabufV1ModifierEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Format = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.ModifierHi = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.ModifierLo = v
	}
	return nil
}

// Ensure ZwpLinuxDmabufV1ModifierEvent implements Event.
var _ Event = &ZwpLinuxDmabufV1ModifierEvent{}

// ZwpLinuxDmabufV1 factory for creating dmabuf-based wl_buffers
//
// Following the interfaces from:
// https://www.khronos.org/registry/egl/extensions/EXT/EGL_EXT_image_dma_buf_import.txt
// https://www.khronos.org/registry/EGL/extensions/EXT/EGL_EXT_image_dma_buf_import_modifiers.txt
// and the Linux DRM sub-system's AddFb2 ioctl.
//
// This interface offers ways to create generic dmabuf-based
// wl_buffers. Immediately after a client binds to this interface,
// the set of supported formats and format modifiers is sent with
// 'format' and 'modifier' events.
//
// The following are required from clients:
//
// - Clients must ensure that either all data in the dma-buf is
// coherent for all subsequent read access or that coherency is
// correctly handled by the underlying kernel-side dma-buf
// implementation.
//
// - Don't make any more attachments after sending the buffer to the
// compositor. Making more attachments later increases the risk of
// the compositor not being able to use (re-import) an existing
// dmabuf-based wl_buffer.
//
// The underlying graphics stack must ensure the following:
//
// - The dmabuf file descriptors relayed to the server will stay valid
// for the whole lifetime of the wl_buffer. This means the server may
// at any time use those fds to import the dmabuf into any kernel
// sub-system that might accept it.
//
// However, when the underlying graphics stack fails to deliver the
// promise, because of e.g. a device hot-unplug which raises internal
// errors, after the wl_buffer has been successfully created the
// compositor must not raise protocol errors to the client when dmabuf
// import later fails.
//
// To create a wl_buffer from one or more dmabufs, a client creates a
// zwp_linux_dmabuf_params_v1 object with a zwp_linux_dmabuf_v1.create_params
// request. All planes required by the intended format are added with
// the 'add' request. Finally, a 'create' or 'create_immed' request is
// issued, which has the following outcome depending on the import success.
//
// The 'create' request,
// - on success, triggers a 'created' event which provides the final
// wl_buffer to the client.
// - on failure, triggers a 'failed' event to convey that the server
// cannot use the dmabufs received from the client.
//
// For the 'create_immed' request,
// - on success, the server immediately imports the added dmabufs to
// create a wl_buffer. No event is sent from the server in this case.
// - on failure, the server can choose to either:
// - terminate the client by raising a fatal error.
// - mark the wl_buffer as failed, and send a 'failed' event to the
// client. If the client uses a failed wl_buffer as an argument to any
// request, the behaviour is compositor implementation-defined.
//
// Warning! The protocol described in this file is experimental and
// backward incompatible changes may be made. Backward compatible changes
// may be added together with the corresponding interface version bump.
// Backward incompatible changes are done by bumping the version number in
// the protocol and interface names and resetting the interface version.
// Once the protocol is to be declared stable, the 'z' prefix and the
// version number in the protocol and interface names are removed and the
// interface version number is reset.
type ZwpLinuxDmabufV1 struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *ZwpLinuxDmabufV1) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (ZwpLinuxDmabufV1) Descriptor() *InterfaceDescriptor {
	return &ZwpLinuxDmabufV1Descriptor
}

// Dispatch returns an Event object for a given opcode.
func (ZwpLinuxDmabufV1) Dispatch(opcode uint16) Event {
	switch opcode {
	case 0:
		return &ZwpLinuxDmabufV1FormatEvent{}
	case 1:
		return &ZwpLinuxDmabufV1ModifierEvent{}
	default:
		return nil
	}
}

// Destroy requests to unbind the factory
//
// Objects created through this interface, especially wl_buffers, will
// remain valid.
func (proxy *ZwpLinuxDmabufV1) Destroy(connection Connection) (err error) {
	request := ZwpLinuxDmabufV1DestroyRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// CreateParams requests to create a temporary object for buffer parameters
//
// This temporary object is used to collect multiple dmabuf handles into
// a single batch to create a wl_buffer. It can only be used once and
// should be destroyed after a 'created' or 'failed' event has been
// received.
func (proxy *ZwpLinuxDmabufV1) CreateParams(connection Connection) (aParamsID *ZwpLinuxBufferParamsV1, err error) {
	aParamsID = &ZwpLinuxBufferParamsV1{connection.NewID()}
	request := ZwpLinuxDmabufV1CreateParamsRequest{
		ParamsID: aParamsID.id,
	}
	err = connection.SendRequest(proxy.id, &request)
	if err == nil {
		connection.RegisterProxy(aParamsID)
	}
	return
}

// Ensure ZwpLinuxDmabufV1 implements Proxy.
var _ Proxy = &ZwpLinuxDmabufV1{}

// #endregion Interface linux_dmabuf_unstable_v1.zwp_linux_dmabuf_v1

// ----------------------------------------------------------------------------
// #region Interface linux_dmabuf_unstable_v1.zwp_linux_buffer_params_v1

type ZwpLinuxBufferParamsV1Error int

const (
	// ZwpLinuxBufferParamsV1ErrorAlreadyUsed corresponds to the dmabuf_batch object has already been used to create a wl_buffer
	ZwpLinuxBufferParamsV1ErrorAlreadyUsed ZwpLinuxBufferParamsV1Error = 0

	// ZwpLinuxBufferParamsV1ErrorPlaneIdx corresponds to plane index out of bounds
	ZwpLinuxBufferParamsV1ErrorPlaneIdx ZwpLinuxBufferParamsV1Error = 1

	// ZwpLinuxBufferParamsV1ErrorPlaneSet corresponds to the plane index was already set
	ZwpLinuxBufferParamsV1ErrorPlaneSet ZwpLinuxBufferParamsV1Error = 2

	// ZwpLinuxBufferParamsV1ErrorIncomplete corresponds to missing or too many planes to create a buffer
	ZwpLinuxBufferParamsV1ErrorIncomplete ZwpLinuxBufferParamsV1Error = 3

	// ZwpLinuxBufferParamsV1ErrorInvalidFormat corresponds to format not supported
	ZwpLinuxBufferParamsV1ErrorInvalidFormat ZwpLinuxBufferParamsV1Error = 4

	// ZwpLinuxBufferParamsV1ErrorInvalidDimensions corresponds to invalid width or height
	ZwpLinuxBufferParamsV1ErrorInvalidDimensions ZwpLinuxBufferParamsV1Error = 5

	// ZwpLinuxBufferParamsV1ErrorOutOfBounds corresponds to offset + stride * height goes out of dmabuf bounds
	ZwpLinuxBufferParamsV1ErrorOutOfBounds ZwpLinuxBufferParamsV1Error = 6

	// ZwpLinuxBufferParamsV1ErrorInvalidWlBuffer corresponds to invalid wl_buffer resulted from importing dmabufs via the create_immed request on given buffer_params
	ZwpLinuxBufferParamsV1ErrorInvalidWlBuffer ZwpLinuxBufferParamsV1Error = 7
)

type ZwpLinuxBufferParamsV1Flags uint

const (
	// ZwpLinuxBufferParamsV1FlagsYInvert corresponds to contents are y-inverted
	ZwpLinuxBufferParamsV1FlagsYInvert ZwpLinuxBufferParamsV1Flags = 1

	// ZwpLinuxBufferParamsV1FlagsInterlaced corresponds to content is interlaced
	ZwpLinuxBufferParamsV1FlagsInterlaced ZwpLinuxBufferParamsV1Flags = 2

	// ZwpLinuxBufferParamsV1FlagsBottomFirst corresponds to bottom field first
	ZwpLinuxBufferParamsV1FlagsBottomFirst ZwpLinuxBufferParamsV1Flags = 4
)

// ZwpLinuxBufferParamsV1DestroyRequest requests to delete this object, used or not
//
// Cleans up the temporary data sent to the server for dmabuf-based
// wl_buffer creation.
type ZwpLinuxBufferParamsV1DestroyRequest struct {
}

// Opcode returns the request opcode for zwp_linux_buffer_params_v1.destroy in linux_dmabuf_unstable_v1
func (ZwpLinuxBufferParamsV1DestroyRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for zwp_linux_buffer_params_v1.destroy in linux_dmabuf_unstable_v1
func (ZwpLinuxBufferParamsV1DestroyRequest) MessageName() string { return "destroy" }

// Ensure ZwpLinuxBufferParamsV1DestroyRequest implements Message.
var _ Message = ZwpLinuxBufferParamsV1DestroyRequest{}

// Emit emits the message to the emitter.
func (r *ZwpLinuxBufferParamsV1DestroyRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure ZwpLinuxBufferParamsV1DestroyRequest implements Request.
var _ Request = &ZwpLinuxBufferParamsV1DestroyRequest{}

// ZwpLinuxBufferParamsV1AddRequest requests to add a dmabuf to the temporary set
//
// This request adds one dmabuf to the set in this
// zwp_linux_buffer_params_v1.
//
// The 64-bit unsigned value combined from modifier_hi and modifier_lo
// is the dmabuf layout modifier. DRM AddFB2 ioctl calls this the
// fb modifier, which is defined in drm_mode.h of Linux UAPI.
// This is an opaque token. Drivers use this token to express tiling,
// compression, etc. driver-specific modifications to the base format
// defined by the DRM fourcc code.
//
// Warning: It should be an error if the format/modifier pair was not
// advertised with the modifier event. This is not enforced yet because
// some implementations always accept DRM_FORMAT_MOD_INVALID. Also
// version 2 of this protocol does not have the modifier event.
//
// This request raises the PLANE_IDX error if plane_idx is too large.
// The error PLANE_SET is raised if attempting to set a plane that
// was already set.
type ZwpLinuxBufferParamsV1AddRequest struct {
	// FD contains dmabuf fd
	FD FD

	// PlaneIdx contains plane index
	PlaneIdx uint32

	// Offset contains offset in bytes
	Offset uint32

	// Stride contains stride in bytes
	Stride uint32

	// ModifierHi contains high 32 bits of layout modifier
	ModifierHi uint32

	// ModifierLo contains low 32 bits of layout modifier
	ModifierLo uint32
}

// Opcode returns the request opcode for zwp_linux_buffer_params_v1.add in linux_dmabuf_unstable_v1
func (ZwpLinuxBufferParamsV1AddRequest) Opcode() uint16 { return 1 }

// MessageName returns the request name for zwp_linux_buffer_params_v1.add in linux_dmabuf_unstable_v1
func (ZwpLinuxBufferParamsV1AddRequest) MessageName() string { return "add" }

// Ensure ZwpLinuxBufferParamsV1AddRequest implements Message.
var _ Message = ZwpLinuxBufferParamsV1AddRequest{}

// Emit emits the message to the emitter.
func (r *ZwpLinuxBufferParamsV1AddRequest) Emit(e *RequestEmitter) error {
	if err := e.PutFD(r.FD); err != nil {
		return err
	}
	if err := e.PutUint(r.PlaneIdx); err != nil {
		return err
	}
	if err := e.PutUint(r.Offset); err != nil {
		return err
	}
	if err := e.PutUint(r.Stride); err != nil {
		return err
	}
	if err := e.PutUint(r.ModifierHi); err != nil {
		return err
	}
	if err := e.PutUint(r.ModifierLo); err != nil {
		return err
	}
	return nil
}

// Ensure ZwpLinuxBufferParamsV1AddRequest implements Request.
var _ Request = &ZwpLinuxBufferParamsV1AddRequest{}

// ZwpLinuxBufferParamsV1CreateRequest requests to create a wl_buffer from the given dmabufs
//
// This asks for creation of a wl_buffer from the added dmabuf
// buffers. The wl_buffer is not created immediately but returned via
// the 'created' event if the dmabuf sharing succeeds. The sharing
// may fail at runtime for reasons a client cannot predict, in
// which case the 'failed' event is triggered.
//
// The 'format' argument is a DRM_FORMAT code, as defined by the
// libdrm's drm_fourcc.h. The Linux kernel's DRM sub-system is the
// authoritative source on how the format codes should work.
//
// The 'flags' is a bitfield of the flags defined in enum "flags".
// 'y_invert' means the that the image needs to be y-flipped.
//
// Flag 'interlaced' means that the frame in the buffer is not
// progressive as usual, but interlaced. An interlaced buffer as
// supported here must always contain both top and bottom fields.
// The top field always begins on the first pixel row. The temporal
// ordering between the two fields is top field first, unless
// 'bottom_first' is specified. It is undefined whether 'bottom_first'
// is ignored if 'interlaced' is not set.
//
// This protocol does not convey any information about field rate,
// duration, or timing, other than the relative ordering between the
// two fields in one buffer. A compositor may have to estimate the
// intended field rate from the incoming buffer rate. It is undefined
// whether the time of receiving wl_surface.commit with a new buffer
// attached, applying the wl_surface state, wl_surface.frame callback
// trigger, presentation, or any other point in the compositor cycle
// is used to measure the frame or field times. There is no support
// for detecting missed or late frames/fields/buffers either, and
// there is no support whatsoever for cooperating with interlaced
// compositor output.
//
// The composited image quality resulting from the use of interlaced
// buffers is explicitly undefined. A compositor may use elaborate
// hardware features or software to deinterlace and create progressive
// output frames from a sequence of interlaced input buffers, or it
// may produce substandard image quality. However, compositors that
// cannot guarantee reasonable image quality in all cases are recommended
// to just reject all interlaced buffers.
//
// Any argument errors, including non-positive width or height,
// mismatch between the number of planes and the format, bad
// format, bad offset or stride, may be indicated by fatal protocol
// errors: INCOMPLETE, INVALID_FORMAT, INVALID_DIMENSIONS,
// OUT_OF_BOUNDS.
//
// Dmabuf import errors in the server that are not obvious client
// bugs are returned via the 'failed' event as non-fatal. This
// allows attempting dmabuf sharing and falling back in the client
// if it fails.
//
// This request can be sent only once in the object's lifetime, after
// which the only legal request is destroy. This object should be
// destroyed after issuing a 'create' request. Attempting to use this
// object after issuing 'create' raises ALREADY_USED protocol error.
//
// It is not mandatory to issue 'create'. If a client wants to
// cancel the buffer creation, it can just destroy this object.
type ZwpLinuxBufferParamsV1CreateRequest struct {
	// Width contains base plane width in pixels
	Width int32

	// Height contains base plane height in pixels
	Height int32

	// Format contains DRM_FORMAT code
	Format uint32

	// Flags contains see enum flags
	Flags uint32
}

// Opcode returns the request opcode for zwp_linux_buffer_params_v1.create in linux_dmabuf_unstable_v1
func (ZwpLinuxBufferParamsV1CreateRequest) Opcode() uint16 { return 2 }

// MessageName returns the request name for zwp_linux_buffer_params_v1.create in linux_dmabuf_unstable_v1
func (ZwpLinuxBufferParamsV1CreateRequest) MessageName() string { return "create" }

// Ensure ZwpLinuxBufferParamsV1CreateRequest implements Message.
var _ Message = ZwpLinuxBufferParamsV1CreateRequest{}

// Emit emits the message to the emitter.
func (r *ZwpLinuxBufferParamsV1CreateRequest) Emit(e *RequestEmitter) error {
	if err := e.PutInt(r.Width); err != nil {
		return err
	}
	if err := e.PutInt(r.Height); err != nil {
		return err
	}
	if err := e.PutUint(r.Format); err != nil {
		return err
	}
	if err := e.PutUint(r.Flags); err != nil {
		return err
	}
	return nil
}

// Ensure ZwpLinuxBufferParamsV1CreateRequest implements Request.
var _ Request = &ZwpLinuxBufferParamsV1CreateRequest{}

// ZwpLinuxBufferParamsV1CreateImmedRequest requests to immediately create a wl_buffer from the given dmabufs
//
// This asks for immediate creation of a wl_buffer by importing the
// added dmabufs.
//
// In case of import success, no event is sent from the server, and the
// wl_buffer is ready to be used by the client.
//
// Upon import failure, either of the following may happen, as seen fit
// by the implementation:
// - the client is terminated with one of the following fatal protocol
// errors:
// - INCOMPLETE, INVALID_FORMAT, INVALID_DIMENSIONS, OUT_OF_BOUNDS,
// in case of argument errors such as mismatch between the number
// of planes and the format, bad format, non-positive width or
// height, or bad offset or stride.
// - INVALID_WL_BUFFER, in case the cause for failure is unknown or
// plaform specific.
// - the server creates an invalid wl_buffer, marks it as failed and
// sends a 'failed' event to the client. The result of using this
// invalid wl_buffer as an argument in any request by the client is
// defined by the compositor implementation.
//
// This takes the same arguments as a 'create' request, and obeys the
// same restrictions.
type ZwpLinuxBufferParamsV1CreateImmedRequest struct {
	// BufferID contains id for the newly created wl_buffer
	BufferID ObjectID

	// Width contains base plane width in pixels
	Width int32

	// Height contains base plane height in pixels
	Height int32

	// Format contains DRM_FORMAT code
	Format uint32

	// Flags contains see enum flags
	Flags uint32
}

// Opcode returns the request opcode for zwp_linux_buffer_params_v1.create_immed in linux_dmabuf_unstable_v1
func (ZwpLinuxBufferParamsV1CreateImmedRequest) Opcode() uint16 { return 3 }

// MessageName returns the request name for zwp_linux_buffer_params_v1.create_immed in linux_dmabuf_unstable_v1
func (ZwpLinuxBufferParamsV1CreateImmedRequest) MessageName() string { return "create_immed" }

// Ensure ZwpLinuxBufferParamsV1CreateImmedRequest implements Message.
var _ Message = ZwpLinuxBufferParamsV1CreateImmedRequest{}

// Emit emits the message to the emitter.
func (r *ZwpLinuxBufferParamsV1CreateImmedRequest) Emit(e *RequestEmitter) error {
	if err := e.PutObjectID(r.BufferID); err != nil {
		return err
	}
	if err := e.PutInt(r.Width); err != nil {
		return err
	}
	if err := e.PutInt(r.Height); err != nil {
		return err
	}
	if err := e.PutUint(r.Format); err != nil {
		return err
	}
	if err := e.PutUint(r.Flags); err != nil {
		return err
	}
	return nil
}

// Ensure ZwpLinuxBufferParamsV1CreateImmedRequest implements Request.
var _ Request = &ZwpLinuxBufferParamsV1CreateImmedRequest{}

// ZwpLinuxBufferParamsV1CreatedEvent signals when buffer creation succeeded
//
// This event indicates that the attempted buffer creation was
// successful. It provides the new wl_buffer referencing the dmabuf(s).
//
// Upon receiving this event, the client should destroy the
// zlinux_dmabuf_params object.
type ZwpLinuxBufferParamsV1CreatedEvent struct {
	// Buffer contains the newly created wl_buffer
	Buffer ObjectID
}

// Opcode returns the event opcode for zwp_linux_buffer_params_v1.created in linux_dmabuf_unstable_v1
func (ZwpLinuxBufferParamsV1CreatedEvent) Opcode() uint16 { return 0 }

// MessageName returns the event name for zwp_linux_buffer_params_v1.created in linux_dmabuf_unstable_v1
func (ZwpLinuxBufferParamsV1CreatedEvent) MessageName() string { return "created" }

// Ensure ZwpLinuxBufferParamsV1CreatedEvent implements Message.
var _ Message = ZwpLinuxBufferParamsV1CreatedEvent{}

// Scan scans the event from the socket.
func (e *ZwpLinuxBufferParamsV1CreatedEvent) Scan(s *EventScanner) error {
	if v, err := s.ObjectID(); err != nil {
		return err
	} else {
		e.Buffer = v
	}
	return nil
}

// Ensure ZwpLinuxBufferParamsV1CreatedEvent implements Event.
var _ Event = &ZwpLinuxBufferParamsV1CreatedEvent{}

// ZwpLinuxBufferParamsV1FailedEvent signals when buffer creation failed
//
// This event indicates that the attempted buffer creation has
// failed. It usually means that one of the dmabuf constraints
// has not been fulfilled.
//
// Upon receiving this event, the client should destroy the
// zlinux_buffer_params object.
type ZwpLinuxBufferParamsV1FailedEvent struct {
}

// Opcode returns the event opcode for zwp_linux_buffer_params_v1.failed in linux_dmabuf_unstable_v1
func (ZwpLinuxBufferParamsV1FailedEvent) Opcode() uint16 { return 1 }

// MessageName returns the event name for zwp_linux_buffer_params_v1.failed in linux_dmabuf_unstable_v1
func (ZwpLinuxBufferParamsV1FailedEvent) MessageName() string { return "failed" }

// Ensure ZwpLinuxBufferParamsV1FailedEvent implements Message.
var _ Message = ZwpLinuxBufferParamsV1FailedEvent{}

// Scan scans the event from the socket.
func (e *ZwpLinuxBufferParamsV1FailedEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure ZwpLinuxBufferParamsV1FailedEvent implements Event.
var _ Event = &ZwpLinuxBufferParamsV1FailedEvent{}

// ZwpLinuxBufferParamsV1 parameters for creating a dmabuf-based wl_buffer
//
// This temporary object is a collection of dmabufs and other
// parameters that together form a single logical buffer. The temporary
// object may eventually create one wl_buffer unless cancelled by
// destroying it before requesting 'create'.
//
// Single-planar formats only require one dmabuf, however
// multi-planar formats may require more than one dmabuf. For all
// formats, an 'add' request must be called once per plane (even if the
// underlying dmabuf fd is identical).
//
// You must use consecutive plane indices ('plane_idx' argument for 'add')
// from zero to the number of planes used by the drm_fourcc format code.
// All planes required by the format must be given exactly once, but can
// be given in any order. Each plane index can be set only once.
type ZwpLinuxBufferParamsV1 struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *ZwpLinuxBufferParamsV1) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (ZwpLinuxBufferParamsV1) Descriptor() *InterfaceDescriptor {
	return &ZwpLinuxBufferParamsV1Descriptor
}

// Dispatch returns an Event object for a given opcode.
func (ZwpLinuxBufferParamsV1) Dispatch(opcode uint16) Event {
	switch opcode {
	case 0:
		return &ZwpLinuxBufferParamsV1CreatedEvent{}
	case 1:
		return &ZwpLinuxBufferParamsV1FailedEvent{}
	default:
		return nil
	}
}

// Destroy requests to delete this object, used or not
//
// Cleans up the temporary data sent to the server for dmabuf-based
// wl_buffer creation.
func (proxy *ZwpLinuxBufferParamsV1) Destroy(connection Connection) (err error) {
	request := ZwpLinuxBufferParamsV1DestroyRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Add requests to add a dmabuf to the temporary set
//
// This request adds one dmabuf to the set in this
// zwp_linux_buffer_params_v1.
//
// The 64-bit unsigned value combined from modifier_hi and modifier_lo
// is the dmabuf layout modifier. DRM AddFB2 ioctl calls this the
// fb modifier, which is defined in drm_mode.h of Linux UAPI.
// This is an opaque token. Drivers use this token to express tiling,
// compression, etc. driver-specific modifications to the base format
// defined by the DRM fourcc code.
//
// Warning: It should be an error if the format/modifier pair was not
// advertised with the modifier event. This is not enforced yet because
// some implementations always accept DRM_FORMAT_MOD_INVALID. Also
// version 2 of this protocol does not have the modifier event.
//
// This request raises the PLANE_IDX error if plane_idx is too large.
// The error PLANE_SET is raised if attempting to set a plane that
// was already set.
func (proxy *ZwpLinuxBufferParamsV1) Add(connection Connection, aFD FD, aPlaneIdx uint32, aOffset uint32, aStride uint32, aModifierHi uint32, aModifierLo uint32) (err error) {
	request := ZwpLinuxBufferParamsV1AddRequest{
		FD:         aFD,
		PlaneIdx:   aPlaneIdx,
		Offset:     aOffset,
		Stride:     aStride,
		ModifierHi: aModifierHi,
		ModifierLo: aModifierLo,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Create requests to create a wl_buffer from the given dmabufs
//
// This asks for creation of a wl_buffer from the added dmabuf
// buffers. The wl_buffer is not created immediately but returned via
// the 'created' event if the dmabuf sharing succeeds. The sharing
// may fail at runtime for reasons a client cannot predict, in
// which case the 'failed' event is triggered.
//
// The 'format' argument is a DRM_FORMAT code, as defined by the
// libdrm's drm_fourcc.h. The Linux kernel's DRM sub-system is the
// authoritative source on how the format codes should work.
//
// The 'flags' is a bitfield of the flags defined in enum "flags".
// 'y_invert' means the that the image needs to be y-flipped.
//
// Flag 'interlaced' means that the frame in the buffer is not
// progressive as usual, but interlaced. An interlaced buffer as
// supported here must always contain both top and bottom fields.
// The top field always begins on the first pixel row. The temporal
// ordering between the two fields is top field first, unless
// 'bottom_first' is specified. It is undefined whether 'bottom_first'
// is ignored if 'interlaced' is not set.
//
// This protocol does not convey any information about field rate,
// duration, or timing, other than the relative ordering between the
// two fields in one buffer. A compositor may have to estimate the
// intended field rate from the incoming buffer rate. It is undefined
// whether the time of receiving wl_surface.commit with a new buffer
// attached, applying the wl_surface state, wl_surface.frame callback
// trigger, presentation, or any other point in the compositor cycle
// is used to measure the frame or field times. There is no support
// for detecting missed or late frames/fields/buffers either, and
// there is no support whatsoever for cooperating with interlaced
// compositor output.
//
// The composited image quality resulting from the use of interlaced
// buffers is explicitly undefined. A compositor may use elaborate
// hardware features or software to deinterlace and create progressive
// output frames from a sequence of interlaced input buffers, or it
// may produce substandard image quality. However, compositors that
// cannot guarantee reasonable image quality in all cases are recommended
// to just reject all interlaced buffers.
//
// Any argument errors, including non-positive width or height,
// mismatch between the number of planes and the format, bad
// format, bad offset or stride, may be indicated by fatal protocol
// errors: INCOMPLETE, INVALID_FORMAT, INVALID_DIMENSIONS,
// OUT_OF_BOUNDS.
//
// Dmabuf import errors in the server that are not obvious client
// bugs are returned via the 'failed' event as non-fatal. This
// allows attempting dmabuf sharing and falling back in the client
// if it fails.
//
// This request can be sent only once in the object's lifetime, after
// which the only legal request is destroy. This object should be
// destroyed after issuing a 'create' request. Attempting to use this
// object after issuing 'create' raises ALREADY_USED protocol error.
//
// It is not mandatory to issue 'create'. If a client wants to
// cancel the buffer creation, it can just destroy this object.
func (proxy *ZwpLinuxBufferParamsV1) Create(connection Connection, aWidth int32, aHeight int32, aFormat uint32, aFlags uint32) (err error) {
	request := ZwpLinuxBufferParamsV1CreateRequest{
		Width:  aWidth,
		Height: aHeight,
		Format: aFormat,
		Flags:  aFlags,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// CreateImmed requests to immediately create a wl_buffer from the given dmabufs
//
// This asks for immediate creation of a wl_buffer by importing the
// added dmabufs.
//
// In case of import success, no event is sent from the server, and the
// wl_buffer is ready to be used by the client.
//
// Upon import failure, either of the following may happen, as seen fit
// by the implementation:
// - the client is terminated with one of the following fatal protocol
// errors:
// - INCOMPLETE, INVALID_FORMAT, INVALID_DIMENSIONS, OUT_OF_BOUNDS,
// in case of argument errors such as mismatch between the number
// of planes and the format, bad format, non-positive width or
// height, or bad offset or stride.
// - INVALID_WL_BUFFER, in case the cause for failure is unknown or
// plaform specific.
// - the server creates an invalid wl_buffer, marks it as failed and
// sends a 'failed' event to the client. The result of using this
// invalid wl_buffer as an argument in any request by the client is
// defined by the compositor implementation.
//
// This takes the same arguments as a 'create' request, and obeys the
// same restrictions.
func (proxy *ZwpLinuxBufferParamsV1) CreateImmed(connection Connection, aWidth int32, aHeight int32, aFormat uint32, aFlags uint32) (aBufferID *WlBuffer, err error) {
	aBufferID = &WlBuffer{connection.NewID()}
	request := ZwpLinuxBufferParamsV1CreateImmedRequest{
		BufferID: aBufferID.id,
		Width:    aWidth,
		Height:   aHeight,
		Format:   aFormat,
		Flags:    aFlags,
	}
	err = connection.SendRequest(proxy.id, &request)
	if err == nil {
		connection.RegisterProxy(aBufferID)
	}
	return
}

// Ensure ZwpLinuxBufferParamsV1 implements Proxy.
var _ Proxy = &ZwpLinuxBufferParamsV1{}

// #endregion Interface linux_dmabuf_unstable_v1.zwp_linux_buffer_params_v1

////////////////////////////////////////////////////////////////////////////////
// #endregion Protocol linux_dmabuf_unstable_v1

////////////////////////////////////////////////////////////////////////////////
// #region Protocol pointer_constraints_unstable_v1

// ----------------------------------------------------------------------------
// #region Interface pointer_constraints_unstable_v1.zwp_pointer_constraints_v1

// ZwpPointerConstraintsV1Error represents wp_pointer_constraints error values
//
// These errors can be emitted in response to wp_pointer_constraints
// requests.
type ZwpPointerConstraintsV1Error int

const (
	// ZwpPointerConstraintsV1ErrorAlreadyConstrained corresponds to pointer constraint already requested on that surface
	ZwpPointerConstraintsV1ErrorAlreadyConstrained ZwpPointerConstraintsV1Error = 1
)

// ZwpPointerConstraintsV1Lifetime represents constraint lifetime
//
// These values represent different lifetime semantics. They are passed
// as arguments to the factory requests to specify how the constraint
// lifetimes should be managed.
type ZwpPointerConstraintsV1Lifetime int

const (
	ZwpPointerConstraintsV1LifetimeOneshot ZwpPointerConstraintsV1Lifetime = 1

	ZwpPointerConstraintsV1LifetimePersistent ZwpPointerConstraintsV1Lifetime = 2
)

// ZwpPointerConstraintsV1DestroyRequest requests to destroy the pointer constraints manager object
//
// Used by the client to notify the server that it will no longer use this
// pointer constraints object.
type ZwpPointerConstraintsV1DestroyRequest struct {
}

// Opcode returns the request opcode for zwp_pointer_constraints_v1.destroy in pointer_constraints_unstable_v1
func (ZwpPointerConstraintsV1DestroyRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for zwp_pointer_constraints_v1.destroy in pointer_constraints_unstable_v1
func (ZwpPointerConstraintsV1DestroyRequest) MessageName() string { return "destroy" }

// Ensure ZwpPointerConstraintsV1DestroyRequest implements Message.
var _ Message = ZwpPointerConstraintsV1DestroyRequest{}

// Emit emits the message to the emitter.
func (r *ZwpPointerConstraintsV1DestroyRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure ZwpPointerConstraintsV1DestroyRequest implements Request.
var _ Request = &ZwpPointerConstraintsV1DestroyRequest{}

// ZwpPointerConstraintsV1LockPointerRequest requests to lock pointer to a position
//
// The lock_pointer request lets the client request to disable movements of
// the virtual pointer (i.e. the cursor), effectively locking the pointer
// to a position. This request may not take effect immediately; in the
// future, when the compositor deems implementation-specific constraints
// are satisfied, the pointer lock will be activated and the compositor
// sends a locked event.
//
// The protocol provides no guarantee that the constraints are ever
// satisfied, and does not require the compositor to send an error if the
// constraints cannot ever be satisfied. It is thus possible to request a
// lock that will never activate.
//
// There may not be another pointer constraint of any kind requested or
// active on the surface for any of the wl_pointer objects of the seat of
// the passed pointer when requesting a lock. If there is, an error will be
// raised. See general pointer lock documentation for more details.
//
// The intersection of the region passed with this request and the input
// region of the surface is used to determine where the pointer must be
// in order for the lock to activate. It is up to the compositor whether to
// warp the pointer or require some kind of user interaction for the lock
// to activate. If the region is null the surface input region is used.
//
// A surface may receive pointer focus without the lock being activated.
//
// The request creates a new object wp_locked_pointer which is used to
// interact with the lock as well as receive updates about its state. See
// the the description of wp_locked_pointer for further information.
//
// Note that while a pointer is locked, the wl_pointer objects of the
// corresponding seat will not emit any wl_pointer.motion events, but
// relative motion events will still be emitted via wp_relative_pointer
// objects of the same seat. wl_pointer.axis and wl_pointer.button events
// are unaffected.
type ZwpPointerConstraintsV1LockPointerRequest struct {
	ID ObjectID

	// Surface contains surface to lock pointer to
	Surface ObjectID

	// Pointer contains the pointer that should be locked
	Pointer ObjectID

	// Region contains region of surface
	Region ObjectID

	// Lifetime contains lock lifetime
	Lifetime uint32
}

// Opcode returns the request opcode for zwp_pointer_constraints_v1.lock_pointer in pointer_constraints_unstable_v1
func (ZwpPointerConstraintsV1LockPointerRequest) Opcode() uint16 { return 1 }

// MessageName returns the request name for zwp_pointer_constraints_v1.lock_pointer in pointer_constraints_unstable_v1
func (ZwpPointerConstraintsV1LockPointerRequest) MessageName() string { return "lock_pointer" }

// Ensure ZwpPointerConstraintsV1LockPointerRequest implements Message.
var _ Message = ZwpPointerConstraintsV1LockPointerRequest{}

// Emit emits the message to the emitter.
func (r *ZwpPointerConstraintsV1LockPointerRequest) Emit(e *RequestEmitter) error {
	if err := e.PutObjectID(r.ID); err != nil {
		return err
	}
	if err := e.PutObjectID(r.Surface); err != nil {
		return err
	}
	if err := e.PutObjectID(r.Pointer); err != nil {
		return err
	}
	if err := e.PutObjectID(r.Region); err != nil {
		return err
	}
	if err := e.PutUint(r.Lifetime); err != nil {
		return err
	}
	return nil
}

// Ensure ZwpPointerConstraintsV1LockPointerRequest implements Request.
var _ Request = &ZwpPointerConstraintsV1LockPointerRequest{}

// ZwpPointerConstraintsV1ConfinePointerRequest requests to confine pointer to a region
//
// The confine_pointer request lets the client request to confine the
// pointer cursor to a given region. This request may not take effect
// immediately; in the future, when the compositor deems implementation-
// specific constraints are satisfied, the pointer confinement will be
// activated and the compositor sends a confined event.
//
// The intersection of the region passed with this request and the input
// region of the surface is used to determine where the pointer must be
// in order for the confinement to activate. It is up to the compositor
// whether to warp the pointer or require some kind of user interaction for
// the confinement to activate. If the region is null the surface input
// region is used.
//
// The request will create a new object wp_confined_pointer which is used
// to interact with the confinement as well as receive updates about its
// state. See the the description of wp_confined_pointer for further
// information.
type ZwpPointerConstraintsV1ConfinePointerRequest struct {
	ID ObjectID

	// Surface contains surface to lock pointer to
	Surface ObjectID

	// Pointer contains the pointer that should be confined
	Pointer ObjectID

	// Region contains region of surface
	Region ObjectID

	// Lifetime contains confinement lifetime
	Lifetime uint32
}

// Opcode returns the request opcode for zwp_pointer_constraints_v1.confine_pointer in pointer_constraints_unstable_v1
func (ZwpPointerConstraintsV1ConfinePointerRequest) Opcode() uint16 { return 2 }

// MessageName returns the request name for zwp_pointer_constraints_v1.confine_pointer in pointer_constraints_unstable_v1
func (ZwpPointerConstraintsV1ConfinePointerRequest) MessageName() string { return "confine_pointer" }

// Ensure ZwpPointerConstraintsV1ConfinePointerRequest implements Message.
var _ Message = ZwpPointerConstraintsV1ConfinePointerRequest{}

// Emit emits the message to the emitter.
func (r *ZwpPointerConstraintsV1ConfinePointerRequest) Emit(e *RequestEmitter) error {
	if err := e.PutObjectID(r.ID); err != nil {
		return err
	}
	if err := e.PutObjectID(r.Surface); err != nil {
		return err
	}
	if err := e.PutObjectID(r.Pointer); err != nil {
		return err
	}
	if err := e.PutObjectID(r.Region); err != nil {
		return err
	}
	if err := e.PutUint(r.Lifetime); err != nil {
		return err
	}
	return nil
}

// Ensure ZwpPointerConstraintsV1ConfinePointerRequest implements Request.
var _ Request = &ZwpPointerConstraintsV1ConfinePointerRequest{}

// ZwpPointerConstraintsV1 constrain the movement of a pointer
//
// The global interface exposing pointer constraining functionality. It
// exposes two requests: lock_pointer for locking the pointer to its
// position, and confine_pointer for locking the pointer to a region.
//
// The lock_pointer and confine_pointer requests create the objects
// wp_locked_pointer and wp_confined_pointer respectively, and the client can
// use these objects to interact with the lock.
//
// For any surface, only one lock or confinement may be active across all
// wl_pointer objects of the same seat. If a lock or confinement is requested
// when another lock or confinement is active or requested on the same surface
// and with any of the wl_pointer objects of the same seat, an
// 'already_constrained' error will be raised.
type ZwpPointerConstraintsV1 struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *ZwpPointerConstraintsV1) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (ZwpPointerConstraintsV1) Descriptor() *InterfaceDescriptor {
	return &ZwpPointerConstraintsV1Descriptor
}

// Dispatch returns an Event object for a given opcode.
func (ZwpPointerConstraintsV1) Dispatch(opcode uint16) Event {
	switch opcode {
	default:
		return nil
	}
}

// Destroy requests to destroy the pointer constraints manager object
//
// Used by the client to notify the server that it will no longer use this
// pointer constraints object.
func (proxy *ZwpPointerConstraintsV1) Destroy(connection Connection) (err error) {
	request := ZwpPointerConstraintsV1DestroyRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// LockPointer requests to lock pointer to a position
//
// The lock_pointer request lets the client request to disable movements of
// the virtual pointer (i.e. the cursor), effectively locking the pointer
// to a position. This request may not take effect immediately; in the
// future, when the compositor deems implementation-specific constraints
// are satisfied, the pointer lock will be activated and the compositor
// sends a locked event.
//
// The protocol provides no guarantee that the constraints are ever
// satisfied, and does not require the compositor to send an error if the
// constraints cannot ever be satisfied. It is thus possible to request a
// lock that will never activate.
//
// There may not be another pointer constraint of any kind requested or
// active on the surface for any of the wl_pointer objects of the seat of
// the passed pointer when requesting a lock. If there is, an error will be
// raised. See general pointer lock documentation for more details.
//
// The intersection of the region passed with this request and the input
// region of the surface is used to determine where the pointer must be
// in order for the lock to activate. It is up to the compositor whether to
// warp the pointer or require some kind of user interaction for the lock
// to activate. If the region is null the surface input region is used.
//
// A surface may receive pointer focus without the lock being activated.
//
// The request creates a new object wp_locked_pointer which is used to
// interact with the lock as well as receive updates about its state. See
// the the description of wp_locked_pointer for further information.
//
// Note that while a pointer is locked, the wl_pointer objects of the
// corresponding seat will not emit any wl_pointer.motion events, but
// relative motion events will still be emitted via wp_relative_pointer
// objects of the same seat. wl_pointer.axis and wl_pointer.button events
// are unaffected.
func (proxy *ZwpPointerConstraintsV1) LockPointer(connection Connection, aSurface ObjectID, aPointer ObjectID, aRegion ObjectID, aLifetime uint32) (aID *ZwpLockedPointerV1, err error) {
	aID = &ZwpLockedPointerV1{connection.NewID()}
	request := ZwpPointerConstraintsV1LockPointerRequest{
		ID:       aID.id,
		Surface:  aSurface,
		Pointer:  aPointer,
		Region:   aRegion,
		Lifetime: aLifetime,
	}
	err = connection.SendRequest(proxy.id, &request)
	if err == nil {
		connection.RegisterProxy(aID)
	}
	return
}

// ConfinePointer requests to confine pointer to a region
//
// The confine_pointer request lets the client request to confine the
// pointer cursor to a given region. This request may not take effect
// immediately; in the future, when the compositor deems implementation-
// specific constraints are satisfied, the pointer confinement will be
// activated and the compositor sends a confined event.
//
// The intersection of the region passed with this request and the input
// region of the surface is used to determine where the pointer must be
// in order for the confinement to activate. It is up to the compositor
// whether to warp the pointer or require some kind of user interaction for
// the confinement to activate. If the region is null the surface input
// region is used.
//
// The request will create a new object wp_confined_pointer which is used
// to interact with the confinement as well as receive updates about its
// state. See the the description of wp_confined_pointer for further
// information.
func (proxy *ZwpPointerConstraintsV1) ConfinePointer(connection Connection, aSurface ObjectID, aPointer ObjectID, aRegion ObjectID, aLifetime uint32) (aID *ZwpConfinedPointerV1, err error) {
	aID = &ZwpConfinedPointerV1{connection.NewID()}
	request := ZwpPointerConstraintsV1ConfinePointerRequest{
		ID:       aID.id,
		Surface:  aSurface,
		Pointer:  aPointer,
		Region:   aRegion,
		Lifetime: aLifetime,
	}
	err = connection.SendRequest(proxy.id, &request)
	if err == nil {
		connection.RegisterProxy(aID)
	}
	return
}

// Ensure ZwpPointerConstraintsV1 implements Proxy.
var _ Proxy = &ZwpPointerConstraintsV1{}

// #endregion Interface pointer_constraints_unstable_v1.zwp_pointer_constraints_v1

// ----------------------------------------------------------------------------
// #region Interface pointer_constraints_unstable_v1.zwp_locked_pointer_v1

// ZwpLockedPointerV1DestroyRequest requests to destroy the locked pointer object
//
// Destroy the locked pointer object. If applicable, the compositor will
// unlock the pointer.
type ZwpLockedPointerV1DestroyRequest struct {
}

// Opcode returns the request opcode for zwp_locked_pointer_v1.destroy in pointer_constraints_unstable_v1
func (ZwpLockedPointerV1DestroyRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for zwp_locked_pointer_v1.destroy in pointer_constraints_unstable_v1
func (ZwpLockedPointerV1DestroyRequest) MessageName() string { return "destroy" }

// Ensure ZwpLockedPointerV1DestroyRequest implements Message.
var _ Message = ZwpLockedPointerV1DestroyRequest{}

// Emit emits the message to the emitter.
func (r *ZwpLockedPointerV1DestroyRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure ZwpLockedPointerV1DestroyRequest implements Request.
var _ Request = &ZwpLockedPointerV1DestroyRequest{}

// ZwpLockedPointerV1SetCursorPositionHintRequest requests to set the pointer cursor position hint
//
// Set the cursor position hint relative to the top left corner of the
// surface.
//
// If the client is drawing its own cursor, it should update the position
// hint to the position of its own cursor. A compositor may use this
// information to warp the pointer upon unlock in order to avoid pointer
// jumps.
//
// The cursor position hint is double buffered. The new hint will only take
// effect when the associated surface gets it pending state applied. See
// wl_surface.commit for details.
type ZwpLockedPointerV1SetCursorPositionHintRequest struct {
	// SurfaceX contains surface-local x coordinate
	SurfaceX Fixed

	// SurfaceY contains surface-local y coordinate
	SurfaceY Fixed
}

// Opcode returns the request opcode for zwp_locked_pointer_v1.set_cursor_position_hint in pointer_constraints_unstable_v1
func (ZwpLockedPointerV1SetCursorPositionHintRequest) Opcode() uint16 { return 1 }

// MessageName returns the request name for zwp_locked_pointer_v1.set_cursor_position_hint in pointer_constraints_unstable_v1
func (ZwpLockedPointerV1SetCursorPositionHintRequest) MessageName() string {
	return "set_cursor_position_hint"
}

// Ensure ZwpLockedPointerV1SetCursorPositionHintRequest implements Message.
var _ Message = ZwpLockedPointerV1SetCursorPositionHintRequest{}

// Emit emits the message to the emitter.
func (r *ZwpLockedPointerV1SetCursorPositionHintRequest) Emit(e *RequestEmitter) error {
	if err := e.PutFixed(r.SurfaceX); err != nil {
		return err
	}
	if err := e.PutFixed(r.SurfaceY); err != nil {
		return err
	}
	return nil
}

// Ensure ZwpLockedPointerV1SetCursorPositionHintRequest implements Request.
var _ Request = &ZwpLockedPointerV1SetCursorPositionHintRequest{}

// ZwpLockedPointerV1SetRegionRequest requests to set a new lock region
//
// Set a new region used to lock the pointer.
//
// The new lock region is double-buffered. The new lock region will
// only take effect when the associated surface gets its pending state
// applied. See wl_surface.commit for details.
//
// For details about the lock region, see wp_locked_pointer.
type ZwpLockedPointerV1SetRegionRequest struct {
	// Region contains region of surface
	Region ObjectID
}

// Opcode returns the request opcode for zwp_locked_pointer_v1.set_region in pointer_constraints_unstable_v1
func (ZwpLockedPointerV1SetRegionRequest) Opcode() uint16 { return 2 }

// MessageName returns the request name for zwp_locked_pointer_v1.set_region in pointer_constraints_unstable_v1
func (ZwpLockedPointerV1SetRegionRequest) MessageName() string { return "set_region" }

// Ensure ZwpLockedPointerV1SetRegionRequest implements Message.
var _ Message = ZwpLockedPointerV1SetRegionRequest{}

// Emit emits the message to the emitter.
func (r *ZwpLockedPointerV1SetRegionRequest) Emit(e *RequestEmitter) error {
	if err := e.PutObjectID(r.Region); err != nil {
		return err
	}
	return nil
}

// Ensure ZwpLockedPointerV1SetRegionRequest implements Request.
var _ Request = &ZwpLockedPointerV1SetRegionRequest{}

// ZwpLockedPointerV1LockedEvent signals when lock activation event
//
// Notification that the pointer lock of the seat's pointer is activated.
type ZwpLockedPointerV1LockedEvent struct {
}

// Opcode returns the event opcode for zwp_locked_pointer_v1.locked in pointer_constraints_unstable_v1
func (ZwpLockedPointerV1LockedEvent) Opcode() uint16 { return 0 }

// MessageName returns the event name for zwp_locked_pointer_v1.locked in pointer_constraints_unstable_v1
func (ZwpLockedPointerV1LockedEvent) MessageName() string { return "locked" }

// Ensure ZwpLockedPointerV1LockedEvent implements Message.
var _ Message = ZwpLockedPointerV1LockedEvent{}

// Scan scans the event from the socket.
func (e *ZwpLockedPointerV1LockedEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure ZwpLockedPointerV1LockedEvent implements Event.
var _ Event = &ZwpLockedPointerV1LockedEvent{}

// ZwpLockedPointerV1UnlockedEvent signals when lock deactivation event
//
// Notification that the pointer lock of the seat's pointer is no longer
// active. If this is a oneshot pointer lock (see
// wp_pointer_constraints.lifetime) this object is now defunct and should
// be destroyed. If this is a persistent pointer lock (see
// wp_pointer_constraints.lifetime) this pointer lock may again
// reactivate in the future.
type ZwpLockedPointerV1UnlockedEvent struct {
}

// Opcode returns the event opcode for zwp_locked_pointer_v1.unlocked in pointer_constraints_unstable_v1
func (ZwpLockedPointerV1UnlockedEvent) Opcode() uint16 { return 1 }

// MessageName returns the event name for zwp_locked_pointer_v1.unlocked in pointer_constraints_unstable_v1
func (ZwpLockedPointerV1UnlockedEvent) MessageName() string { return "unlocked" }

// Ensure ZwpLockedPointerV1UnlockedEvent implements Message.
var _ Message = ZwpLockedPointerV1UnlockedEvent{}

// Scan scans the event from the socket.
func (e *ZwpLockedPointerV1UnlockedEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure ZwpLockedPointerV1UnlockedEvent implements Event.
var _ Event = &ZwpLockedPointerV1UnlockedEvent{}

// ZwpLockedPointerV1 receive relative pointer motion events
//
// The wp_locked_pointer interface represents a locked pointer state.
//
// While the lock of this object is active, the wl_pointer objects of the
// associated seat will not emit any wl_pointer.motion events.
//
// This object will send the event 'locked' when the lock is activated.
// Whenever the lock is activated, it is guaranteed that the locked surface
// will already have received pointer focus and that the pointer will be
// within the region passed to the request creating this object.
//
// To unlock the pointer, send the destroy request. This will also destroy
// the wp_locked_pointer object.
//
// If the compositor decides to unlock the pointer the unlocked event is
// sent. See wp_locked_pointer.unlock for details.
//
// When unlocking, the compositor may warp the cursor position to the set
// cursor position hint. If it does, it will not result in any relative
// motion events emitted via wp_relative_pointer.
//
// If the surface the lock was requested on is destroyed and the lock is not
// yet activated, the wp_locked_pointer object is now defunct and must be
// destroyed.
type ZwpLockedPointerV1 struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *ZwpLockedPointerV1) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (ZwpLockedPointerV1) Descriptor() *InterfaceDescriptor {
	return &ZwpLockedPointerV1Descriptor
}

// Dispatch returns an Event object for a given opcode.
func (ZwpLockedPointerV1) Dispatch(opcode uint16) Event {
	switch opcode {
	case 0:
		return &ZwpLockedPointerV1LockedEvent{}
	case 1:
		return &ZwpLockedPointerV1UnlockedEvent{}
	default:
		return nil
	}
}

// Destroy requests to destroy the locked pointer object
//
// Destroy the locked pointer object. If applicable, the compositor will
// unlock the pointer.
func (proxy *ZwpLockedPointerV1) Destroy(connection Connection) (err error) {
	request := ZwpLockedPointerV1DestroyRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// SetCursorPositionHint requests to set the pointer cursor position hint
//
// Set the cursor position hint relative to the top left corner of the
// surface.
//
// If the client is drawing its own cursor, it should update the position
// hint to the position of its own cursor. A compositor may use this
// information to warp the pointer upon unlock in order to avoid pointer
// jumps.
//
// The cursor position hint is double buffered. The new hint will only take
// effect when the associated surface gets it pending state applied. See
// wl_surface.commit for details.
func (proxy *ZwpLockedPointerV1) SetCursorPositionHint(connection Connection, aSurfaceX Fixed, aSurfaceY Fixed) (err error) {
	request := ZwpLockedPointerV1SetCursorPositionHintRequest{
		SurfaceX: aSurfaceX,
		SurfaceY: aSurfaceY,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// SetRegion requests to set a new lock region
//
// Set a new region used to lock the pointer.
//
// The new lock region is double-buffered. The new lock region will
// only take effect when the associated surface gets its pending state
// applied. See wl_surface.commit for details.
//
// For details about the lock region, see wp_locked_pointer.
func (proxy *ZwpLockedPointerV1) SetRegion(connection Connection, aRegion ObjectID) (err error) {
	request := ZwpLockedPointerV1SetRegionRequest{
		Region: aRegion,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Ensure ZwpLockedPointerV1 implements Proxy.
var _ Proxy = &ZwpLockedPointerV1{}

// #endregion Interface pointer_constraints_unstable_v1.zwp_locked_pointer_v1

// ----------------------------------------------------------------------------
// #region Interface pointer_constraints_unstable_v1.zwp_confined_pointer_v1

// ZwpConfinedPointerV1DestroyRequest requests to destroy the confined pointer object
//
// Destroy the confined pointer object. If applicable, the compositor will
// unconfine the pointer.
type ZwpConfinedPointerV1DestroyRequest struct {
}

// Opcode returns the request opcode for zwp_confined_pointer_v1.destroy in pointer_constraints_unstable_v1
func (ZwpConfinedPointerV1DestroyRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for zwp_confined_pointer_v1.destroy in pointer_constraints_unstable_v1
func (ZwpConfinedPointerV1DestroyRequest) MessageName() string { return "destroy" }

// Ensure ZwpConfinedPointerV1DestroyRequest implements Message.
var _ Message = ZwpConfinedPointerV1DestroyRequest{}

// Emit emits the message to the emitter.
func (r *ZwpConfinedPointerV1DestroyRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure ZwpConfinedPointerV1DestroyRequest implements Request.
var _ Request = &ZwpConfinedPointerV1DestroyRequest{}

// ZwpConfinedPointerV1SetRegionRequest requests to set a new confine region
//
// Set a new region used to confine the pointer.
//
// The new confine region is double-buffered. The new confine region will
// only take effect when the associated surface gets its pending state
// applied. See wl_surface.commit for details.
//
// If the confinement is active when the new confinement region is applied
// and the pointer ends up outside of newly applied region, the pointer may
// warped to a position within the new confinement region. If warped, a
// wl_pointer.motion event will be emitted, but no
// wp_relative_pointer.relative_motion event.
//
// The compositor may also, instead of using the new region, unconfine the
// pointer.
//
// For details about the confine region, see wp_confined_pointer.
type ZwpConfinedPointerV1SetRegionRequest struct {
	// Region contains region of surface
	Region ObjectID
}

// Opcode returns the request opcode for zwp_confined_pointer_v1.set_region in pointer_constraints_unstable_v1
func (ZwpConfinedPointerV1SetRegionRequest) Opcode() uint16 { return 1 }

// MessageName returns the request name for zwp_confined_pointer_v1.set_region in pointer_constraints_unstable_v1
func (ZwpConfinedPointerV1SetRegionRequest) MessageName() string { return "set_region" }

// Ensure ZwpConfinedPointerV1SetRegionRequest implements Message.
var _ Message = ZwpConfinedPointerV1SetRegionRequest{}

// Emit emits the message to the emitter.
func (r *ZwpConfinedPointerV1SetRegionRequest) Emit(e *RequestEmitter) error {
	if err := e.PutObjectID(r.Region); err != nil {
		return err
	}
	return nil
}

// Ensure ZwpConfinedPointerV1SetRegionRequest implements Request.
var _ Request = &ZwpConfinedPointerV1SetRegionRequest{}

// ZwpConfinedPointerV1ConfinedEvent signals when pointer confined
//
// Notification that the pointer confinement of the seat's pointer is
// activated.
type ZwpConfinedPointerV1ConfinedEvent struct {
}

// Opcode returns the event opcode for zwp_confined_pointer_v1.confined in pointer_constraints_unstable_v1
func (ZwpConfinedPointerV1ConfinedEvent) Opcode() uint16 { return 0 }

// MessageName returns the event name for zwp_confined_pointer_v1.confined in pointer_constraints_unstable_v1
func (ZwpConfinedPointerV1ConfinedEvent) MessageName() string { return "confined" }

// Ensure ZwpConfinedPointerV1ConfinedEvent implements Message.
var _ Message = ZwpConfinedPointerV1ConfinedEvent{}

// Scan scans the event from the socket.
func (e *ZwpConfinedPointerV1ConfinedEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure ZwpConfinedPointerV1ConfinedEvent implements Event.
var _ Event = &ZwpConfinedPointerV1ConfinedEvent{}

// ZwpConfinedPointerV1UnconfinedEvent signals when pointer unconfined
//
// Notification that the pointer confinement of the seat's pointer is no
// longer active. If this is a oneshot pointer confinement (see
// wp_pointer_constraints.lifetime) this object is now defunct and should
// be destroyed. If this is a persistent pointer confinement (see
// wp_pointer_constraints.lifetime) this pointer confinement may again
// reactivate in the future.
type ZwpConfinedPointerV1UnconfinedEvent struct {
}

// Opcode returns the event opcode for zwp_confined_pointer_v1.unconfined in pointer_constraints_unstable_v1
func (ZwpConfinedPointerV1UnconfinedEvent) Opcode() uint16 { return 1 }

// MessageName returns the event name for zwp_confined_pointer_v1.unconfined in pointer_constraints_unstable_v1
func (ZwpConfinedPointerV1UnconfinedEvent) MessageName() string { return "unconfined" }

// Ensure ZwpConfinedPointerV1UnconfinedEvent implements Message.
var _ Message = ZwpConfinedPointerV1UnconfinedEvent{}

// Scan scans the event from the socket.
func (e *ZwpConfinedPointerV1UnconfinedEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure ZwpConfinedPointerV1UnconfinedEvent implements Event.
var _ Event = &ZwpConfinedPointerV1UnconfinedEvent{}

// ZwpConfinedPointerV1 confined pointer object
//
// The wp_confined_pointer interface represents a confined pointer state.
//
// This object will send the event 'confined' when the confinement is
// activated. Whenever the confinement is activated, it is guaranteed that
// the surface the pointer is confined to will already have received pointer
// focus and that the pointer will be within the region passed to the request
// creating this object. It is up to the compositor to decide whether this
// requires some user interaction and if the pointer will warp to within the
// passed region if outside.
//
// To unconfine the pointer, send the destroy request. This will also destroy
// the wp_confined_pointer object.
//
// If the compositor decides to unconfine the pointer the unconfined event is
// sent. The wp_confined_pointer object is at this point defunct and should
// be destroyed.
type ZwpConfinedPointerV1 struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *ZwpConfinedPointerV1) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (ZwpConfinedPointerV1) Descriptor() *InterfaceDescriptor {
	return &ZwpConfinedPointerV1Descriptor
}

// Dispatch returns an Event object for a given opcode.
func (ZwpConfinedPointerV1) Dispatch(opcode uint16) Event {
	switch opcode {
	case 0:
		return &ZwpConfinedPointerV1ConfinedEvent{}
	case 1:
		return &ZwpConfinedPointerV1UnconfinedEvent{}
	default:
		return nil
	}
}

// Destroy requests to destroy the confined pointer object
//
// Destroy the confined pointer object. If applicable, the compositor will
// unconfine the pointer.
func (proxy *ZwpConfinedPointerV1) Destroy(connection Connection) (err error) {
	request := ZwpConfinedPointerV1DestroyRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// SetRegion requests to set a new confine region
//
// Set a new region used to confine the pointer.
//
// The new confine region is double-buffered. The new confine region will
// only take effect when the associated surface gets its pending state
// applied. See wl_surface.commit for details.
//
// If the confinement is active when the new confinement region is applied
// and the pointer ends up outside of newly applied region, the pointer may
// warped to a position within the new confinement region. If warped, a
// wl_pointer.motion event will be emitted, but no
// wp_relative_pointer.relative_motion event.
//
// The compositor may also, instead of using the new region, unconfine the
// pointer.
//
// For details about the confine region, see wp_confined_pointer.
func (proxy *ZwpConfinedPointerV1) SetRegion(connection Connection, aRegion ObjectID) (err error) {
	request := ZwpConfinedPointerV1SetRegionRequest{
		Region: aRegion,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Ensure ZwpConfinedPointerV1 implements Proxy.
var _ Proxy = &ZwpConfinedPointerV1{}

// #endregion Interface pointer_constraints_unstable_v1.zwp_confined_pointer_v1

////////////////////////////////////////////////////////////////////////////////
// #endregion Protocol pointer_constraints_unstable_v1

////////////////////////////////////////////////////////////////////////////////
// #region Protocol pointer_gestures_unstable_v1

// ----------------------------------------------------------------------------
// #region Interface pointer_gestures_unstable_v1.zwp_pointer_gestures_v1

// ZwpPointerGesturesV1GetSwipeGestureRequest requests to get swipe gesture
//
// Create a swipe gesture object. See the
// wl_pointer_gesture_swipe interface for details.
type ZwpPointerGesturesV1GetSwipeGestureRequest struct {
	ID ObjectID

	Pointer ObjectID
}

// Opcode returns the request opcode for zwp_pointer_gestures_v1.get_swipe_gesture in pointer_gestures_unstable_v1
func (ZwpPointerGesturesV1GetSwipeGestureRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for zwp_pointer_gestures_v1.get_swipe_gesture in pointer_gestures_unstable_v1
func (ZwpPointerGesturesV1GetSwipeGestureRequest) MessageName() string { return "get_swipe_gesture" }

// Ensure ZwpPointerGesturesV1GetSwipeGestureRequest implements Message.
var _ Message = ZwpPointerGesturesV1GetSwipeGestureRequest{}

// Emit emits the message to the emitter.
func (r *ZwpPointerGesturesV1GetSwipeGestureRequest) Emit(e *RequestEmitter) error {
	if err := e.PutObjectID(r.ID); err != nil {
		return err
	}
	if err := e.PutObjectID(r.Pointer); err != nil {
		return err
	}
	return nil
}

// Ensure ZwpPointerGesturesV1GetSwipeGestureRequest implements Request.
var _ Request = &ZwpPointerGesturesV1GetSwipeGestureRequest{}

// ZwpPointerGesturesV1GetPinchGestureRequest requests to get pinch gesture
//
// Create a pinch gesture object. See the
// wl_pointer_gesture_pinch interface for details.
type ZwpPointerGesturesV1GetPinchGestureRequest struct {
	ID ObjectID

	Pointer ObjectID
}

// Opcode returns the request opcode for zwp_pointer_gestures_v1.get_pinch_gesture in pointer_gestures_unstable_v1
func (ZwpPointerGesturesV1GetPinchGestureRequest) Opcode() uint16 { return 1 }

// MessageName returns the request name for zwp_pointer_gestures_v1.get_pinch_gesture in pointer_gestures_unstable_v1
func (ZwpPointerGesturesV1GetPinchGestureRequest) MessageName() string { return "get_pinch_gesture" }

// Ensure ZwpPointerGesturesV1GetPinchGestureRequest implements Message.
var _ Message = ZwpPointerGesturesV1GetPinchGestureRequest{}

// Emit emits the message to the emitter.
func (r *ZwpPointerGesturesV1GetPinchGestureRequest) Emit(e *RequestEmitter) error {
	if err := e.PutObjectID(r.ID); err != nil {
		return err
	}
	if err := e.PutObjectID(r.Pointer); err != nil {
		return err
	}
	return nil
}

// Ensure ZwpPointerGesturesV1GetPinchGestureRequest implements Request.
var _ Request = &ZwpPointerGesturesV1GetPinchGestureRequest{}

// ZwpPointerGesturesV1ReleaseRequest requests to destroy the pointer gesture object
//
// Destroy the pointer gesture object. Swipe, pinch and hold objects
// created via this gesture object remain valid.
type ZwpPointerGesturesV1ReleaseRequest struct {
}

// Opcode returns the request opcode for zwp_pointer_gestures_v1.release in pointer_gestures_unstable_v1
func (ZwpPointerGesturesV1ReleaseRequest) Opcode() uint16 { return 2 }

// MessageName returns the request name for zwp_pointer_gestures_v1.release in pointer_gestures_unstable_v1
func (ZwpPointerGesturesV1ReleaseRequest) MessageName() string { return "release" }

// Ensure ZwpPointerGesturesV1ReleaseRequest implements Message.
var _ Message = ZwpPointerGesturesV1ReleaseRequest{}

// Emit emits the message to the emitter.
func (r *ZwpPointerGesturesV1ReleaseRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure ZwpPointerGesturesV1ReleaseRequest implements Request.
var _ Request = &ZwpPointerGesturesV1ReleaseRequest{}

// ZwpPointerGesturesV1GetHoldGestureRequest requests to get hold gesture
//
// Create a hold gesture object. See the
// wl_pointer_gesture_hold interface for details.
type ZwpPointerGesturesV1GetHoldGestureRequest struct {
	ID ObjectID

	Pointer ObjectID
}

// Opcode returns the request opcode for zwp_pointer_gestures_v1.get_hold_gesture in pointer_gestures_unstable_v1
func (ZwpPointerGesturesV1GetHoldGestureRequest) Opcode() uint16 { return 3 }

// MessageName returns the request name for zwp_pointer_gestures_v1.get_hold_gesture in pointer_gestures_unstable_v1
func (ZwpPointerGesturesV1GetHoldGestureRequest) MessageName() string { return "get_hold_gesture" }

// Ensure ZwpPointerGesturesV1GetHoldGestureRequest implements Message.
var _ Message = ZwpPointerGesturesV1GetHoldGestureRequest{}

// Emit emits the message to the emitter.
func (r *ZwpPointerGesturesV1GetHoldGestureRequest) Emit(e *RequestEmitter) error {
	if err := e.PutObjectID(r.ID); err != nil {
		return err
	}
	if err := e.PutObjectID(r.Pointer); err != nil {
		return err
	}
	return nil
}

// Ensure ZwpPointerGesturesV1GetHoldGestureRequest implements Request.
var _ Request = &ZwpPointerGesturesV1GetHoldGestureRequest{}

// ZwpPointerGesturesV1 touchpad gestures
//
// A global interface to provide semantic touchpad gestures for a given
// pointer.
//
// Three gestures are currently supported: swipe, pinch, and hold.
// Pinch and swipe gestures follow a three-stage cycle: begin, update,
// end, hold gestures follow a two-stage cycle: begin and end. All
// gestures are identified by a unique id.
//
// Warning! The protocol described in this file is experimental and
// backward incompatible changes may be made. Backward compatible changes
// may be added together with the corresponding interface version bump.
// Backward incompatible changes are done by bumping the version number in
// the protocol and interface names and resetting the interface version.
// Once the protocol is to be declared stable, the 'z' prefix and the
// version number in the protocol and interface names are removed and the
// interface version number is reset.
type ZwpPointerGesturesV1 struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *ZwpPointerGesturesV1) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (ZwpPointerGesturesV1) Descriptor() *InterfaceDescriptor {
	return &ZwpPointerGesturesV1Descriptor
}

// Dispatch returns an Event object for a given opcode.
func (ZwpPointerGesturesV1) Dispatch(opcode uint16) Event {
	switch opcode {
	default:
		return nil
	}
}

// GetSwipeGesture requests to get swipe gesture
//
// Create a swipe gesture object. See the
// wl_pointer_gesture_swipe interface for details.
func (proxy *ZwpPointerGesturesV1) GetSwipeGesture(connection Connection, aPointer ObjectID) (aID *ZwpPointerGestureSwipeV1, err error) {
	aID = &ZwpPointerGestureSwipeV1{connection.NewID()}
	request := ZwpPointerGesturesV1GetSwipeGestureRequest{
		ID:      aID.id,
		Pointer: aPointer,
	}
	err = connection.SendRequest(proxy.id, &request)
	if err == nil {
		connection.RegisterProxy(aID)
	}
	return
}

// GetPinchGesture requests to get pinch gesture
//
// Create a pinch gesture object. See the
// wl_pointer_gesture_pinch interface for details.
func (proxy *ZwpPointerGesturesV1) GetPinchGesture(connection Connection, aPointer ObjectID) (aID *ZwpPointerGesturePinchV1, err error) {
	aID = &ZwpPointerGesturePinchV1{connection.NewID()}
	request := ZwpPointerGesturesV1GetPinchGestureRequest{
		ID:      aID.id,
		Pointer: aPointer,
	}
	err = connection.SendRequest(proxy.id, &request)
	if err == nil {
		connection.RegisterProxy(aID)
	}
	return
}

// Release requests to destroy the pointer gesture object
//
// Destroy the pointer gesture object. Swipe, pinch and hold objects
// created via this gesture object remain valid.
func (proxy *ZwpPointerGesturesV1) Release(connection Connection) (err error) {
	request := ZwpPointerGesturesV1ReleaseRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// GetHoldGesture requests to get hold gesture
//
// Create a hold gesture object. See the
// wl_pointer_gesture_hold interface for details.
func (proxy *ZwpPointerGesturesV1) GetHoldGesture(connection Connection, aPointer ObjectID) (aID *ZwpPointerGestureHoldV1, err error) {
	aID = &ZwpPointerGestureHoldV1{connection.NewID()}
	request := ZwpPointerGesturesV1GetHoldGestureRequest{
		ID:      aID.id,
		Pointer: aPointer,
	}
	err = connection.SendRequest(proxy.id, &request)
	if err == nil {
		connection.RegisterProxy(aID)
	}
	return
}

// Ensure ZwpPointerGesturesV1 implements Proxy.
var _ Proxy = &ZwpPointerGesturesV1{}

// #endregion Interface pointer_gestures_unstable_v1.zwp_pointer_gestures_v1

// ----------------------------------------------------------------------------
// #region Interface pointer_gestures_unstable_v1.zwp_pointer_gesture_swipe_v1

// ZwpPointerGestureSwipeV1DestroyRequest requests to destroy the pointer swipe gesture object
type ZwpPointerGestureSwipeV1DestroyRequest struct {
}

// Opcode returns the request opcode for zwp_pointer_gesture_swipe_v1.destroy in pointer_gestures_unstable_v1
func (ZwpPointerGestureSwipeV1DestroyRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for zwp_pointer_gesture_swipe_v1.destroy in pointer_gestures_unstable_v1
func (ZwpPointerGestureSwipeV1DestroyRequest) MessageName() string { return "destroy" }

// Ensure ZwpPointerGestureSwipeV1DestroyRequest implements Message.
var _ Message = ZwpPointerGestureSwipeV1DestroyRequest{}

// Emit emits the message to the emitter.
func (r *ZwpPointerGestureSwipeV1DestroyRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure ZwpPointerGestureSwipeV1DestroyRequest implements Request.
var _ Request = &ZwpPointerGestureSwipeV1DestroyRequest{}

// ZwpPointerGestureSwipeV1BeginEvent signals when multi-finger swipe begin
//
// This event is sent when a multi-finger swipe gesture is detected
// on the device.
type ZwpPointerGestureSwipeV1BeginEvent struct {
	Serial uint32

	// Time contains timestamp with millisecond granularity
	Time uint32

	Surface ObjectID

	// Fingers contains number of fingers
	Fingers uint32
}

// Opcode returns the event opcode for zwp_pointer_gesture_swipe_v1.begin in pointer_gestures_unstable_v1
func (ZwpPointerGestureSwipeV1BeginEvent) Opcode() uint16 { return 0 }

// MessageName returns the event name for zwp_pointer_gesture_swipe_v1.begin in pointer_gestures_unstable_v1
func (ZwpPointerGestureSwipeV1BeginEvent) MessageName() string { return "begin" }

// Ensure ZwpPointerGestureSwipeV1BeginEvent implements Message.
var _ Message = ZwpPointerGestureSwipeV1BeginEvent{}

// Scan scans the event from the socket.
func (e *ZwpPointerGestureSwipeV1BeginEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Serial = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Time = v
	}
	if v, err := s.ObjectID(); err != nil {
		return err
	} else {
		e.Surface = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Fingers = v
	}
	return nil
}

// Ensure ZwpPointerGestureSwipeV1BeginEvent implements Event.
var _ Event = &ZwpPointerGestureSwipeV1BeginEvent{}

// ZwpPointerGestureSwipeV1UpdateEvent signals when multi-finger swipe motion
//
// This event is sent when a multi-finger swipe gesture changes the
// position of the logical center.
//
// The dx and dy coordinates are relative coordinates of the logical
// center of the gesture compared to the previous event.
type ZwpPointerGestureSwipeV1UpdateEvent struct {
	// Time contains timestamp with millisecond granularity
	Time uint32

	// Dx contains delta x coordinate in surface coordinate space
	Dx Fixed

	// Dy contains delta y coordinate in surface coordinate space
	Dy Fixed
}

// Opcode returns the event opcode for zwp_pointer_gesture_swipe_v1.update in pointer_gestures_unstable_v1
func (ZwpPointerGestureSwipeV1UpdateEvent) Opcode() uint16 { return 1 }

// MessageName returns the event name for zwp_pointer_gesture_swipe_v1.update in pointer_gestures_unstable_v1
func (ZwpPointerGestureSwipeV1UpdateEvent) MessageName() string { return "update" }

// Ensure ZwpPointerGestureSwipeV1UpdateEvent implements Message.
var _ Message = ZwpPointerGestureSwipeV1UpdateEvent{}

// Scan scans the event from the socket.
func (e *ZwpPointerGestureSwipeV1UpdateEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Time = v
	}
	if v, err := s.Fixed(); err != nil {
		return err
	} else {
		e.Dx = v
	}
	if v, err := s.Fixed(); err != nil {
		return err
	} else {
		e.Dy = v
	}
	return nil
}

// Ensure ZwpPointerGestureSwipeV1UpdateEvent implements Event.
var _ Event = &ZwpPointerGestureSwipeV1UpdateEvent{}

// ZwpPointerGestureSwipeV1EndEvent signals when multi-finger swipe end
//
// This event is sent when a multi-finger swipe gesture ceases to
// be valid. This may happen when one or more fingers are lifted or
// the gesture is cancelled.
//
// When a gesture is cancelled, the client should undo state changes
// caused by this gesture. What causes a gesture to be cancelled is
// implementation-dependent.
type ZwpPointerGestureSwipeV1EndEvent struct {
	Serial uint32

	// Time contains timestamp with millisecond granularity
	Time uint32

	// Cancelled contains 1 if the gesture was cancelled, 0 otherwise
	Cancelled int32
}

// Opcode returns the event opcode for zwp_pointer_gesture_swipe_v1.end in pointer_gestures_unstable_v1
func (ZwpPointerGestureSwipeV1EndEvent) Opcode() uint16 { return 2 }

// MessageName returns the event name for zwp_pointer_gesture_swipe_v1.end in pointer_gestures_unstable_v1
func (ZwpPointerGestureSwipeV1EndEvent) MessageName() string { return "end" }

// Ensure ZwpPointerGestureSwipeV1EndEvent implements Message.
var _ Message = ZwpPointerGestureSwipeV1EndEvent{}

// Scan scans the event from the socket.
func (e *ZwpPointerGestureSwipeV1EndEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Serial = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Time = v
	}
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.Cancelled = v
	}
	return nil
}

// Ensure ZwpPointerGestureSwipeV1EndEvent implements Event.
var _ Event = &ZwpPointerGestureSwipeV1EndEvent{}

// ZwpPointerGestureSwipeV1 a swipe gesture object
//
// A swipe gesture object notifies a client about a multi-finger swipe
// gesture detected on an indirect input device such as a touchpad.
// The gesture is usually initiated by multiple fingers moving in the
// same direction but once initiated the direction may change.
// The precise conditions of when such a gesture is detected are
// implementation-dependent.
//
// A gesture consists of three stages: begin, update (optional) and end.
// There cannot be multiple simultaneous hold, pinch or swipe gestures on a
// same pointer/seat, how compositors prevent these situations is
// implementation-dependent.
//
// A gesture may be cancelled by the compositor or the hardware.
// Clients should not consider performing permanent or irreversible
// actions until the end of a gesture has been received.
type ZwpPointerGestureSwipeV1 struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *ZwpPointerGestureSwipeV1) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (ZwpPointerGestureSwipeV1) Descriptor() *InterfaceDescriptor {
	return &ZwpPointerGestureSwipeV1Descriptor
}

// Dispatch returns an Event object for a given opcode.
func (ZwpPointerGestureSwipeV1) Dispatch(opcode uint16) Event {
	switch opcode {
	case 0:
		return &ZwpPointerGestureSwipeV1BeginEvent{}
	case 1:
		return &ZwpPointerGestureSwipeV1UpdateEvent{}
	case 2:
		return &ZwpPointerGestureSwipeV1EndEvent{}
	default:
		return nil
	}
}

// Destroy requests to destroy the pointer swipe gesture object
func (proxy *ZwpPointerGestureSwipeV1) Destroy(connection Connection) (err error) {
	request := ZwpPointerGestureSwipeV1DestroyRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Ensure ZwpPointerGestureSwipeV1 implements Proxy.
var _ Proxy = &ZwpPointerGestureSwipeV1{}

// #endregion Interface pointer_gestures_unstable_v1.zwp_pointer_gesture_swipe_v1

// ----------------------------------------------------------------------------
// #region Interface pointer_gestures_unstable_v1.zwp_pointer_gesture_pinch_v1

// ZwpPointerGesturePinchV1DestroyRequest requests to destroy the pinch gesture object
type ZwpPointerGesturePinchV1DestroyRequest struct {
}

// Opcode returns the request opcode for zwp_pointer_gesture_pinch_v1.destroy in pointer_gestures_unstable_v1
func (ZwpPointerGesturePinchV1DestroyRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for zwp_pointer_gesture_pinch_v1.destroy in pointer_gestures_unstable_v1
func (ZwpPointerGesturePinchV1DestroyRequest) MessageName() string { return "destroy" }

// Ensure ZwpPointerGesturePinchV1DestroyRequest implements Message.
var _ Message = ZwpPointerGesturePinchV1DestroyRequest{}

// Emit emits the message to the emitter.
func (r *ZwpPointerGesturePinchV1DestroyRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure ZwpPointerGesturePinchV1DestroyRequest implements Request.
var _ Request = &ZwpPointerGesturePinchV1DestroyRequest{}

// ZwpPointerGesturePinchV1BeginEvent signals when multi-finger pinch begin
//
// This event is sent when a multi-finger pinch gesture is detected
// on the device.
type ZwpPointerGesturePinchV1BeginEvent struct {
	Serial uint32

	// Time contains timestamp with millisecond granularity
	Time uint32

	Surface ObjectID

	// Fingers contains number of fingers
	Fingers uint32
}

// Opcode returns the event opcode for zwp_pointer_gesture_pinch_v1.begin in pointer_gestures_unstable_v1
func (ZwpPointerGesturePinchV1BeginEvent) Opcode() uint16 { return 0 }

// MessageName returns the event name for zwp_pointer_gesture_pinch_v1.begin in pointer_gestures_unstable_v1
func (ZwpPointerGesturePinchV1BeginEvent) MessageName() string { return "begin" }

// Ensure ZwpPointerGesturePinchV1BeginEvent implements Message.
var _ Message = ZwpPointerGesturePinchV1BeginEvent{}

// Scan scans the event from the socket.
func (e *ZwpPointerGesturePinchV1BeginEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Serial = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Time = v
	}
	if v, err := s.ObjectID(); err != nil {
		return err
	} else {
		e.Surface = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Fingers = v
	}
	return nil
}

// Ensure ZwpPointerGesturePinchV1BeginEvent implements Event.
var _ Event = &ZwpPointerGesturePinchV1BeginEvent{}

// ZwpPointerGesturePinchV1UpdateEvent signals when multi-finger pinch motion
//
// This event is sent when a multi-finger pinch gesture changes the
// position of the logical center, the rotation or the relative scale.
//
// The dx and dy coordinates are relative coordinates in the
// surface coordinate space of the logical center of the gesture.
//
// The scale factor is an absolute scale compared to the
// pointer_gesture_pinch.begin event, e.g. a scale of 2 means the fingers
// are now twice as far apart as on pointer_gesture_pinch.begin.
//
// The rotation is the relative angle in degrees clockwise compared to the previous
// pointer_gesture_pinch.begin or pointer_gesture_pinch.update event.
type ZwpPointerGesturePinchV1UpdateEvent struct {
	// Time contains timestamp with millisecond granularity
	Time uint32

	// Dx contains delta x coordinate in surface coordinate space
	Dx Fixed

	// Dy contains delta y coordinate in surface coordinate space
	Dy Fixed

	// Scale contains scale relative to the initial finger position
	Scale Fixed

	// Rotation contains angle in degrees cw relative to the previous event
	Rotation Fixed
}

// Opcode returns the event opcode for zwp_pointer_gesture_pinch_v1.update in pointer_gestures_unstable_v1
func (ZwpPointerGesturePinchV1UpdateEvent) Opcode() uint16 { return 1 }

// MessageName returns the event name for zwp_pointer_gesture_pinch_v1.update in pointer_gestures_unstable_v1
func (ZwpPointerGesturePinchV1UpdateEvent) MessageName() string { return "update" }

// Ensure ZwpPointerGesturePinchV1UpdateEvent implements Message.
var _ Message = ZwpPointerGesturePinchV1UpdateEvent{}

// Scan scans the event from the socket.
func (e *ZwpPointerGesturePinchV1UpdateEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Time = v
	}
	if v, err := s.Fixed(); err != nil {
		return err
	} else {
		e.Dx = v
	}
	if v, err := s.Fixed(); err != nil {
		return err
	} else {
		e.Dy = v
	}
	if v, err := s.Fixed(); err != nil {
		return err
	} else {
		e.Scale = v
	}
	if v, err := s.Fixed(); err != nil {
		return err
	} else {
		e.Rotation = v
	}
	return nil
}

// Ensure ZwpPointerGesturePinchV1UpdateEvent implements Event.
var _ Event = &ZwpPointerGesturePinchV1UpdateEvent{}

// ZwpPointerGesturePinchV1EndEvent signals when multi-finger pinch end
//
// This event is sent when a multi-finger pinch gesture ceases to
// be valid. This may happen when one or more fingers are lifted or
// the gesture is cancelled.
//
// When a gesture is cancelled, the client should undo state changes
// caused by this gesture. What causes a gesture to be cancelled is
// implementation-dependent.
type ZwpPointerGesturePinchV1EndEvent struct {
	Serial uint32

	// Time contains timestamp with millisecond granularity
	Time uint32

	// Cancelled contains 1 if the gesture was cancelled, 0 otherwise
	Cancelled int32
}

// Opcode returns the event opcode for zwp_pointer_gesture_pinch_v1.end in pointer_gestures_unstable_v1
func (ZwpPointerGesturePinchV1EndEvent) Opcode() uint16 { return 2 }

// MessageName returns the event name for zwp_pointer_gesture_pinch_v1.end in pointer_gestures_unstable_v1
func (ZwpPointerGesturePinchV1EndEvent) MessageName() string { return "end" }

// Ensure ZwpPointerGesturePinchV1EndEvent implements Message.
var _ Message = ZwpPointerGesturePinchV1EndEvent{}

// Scan scans the event from the socket.
func (e *ZwpPointerGesturePinchV1EndEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Serial = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Time = v
	}
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.Cancelled = v
	}
	return nil
}

// Ensure ZwpPointerGesturePinchV1EndEvent implements Event.
var _ Event = &ZwpPointerGesturePinchV1EndEvent{}

// ZwpPointerGesturePinchV1 a pinch gesture object
//
// A pinch gesture object notifies a client about a multi-finger pinch
// gesture detected on an indirect input device such as a touchpad.
// The gesture is usually initiated by multiple fingers moving towards
// each other or away from each other, or by two or more fingers rotating
// around a logical center of gravity. The precise conditions of when
// such a gesture is detected are implementation-dependent.
//
// A gesture consists of three stages: begin, update (optional) and end.
// There cannot be multiple simultaneous hold, pinch or swipe gestures on a
// same pointer/seat, how compositors prevent these situations is
// implementation-dependent.
//
// A gesture may be cancelled by the compositor or the hardware.
// Clients should not consider performing permanent or irreversible
// actions until the end of a gesture has been received.
type ZwpPointerGesturePinchV1 struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *ZwpPointerGesturePinchV1) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (ZwpPointerGesturePinchV1) Descriptor() *InterfaceDescriptor {
	return &ZwpPointerGesturePinchV1Descriptor
}

// Dispatch returns an Event object for a given opcode.
func (ZwpPointerGesturePinchV1) Dispatch(opcode uint16) Event {
	switch opcode {
	case 0:
		return &ZwpPointerGesturePinchV1BeginEvent{}
	case 1:
		return &ZwpPointerGesturePinchV1UpdateEvent{}
	case 2:
		return &ZwpPointerGesturePinchV1EndEvent{}
	default:
		return nil
	}
}

// Destroy requests to destroy the pinch gesture object
func (proxy *ZwpPointerGesturePinchV1) Destroy(connection Connection) (err error) {
	request := ZwpPointerGesturePinchV1DestroyRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Ensure ZwpPointerGesturePinchV1 implements Proxy.
var _ Proxy = &ZwpPointerGesturePinchV1{}

// #endregion Interface pointer_gestures_unstable_v1.zwp_pointer_gesture_pinch_v1

// ----------------------------------------------------------------------------
// #region Interface pointer_gestures_unstable_v1.zwp_pointer_gesture_hold_v1

// ZwpPointerGestureHoldV1DestroyRequest requests to destroy the hold gesture object
type ZwpPointerGestureHoldV1DestroyRequest struct {
}

// Opcode returns the request opcode for zwp_pointer_gesture_hold_v1.destroy in pointer_gestures_unstable_v1
func (ZwpPointerGestureHoldV1DestroyRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for zwp_pointer_gesture_hold_v1.destroy in pointer_gestures_unstable_v1
func (ZwpPointerGestureHoldV1DestroyRequest) MessageName() string { return "destroy" }

// Ensure ZwpPointerGestureHoldV1DestroyRequest implements Message.
var _ Message = ZwpPointerGestureHoldV1DestroyRequest{}

// Emit emits the message to the emitter.
func (r *ZwpPointerGestureHoldV1DestroyRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure ZwpPointerGestureHoldV1DestroyRequest implements Request.
var _ Request = &ZwpPointerGestureHoldV1DestroyRequest{}

// ZwpPointerGestureHoldV1BeginEvent signals when multi-finger hold begin
//
// This event is sent when a hold gesture is detected on the device.
type ZwpPointerGestureHoldV1BeginEvent struct {
	Serial uint32

	// Time contains timestamp with millisecond granularity
	Time uint32

	Surface ObjectID

	// Fingers contains number of fingers
	Fingers uint32
}

// Opcode returns the event opcode for zwp_pointer_gesture_hold_v1.begin in pointer_gestures_unstable_v1
func (ZwpPointerGestureHoldV1BeginEvent) Opcode() uint16 { return 0 }

// MessageName returns the event name for zwp_pointer_gesture_hold_v1.begin in pointer_gestures_unstable_v1
func (ZwpPointerGestureHoldV1BeginEvent) MessageName() string { return "begin" }

// Ensure ZwpPointerGestureHoldV1BeginEvent implements Message.
var _ Message = ZwpPointerGestureHoldV1BeginEvent{}

// Scan scans the event from the socket.
func (e *ZwpPointerGestureHoldV1BeginEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Serial = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Time = v
	}
	if v, err := s.ObjectID(); err != nil {
		return err
	} else {
		e.Surface = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Fingers = v
	}
	return nil
}

// Ensure ZwpPointerGestureHoldV1BeginEvent implements Event.
var _ Event = &ZwpPointerGestureHoldV1BeginEvent{}

// ZwpPointerGestureHoldV1EndEvent signals when multi-finger hold end
//
// This event is sent when a hold gesture ceases to
// be valid. This may happen when the holding fingers are lifted or
// the gesture is cancelled, for example if the fingers move past an
// implementation-defined threshold, the finger count changes or the hold
// gesture changes into a different type of gesture.
//
// When a gesture is cancelled, the client may need to undo state changes
// caused by this gesture. What causes a gesture to be cancelled is
// implementation-dependent.
type ZwpPointerGestureHoldV1EndEvent struct {
	Serial uint32

	// Time contains timestamp with millisecond granularity
	Time uint32

	// Cancelled contains 1 if the gesture was cancelled, 0 otherwise
	Cancelled int32
}

// Opcode returns the event opcode for zwp_pointer_gesture_hold_v1.end in pointer_gestures_unstable_v1
func (ZwpPointerGestureHoldV1EndEvent) Opcode() uint16 { return 1 }

// MessageName returns the event name for zwp_pointer_gesture_hold_v1.end in pointer_gestures_unstable_v1
func (ZwpPointerGestureHoldV1EndEvent) MessageName() string { return "end" }

// Ensure ZwpPointerGestureHoldV1EndEvent implements Message.
var _ Message = ZwpPointerGestureHoldV1EndEvent{}

// Scan scans the event from the socket.
func (e *ZwpPointerGestureHoldV1EndEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Serial = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Time = v
	}
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.Cancelled = v
	}
	return nil
}

// Ensure ZwpPointerGestureHoldV1EndEvent implements Event.
var _ Event = &ZwpPointerGestureHoldV1EndEvent{}

// ZwpPointerGestureHoldV1 a hold gesture object
//
// A hold gesture object notifies a client about a single- or
// multi-finger hold gesture detected on an indirect input device such as
// a touchpad. The gesture is usually initiated by one or more fingers
// being held down without significant movement. The precise conditions
// of when such a gesture is detected are implementation-dependent.
//
// In particular, this gesture may be used to cancel kinetic scrolling.
//
// A hold gesture consists of two stages: begin and end. Unlike pinch and
// swipe there is no update stage.
// There cannot be multiple simultaneous hold, pinch or swipe gestures on a
// same pointer/seat, how compositors prevent these situations is
// implementation-dependent.
//
// A gesture may be cancelled by the compositor or the hardware.
// Clients should not consider performing permanent or irreversible
// actions until the end of a gesture has been received.
type ZwpPointerGestureHoldV1 struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *ZwpPointerGestureHoldV1) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (ZwpPointerGestureHoldV1) Descriptor() *InterfaceDescriptor {
	return &ZwpPointerGestureHoldV1Descriptor
}

// Dispatch returns an Event object for a given opcode.
func (ZwpPointerGestureHoldV1) Dispatch(opcode uint16) Event {
	switch opcode {
	case 0:
		return &ZwpPointerGestureHoldV1BeginEvent{}
	case 1:
		return &ZwpPointerGestureHoldV1EndEvent{}
	default:
		return nil
	}
}

// Destroy requests to destroy the hold gesture object
func (proxy *ZwpPointerGestureHoldV1) Destroy(connection Connection) (err error) {
	request := ZwpPointerGestureHoldV1DestroyRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Ensure ZwpPointerGestureHoldV1 implements Proxy.
var _ Proxy = &ZwpPointerGestureHoldV1{}

// #endregion Interface pointer_gestures_unstable_v1.zwp_pointer_gesture_hold_v1

////////////////////////////////////////////////////////////////////////////////
// #endregion Protocol pointer_gestures_unstable_v1

////////////////////////////////////////////////////////////////////////////////
// #region Protocol presentation_time

// ----------------------------------------------------------------------------
// #region Interface presentation_time.wp_presentation

// WpPresentationError represents fatal presentation errors
//
// These fatal protocol errors may be emitted in response to
// illegal presentation requests.
type WpPresentationError int

const (
	// WpPresentationErrorInvalidTimestamp corresponds to invalid value in tv_nsec
	WpPresentationErrorInvalidTimestamp WpPresentationError = 0

	// WpPresentationErrorInvalidFlag corresponds to invalid flag
	WpPresentationErrorInvalidFlag WpPresentationError = 1
)

// WpPresentationDestroyRequest requests to unbind from the presentation interface
//
// Informs the server that the client will no longer be using
// this protocol object. Existing objects created by this object
// are not affected.
type WpPresentationDestroyRequest struct {
}

// Opcode returns the request opcode for wp_presentation.destroy in presentation_time
func (WpPresentationDestroyRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for wp_presentation.destroy in presentation_time
func (WpPresentationDestroyRequest) MessageName() string { return "destroy" }

// Ensure WpPresentationDestroyRequest implements Message.
var _ Message = WpPresentationDestroyRequest{}

// Emit emits the message to the emitter.
func (r *WpPresentationDestroyRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure WpPresentationDestroyRequest implements Request.
var _ Request = &WpPresentationDestroyRequest{}

// WpPresentationFeedbackRequest requests to request presentation feedback information
//
// Request presentation feedback for the current content submission
// on the given surface. This creates a new presentation_feedback
// object, which will deliver the feedback information once. If
// multiple presentation_feedback objects are created for the same
// submission, they will all deliver the same information.
//
// For details on what information is returned, see the
// presentation_feedback interface.
type WpPresentationFeedbackRequest struct {
	// Surface contains target surface
	Surface ObjectID

	// Callback contains new feedback object
	Callback ObjectID
}

// Opcode returns the request opcode for wp_presentation.feedback in presentation_time
func (WpPresentationFeedbackRequest) Opcode() uint16 { return 1 }

// MessageName returns the request name for wp_presentation.feedback in presentation_time
func (WpPresentationFeedbackRequest) MessageName() string { return "feedback" }

// Ensure WpPresentationFeedbackRequest implements Message.
var _ Message = WpPresentationFeedbackRequest{}

// Emit emits the message to the emitter.
func (r *WpPresentationFeedbackRequest) Emit(e *RequestEmitter) error {
	if err := e.PutObjectID(r.Surface); err != nil {
		return err
	}
	if err := e.PutObjectID(r.Callback); err != nil {
		return err
	}
	return nil
}

// Ensure WpPresentationFeedbackRequest implements Request.
var _ Request = &WpPresentationFeedbackRequest{}

// WpPresentationClockIDEvent signals when clock ID for timestamps
//
// This event tells the client in which clock domain the
// compositor interprets the timestamps used by the presentation
// extension. This clock is called the presentation clock.
//
// The compositor sends this event when the client binds to the
// presentation interface. The presentation clock does not change
// during the lifetime of the client connection.
//
// The clock identifier is platform dependent. On Linux/glibc,
// the identifier value is one of the clockid_t values accepted
// by clock_gettime(). clock_gettime() is defined by
// POSIX.1-2001.
//
// Timestamps in this clock domain are expressed as tv_sec_hi,
// tv_sec_lo, tv_nsec triples, each component being an unsigned
// 32-bit value. Whole seconds are in tv_sec which is a 64-bit
// value combined from tv_sec_hi and tv_sec_lo, and the
// additional fractional part in tv_nsec as nanoseconds. Hence,
// for valid timestamps tv_nsec must be in [0, 999999999].
//
// Note that clock_id applies only to the presentation clock,
// and implies nothing about e.g. the timestamps used in the
// Wayland core protocol input events.
//
// Compositors should prefer a clock which does not jump and is
// not slewed e.g. by NTP. The absolute value of the clock is
// irrelevant. Precision of one millisecond or better is
// recommended. Clients must be able to query the current clock
// value directly, not by asking the compositor.
type WpPresentationClockIDEvent struct {
	// ClkID contains platform clock identifier
	ClkID uint32
}

// Opcode returns the event opcode for wp_presentation.clock_id in presentation_time
func (WpPresentationClockIDEvent) Opcode() uint16 { return 0 }

// MessageName returns the event name for wp_presentation.clock_id in presentation_time
func (WpPresentationClockIDEvent) MessageName() string { return "clock_id" }

// Ensure WpPresentationClockIDEvent implements Message.
var _ Message = WpPresentationClockIDEvent{}

// Scan scans the event from the socket.
func (e *WpPresentationClockIDEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.ClkID = v
	}
	return nil
}

// Ensure WpPresentationClockIDEvent implements Event.
var _ Event = &WpPresentationClockIDEvent{}

// WpPresentation timed presentation related wl_surface requests
//
// The main feature of this interface is accurate presentation
// timing feedback to ensure smooth video playback while maintaining
// audio/video synchronization. Some features use the concept of a
// presentation clock, which is defined in the
// presentation.clock_id event.
//
// A content update for a wl_surface is submitted by a
// wl_surface.commit request. Request 'feedback' associates with
// the wl_surface.commit and provides feedback on the content
// update, particularly the final realized presentation time.
//
//
//
// When the final realized presentation time is available, e.g.
// after a framebuffer flip completes, the requested
// presentation_feedback.presented events are sent. The final
// presentation time can differ from the compositor's predicted
// display update time and the update's target time, especially
// when the compositor misses its target vertical blanking period.
type WpPresentation struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *WpPresentation) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (WpPresentation) Descriptor() *InterfaceDescriptor {
	return &WpPresentationDescriptor
}

// Dispatch returns an Event object for a given opcode.
func (WpPresentation) Dispatch(opcode uint16) Event {
	switch opcode {
	case 0:
		return &WpPresentationClockIDEvent{}
	default:
		return nil
	}
}

// Destroy requests to unbind from the presentation interface
//
// Informs the server that the client will no longer be using
// this protocol object. Existing objects created by this object
// are not affected.
func (proxy *WpPresentation) Destroy(connection Connection) (err error) {
	request := WpPresentationDestroyRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Feedback requests to request presentation feedback information
//
// Request presentation feedback for the current content submission
// on the given surface. This creates a new presentation_feedback
// object, which will deliver the feedback information once. If
// multiple presentation_feedback objects are created for the same
// submission, they will all deliver the same information.
//
// For details on what information is returned, see the
// presentation_feedback interface.
func (proxy *WpPresentation) Feedback(connection Connection, aSurface ObjectID) (aCallback *WpPresentationFeedback, err error) {
	aCallback = &WpPresentationFeedback{connection.NewID()}
	request := WpPresentationFeedbackRequest{
		Surface:  aSurface,
		Callback: aCallback.id,
	}
	err = connection.SendRequest(proxy.id, &request)
	if err == nil {
		connection.RegisterProxy(aCallback)
	}
	return
}

// Ensure WpPresentation implements Proxy.
var _ Proxy = &WpPresentation{}

// #endregion Interface presentation_time.wp_presentation

// ----------------------------------------------------------------------------
// #region Interface presentation_time.wp_presentation_feedback

// WpPresentationFeedbackKind represents bitmask of flags in presented event
//
// These flags provide information about how the presentation of
// the related content update was done. The intent is to help
// clients assess the reliability of the feedback and the visual
// quality with respect to possible tearing and timings.
type WpPresentationFeedbackKind uint

const (
	WpPresentationFeedbackKindVsync WpPresentationFeedbackKind = 0x1

	WpPresentationFeedbackKindHwClock WpPresentationFeedbackKind = 0x2

	WpPresentationFeedbackKindHwCompletion WpPresentationFeedbackKind = 0x4

	WpPresentationFeedbackKindZeroCopy WpPresentationFeedbackKind = 0x8
)

// WpPresentationFeedbackSyncOutputEvent signals when presentation synchronized to this output
//
// As presentation can be synchronized to only one output at a
// time, this event tells which output it was. This event is only
// sent prior to the presented event.
//
// As clients may bind to the same global wl_output multiple
// times, this event is sent for each bound instance that matches
// the synchronized output. If a client has not bound to the
// right wl_output global at all, this event is not sent.
type WpPresentationFeedbackSyncOutputEvent struct {
	// Output contains presentation output
	Output ObjectID
}

// Opcode returns the event opcode for wp_presentation_feedback.sync_output in presentation_time
func (WpPresentationFeedbackSyncOutputEvent) Opcode() uint16 { return 0 }

// MessageName returns the event name for wp_presentation_feedback.sync_output in presentation_time
func (WpPresentationFeedbackSyncOutputEvent) MessageName() string { return "sync_output" }

// Ensure WpPresentationFeedbackSyncOutputEvent implements Message.
var _ Message = WpPresentationFeedbackSyncOutputEvent{}

// Scan scans the event from the socket.
func (e *WpPresentationFeedbackSyncOutputEvent) Scan(s *EventScanner) error {
	if v, err := s.ObjectID(); err != nil {
		return err
	} else {
		e.Output = v
	}
	return nil
}

// Ensure WpPresentationFeedbackSyncOutputEvent implements Event.
var _ Event = &WpPresentationFeedbackSyncOutputEvent{}

// WpPresentationFeedbackPresentedEvent signals when the content update was displayed
//
// The associated content update was displayed to the user at the
// indicated time (tv_sec_hi/lo, tv_nsec). For the interpretation of
// the timestamp, see presentation.clock_id event.
//
// The timestamp corresponds to the time when the content update
// turned into light the first time on the surface's main output.
// Compositors may approximate this from the framebuffer flip
// completion events from the system, and the latency of the
// physical display path if known.
//
// This event is preceded by all related sync_output events
// telling which output's refresh cycle the feedback corresponds
// to, i.e. the main output for the surface. Compositors are
// recommended to choose the output containing the largest part
// of the wl_surface, or keeping the output they previously
// chose. Having a stable presentation output association helps
// clients predict future output refreshes (vblank).
//
// The 'refresh' argument gives the compositor's prediction of how
// many nanoseconds after tv_sec, tv_nsec the very next output
// refresh may occur. This is to further aid clients in
// predicting future refreshes, i.e., estimating the timestamps
// targeting the next few vblanks. If such prediction cannot
// usefully be done, the argument is zero.
//
// If the output does not have a constant refresh rate, explicit
// video mode switches excluded, then the refresh argument must
// be zero.
//
// The 64-bit value combined from seq_hi and seq_lo is the value
// of the output's vertical retrace counter when the content
// update was first scanned out to the display. This value must
// be compatible with the definition of MSC in
// GLX_OML_sync_control specification. Note, that if the display
// path has a non-zero latency, the time instant specified by
// this counter may differ from the timestamp's.
//
// If the output does not have a concept of vertical retrace or a
// refresh cycle, or the output device is self-refreshing without
// a way to query the refresh count, then the arguments seq_hi
// and seq_lo must be zero.
type WpPresentationFeedbackPresentedEvent struct {
	// TvSecHi contains high 32 bits of the seconds part of the presentation timestamp
	TvSecHi uint32

	// TvSecLo contains low 32 bits of the seconds part of the presentation timestamp
	TvSecLo uint32

	// TvNsec contains nanoseconds part of the presentation timestamp
	TvNsec uint32

	// Refresh contains nanoseconds till next refresh
	Refresh uint32

	// SeqHi contains high 32 bits of refresh counter
	SeqHi uint32

	// SeqLo contains low 32 bits of refresh counter
	SeqLo uint32

	// Flags contains combination of 'kind' values
	Flags uint32
}

// Opcode returns the event opcode for wp_presentation_feedback.presented in presentation_time
func (WpPresentationFeedbackPresentedEvent) Opcode() uint16 { return 1 }

// MessageName returns the event name for wp_presentation_feedback.presented in presentation_time
func (WpPresentationFeedbackPresentedEvent) MessageName() string { return "presented" }

// Ensure WpPresentationFeedbackPresentedEvent implements Message.
var _ Message = WpPresentationFeedbackPresentedEvent{}

// Scan scans the event from the socket.
func (e *WpPresentationFeedbackPresentedEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.TvSecHi = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.TvSecLo = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.TvNsec = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Refresh = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.SeqHi = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.SeqLo = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Flags = v
	}
	return nil
}

// Ensure WpPresentationFeedbackPresentedEvent implements Event.
var _ Event = &WpPresentationFeedbackPresentedEvent{}

// WpPresentationFeedbackDiscardedEvent signals when the content update was not displayed
//
// The content update was never displayed to the user.
type WpPresentationFeedbackDiscardedEvent struct {
}

// Opcode returns the event opcode for wp_presentation_feedback.discarded in presentation_time
func (WpPresentationFeedbackDiscardedEvent) Opcode() uint16 { return 2 }

// MessageName returns the event name for wp_presentation_feedback.discarded in presentation_time
func (WpPresentationFeedbackDiscardedEvent) MessageName() string { return "discarded" }

// Ensure WpPresentationFeedbackDiscardedEvent implements Message.
var _ Message = WpPresentationFeedbackDiscardedEvent{}

// Scan scans the event from the socket.
func (e *WpPresentationFeedbackDiscardedEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure WpPresentationFeedbackDiscardedEvent implements Event.
var _ Event = &WpPresentationFeedbackDiscardedEvent{}

// WpPresentationFeedback presentation time feedback event
//
// A presentation_feedback object returns an indication that a
// wl_surface content update has become visible to the user.
// One object corresponds to one content update submission
// (wl_surface.commit). There are two possible outcomes: the
// content update is presented to the user, and a presentation
// timestamp delivered; or, the user did not see the content
// update because it was superseded or its surface destroyed,
// and the content update is discarded.
//
// Once a presentation_feedback object has delivered a 'presented'
// or 'discarded' event it is automatically destroyed.
type WpPresentationFeedback struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *WpPresentationFeedback) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (WpPresentationFeedback) Descriptor() *InterfaceDescriptor {
	return &WpPresentationFeedbackDescriptor
}

// Dispatch returns an Event object for a given opcode.
func (WpPresentationFeedback) Dispatch(opcode uint16) Event {
	switch opcode {
	case 0:
		return &WpPresentationFeedbackSyncOutputEvent{}
	case 1:
		return &WpPresentationFeedbackPresentedEvent{}
	case 2:
		return &WpPresentationFeedbackDiscardedEvent{}
	default:
		return nil
	}
}

// Ensure WpPresentationFeedback implements Proxy.
var _ Proxy = &WpPresentationFeedback{}

// #endregion Interface presentation_time.wp_presentation_feedback

////////////////////////////////////////////////////////////////////////////////
// #endregion Protocol presentation_time

////////////////////////////////////////////////////////////////////////////////
// #region Protocol relative_pointer_unstable_v1

// ----------------------------------------------------------------------------
// #region Interface relative_pointer_unstable_v1.zwp_relative_pointer_manager_v1

// ZwpRelativePointerManagerV1DestroyRequest requests to destroy the relative pointer manager object
//
// Used by the client to notify the server that it will no longer use this
// relative pointer manager object.
type ZwpRelativePointerManagerV1DestroyRequest struct {
}

// Opcode returns the request opcode for zwp_relative_pointer_manager_v1.destroy in relative_pointer_unstable_v1
func (ZwpRelativePointerManagerV1DestroyRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for zwp_relative_pointer_manager_v1.destroy in relative_pointer_unstable_v1
func (ZwpRelativePointerManagerV1DestroyRequest) MessageName() string { return "destroy" }

// Ensure ZwpRelativePointerManagerV1DestroyRequest implements Message.
var _ Message = ZwpRelativePointerManagerV1DestroyRequest{}

// Emit emits the message to the emitter.
func (r *ZwpRelativePointerManagerV1DestroyRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure ZwpRelativePointerManagerV1DestroyRequest implements Request.
var _ Request = &ZwpRelativePointerManagerV1DestroyRequest{}

// ZwpRelativePointerManagerV1GetRelativePointerRequest requests to get a relative pointer object
//
// Create a relative pointer interface given a wl_pointer object. See the
// wp_relative_pointer interface for more details.
type ZwpRelativePointerManagerV1GetRelativePointerRequest struct {
	ID ObjectID

	Pointer ObjectID
}

// Opcode returns the request opcode for zwp_relative_pointer_manager_v1.get_relative_pointer in relative_pointer_unstable_v1
func (ZwpRelativePointerManagerV1GetRelativePointerRequest) Opcode() uint16 { return 1 }

// MessageName returns the request name for zwp_relative_pointer_manager_v1.get_relative_pointer in relative_pointer_unstable_v1
func (ZwpRelativePointerManagerV1GetRelativePointerRequest) MessageName() string {
	return "get_relative_pointer"
}

// Ensure ZwpRelativePointerManagerV1GetRelativePointerRequest implements Message.
var _ Message = ZwpRelativePointerManagerV1GetRelativePointerRequest{}

// Emit emits the message to the emitter.
func (r *ZwpRelativePointerManagerV1GetRelativePointerRequest) Emit(e *RequestEmitter) error {
	if err := e.PutObjectID(r.ID); err != nil {
		return err
	}
	if err := e.PutObjectID(r.Pointer); err != nil {
		return err
	}
	return nil
}

// Ensure ZwpRelativePointerManagerV1GetRelativePointerRequest implements Request.
var _ Request = &ZwpRelativePointerManagerV1GetRelativePointerRequest{}

// ZwpRelativePointerManagerV1 get relative pointer objects
//
// A global interface used for getting the relative pointer object for a
// given pointer.
type ZwpRelativePointerManagerV1 struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *ZwpRelativePointerManagerV1) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (ZwpRelativePointerManagerV1) Descriptor() *InterfaceDescriptor {
	return &ZwpRelativePointerManagerV1Descriptor
}

// Dispatch returns an Event object for a given opcode.
func (ZwpRelativePointerManagerV1) Dispatch(opcode uint16) Event {
	switch opcode {
	default:
		return nil
	}
}

// Destroy requests to destroy the relative pointer manager object
//
// Used by the client to notify the server that it will no longer use this
// relative pointer manager object.
func (proxy *ZwpRelativePointerManagerV1) Destroy(connection Connection) (err error) {
	request := ZwpRelativePointerManagerV1DestroyRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// GetRelativePointer requests to get a relative pointer object
//
// Create a relative pointer interface given a wl_pointer object. See the
// wp_relative_pointer interface for more details.
func (proxy *ZwpRelativePointerManagerV1) GetRelativePointer(connection Connection, aPointer ObjectID) (aID *ZwpRelativePointerV1, err error) {
	aID = &ZwpRelativePointerV1{connection.NewID()}
	request := ZwpRelativePointerManagerV1GetRelativePointerRequest{
		ID:      aID.id,
		Pointer: aPointer,
	}
	err = connection.SendRequest(proxy.id, &request)
	if err == nil {
		connection.RegisterProxy(aID)
	}
	return
}

// Ensure ZwpRelativePointerManagerV1 implements Proxy.
var _ Proxy = &ZwpRelativePointerManagerV1{}

// #endregion Interface relative_pointer_unstable_v1.zwp_relative_pointer_manager_v1

// ----------------------------------------------------------------------------
// #region Interface relative_pointer_unstable_v1.zwp_relative_pointer_v1

// ZwpRelativePointerV1DestroyRequest requests to release the relative pointer object
type ZwpRelativePointerV1DestroyRequest struct {
}

// Opcode returns the request opcode for zwp_relative_pointer_v1.destroy in relative_pointer_unstable_v1
func (ZwpRelativePointerV1DestroyRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for zwp_relative_pointer_v1.destroy in relative_pointer_unstable_v1
func (ZwpRelativePointerV1DestroyRequest) MessageName() string { return "destroy" }

// Ensure ZwpRelativePointerV1DestroyRequest implements Message.
var _ Message = ZwpRelativePointerV1DestroyRequest{}

// Emit emits the message to the emitter.
func (r *ZwpRelativePointerV1DestroyRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure ZwpRelativePointerV1DestroyRequest implements Request.
var _ Request = &ZwpRelativePointerV1DestroyRequest{}

// ZwpRelativePointerV1RelativeMotionEvent signals when relative pointer motion
//
// Relative x/y pointer motion from the pointer of the seat associated with
// this object.
//
// A relative motion is in the same dimension as regular wl_pointer motion
// events, except they do not represent an absolute position. For example,
// moving a pointer from (x, y) to (x', y') would have the equivalent
// relative motion (x' - x, y' - y). If a pointer motion caused the
// absolute pointer position to be clipped by for example the edge of the
// monitor, the relative motion is unaffected by the clipping and will
// represent the unclipped motion.
//
// This event also contains non-accelerated motion deltas. The
// non-accelerated delta is, when applicable, the regular pointer motion
// delta as it was before having applied motion acceleration and other
// transformations such as normalization.
//
// Note that the non-accelerated delta does not represent 'raw' events as
// they were read from some device. Pointer motion acceleration is device-
// and configuration-specific and non-accelerated deltas and accelerated
// deltas may have the same value on some devices.
//
// Relative motions are not coupled to wl_pointer.motion events, and can be
// sent in combination with such events, but also independently. There may
// also be scenarios where wl_pointer.motion is sent, but there is no
// relative motion. The order of an absolute and relative motion event
// originating from the same physical motion is not guaranteed.
//
// If the client needs button events or focus state, it can receive them
// from a wl_pointer object of the same seat that the wp_relative_pointer
// object is associated with.
type ZwpRelativePointerV1RelativeMotionEvent struct {
	// UtimeHi contains high 32 bits of a 64 bit timestamp with microsecond granularity
	UtimeHi uint32

	// UtimeLo contains low 32 bits of a 64 bit timestamp with microsecond granularity
	UtimeLo uint32

	// Dx contains the x component of the motion vector
	Dx Fixed

	// Dy contains the y component of the motion vector
	Dy Fixed

	// DxUnaccel contains the x component of the unaccelerated motion vector
	DxUnaccel Fixed

	// DyUnaccel contains the y component of the unaccelerated motion vector
	DyUnaccel Fixed
}

// Opcode returns the event opcode for zwp_relative_pointer_v1.relative_motion in relative_pointer_unstable_v1
func (ZwpRelativePointerV1RelativeMotionEvent) Opcode() uint16 { return 0 }

// MessageName returns the event name for zwp_relative_pointer_v1.relative_motion in relative_pointer_unstable_v1
func (ZwpRelativePointerV1RelativeMotionEvent) MessageName() string { return "relative_motion" }

// Ensure ZwpRelativePointerV1RelativeMotionEvent implements Message.
var _ Message = ZwpRelativePointerV1RelativeMotionEvent{}

// Scan scans the event from the socket.
func (e *ZwpRelativePointerV1RelativeMotionEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.UtimeHi = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.UtimeLo = v
	}
	if v, err := s.Fixed(); err != nil {
		return err
	} else {
		e.Dx = v
	}
	if v, err := s.Fixed(); err != nil {
		return err
	} else {
		e.Dy = v
	}
	if v, err := s.Fixed(); err != nil {
		return err
	} else {
		e.DxUnaccel = v
	}
	if v, err := s.Fixed(); err != nil {
		return err
	} else {
		e.DyUnaccel = v
	}
	return nil
}

// Ensure ZwpRelativePointerV1RelativeMotionEvent implements Event.
var _ Event = &ZwpRelativePointerV1RelativeMotionEvent{}

// ZwpRelativePointerV1 relative pointer object
//
// A wp_relative_pointer object is an extension to the wl_pointer interface
// used for emitting relative pointer events. It shares the same focus as
// wl_pointer objects of the same seat and will only emit events when it has
// focus.
type ZwpRelativePointerV1 struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *ZwpRelativePointerV1) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (ZwpRelativePointerV1) Descriptor() *InterfaceDescriptor {
	return &ZwpRelativePointerV1Descriptor
}

// Dispatch returns an Event object for a given opcode.
func (ZwpRelativePointerV1) Dispatch(opcode uint16) Event {
	switch opcode {
	case 0:
		return &ZwpRelativePointerV1RelativeMotionEvent{}
	default:
		return nil
	}
}

// Destroy requests to release the relative pointer object
func (proxy *ZwpRelativePointerV1) Destroy(connection Connection) (err error) {
	request := ZwpRelativePointerV1DestroyRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Ensure ZwpRelativePointerV1 implements Proxy.
var _ Proxy = &ZwpRelativePointerV1{}

// #endregion Interface relative_pointer_unstable_v1.zwp_relative_pointer_v1

////////////////////////////////////////////////////////////////////////////////
// #endregion Protocol relative_pointer_unstable_v1

////////////////////////////////////////////////////////////////////////////////
// #region Protocol tablet_unstable_v1

// ----------------------------------------------------------------------------
// #region Interface tablet_unstable_v1.zwp_tablet_manager_v1

// ZwpTabletManagerV1GetTabletSeatRequest requests to get the tablet seat
//
// Get the wp_tablet_seat object for the given seat. This object
// provides access to all graphics tablets in this seat.
type ZwpTabletManagerV1GetTabletSeatRequest struct {
	TabletSeat ObjectID

	// Seat contains The wl_seat object to retrieve the tablets for
	Seat ObjectID
}

// Opcode returns the request opcode for zwp_tablet_manager_v1.get_tablet_seat in tablet_unstable_v1
func (ZwpTabletManagerV1GetTabletSeatRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for zwp_tablet_manager_v1.get_tablet_seat in tablet_unstable_v1
func (ZwpTabletManagerV1GetTabletSeatRequest) MessageName() string { return "get_tablet_seat" }

// Ensure ZwpTabletManagerV1GetTabletSeatRequest implements Message.
var _ Message = ZwpTabletManagerV1GetTabletSeatRequest{}

// Emit emits the message to the emitter.
func (r *ZwpTabletManagerV1GetTabletSeatRequest) Emit(e *RequestEmitter) error {
	if err := e.PutObjectID(r.TabletSeat); err != nil {
		return err
	}
	if err := e.PutObjectID(r.Seat); err != nil {
		return err
	}
	return nil
}

// Ensure ZwpTabletManagerV1GetTabletSeatRequest implements Request.
var _ Request = &ZwpTabletManagerV1GetTabletSeatRequest{}

// ZwpTabletManagerV1DestroyRequest requests to release the memory for the tablet manager object
//
// Destroy the wp_tablet_manager object. Objects created from this
// object are unaffected and should be destroyed separately.
type ZwpTabletManagerV1DestroyRequest struct {
}

// Opcode returns the request opcode for zwp_tablet_manager_v1.destroy in tablet_unstable_v1
func (ZwpTabletManagerV1DestroyRequest) Opcode() uint16 { return 1 }

// MessageName returns the request name for zwp_tablet_manager_v1.destroy in tablet_unstable_v1
func (ZwpTabletManagerV1DestroyRequest) MessageName() string { return "destroy" }

// Ensure ZwpTabletManagerV1DestroyRequest implements Message.
var _ Message = ZwpTabletManagerV1DestroyRequest{}

// Emit emits the message to the emitter.
func (r *ZwpTabletManagerV1DestroyRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure ZwpTabletManagerV1DestroyRequest implements Request.
var _ Request = &ZwpTabletManagerV1DestroyRequest{}

// ZwpTabletManagerV1 controller object for graphic tablet devices
//
// An object that provides access to the graphics tablets available on this
// system. All tablets are associated with a seat, to get access to the
// actual tablets, use wp_tablet_manager.get_tablet_seat.
type ZwpTabletManagerV1 struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *ZwpTabletManagerV1) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (ZwpTabletManagerV1) Descriptor() *InterfaceDescriptor {
	return &ZwpTabletManagerV1Descriptor
}

// Dispatch returns an Event object for a given opcode.
func (ZwpTabletManagerV1) Dispatch(opcode uint16) Event {
	switch opcode {
	default:
		return nil
	}
}

// GetTabletSeat requests to get the tablet seat
//
// Get the wp_tablet_seat object for the given seat. This object
// provides access to all graphics tablets in this seat.
func (proxy *ZwpTabletManagerV1) GetTabletSeat(connection Connection, aSeat ObjectID) (aTabletSeat *ZwpTabletSeatV1, err error) {
	aTabletSeat = &ZwpTabletSeatV1{connection.NewID()}
	request := ZwpTabletManagerV1GetTabletSeatRequest{
		TabletSeat: aTabletSeat.id,
		Seat:       aSeat,
	}
	err = connection.SendRequest(proxy.id, &request)
	if err == nil {
		connection.RegisterProxy(aTabletSeat)
	}
	return
}

// Destroy requests to release the memory for the tablet manager object
//
// Destroy the wp_tablet_manager object. Objects created from this
// object are unaffected and should be destroyed separately.
func (proxy *ZwpTabletManagerV1) Destroy(connection Connection) (err error) {
	request := ZwpTabletManagerV1DestroyRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Ensure ZwpTabletManagerV1 implements Proxy.
var _ Proxy = &ZwpTabletManagerV1{}

// #endregion Interface tablet_unstable_v1.zwp_tablet_manager_v1

// ----------------------------------------------------------------------------
// #region Interface tablet_unstable_v1.zwp_tablet_seat_v1

// ZwpTabletSeatV1DestroyRequest requests to release the memory for the tablet seat object
//
// Destroy the wp_tablet_seat object. Objects created from this
// object are unaffected and should be destroyed separately.
type ZwpTabletSeatV1DestroyRequest struct {
}

// Opcode returns the request opcode for zwp_tablet_seat_v1.destroy in tablet_unstable_v1
func (ZwpTabletSeatV1DestroyRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for zwp_tablet_seat_v1.destroy in tablet_unstable_v1
func (ZwpTabletSeatV1DestroyRequest) MessageName() string { return "destroy" }

// Ensure ZwpTabletSeatV1DestroyRequest implements Message.
var _ Message = ZwpTabletSeatV1DestroyRequest{}

// Emit emits the message to the emitter.
func (r *ZwpTabletSeatV1DestroyRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure ZwpTabletSeatV1DestroyRequest implements Request.
var _ Request = &ZwpTabletSeatV1DestroyRequest{}

// ZwpTabletSeatV1TabletAddedEvent signals when new device notification
//
// This event is sent whenever a new tablet becomes available on this
// seat. This event only provides the object id of the tablet, any
// static information about the tablet (device name, vid/pid, etc.) is
// sent through the wp_tablet interface.
type ZwpTabletSeatV1TabletAddedEvent struct {
	// ID contains the newly added graphics tablet
	ID ObjectID
}

// Opcode returns the event opcode for zwp_tablet_seat_v1.tablet_added in tablet_unstable_v1
func (ZwpTabletSeatV1TabletAddedEvent) Opcode() uint16 { return 0 }

// MessageName returns the event name for zwp_tablet_seat_v1.tablet_added in tablet_unstable_v1
func (ZwpTabletSeatV1TabletAddedEvent) MessageName() string { return "tablet_added" }

// Ensure ZwpTabletSeatV1TabletAddedEvent implements Message.
var _ Message = ZwpTabletSeatV1TabletAddedEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletSeatV1TabletAddedEvent) Scan(s *EventScanner) error {
	if v, err := s.ObjectID(); err != nil {
		return err
	} else {
		e.ID = v
	}
	return nil
}

// Ensure ZwpTabletSeatV1TabletAddedEvent implements Event.
var _ Event = &ZwpTabletSeatV1TabletAddedEvent{}

// ZwpTabletSeatV1ToolAddedEvent signals when a new tool has been used with a tablet
//
// This event is sent whenever a tool that has not previously been used
// with a tablet comes into use. This event only provides the object id
// of the tool; any static information about the tool (capabilities,
// type, etc.) is sent through the wp_tablet_tool interface.
type ZwpTabletSeatV1ToolAddedEvent struct {
	// ID contains the newly added tablet tool
	ID ObjectID
}

// Opcode returns the event opcode for zwp_tablet_seat_v1.tool_added in tablet_unstable_v1
func (ZwpTabletSeatV1ToolAddedEvent) Opcode() uint16 { return 1 }

// MessageName returns the event name for zwp_tablet_seat_v1.tool_added in tablet_unstable_v1
func (ZwpTabletSeatV1ToolAddedEvent) MessageName() string { return "tool_added" }

// Ensure ZwpTabletSeatV1ToolAddedEvent implements Message.
var _ Message = ZwpTabletSeatV1ToolAddedEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletSeatV1ToolAddedEvent) Scan(s *EventScanner) error {
	if v, err := s.ObjectID(); err != nil {
		return err
	} else {
		e.ID = v
	}
	return nil
}

// Ensure ZwpTabletSeatV1ToolAddedEvent implements Event.
var _ Event = &ZwpTabletSeatV1ToolAddedEvent{}

// ZwpTabletSeatV1 controller object for graphic tablet devices of a seat
//
// An object that provides access to the graphics tablets available on this
// seat. After binding to this interface, the compositor sends a set of
// wp_tablet_seat.tablet_added and wp_tablet_seat.tool_added events.
type ZwpTabletSeatV1 struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *ZwpTabletSeatV1) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (ZwpTabletSeatV1) Descriptor() *InterfaceDescriptor {
	return &ZwpTabletSeatV1Descriptor
}

// Dispatch returns an Event object for a given opcode.
func (ZwpTabletSeatV1) Dispatch(opcode uint16) Event {
	switch opcode {
	case 0:
		return &ZwpTabletSeatV1TabletAddedEvent{}
	case 1:
		return &ZwpTabletSeatV1ToolAddedEvent{}
	default:
		return nil
	}
}

// Destroy requests to release the memory for the tablet seat object
//
// Destroy the wp_tablet_seat object. Objects created from this
// object are unaffected and should be destroyed separately.
func (proxy *ZwpTabletSeatV1) Destroy(connection Connection) (err error) {
	request := ZwpTabletSeatV1DestroyRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Ensure ZwpTabletSeatV1 implements Proxy.
var _ Proxy = &ZwpTabletSeatV1{}

// #endregion Interface tablet_unstable_v1.zwp_tablet_seat_v1

// ----------------------------------------------------------------------------
// #region Interface tablet_unstable_v1.zwp_tablet_tool_v1

// ZwpTabletToolV1Type represents a physical tool type
//
// Describes the physical type of a tool. The physical type of a tool
// generally defines its base usage.
//
// The mouse tool represents a mouse-shaped tool that is not a relative
// device but bound to the tablet's surface, providing absolute
// coordinates.
//
// The lens tool is a mouse-shaped tool with an attached lens to
// provide precision focus.
type ZwpTabletToolV1Type int

const (
	// ZwpTabletToolV1TypePen corresponds to Pen
	ZwpTabletToolV1TypePen ZwpTabletToolV1Type = 0x140

	// ZwpTabletToolV1TypeEraser corresponds to Eraser
	ZwpTabletToolV1TypeEraser ZwpTabletToolV1Type = 0x141

	// ZwpTabletToolV1TypeBrush corresponds to Brush
	ZwpTabletToolV1TypeBrush ZwpTabletToolV1Type = 0x142

	// ZwpTabletToolV1TypePencil corresponds to Pencil
	ZwpTabletToolV1TypePencil ZwpTabletToolV1Type = 0x143

	// ZwpTabletToolV1TypeAirbrush corresponds to Airbrush
	ZwpTabletToolV1TypeAirbrush ZwpTabletToolV1Type = 0x144

	// ZwpTabletToolV1TypeFinger corresponds to Finger
	ZwpTabletToolV1TypeFinger ZwpTabletToolV1Type = 0x145

	// ZwpTabletToolV1TypeMouse corresponds to Mouse
	ZwpTabletToolV1TypeMouse ZwpTabletToolV1Type = 0x146

	// ZwpTabletToolV1TypeLens corresponds to Lens
	ZwpTabletToolV1TypeLens ZwpTabletToolV1Type = 0x147
)

// ZwpTabletToolV1Capability represents capability flags for a tool
//
// Describes extra capabilities on a tablet.
//
// Any tool must provide x and y values, extra axes are
// device-specific.
type ZwpTabletToolV1Capability int

const (
	// ZwpTabletToolV1CapabilityTilt corresponds to Tilt axes
	ZwpTabletToolV1CapabilityTilt ZwpTabletToolV1Capability = 1

	// ZwpTabletToolV1CapabilityPressure corresponds to Pressure axis
	ZwpTabletToolV1CapabilityPressure ZwpTabletToolV1Capability = 2

	// ZwpTabletToolV1CapabilityDistance corresponds to Distance axis
	ZwpTabletToolV1CapabilityDistance ZwpTabletToolV1Capability = 3

	// ZwpTabletToolV1CapabilityRotation corresponds to Z-rotation axis
	ZwpTabletToolV1CapabilityRotation ZwpTabletToolV1Capability = 4

	// ZwpTabletToolV1CapabilitySlider corresponds to Slider axis
	ZwpTabletToolV1CapabilitySlider ZwpTabletToolV1Capability = 5

	// ZwpTabletToolV1CapabilityWheel corresponds to Wheel axis
	ZwpTabletToolV1CapabilityWheel ZwpTabletToolV1Capability = 6
)

// ZwpTabletToolV1ButtonState represents physical button state
//
// Describes the physical state of a button that produced the button event.
type ZwpTabletToolV1ButtonState int

const (
	// ZwpTabletToolV1ButtonStateReleased corresponds to button is not pressed
	ZwpTabletToolV1ButtonStateReleased ZwpTabletToolV1ButtonState = 0

	// ZwpTabletToolV1ButtonStatePressed corresponds to button is pressed
	ZwpTabletToolV1ButtonStatePressed ZwpTabletToolV1ButtonState = 1
)

type ZwpTabletToolV1Error int

const (
	// ZwpTabletToolV1ErrorRole corresponds to given wl_surface has another role
	ZwpTabletToolV1ErrorRole ZwpTabletToolV1Error = 0
)

// ZwpTabletToolV1SetCursorRequest requests to set the tablet tool's surface
//
// Sets the surface of the cursor used for this tool on the given
// tablet. This request only takes effect if the tool is in proximity
// of one of the requesting client's surfaces or the surface parameter
// is the current pointer surface. If there was a previous surface set
// with this request it is replaced. If surface is NULL, the cursor
// image is hidden.
//
// The parameters hotspot_x and hotspot_y define the position of the
// pointer surface relative to the pointer location. Its top-left corner
// is always at (x, y) - (hotspot_x, hotspot_y), where (x, y) are the
// coordinates of the pointer location, in surface-local coordinates.
//
// On surface.attach requests to the pointer surface, hotspot_x and
// hotspot_y are decremented by the x and y parameters passed to the
// request. Attach must be confirmed by wl_surface.commit as usual.
//
// The hotspot can also be updated by passing the currently set pointer
// surface to this request with new values for hotspot_x and hotspot_y.
//
// The current and pending input regions of the wl_surface are cleared,
// and wl_surface.set_input_region is ignored until the wl_surface is no
// longer used as the cursor. When the use as a cursor ends, the current
// and pending input regions become undefined, and the wl_surface is
// unmapped.
//
// This request gives the surface the role of a cursor. The role
// assigned by this request is the same as assigned by
// wl_pointer.set_cursor meaning the same surface can be
// used both as a wl_pointer cursor and a wp_tablet cursor. If the
// surface already has another role, it raises a protocol error.
// The surface may be used on multiple tablets and across multiple
// seats.
type ZwpTabletToolV1SetCursorRequest struct {
	// Serial contains serial of the enter event
	Serial uint32

	Surface ObjectID

	// HotspotX contains surface-local x coordinate
	HotspotX int32

	// HotspotY contains surface-local y coordinate
	HotspotY int32
}

// Opcode returns the request opcode for zwp_tablet_tool_v1.set_cursor in tablet_unstable_v1
func (ZwpTabletToolV1SetCursorRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for zwp_tablet_tool_v1.set_cursor in tablet_unstable_v1
func (ZwpTabletToolV1SetCursorRequest) MessageName() string { return "set_cursor" }

// Ensure ZwpTabletToolV1SetCursorRequest implements Message.
var _ Message = ZwpTabletToolV1SetCursorRequest{}

// Emit emits the message to the emitter.
func (r *ZwpTabletToolV1SetCursorRequest) Emit(e *RequestEmitter) error {
	if err := e.PutUint(r.Serial); err != nil {
		return err
	}
	if err := e.PutObjectID(r.Surface); err != nil {
		return err
	}
	if err := e.PutInt(r.HotspotX); err != nil {
		return err
	}
	if err := e.PutInt(r.HotspotY); err != nil {
		return err
	}
	return nil
}

// Ensure ZwpTabletToolV1SetCursorRequest implements Request.
var _ Request = &ZwpTabletToolV1SetCursorRequest{}

// ZwpTabletToolV1DestroyRequest requests to destroy the tool object
//
// This destroys the client's resource for this tool object.
type ZwpTabletToolV1DestroyRequest struct {
}

// Opcode returns the request opcode for zwp_tablet_tool_v1.destroy in tablet_unstable_v1
func (ZwpTabletToolV1DestroyRequest) Opcode() uint16 { return 1 }

// MessageName returns the request name for zwp_tablet_tool_v1.destroy in tablet_unstable_v1
func (ZwpTabletToolV1DestroyRequest) MessageName() string { return "destroy" }

// Ensure ZwpTabletToolV1DestroyRequest implements Message.
var _ Message = ZwpTabletToolV1DestroyRequest{}

// Emit emits the message to the emitter.
func (r *ZwpTabletToolV1DestroyRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure ZwpTabletToolV1DestroyRequest implements Request.
var _ Request = &ZwpTabletToolV1DestroyRequest{}

// ZwpTabletToolV1TypeEvent signals when tool type
//
// The tool type is the high-level type of the tool and usually decides
// the interaction expected from this tool.
//
// This event is sent in the initial burst of events before the
// wp_tablet_tool.done event.
type ZwpTabletToolV1TypeEvent struct {
	// ToolType contains the physical tool type
	ToolType uint32
}

// Opcode returns the event opcode for zwp_tablet_tool_v1.type in tablet_unstable_v1
func (ZwpTabletToolV1TypeEvent) Opcode() uint16 { return 0 }

// MessageName returns the event name for zwp_tablet_tool_v1.type in tablet_unstable_v1
func (ZwpTabletToolV1TypeEvent) MessageName() string { return "type" }

// Ensure ZwpTabletToolV1TypeEvent implements Message.
var _ Message = ZwpTabletToolV1TypeEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletToolV1TypeEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.ToolType = v
	}
	return nil
}

// Ensure ZwpTabletToolV1TypeEvent implements Event.
var _ Event = &ZwpTabletToolV1TypeEvent{}

// ZwpTabletToolV1HardwareSerialEvent signals when unique hardware serial number of the tool
//
// If the physical tool can be identified by a unique 64-bit serial
// number, this event notifies the client of this serial number.
//
// If multiple tablets are available in the same seat and the tool is
// uniquely identifiable by the serial number, that tool may move
// between tablets.
//
// Otherwise, if the tool has no serial number and this event is
// missing, the tool is tied to the tablet it first comes into
// proximity with. Even if the physical tool is used on multiple
// tablets, separate wp_tablet_tool objects will be created, one per
// tablet.
//
// This event is sent in the initial burst of events before the
// wp_tablet_tool.done event.
type ZwpTabletToolV1HardwareSerialEvent struct {
	// HardwareSerialHi contains the unique serial number of the tool, most significant bits
	HardwareSerialHi uint32

	// HardwareSerialLo contains the unique serial number of the tool, least significant bits
	HardwareSerialLo uint32
}

// Opcode returns the event opcode for zwp_tablet_tool_v1.hardware_serial in tablet_unstable_v1
func (ZwpTabletToolV1HardwareSerialEvent) Opcode() uint16 { return 1 }

// MessageName returns the event name for zwp_tablet_tool_v1.hardware_serial in tablet_unstable_v1
func (ZwpTabletToolV1HardwareSerialEvent) MessageName() string { return "hardware_serial" }

// Ensure ZwpTabletToolV1HardwareSerialEvent implements Message.
var _ Message = ZwpTabletToolV1HardwareSerialEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletToolV1HardwareSerialEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.HardwareSerialHi = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.HardwareSerialLo = v
	}
	return nil
}

// Ensure ZwpTabletToolV1HardwareSerialEvent implements Event.
var _ Event = &ZwpTabletToolV1HardwareSerialEvent{}

// ZwpTabletToolV1HardwareIDWacomEvent signals when hardware id notification in Wacom's format
//
// This event notifies the client of a hardware id available on this tool.
//
// The hardware id is a device-specific 64-bit id that provides extra
// information about the tool in use, beyond the wl_tool.type
// enumeration. The format of the id is specific to tablets made by
// Wacom Inc. For example, the hardware id of a Wacom Grip
// Pen (a stylus) is 0x802.
//
// This event is sent in the initial burst of events before the
// wp_tablet_tool.done event.
type ZwpTabletToolV1HardwareIDWacomEvent struct {
	// HardwareIDHi contains the hardware id, most significant bits
	HardwareIDHi uint32

	// HardwareIDLo contains the hardware id, least significant bits
	HardwareIDLo uint32
}

// Opcode returns the event opcode for zwp_tablet_tool_v1.hardware_id_wacom in tablet_unstable_v1
func (ZwpTabletToolV1HardwareIDWacomEvent) Opcode() uint16 { return 2 }

// MessageName returns the event name for zwp_tablet_tool_v1.hardware_id_wacom in tablet_unstable_v1
func (ZwpTabletToolV1HardwareIDWacomEvent) MessageName() string { return "hardware_id_wacom" }

// Ensure ZwpTabletToolV1HardwareIDWacomEvent implements Message.
var _ Message = ZwpTabletToolV1HardwareIDWacomEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletToolV1HardwareIDWacomEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.HardwareIDHi = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.HardwareIDLo = v
	}
	return nil
}

// Ensure ZwpTabletToolV1HardwareIDWacomEvent implements Event.
var _ Event = &ZwpTabletToolV1HardwareIDWacomEvent{}

// ZwpTabletToolV1CapabilityEvent signals when tool capability notification
//
// This event notifies the client of any capabilities of this tool,
// beyond the main set of x/y axes and tip up/down detection.
//
// One event is sent for each extra capability available on this tool.
//
// This event is sent in the initial burst of events before the
// wp_tablet_tool.done event.
type ZwpTabletToolV1CapabilityEvent struct {
	// Capability contains the capability
	Capability uint32
}

// Opcode returns the event opcode for zwp_tablet_tool_v1.capability in tablet_unstable_v1
func (ZwpTabletToolV1CapabilityEvent) Opcode() uint16 { return 3 }

// MessageName returns the event name for zwp_tablet_tool_v1.capability in tablet_unstable_v1
func (ZwpTabletToolV1CapabilityEvent) MessageName() string { return "capability" }

// Ensure ZwpTabletToolV1CapabilityEvent implements Message.
var _ Message = ZwpTabletToolV1CapabilityEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletToolV1CapabilityEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Capability = v
	}
	return nil
}

// Ensure ZwpTabletToolV1CapabilityEvent implements Event.
var _ Event = &ZwpTabletToolV1CapabilityEvent{}

// ZwpTabletToolV1DoneEvent signals when tool description events sequence complete
//
// This event signals the end of the initial burst of descriptive
// events. A client may consider the static description of the tool to
// be complete and finalize initialization of the tool.
type ZwpTabletToolV1DoneEvent struct {
}

// Opcode returns the event opcode for zwp_tablet_tool_v1.done in tablet_unstable_v1
func (ZwpTabletToolV1DoneEvent) Opcode() uint16 { return 4 }

// MessageName returns the event name for zwp_tablet_tool_v1.done in tablet_unstable_v1
func (ZwpTabletToolV1DoneEvent) MessageName() string { return "done" }

// Ensure ZwpTabletToolV1DoneEvent implements Message.
var _ Message = ZwpTabletToolV1DoneEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletToolV1DoneEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure ZwpTabletToolV1DoneEvent implements Event.
var _ Event = &ZwpTabletToolV1DoneEvent{}

// ZwpTabletToolV1RemovedEvent signals when tool removed
//
// This event is sent when the tool is removed from the system and will
// send no further events. Should the physical tool come back into
// proximity later, a new wp_tablet_tool object will be created.
//
// It is compositor-dependent when a tool is removed. A compositor may
// remove a tool on proximity out, tablet removal or any other reason.
// A compositor may also keep a tool alive until shutdown.
//
// If the tool is currently in proximity, a proximity_out event will be
// sent before the removed event. See wp_tablet_tool.proximity_out for
// the handling of any buttons logically down.
//
// When this event is received, the client must wp_tablet_tool.destroy
// the object.
type ZwpTabletToolV1RemovedEvent struct {
}

// Opcode returns the event opcode for zwp_tablet_tool_v1.removed in tablet_unstable_v1
func (ZwpTabletToolV1RemovedEvent) Opcode() uint16 { return 5 }

// MessageName returns the event name for zwp_tablet_tool_v1.removed in tablet_unstable_v1
func (ZwpTabletToolV1RemovedEvent) MessageName() string { return "removed" }

// Ensure ZwpTabletToolV1RemovedEvent implements Message.
var _ Message = ZwpTabletToolV1RemovedEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletToolV1RemovedEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure ZwpTabletToolV1RemovedEvent implements Event.
var _ Event = &ZwpTabletToolV1RemovedEvent{}

// ZwpTabletToolV1ProximityInEvent signals when proximity in event
//
// Notification that this tool is focused on a certain surface.
//
// This event can be received when the tool has moved from one surface to
// another, or when the tool has come back into proximity above the
// surface.
//
// If any button is logically down when the tool comes into proximity,
// the respective button event is sent after the proximity_in event but
// within the same frame as the proximity_in event.
type ZwpTabletToolV1ProximityInEvent struct {
	Serial uint32

	// Tablet contains The tablet the tool is in proximity of
	Tablet ObjectID

	// Surface contains The current surface the tablet tool is over
	Surface ObjectID
}

// Opcode returns the event opcode for zwp_tablet_tool_v1.proximity_in in tablet_unstable_v1
func (ZwpTabletToolV1ProximityInEvent) Opcode() uint16 { return 6 }

// MessageName returns the event name for zwp_tablet_tool_v1.proximity_in in tablet_unstable_v1
func (ZwpTabletToolV1ProximityInEvent) MessageName() string { return "proximity_in" }

// Ensure ZwpTabletToolV1ProximityInEvent implements Message.
var _ Message = ZwpTabletToolV1ProximityInEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletToolV1ProximityInEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Serial = v
	}
	if v, err := s.ObjectID(); err != nil {
		return err
	} else {
		e.Tablet = v
	}
	if v, err := s.ObjectID(); err != nil {
		return err
	} else {
		e.Surface = v
	}
	return nil
}

// Ensure ZwpTabletToolV1ProximityInEvent implements Event.
var _ Event = &ZwpTabletToolV1ProximityInEvent{}

// ZwpTabletToolV1ProximityOutEvent signals when proximity out event
//
// Notification that this tool has either left proximity, or is no
// longer focused on a certain surface.
//
// When the tablet tool leaves proximity of the tablet, button release
// events are sent for each button that was held down at the time of
// leaving proximity. These events are sent before the proximity_out
// event but within the same wp_tablet.frame.
//
// If the tool stays within proximity of the tablet, but the focus
// changes from one surface to another, a button release event may not
// be sent until the button is actually released or the tool leaves the
// proximity of the tablet.
type ZwpTabletToolV1ProximityOutEvent struct {
}

// Opcode returns the event opcode for zwp_tablet_tool_v1.proximity_out in tablet_unstable_v1
func (ZwpTabletToolV1ProximityOutEvent) Opcode() uint16 { return 7 }

// MessageName returns the event name for zwp_tablet_tool_v1.proximity_out in tablet_unstable_v1
func (ZwpTabletToolV1ProximityOutEvent) MessageName() string { return "proximity_out" }

// Ensure ZwpTabletToolV1ProximityOutEvent implements Message.
var _ Message = ZwpTabletToolV1ProximityOutEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletToolV1ProximityOutEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure ZwpTabletToolV1ProximityOutEvent implements Event.
var _ Event = &ZwpTabletToolV1ProximityOutEvent{}

// ZwpTabletToolV1DownEvent signals when tablet tool is making contact
//
// Sent whenever the tablet tool comes in contact with the surface of the
// tablet.
//
// If the tool is already in contact with the tablet when entering the
// input region, the client owning said region will receive a
// wp_tablet.proximity_in event, followed by a wp_tablet.down
// event and a wp_tablet.frame event.
//
// Note that this event describes logical contact, not physical
// contact. On some devices, a compositor may not consider a tool in
// logical contact until a minimum physical pressure threshold is
// exceeded.
type ZwpTabletToolV1DownEvent struct {
	Serial uint32
}

// Opcode returns the event opcode for zwp_tablet_tool_v1.down in tablet_unstable_v1
func (ZwpTabletToolV1DownEvent) Opcode() uint16 { return 8 }

// MessageName returns the event name for zwp_tablet_tool_v1.down in tablet_unstable_v1
func (ZwpTabletToolV1DownEvent) MessageName() string { return "down" }

// Ensure ZwpTabletToolV1DownEvent implements Message.
var _ Message = ZwpTabletToolV1DownEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletToolV1DownEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Serial = v
	}
	return nil
}

// Ensure ZwpTabletToolV1DownEvent implements Event.
var _ Event = &ZwpTabletToolV1DownEvent{}

// ZwpTabletToolV1UpEvent signals when tablet tool is no longer making contact
//
// Sent whenever the tablet tool stops making contact with the surface of
// the tablet, or when the tablet tool moves out of the input region
// and the compositor grab (if any) is dismissed.
//
// If the tablet tool moves out of the input region while in contact
// with the surface of the tablet and the compositor does not have an
// ongoing grab on the surface, the client owning said region will
// receive a wp_tablet.up event, followed by a wp_tablet.proximity_out
// event and a wp_tablet.frame event. If the compositor has an ongoing
// grab on this device, this event sequence is sent whenever the grab
// is dismissed in the future.
//
// Note that this event describes logical contact, not physical
// contact. On some devices, a compositor may not consider a tool out
// of logical contact until physical pressure falls below a specific
// threshold.
type ZwpTabletToolV1UpEvent struct {
}

// Opcode returns the event opcode for zwp_tablet_tool_v1.up in tablet_unstable_v1
func (ZwpTabletToolV1UpEvent) Opcode() uint16 { return 9 }

// MessageName returns the event name for zwp_tablet_tool_v1.up in tablet_unstable_v1
func (ZwpTabletToolV1UpEvent) MessageName() string { return "up" }

// Ensure ZwpTabletToolV1UpEvent implements Message.
var _ Message = ZwpTabletToolV1UpEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletToolV1UpEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure ZwpTabletToolV1UpEvent implements Event.
var _ Event = &ZwpTabletToolV1UpEvent{}

// ZwpTabletToolV1MotionEvent signals when motion event
//
// Sent whenever a tablet tool moves.
type ZwpTabletToolV1MotionEvent struct {
	// X contains surface-local x coordinate
	X Fixed

	// Y contains surface-local y coordinate
	Y Fixed
}

// Opcode returns the event opcode for zwp_tablet_tool_v1.motion in tablet_unstable_v1
func (ZwpTabletToolV1MotionEvent) Opcode() uint16 { return 10 }

// MessageName returns the event name for zwp_tablet_tool_v1.motion in tablet_unstable_v1
func (ZwpTabletToolV1MotionEvent) MessageName() string { return "motion" }

// Ensure ZwpTabletToolV1MotionEvent implements Message.
var _ Message = ZwpTabletToolV1MotionEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletToolV1MotionEvent) Scan(s *EventScanner) error {
	if v, err := s.Fixed(); err != nil {
		return err
	} else {
		e.X = v
	}
	if v, err := s.Fixed(); err != nil {
		return err
	} else {
		e.Y = v
	}
	return nil
}

// Ensure ZwpTabletToolV1MotionEvent implements Event.
var _ Event = &ZwpTabletToolV1MotionEvent{}

// ZwpTabletToolV1PressureEvent signals when pressure change event
//
// Sent whenever the pressure axis on a tool changes. The value of this
// event is normalized to a value between 0 and 65535.
//
// Note that pressure may be nonzero even when a tool is not in logical
// contact. See the down and up events for more details.
type ZwpTabletToolV1PressureEvent struct {
	// Pressure contains The current pressure value
	Pressure uint32
}

// Opcode returns the event opcode for zwp_tablet_tool_v1.pressure in tablet_unstable_v1
func (ZwpTabletToolV1PressureEvent) Opcode() uint16 { return 11 }

// MessageName returns the event name for zwp_tablet_tool_v1.pressure in tablet_unstable_v1
func (ZwpTabletToolV1PressureEvent) MessageName() string { return "pressure" }

// Ensure ZwpTabletToolV1PressureEvent implements Message.
var _ Message = ZwpTabletToolV1PressureEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletToolV1PressureEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Pressure = v
	}
	return nil
}

// Ensure ZwpTabletToolV1PressureEvent implements Event.
var _ Event = &ZwpTabletToolV1PressureEvent{}

// ZwpTabletToolV1DistanceEvent signals when distance change event
//
// Sent whenever the distance axis on a tool changes. The value of this
// event is normalized to a value between 0 and 65535.
//
// Note that distance may be nonzero even when a tool is not in logical
// contact. See the down and up events for more details.
type ZwpTabletToolV1DistanceEvent struct {
	// Distance contains The current distance value
	Distance uint32
}

// Opcode returns the event opcode for zwp_tablet_tool_v1.distance in tablet_unstable_v1
func (ZwpTabletToolV1DistanceEvent) Opcode() uint16 { return 12 }

// MessageName returns the event name for zwp_tablet_tool_v1.distance in tablet_unstable_v1
func (ZwpTabletToolV1DistanceEvent) MessageName() string { return "distance" }

// Ensure ZwpTabletToolV1DistanceEvent implements Message.
var _ Message = ZwpTabletToolV1DistanceEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletToolV1DistanceEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Distance = v
	}
	return nil
}

// Ensure ZwpTabletToolV1DistanceEvent implements Event.
var _ Event = &ZwpTabletToolV1DistanceEvent{}

// ZwpTabletToolV1TiltEvent signals when tilt change event
//
// Sent whenever one or both of the tilt axes on a tool change. Each tilt
// value is in 0.01 of a degree, relative to the z-axis of the tablet.
// The angle is positive when the top of a tool tilts along the
// positive x or y axis.
type ZwpTabletToolV1TiltEvent struct {
	// TiltX contains The current value of the X tilt axis
	TiltX int32

	// TiltY contains The current value of the Y tilt axis
	TiltY int32
}

// Opcode returns the event opcode for zwp_tablet_tool_v1.tilt in tablet_unstable_v1
func (ZwpTabletToolV1TiltEvent) Opcode() uint16 { return 13 }

// MessageName returns the event name for zwp_tablet_tool_v1.tilt in tablet_unstable_v1
func (ZwpTabletToolV1TiltEvent) MessageName() string { return "tilt" }

// Ensure ZwpTabletToolV1TiltEvent implements Message.
var _ Message = ZwpTabletToolV1TiltEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletToolV1TiltEvent) Scan(s *EventScanner) error {
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.TiltX = v
	}
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.TiltY = v
	}
	return nil
}

// Ensure ZwpTabletToolV1TiltEvent implements Event.
var _ Event = &ZwpTabletToolV1TiltEvent{}

// ZwpTabletToolV1RotationEvent signals when z-rotation change event
//
// Sent whenever the z-rotation axis on the tool changes. The
// rotation value is in 0.01 of a degree clockwise from the tool's
// logical neutral position.
type ZwpTabletToolV1RotationEvent struct {
	// Degrees contains The current rotation of the Z axis
	Degrees int32
}

// Opcode returns the event opcode for zwp_tablet_tool_v1.rotation in tablet_unstable_v1
func (ZwpTabletToolV1RotationEvent) Opcode() uint16 { return 14 }

// MessageName returns the event name for zwp_tablet_tool_v1.rotation in tablet_unstable_v1
func (ZwpTabletToolV1RotationEvent) MessageName() string { return "rotation" }

// Ensure ZwpTabletToolV1RotationEvent implements Message.
var _ Message = ZwpTabletToolV1RotationEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletToolV1RotationEvent) Scan(s *EventScanner) error {
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.Degrees = v
	}
	return nil
}

// Ensure ZwpTabletToolV1RotationEvent implements Event.
var _ Event = &ZwpTabletToolV1RotationEvent{}

// ZwpTabletToolV1SliderEvent signals when Slider position change event
//
// Sent whenever the slider position on the tool changes. The
// value is normalized between -65535 and 65535, with 0 as the logical
// neutral position of the slider.
//
// The slider is available on e.g. the Wacom Airbrush tool.
type ZwpTabletToolV1SliderEvent struct {
	// Position contains The current position of slider
	Position int32
}

// Opcode returns the event opcode for zwp_tablet_tool_v1.slider in tablet_unstable_v1
func (ZwpTabletToolV1SliderEvent) Opcode() uint16 { return 15 }

// MessageName returns the event name for zwp_tablet_tool_v1.slider in tablet_unstable_v1
func (ZwpTabletToolV1SliderEvent) MessageName() string { return "slider" }

// Ensure ZwpTabletToolV1SliderEvent implements Message.
var _ Message = ZwpTabletToolV1SliderEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletToolV1SliderEvent) Scan(s *EventScanner) error {
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.Position = v
	}
	return nil
}

// Ensure ZwpTabletToolV1SliderEvent implements Event.
var _ Event = &ZwpTabletToolV1SliderEvent{}

// ZwpTabletToolV1WheelEvent signals when Wheel delta event
//
// Sent whenever the wheel on the tool emits an event. This event
// contains two values for the same axis change. The degrees value is
// in 0.01 of a degree in the same orientation as the
// wl_pointer.vertical_scroll axis. The clicks value is in discrete
// logical clicks of the mouse wheel. This value may be zero if the
// movement of the wheel was less than one logical click.
//
// Clients should choose either value and avoid mixing degrees and
// clicks. The compositor may accumulate values smaller than a logical
// click and emulate click events when a certain threshold is met.
// Thus, wl_tablet_tool.wheel events with non-zero clicks values may
// have different degrees values.
type ZwpTabletToolV1WheelEvent struct {
	// Degrees contains The wheel delta in 0.01 of a degree
	Degrees int32

	// Clicks contains The wheel delta in discrete clicks
	Clicks int32
}

// Opcode returns the event opcode for zwp_tablet_tool_v1.wheel in tablet_unstable_v1
func (ZwpTabletToolV1WheelEvent) Opcode() uint16 { return 16 }

// MessageName returns the event name for zwp_tablet_tool_v1.wheel in tablet_unstable_v1
func (ZwpTabletToolV1WheelEvent) MessageName() string { return "wheel" }

// Ensure ZwpTabletToolV1WheelEvent implements Message.
var _ Message = ZwpTabletToolV1WheelEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletToolV1WheelEvent) Scan(s *EventScanner) error {
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.Degrees = v
	}
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.Clicks = v
	}
	return nil
}

// Ensure ZwpTabletToolV1WheelEvent implements Event.
var _ Event = &ZwpTabletToolV1WheelEvent{}

// ZwpTabletToolV1ButtonEvent signals when button event
//
// Sent whenever a button on the tool is pressed or released.
//
// If a button is held down when the tool moves in or out of proximity,
// button events are generated by the compositor. See
// wp_tablet_tool.proximity_in and wp_tablet_tool.proximity_out for
// details.
type ZwpTabletToolV1ButtonEvent struct {
	Serial uint32

	// Button contains The button whose state has changed
	Button uint32

	// State contains Whether the button was pressed or released
	State uint32
}

// Opcode returns the event opcode for zwp_tablet_tool_v1.button in tablet_unstable_v1
func (ZwpTabletToolV1ButtonEvent) Opcode() uint16 { return 17 }

// MessageName returns the event name for zwp_tablet_tool_v1.button in tablet_unstable_v1
func (ZwpTabletToolV1ButtonEvent) MessageName() string { return "button" }

// Ensure ZwpTabletToolV1ButtonEvent implements Message.
var _ Message = ZwpTabletToolV1ButtonEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletToolV1ButtonEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Serial = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Button = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.State = v
	}
	return nil
}

// Ensure ZwpTabletToolV1ButtonEvent implements Event.
var _ Event = &ZwpTabletToolV1ButtonEvent{}

// ZwpTabletToolV1FrameEvent signals when frame event
//
// Marks the end of a series of axis and/or button updates from the
// tablet. The Wayland protocol requires axis updates to be sent
// sequentially, however all events within a frame should be considered
// one hardware event.
type ZwpTabletToolV1FrameEvent struct {
	// Time contains The time of the event with millisecond granularity
	Time uint32
}

// Opcode returns the event opcode for zwp_tablet_tool_v1.frame in tablet_unstable_v1
func (ZwpTabletToolV1FrameEvent) Opcode() uint16 { return 18 }

// MessageName returns the event name for zwp_tablet_tool_v1.frame in tablet_unstable_v1
func (ZwpTabletToolV1FrameEvent) MessageName() string { return "frame" }

// Ensure ZwpTabletToolV1FrameEvent implements Message.
var _ Message = ZwpTabletToolV1FrameEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletToolV1FrameEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Time = v
	}
	return nil
}

// Ensure ZwpTabletToolV1FrameEvent implements Event.
var _ Event = &ZwpTabletToolV1FrameEvent{}

// ZwpTabletToolV1 a physical tablet tool
//
// An object that represents a physical tool that has been, or is
// currently in use with a tablet in this seat. Each wp_tablet_tool
// object stays valid until the client destroys it; the compositor
// reuses the wp_tablet_tool object to indicate that the object's
// respective physical tool has come into proximity of a tablet again.
//
// A wp_tablet_tool object's relation to a physical tool depends on the
// tablet's ability to report serial numbers. If the tablet supports
// this capability, then the object represents a specific physical tool
// and can be identified even when used on multiple tablets.
//
// A tablet tool has a number of static characteristics, e.g. tool type,
// hardware_serial and capabilities. These capabilities are sent in an
// event sequence after the wp_tablet_seat.tool_added event before any
// actual events from this tool. This initial event sequence is
// terminated by a wp_tablet_tool.done event.
//
// Tablet tool events are grouped by wp_tablet_tool.frame events.
// Any events received before a wp_tablet_tool.frame event should be
// considered part of the same hardware state change.
type ZwpTabletToolV1 struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *ZwpTabletToolV1) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (ZwpTabletToolV1) Descriptor() *InterfaceDescriptor {
	return &ZwpTabletToolV1Descriptor
}

// Dispatch returns an Event object for a given opcode.
func (ZwpTabletToolV1) Dispatch(opcode uint16) Event {
	switch opcode {
	case 0:
		return &ZwpTabletToolV1TypeEvent{}
	case 1:
		return &ZwpTabletToolV1HardwareSerialEvent{}
	case 2:
		return &ZwpTabletToolV1HardwareIDWacomEvent{}
	case 3:
		return &ZwpTabletToolV1CapabilityEvent{}
	case 4:
		return &ZwpTabletToolV1DoneEvent{}
	case 5:
		return &ZwpTabletToolV1RemovedEvent{}
	case 6:
		return &ZwpTabletToolV1ProximityInEvent{}
	case 7:
		return &ZwpTabletToolV1ProximityOutEvent{}
	case 8:
		return &ZwpTabletToolV1DownEvent{}
	case 9:
		return &ZwpTabletToolV1UpEvent{}
	case 10:
		return &ZwpTabletToolV1MotionEvent{}
	case 11:
		return &ZwpTabletToolV1PressureEvent{}
	case 12:
		return &ZwpTabletToolV1DistanceEvent{}
	case 13:
		return &ZwpTabletToolV1TiltEvent{}
	case 14:
		return &ZwpTabletToolV1RotationEvent{}
	case 15:
		return &ZwpTabletToolV1SliderEvent{}
	case 16:
		return &ZwpTabletToolV1WheelEvent{}
	case 17:
		return &ZwpTabletToolV1ButtonEvent{}
	case 18:
		return &ZwpTabletToolV1FrameEvent{}
	default:
		return nil
	}
}

// SetCursor requests to set the tablet tool's surface
//
// Sets the surface of the cursor used for this tool on the given
// tablet. This request only takes effect if the tool is in proximity
// of one of the requesting client's surfaces or the surface parameter
// is the current pointer surface. If there was a previous surface set
// with this request it is replaced. If surface is NULL, the cursor
// image is hidden.
//
// The parameters hotspot_x and hotspot_y define the position of the
// pointer surface relative to the pointer location. Its top-left corner
// is always at (x, y) - (hotspot_x, hotspot_y), where (x, y) are the
// coordinates of the pointer location, in surface-local coordinates.
//
// On surface.attach requests to the pointer surface, hotspot_x and
// hotspot_y are decremented by the x and y parameters passed to the
// request. Attach must be confirmed by wl_surface.commit as usual.
//
// The hotspot can also be updated by passing the currently set pointer
// surface to this request with new values for hotspot_x and hotspot_y.
//
// The current and pending input regions of the wl_surface are cleared,
// and wl_surface.set_input_region is ignored until the wl_surface is no
// longer used as the cursor. When the use as a cursor ends, the current
// and pending input regions become undefined, and the wl_surface is
// unmapped.
//
// This request gives the surface the role of a cursor. The role
// assigned by this request is the same as assigned by
// wl_pointer.set_cursor meaning the same surface can be
// used both as a wl_pointer cursor and a wp_tablet cursor. If the
// surface already has another role, it raises a protocol error.
// The surface may be used on multiple tablets and across multiple
// seats.
func (proxy *ZwpTabletToolV1) SetCursor(connection Connection, aSerial uint32, aSurface ObjectID, aHotspotX int32, aHotspotY int32) (err error) {
	request := ZwpTabletToolV1SetCursorRequest{
		Serial:   aSerial,
		Surface:  aSurface,
		HotspotX: aHotspotX,
		HotspotY: aHotspotY,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Destroy requests to destroy the tool object
//
// This destroys the client's resource for this tool object.
func (proxy *ZwpTabletToolV1) Destroy(connection Connection) (err error) {
	request := ZwpTabletToolV1DestroyRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Ensure ZwpTabletToolV1 implements Proxy.
var _ Proxy = &ZwpTabletToolV1{}

// #endregion Interface tablet_unstable_v1.zwp_tablet_tool_v1

// ----------------------------------------------------------------------------
// #region Interface tablet_unstable_v1.zwp_tablet_v1

// ZwpTabletV1DestroyRequest requests to destroy the tablet object
//
// This destroys the client's resource for this tablet object.
type ZwpTabletV1DestroyRequest struct {
}

// Opcode returns the request opcode for zwp_tablet_v1.destroy in tablet_unstable_v1
func (ZwpTabletV1DestroyRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for zwp_tablet_v1.destroy in tablet_unstable_v1
func (ZwpTabletV1DestroyRequest) MessageName() string { return "destroy" }

// Ensure ZwpTabletV1DestroyRequest implements Message.
var _ Message = ZwpTabletV1DestroyRequest{}

// Emit emits the message to the emitter.
func (r *ZwpTabletV1DestroyRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure ZwpTabletV1DestroyRequest implements Request.
var _ Request = &ZwpTabletV1DestroyRequest{}

// ZwpTabletV1NameEvent signals when tablet device name
//
// This event is sent in the initial burst of events before the
// wp_tablet.done event.
type ZwpTabletV1NameEvent struct {
	// Name contains the device name
	Name string
}

// Opcode returns the event opcode for zwp_tablet_v1.name in tablet_unstable_v1
func (ZwpTabletV1NameEvent) Opcode() uint16 { return 0 }

// MessageName returns the event name for zwp_tablet_v1.name in tablet_unstable_v1
func (ZwpTabletV1NameEvent) MessageName() string { return "name" }

// Ensure ZwpTabletV1NameEvent implements Message.
var _ Message = ZwpTabletV1NameEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletV1NameEvent) Scan(s *EventScanner) error {
	if v, err := s.String(); err != nil {
		return err
	} else {
		e.Name = v
	}
	return nil
}

// Ensure ZwpTabletV1NameEvent implements Event.
var _ Event = &ZwpTabletV1NameEvent{}

// ZwpTabletV1IDEvent signals when tablet device USB vendor/product id
//
// This event is sent in the initial burst of events before the
// wp_tablet.done event.
type ZwpTabletV1IDEvent struct {
	// Vid contains USB vendor id
	Vid uint32

	// Pid contains USB product id
	Pid uint32
}

// Opcode returns the event opcode for zwp_tablet_v1.id in tablet_unstable_v1
func (ZwpTabletV1IDEvent) Opcode() uint16 { return 1 }

// MessageName returns the event name for zwp_tablet_v1.id in tablet_unstable_v1
func (ZwpTabletV1IDEvent) MessageName() string { return "id" }

// Ensure ZwpTabletV1IDEvent implements Message.
var _ Message = ZwpTabletV1IDEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletV1IDEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Vid = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Pid = v
	}
	return nil
}

// Ensure ZwpTabletV1IDEvent implements Event.
var _ Event = &ZwpTabletV1IDEvent{}

// ZwpTabletV1PathEvent signals when path to the device
//
// A system-specific device path that indicates which device is behind
// this wp_tablet. This information may be used to gather additional
// information about the device, e.g. through libwacom.
//
// A device may have more than one device path. If so, multiple
// wp_tablet.path events are sent. A device may be emulated and not
// have a device path, and in that case this event will not be sent.
//
// The format of the path is unspecified, it may be a device node, a
// sysfs path, or some other identifier. It is up to the client to
// identify the string provided.
//
// This event is sent in the initial burst of events before the
// wp_tablet.done event.
type ZwpTabletV1PathEvent struct {
	// Path contains path to local device
	Path string
}

// Opcode returns the event opcode for zwp_tablet_v1.path in tablet_unstable_v1
func (ZwpTabletV1PathEvent) Opcode() uint16 { return 2 }

// MessageName returns the event name for zwp_tablet_v1.path in tablet_unstable_v1
func (ZwpTabletV1PathEvent) MessageName() string { return "path" }

// Ensure ZwpTabletV1PathEvent implements Message.
var _ Message = ZwpTabletV1PathEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletV1PathEvent) Scan(s *EventScanner) error {
	if v, err := s.String(); err != nil {
		return err
	} else {
		e.Path = v
	}
	return nil
}

// Ensure ZwpTabletV1PathEvent implements Event.
var _ Event = &ZwpTabletV1PathEvent{}

// ZwpTabletV1DoneEvent signals when tablet description events sequence complete
//
// This event is sent immediately to signal the end of the initial
// burst of descriptive events. A client may consider the static
// description of the tablet to be complete and finalize initialization
// of the tablet.
type ZwpTabletV1DoneEvent struct {
}

// Opcode returns the event opcode for zwp_tablet_v1.done in tablet_unstable_v1
func (ZwpTabletV1DoneEvent) Opcode() uint16 { return 3 }

// MessageName returns the event name for zwp_tablet_v1.done in tablet_unstable_v1
func (ZwpTabletV1DoneEvent) MessageName() string { return "done" }

// Ensure ZwpTabletV1DoneEvent implements Message.
var _ Message = ZwpTabletV1DoneEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletV1DoneEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure ZwpTabletV1DoneEvent implements Event.
var _ Event = &ZwpTabletV1DoneEvent{}

// ZwpTabletV1RemovedEvent signals when tablet removed event
//
// Sent when the tablet has been removed from the system. When a tablet
// is removed, some tools may be removed.
//
// When this event is received, the client must wp_tablet.destroy
// the object.
type ZwpTabletV1RemovedEvent struct {
}

// Opcode returns the event opcode for zwp_tablet_v1.removed in tablet_unstable_v1
func (ZwpTabletV1RemovedEvent) Opcode() uint16 { return 4 }

// MessageName returns the event name for zwp_tablet_v1.removed in tablet_unstable_v1
func (ZwpTabletV1RemovedEvent) MessageName() string { return "removed" }

// Ensure ZwpTabletV1RemovedEvent implements Message.
var _ Message = ZwpTabletV1RemovedEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletV1RemovedEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure ZwpTabletV1RemovedEvent implements Event.
var _ Event = &ZwpTabletV1RemovedEvent{}

// ZwpTabletV1 graphics tablet device
//
// The wp_tablet interface represents one graphics tablet device. The
// tablet interface itself does not generate events; all events are
// generated by wp_tablet_tool objects when in proximity above a tablet.
//
// A tablet has a number of static characteristics, e.g. device name and
// pid/vid. These capabilities are sent in an event sequence after the
// wp_tablet_seat.tablet_added event. This initial event sequence is
// terminated by a wp_tablet.done event.
type ZwpTabletV1 struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *ZwpTabletV1) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (ZwpTabletV1) Descriptor() *InterfaceDescriptor {
	return &ZwpTabletV1Descriptor
}

// Dispatch returns an Event object for a given opcode.
func (ZwpTabletV1) Dispatch(opcode uint16) Event {
	switch opcode {
	case 0:
		return &ZwpTabletV1NameEvent{}
	case 1:
		return &ZwpTabletV1IDEvent{}
	case 2:
		return &ZwpTabletV1PathEvent{}
	case 3:
		return &ZwpTabletV1DoneEvent{}
	case 4:
		return &ZwpTabletV1RemovedEvent{}
	default:
		return nil
	}
}

// Destroy requests to destroy the tablet object
//
// This destroys the client's resource for this tablet object.
func (proxy *ZwpTabletV1) Destroy(connection Connection) (err error) {
	request := ZwpTabletV1DestroyRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Ensure ZwpTabletV1 implements Proxy.
var _ Proxy = &ZwpTabletV1{}

// #endregion Interface tablet_unstable_v1.zwp_tablet_v1

////////////////////////////////////////////////////////////////////////////////
// #endregion Protocol tablet_unstable_v1

////////////////////////////////////////////////////////////////////////////////
// #region Protocol tablet_unstable_v2

// ----------------------------------------------------------------------------
// #region Interface tablet_unstable_v2.zwp_tablet_manager_v2

// ZwpTabletManagerV2GetTabletSeatRequest requests to get the tablet seat
//
// Get the wp_tablet_seat object for the given seat. This object
// provides access to all graphics tablets in this seat.
type ZwpTabletManagerV2GetTabletSeatRequest struct {
	TabletSeat ObjectID

	// Seat contains The wl_seat object to retrieve the tablets for
	Seat ObjectID
}

// Opcode returns the request opcode for zwp_tablet_manager_v2.get_tablet_seat in tablet_unstable_v2
func (ZwpTabletManagerV2GetTabletSeatRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for zwp_tablet_manager_v2.get_tablet_seat in tablet_unstable_v2
func (ZwpTabletManagerV2GetTabletSeatRequest) MessageName() string { return "get_tablet_seat" }

// Ensure ZwpTabletManagerV2GetTabletSeatRequest implements Message.
var _ Message = ZwpTabletManagerV2GetTabletSeatRequest{}

// Emit emits the message to the emitter.
func (r *ZwpTabletManagerV2GetTabletSeatRequest) Emit(e *RequestEmitter) error {
	if err := e.PutObjectID(r.TabletSeat); err != nil {
		return err
	}
	if err := e.PutObjectID(r.Seat); err != nil {
		return err
	}
	return nil
}

// Ensure ZwpTabletManagerV2GetTabletSeatRequest implements Request.
var _ Request = &ZwpTabletManagerV2GetTabletSeatRequest{}

// ZwpTabletManagerV2DestroyRequest requests to release the memory for the tablet manager object
//
// Destroy the wp_tablet_manager object. Objects created from this
// object are unaffected and should be destroyed separately.
type ZwpTabletManagerV2DestroyRequest struct {
}

// Opcode returns the request opcode for zwp_tablet_manager_v2.destroy in tablet_unstable_v2
func (ZwpTabletManagerV2DestroyRequest) Opcode() uint16 { return 1 }

// MessageName returns the request name for zwp_tablet_manager_v2.destroy in tablet_unstable_v2
func (ZwpTabletManagerV2DestroyRequest) MessageName() string { return "destroy" }

// Ensure ZwpTabletManagerV2DestroyRequest implements Message.
var _ Message = ZwpTabletManagerV2DestroyRequest{}

// Emit emits the message to the emitter.
func (r *ZwpTabletManagerV2DestroyRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure ZwpTabletManagerV2DestroyRequest implements Request.
var _ Request = &ZwpTabletManagerV2DestroyRequest{}

// ZwpTabletManagerV2 controller object for graphic tablet devices
//
// An object that provides access to the graphics tablets available on this
// system. All tablets are associated with a seat, to get access to the
// actual tablets, use wp_tablet_manager.get_tablet_seat.
type ZwpTabletManagerV2 struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *ZwpTabletManagerV2) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (ZwpTabletManagerV2) Descriptor() *InterfaceDescriptor {
	return &ZwpTabletManagerV2Descriptor
}

// Dispatch returns an Event object for a given opcode.
func (ZwpTabletManagerV2) Dispatch(opcode uint16) Event {
	switch opcode {
	default:
		return nil
	}
}

// GetTabletSeat requests to get the tablet seat
//
// Get the wp_tablet_seat object for the given seat. This object
// provides access to all graphics tablets in this seat.
func (proxy *ZwpTabletManagerV2) GetTabletSeat(connection Connection, aSeat ObjectID) (aTabletSeat *ZwpTabletSeatV2, err error) {
	aTabletSeat = &ZwpTabletSeatV2{connection.NewID()}
	request := ZwpTabletManagerV2GetTabletSeatRequest{
		TabletSeat: aTabletSeat.id,
		Seat:       aSeat,
	}
	err = connection.SendRequest(proxy.id, &request)
	if err == nil {
		connection.RegisterProxy(aTabletSeat)
	}
	return
}

// Destroy requests to release the memory for the tablet manager object
//
// Destroy the wp_tablet_manager object. Objects created from this
// object are unaffected and should be destroyed separately.
func (proxy *ZwpTabletManagerV2) Destroy(connection Connection) (err error) {
	request := ZwpTabletManagerV2DestroyRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Ensure ZwpTabletManagerV2 implements Proxy.
var _ Proxy = &ZwpTabletManagerV2{}

// #endregion Interface tablet_unstable_v2.zwp_tablet_manager_v2

// ----------------------------------------------------------------------------
// #region Interface tablet_unstable_v2.zwp_tablet_seat_v2

// ZwpTabletSeatV2DestroyRequest requests to release the memory for the tablet seat object
//
// Destroy the wp_tablet_seat object. Objects created from this
// object are unaffected and should be destroyed separately.
type ZwpTabletSeatV2DestroyRequest struct {
}

// Opcode returns the request opcode for zwp_tablet_seat_v2.destroy in tablet_unstable_v2
func (ZwpTabletSeatV2DestroyRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for zwp_tablet_seat_v2.destroy in tablet_unstable_v2
func (ZwpTabletSeatV2DestroyRequest) MessageName() string { return "destroy" }

// Ensure ZwpTabletSeatV2DestroyRequest implements Message.
var _ Message = ZwpTabletSeatV2DestroyRequest{}

// Emit emits the message to the emitter.
func (r *ZwpTabletSeatV2DestroyRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure ZwpTabletSeatV2DestroyRequest implements Request.
var _ Request = &ZwpTabletSeatV2DestroyRequest{}

// ZwpTabletSeatV2TabletAddedEvent signals when new device notification
//
// This event is sent whenever a new tablet becomes available on this
// seat. This event only provides the object id of the tablet, any
// static information about the tablet (device name, vid/pid, etc.) is
// sent through the wp_tablet interface.
type ZwpTabletSeatV2TabletAddedEvent struct {
	// ID contains the newly added graphics tablet
	ID ObjectID
}

// Opcode returns the event opcode for zwp_tablet_seat_v2.tablet_added in tablet_unstable_v2
func (ZwpTabletSeatV2TabletAddedEvent) Opcode() uint16 { return 0 }

// MessageName returns the event name for zwp_tablet_seat_v2.tablet_added in tablet_unstable_v2
func (ZwpTabletSeatV2TabletAddedEvent) MessageName() string { return "tablet_added" }

// Ensure ZwpTabletSeatV2TabletAddedEvent implements Message.
var _ Message = ZwpTabletSeatV2TabletAddedEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletSeatV2TabletAddedEvent) Scan(s *EventScanner) error {
	if v, err := s.ObjectID(); err != nil {
		return err
	} else {
		e.ID = v
	}
	return nil
}

// Ensure ZwpTabletSeatV2TabletAddedEvent implements Event.
var _ Event = &ZwpTabletSeatV2TabletAddedEvent{}

// ZwpTabletSeatV2ToolAddedEvent signals when a new tool has been used with a tablet
//
// This event is sent whenever a tool that has not previously been used
// with a tablet comes into use. This event only provides the object id
// of the tool; any static information about the tool (capabilities,
// type, etc.) is sent through the wp_tablet_tool interface.
type ZwpTabletSeatV2ToolAddedEvent struct {
	// ID contains the newly added tablet tool
	ID ObjectID
}

// Opcode returns the event opcode for zwp_tablet_seat_v2.tool_added in tablet_unstable_v2
func (ZwpTabletSeatV2ToolAddedEvent) Opcode() uint16 { return 1 }

// MessageName returns the event name for zwp_tablet_seat_v2.tool_added in tablet_unstable_v2
func (ZwpTabletSeatV2ToolAddedEvent) MessageName() string { return "tool_added" }

// Ensure ZwpTabletSeatV2ToolAddedEvent implements Message.
var _ Message = ZwpTabletSeatV2ToolAddedEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletSeatV2ToolAddedEvent) Scan(s *EventScanner) error {
	if v, err := s.ObjectID(); err != nil {
		return err
	} else {
		e.ID = v
	}
	return nil
}

// Ensure ZwpTabletSeatV2ToolAddedEvent implements Event.
var _ Event = &ZwpTabletSeatV2ToolAddedEvent{}

// ZwpTabletSeatV2PadAddedEvent signals when new pad notification
//
// This event is sent whenever a new pad is known to the system. Typically,
// pads are physically attached to tablets and a pad_added event is
// sent immediately after the wp_tablet_seat.tablet_added.
// However, some standalone pad devices logically attach to tablets at
// runtime, and the client must wait for wp_tablet_pad.enter to know
// the tablet a pad is attached to.
//
// This event only provides the object id of the pad. All further
// features (buttons, strips, rings) are sent through the wp_tablet_pad
// interface.
type ZwpTabletSeatV2PadAddedEvent struct {
	// ID contains the newly added pad
	ID ObjectID
}

// Opcode returns the event opcode for zwp_tablet_seat_v2.pad_added in tablet_unstable_v2
func (ZwpTabletSeatV2PadAddedEvent) Opcode() uint16 { return 2 }

// MessageName returns the event name for zwp_tablet_seat_v2.pad_added in tablet_unstable_v2
func (ZwpTabletSeatV2PadAddedEvent) MessageName() string { return "pad_added" }

// Ensure ZwpTabletSeatV2PadAddedEvent implements Message.
var _ Message = ZwpTabletSeatV2PadAddedEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletSeatV2PadAddedEvent) Scan(s *EventScanner) error {
	if v, err := s.ObjectID(); err != nil {
		return err
	} else {
		e.ID = v
	}
	return nil
}

// Ensure ZwpTabletSeatV2PadAddedEvent implements Event.
var _ Event = &ZwpTabletSeatV2PadAddedEvent{}

// ZwpTabletSeatV2 controller object for graphic tablet devices of a seat
//
// An object that provides access to the graphics tablets available on this
// seat. After binding to this interface, the compositor sends a set of
// wp_tablet_seat.tablet_added and wp_tablet_seat.tool_added events.
type ZwpTabletSeatV2 struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *ZwpTabletSeatV2) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (ZwpTabletSeatV2) Descriptor() *InterfaceDescriptor {
	return &ZwpTabletSeatV2Descriptor
}

// Dispatch returns an Event object for a given opcode.
func (ZwpTabletSeatV2) Dispatch(opcode uint16) Event {
	switch opcode {
	case 0:
		return &ZwpTabletSeatV2TabletAddedEvent{}
	case 1:
		return &ZwpTabletSeatV2ToolAddedEvent{}
	case 2:
		return &ZwpTabletSeatV2PadAddedEvent{}
	default:
		return nil
	}
}

// Destroy requests to release the memory for the tablet seat object
//
// Destroy the wp_tablet_seat object. Objects created from this
// object are unaffected and should be destroyed separately.
func (proxy *ZwpTabletSeatV2) Destroy(connection Connection) (err error) {
	request := ZwpTabletSeatV2DestroyRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Ensure ZwpTabletSeatV2 implements Proxy.
var _ Proxy = &ZwpTabletSeatV2{}

// #endregion Interface tablet_unstable_v2.zwp_tablet_seat_v2

// ----------------------------------------------------------------------------
// #region Interface tablet_unstable_v2.zwp_tablet_tool_v2

// ZwpTabletToolV2Type represents a physical tool type
//
// Describes the physical type of a tool. The physical type of a tool
// generally defines its base usage.
//
// The mouse tool represents a mouse-shaped tool that is not a relative
// device but bound to the tablet's surface, providing absolute
// coordinates.
//
// The lens tool is a mouse-shaped tool with an attached lens to
// provide precision focus.
type ZwpTabletToolV2Type int

const (
	// ZwpTabletToolV2TypePen corresponds to Pen
	ZwpTabletToolV2TypePen ZwpTabletToolV2Type = 0x140

	// ZwpTabletToolV2TypeEraser corresponds to Eraser
	ZwpTabletToolV2TypeEraser ZwpTabletToolV2Type = 0x141

	// ZwpTabletToolV2TypeBrush corresponds to Brush
	ZwpTabletToolV2TypeBrush ZwpTabletToolV2Type = 0x142

	// ZwpTabletToolV2TypePencil corresponds to Pencil
	ZwpTabletToolV2TypePencil ZwpTabletToolV2Type = 0x143

	// ZwpTabletToolV2TypeAirbrush corresponds to Airbrush
	ZwpTabletToolV2TypeAirbrush ZwpTabletToolV2Type = 0x144

	// ZwpTabletToolV2TypeFinger corresponds to Finger
	ZwpTabletToolV2TypeFinger ZwpTabletToolV2Type = 0x145

	// ZwpTabletToolV2TypeMouse corresponds to Mouse
	ZwpTabletToolV2TypeMouse ZwpTabletToolV2Type = 0x146

	// ZwpTabletToolV2TypeLens corresponds to Lens
	ZwpTabletToolV2TypeLens ZwpTabletToolV2Type = 0x147
)

// ZwpTabletToolV2Capability represents capability flags for a tool
//
// Describes extra capabilities on a tablet.
//
// Any tool must provide x and y values, extra axes are
// device-specific.
type ZwpTabletToolV2Capability int

const (
	// ZwpTabletToolV2CapabilityTilt corresponds to Tilt axes
	ZwpTabletToolV2CapabilityTilt ZwpTabletToolV2Capability = 1

	// ZwpTabletToolV2CapabilityPressure corresponds to Pressure axis
	ZwpTabletToolV2CapabilityPressure ZwpTabletToolV2Capability = 2

	// ZwpTabletToolV2CapabilityDistance corresponds to Distance axis
	ZwpTabletToolV2CapabilityDistance ZwpTabletToolV2Capability = 3

	// ZwpTabletToolV2CapabilityRotation corresponds to Z-rotation axis
	ZwpTabletToolV2CapabilityRotation ZwpTabletToolV2Capability = 4

	// ZwpTabletToolV2CapabilitySlider corresponds to Slider axis
	ZwpTabletToolV2CapabilitySlider ZwpTabletToolV2Capability = 5

	// ZwpTabletToolV2CapabilityWheel corresponds to Wheel axis
	ZwpTabletToolV2CapabilityWheel ZwpTabletToolV2Capability = 6
)

// ZwpTabletToolV2ButtonState represents physical button state
//
// Describes the physical state of a button that produced the button event.
type ZwpTabletToolV2ButtonState int

const (
	// ZwpTabletToolV2ButtonStateReleased corresponds to button is not pressed
	ZwpTabletToolV2ButtonStateReleased ZwpTabletToolV2ButtonState = 0

	// ZwpTabletToolV2ButtonStatePressed corresponds to button is pressed
	ZwpTabletToolV2ButtonStatePressed ZwpTabletToolV2ButtonState = 1
)

type ZwpTabletToolV2Error int

const (
	// ZwpTabletToolV2ErrorRole corresponds to given wl_surface has another role
	ZwpTabletToolV2ErrorRole ZwpTabletToolV2Error = 0
)

// ZwpTabletToolV2SetCursorRequest requests to set the tablet tool's surface
//
// Sets the surface of the cursor used for this tool on the given
// tablet. This request only takes effect if the tool is in proximity
// of one of the requesting client's surfaces or the surface parameter
// is the current pointer surface. If there was a previous surface set
// with this request it is replaced. If surface is NULL, the cursor
// image is hidden.
//
// The parameters hotspot_x and hotspot_y define the position of the
// pointer surface relative to the pointer location. Its top-left corner
// is always at (x, y) - (hotspot_x, hotspot_y), where (x, y) are the
// coordinates of the pointer location, in surface-local coordinates.
//
// On surface.attach requests to the pointer surface, hotspot_x and
// hotspot_y are decremented by the x and y parameters passed to the
// request. Attach must be confirmed by wl_surface.commit as usual.
//
// The hotspot can also be updated by passing the currently set pointer
// surface to this request with new values for hotspot_x and hotspot_y.
//
// The current and pending input regions of the wl_surface are cleared,
// and wl_surface.set_input_region is ignored until the wl_surface is no
// longer used as the cursor. When the use as a cursor ends, the current
// and pending input regions become undefined, and the wl_surface is
// unmapped.
//
// This request gives the surface the role of a wp_tablet_tool cursor. A
// surface may only ever be used as the cursor surface for one
// wp_tablet_tool. If the surface already has another role or has
// previously been used as cursor surface for a different tool, a
// protocol error is raised.
type ZwpTabletToolV2SetCursorRequest struct {
	// Serial contains serial of the enter event
	Serial uint32

	Surface ObjectID

	// HotspotX contains surface-local x coordinate
	HotspotX int32

	// HotspotY contains surface-local y coordinate
	HotspotY int32
}

// Opcode returns the request opcode for zwp_tablet_tool_v2.set_cursor in tablet_unstable_v2
func (ZwpTabletToolV2SetCursorRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for zwp_tablet_tool_v2.set_cursor in tablet_unstable_v2
func (ZwpTabletToolV2SetCursorRequest) MessageName() string { return "set_cursor" }

// Ensure ZwpTabletToolV2SetCursorRequest implements Message.
var _ Message = ZwpTabletToolV2SetCursorRequest{}

// Emit emits the message to the emitter.
func (r *ZwpTabletToolV2SetCursorRequest) Emit(e *RequestEmitter) error {
	if err := e.PutUint(r.Serial); err != nil {
		return err
	}
	if err := e.PutObjectID(r.Surface); err != nil {
		return err
	}
	if err := e.PutInt(r.HotspotX); err != nil {
		return err
	}
	if err := e.PutInt(r.HotspotY); err != nil {
		return err
	}
	return nil
}

// Ensure ZwpTabletToolV2SetCursorRequest implements Request.
var _ Request = &ZwpTabletToolV2SetCursorRequest{}

// ZwpTabletToolV2DestroyRequest requests to destroy the tool object
//
// This destroys the client's resource for this tool object.
type ZwpTabletToolV2DestroyRequest struct {
}

// Opcode returns the request opcode for zwp_tablet_tool_v2.destroy in tablet_unstable_v2
func (ZwpTabletToolV2DestroyRequest) Opcode() uint16 { return 1 }

// MessageName returns the request name for zwp_tablet_tool_v2.destroy in tablet_unstable_v2
func (ZwpTabletToolV2DestroyRequest) MessageName() string { return "destroy" }

// Ensure ZwpTabletToolV2DestroyRequest implements Message.
var _ Message = ZwpTabletToolV2DestroyRequest{}

// Emit emits the message to the emitter.
func (r *ZwpTabletToolV2DestroyRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure ZwpTabletToolV2DestroyRequest implements Request.
var _ Request = &ZwpTabletToolV2DestroyRequest{}

// ZwpTabletToolV2TypeEvent signals when tool type
//
// The tool type is the high-level type of the tool and usually decides
// the interaction expected from this tool.
//
// This event is sent in the initial burst of events before the
// wp_tablet_tool.done event.
type ZwpTabletToolV2TypeEvent struct {
	// ToolType contains the physical tool type
	ToolType uint32
}

// Opcode returns the event opcode for zwp_tablet_tool_v2.type in tablet_unstable_v2
func (ZwpTabletToolV2TypeEvent) Opcode() uint16 { return 0 }

// MessageName returns the event name for zwp_tablet_tool_v2.type in tablet_unstable_v2
func (ZwpTabletToolV2TypeEvent) MessageName() string { return "type" }

// Ensure ZwpTabletToolV2TypeEvent implements Message.
var _ Message = ZwpTabletToolV2TypeEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletToolV2TypeEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.ToolType = v
	}
	return nil
}

// Ensure ZwpTabletToolV2TypeEvent implements Event.
var _ Event = &ZwpTabletToolV2TypeEvent{}

// ZwpTabletToolV2HardwareSerialEvent signals when unique hardware serial number of the tool
//
// If the physical tool can be identified by a unique 64-bit serial
// number, this event notifies the client of this serial number.
//
// If multiple tablets are available in the same seat and the tool is
// uniquely identifiable by the serial number, that tool may move
// between tablets.
//
// Otherwise, if the tool has no serial number and this event is
// missing, the tool is tied to the tablet it first comes into
// proximity with. Even if the physical tool is used on multiple
// tablets, separate wp_tablet_tool objects will be created, one per
// tablet.
//
// This event is sent in the initial burst of events before the
// wp_tablet_tool.done event.
type ZwpTabletToolV2HardwareSerialEvent struct {
	// HardwareSerialHi contains the unique serial number of the tool, most significant bits
	HardwareSerialHi uint32

	// HardwareSerialLo contains the unique serial number of the tool, least significant bits
	HardwareSerialLo uint32
}

// Opcode returns the event opcode for zwp_tablet_tool_v2.hardware_serial in tablet_unstable_v2
func (ZwpTabletToolV2HardwareSerialEvent) Opcode() uint16 { return 1 }

// MessageName returns the event name for zwp_tablet_tool_v2.hardware_serial in tablet_unstable_v2
func (ZwpTabletToolV2HardwareSerialEvent) MessageName() string { return "hardware_serial" }

// Ensure ZwpTabletToolV2HardwareSerialEvent implements Message.
var _ Message = ZwpTabletToolV2HardwareSerialEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletToolV2HardwareSerialEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.HardwareSerialHi = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.HardwareSerialLo = v
	}
	return nil
}

// Ensure ZwpTabletToolV2HardwareSerialEvent implements Event.
var _ Event = &ZwpTabletToolV2HardwareSerialEvent{}

// ZwpTabletToolV2HardwareIDWacomEvent signals when hardware id notification in Wacom's format
//
// This event notifies the client of a hardware id available on this tool.
//
// The hardware id is a device-specific 64-bit id that provides extra
// information about the tool in use, beyond the wl_tool.type
// enumeration. The format of the id is specific to tablets made by
// Wacom Inc. For example, the hardware id of a Wacom Grip
// Pen (a stylus) is 0x802.
//
// This event is sent in the initial burst of events before the
// wp_tablet_tool.done event.
type ZwpTabletToolV2HardwareIDWacomEvent struct {
	// HardwareIDHi contains the hardware id, most significant bits
	HardwareIDHi uint32

	// HardwareIDLo contains the hardware id, least significant bits
	HardwareIDLo uint32
}

// Opcode returns the event opcode for zwp_tablet_tool_v2.hardware_id_wacom in tablet_unstable_v2
func (ZwpTabletToolV2HardwareIDWacomEvent) Opcode() uint16 { return 2 }

// MessageName returns the event name for zwp_tablet_tool_v2.hardware_id_wacom in tablet_unstable_v2
func (ZwpTabletToolV2HardwareIDWacomEvent) MessageName() string { return "hardware_id_wacom" }

// Ensure ZwpTabletToolV2HardwareIDWacomEvent implements Message.
var _ Message = ZwpTabletToolV2HardwareIDWacomEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletToolV2HardwareIDWacomEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.HardwareIDHi = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.HardwareIDLo = v
	}
	return nil
}

// Ensure ZwpTabletToolV2HardwareIDWacomEvent implements Event.
var _ Event = &ZwpTabletToolV2HardwareIDWacomEvent{}

// ZwpTabletToolV2CapabilityEvent signals when tool capability notification
//
// This event notifies the client of any capabilities of this tool,
// beyond the main set of x/y axes and tip up/down detection.
//
// One event is sent for each extra capability available on this tool.
//
// This event is sent in the initial burst of events before the
// wp_tablet_tool.done event.
type ZwpTabletToolV2CapabilityEvent struct {
	// Capability contains the capability
	Capability uint32
}

// Opcode returns the event opcode for zwp_tablet_tool_v2.capability in tablet_unstable_v2
func (ZwpTabletToolV2CapabilityEvent) Opcode() uint16 { return 3 }

// MessageName returns the event name for zwp_tablet_tool_v2.capability in tablet_unstable_v2
func (ZwpTabletToolV2CapabilityEvent) MessageName() string { return "capability" }

// Ensure ZwpTabletToolV2CapabilityEvent implements Message.
var _ Message = ZwpTabletToolV2CapabilityEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletToolV2CapabilityEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Capability = v
	}
	return nil
}

// Ensure ZwpTabletToolV2CapabilityEvent implements Event.
var _ Event = &ZwpTabletToolV2CapabilityEvent{}

// ZwpTabletToolV2DoneEvent signals when tool description events sequence complete
//
// This event signals the end of the initial burst of descriptive
// events. A client may consider the static description of the tool to
// be complete and finalize initialization of the tool.
type ZwpTabletToolV2DoneEvent struct {
}

// Opcode returns the event opcode for zwp_tablet_tool_v2.done in tablet_unstable_v2
func (ZwpTabletToolV2DoneEvent) Opcode() uint16 { return 4 }

// MessageName returns the event name for zwp_tablet_tool_v2.done in tablet_unstable_v2
func (ZwpTabletToolV2DoneEvent) MessageName() string { return "done" }

// Ensure ZwpTabletToolV2DoneEvent implements Message.
var _ Message = ZwpTabletToolV2DoneEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletToolV2DoneEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure ZwpTabletToolV2DoneEvent implements Event.
var _ Event = &ZwpTabletToolV2DoneEvent{}

// ZwpTabletToolV2RemovedEvent signals when tool removed
//
// This event is sent when the tool is removed from the system and will
// send no further events. Should the physical tool come back into
// proximity later, a new wp_tablet_tool object will be created.
//
// It is compositor-dependent when a tool is removed. A compositor may
// remove a tool on proximity out, tablet removal or any other reason.
// A compositor may also keep a tool alive until shutdown.
//
// If the tool is currently in proximity, a proximity_out event will be
// sent before the removed event. See wp_tablet_tool.proximity_out for
// the handling of any buttons logically down.
//
// When this event is received, the client must wp_tablet_tool.destroy
// the object.
type ZwpTabletToolV2RemovedEvent struct {
}

// Opcode returns the event opcode for zwp_tablet_tool_v2.removed in tablet_unstable_v2
func (ZwpTabletToolV2RemovedEvent) Opcode() uint16 { return 5 }

// MessageName returns the event name for zwp_tablet_tool_v2.removed in tablet_unstable_v2
func (ZwpTabletToolV2RemovedEvent) MessageName() string { return "removed" }

// Ensure ZwpTabletToolV2RemovedEvent implements Message.
var _ Message = ZwpTabletToolV2RemovedEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletToolV2RemovedEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure ZwpTabletToolV2RemovedEvent implements Event.
var _ Event = &ZwpTabletToolV2RemovedEvent{}

// ZwpTabletToolV2ProximityInEvent signals when proximity in event
//
// Notification that this tool is focused on a certain surface.
//
// This event can be received when the tool has moved from one surface to
// another, or when the tool has come back into proximity above the
// surface.
//
// If any button is logically down when the tool comes into proximity,
// the respective button event is sent after the proximity_in event but
// within the same frame as the proximity_in event.
type ZwpTabletToolV2ProximityInEvent struct {
	Serial uint32

	// Tablet contains The tablet the tool is in proximity of
	Tablet ObjectID

	// Surface contains The current surface the tablet tool is over
	Surface ObjectID
}

// Opcode returns the event opcode for zwp_tablet_tool_v2.proximity_in in tablet_unstable_v2
func (ZwpTabletToolV2ProximityInEvent) Opcode() uint16 { return 6 }

// MessageName returns the event name for zwp_tablet_tool_v2.proximity_in in tablet_unstable_v2
func (ZwpTabletToolV2ProximityInEvent) MessageName() string { return "proximity_in" }

// Ensure ZwpTabletToolV2ProximityInEvent implements Message.
var _ Message = ZwpTabletToolV2ProximityInEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletToolV2ProximityInEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Serial = v
	}
	if v, err := s.ObjectID(); err != nil {
		return err
	} else {
		e.Tablet = v
	}
	if v, err := s.ObjectID(); err != nil {
		return err
	} else {
		e.Surface = v
	}
	return nil
}

// Ensure ZwpTabletToolV2ProximityInEvent implements Event.
var _ Event = &ZwpTabletToolV2ProximityInEvent{}

// ZwpTabletToolV2ProximityOutEvent signals when proximity out event
//
// Notification that this tool has either left proximity, or is no
// longer focused on a certain surface.
//
// When the tablet tool leaves proximity of the tablet, button release
// events are sent for each button that was held down at the time of
// leaving proximity. These events are sent before the proximity_out
// event but within the same wp_tablet.frame.
//
// If the tool stays within proximity of the tablet, but the focus
// changes from one surface to another, a button release event may not
// be sent until the button is actually released or the tool leaves the
// proximity of the tablet.
type ZwpTabletToolV2ProximityOutEvent struct {
}

// Opcode returns the event opcode for zwp_tablet_tool_v2.proximity_out in tablet_unstable_v2
func (ZwpTabletToolV2ProximityOutEvent) Opcode() uint16 { return 7 }

// MessageName returns the event name for zwp_tablet_tool_v2.proximity_out in tablet_unstable_v2
func (ZwpTabletToolV2ProximityOutEvent) MessageName() string { return "proximity_out" }

// Ensure ZwpTabletToolV2ProximityOutEvent implements Message.
var _ Message = ZwpTabletToolV2ProximityOutEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletToolV2ProximityOutEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure ZwpTabletToolV2ProximityOutEvent implements Event.
var _ Event = &ZwpTabletToolV2ProximityOutEvent{}

// ZwpTabletToolV2DownEvent signals when tablet tool is making contact
//
// Sent whenever the tablet tool comes in contact with the surface of the
// tablet.
//
// If the tool is already in contact with the tablet when entering the
// input region, the client owning said region will receive a
// wp_tablet.proximity_in event, followed by a wp_tablet.down
// event and a wp_tablet.frame event.
//
// Note that this event describes logical contact, not physical
// contact. On some devices, a compositor may not consider a tool in
// logical contact until a minimum physical pressure threshold is
// exceeded.
type ZwpTabletToolV2DownEvent struct {
	Serial uint32
}

// Opcode returns the event opcode for zwp_tablet_tool_v2.down in tablet_unstable_v2
func (ZwpTabletToolV2DownEvent) Opcode() uint16 { return 8 }

// MessageName returns the event name for zwp_tablet_tool_v2.down in tablet_unstable_v2
func (ZwpTabletToolV2DownEvent) MessageName() string { return "down" }

// Ensure ZwpTabletToolV2DownEvent implements Message.
var _ Message = ZwpTabletToolV2DownEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletToolV2DownEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Serial = v
	}
	return nil
}

// Ensure ZwpTabletToolV2DownEvent implements Event.
var _ Event = &ZwpTabletToolV2DownEvent{}

// ZwpTabletToolV2UpEvent signals when tablet tool is no longer making contact
//
// Sent whenever the tablet tool stops making contact with the surface of
// the tablet, or when the tablet tool moves out of the input region
// and the compositor grab (if any) is dismissed.
//
// If the tablet tool moves out of the input region while in contact
// with the surface of the tablet and the compositor does not have an
// ongoing grab on the surface, the client owning said region will
// receive a wp_tablet.up event, followed by a wp_tablet.proximity_out
// event and a wp_tablet.frame event. If the compositor has an ongoing
// grab on this device, this event sequence is sent whenever the grab
// is dismissed in the future.
//
// Note that this event describes logical contact, not physical
// contact. On some devices, a compositor may not consider a tool out
// of logical contact until physical pressure falls below a specific
// threshold.
type ZwpTabletToolV2UpEvent struct {
}

// Opcode returns the event opcode for zwp_tablet_tool_v2.up in tablet_unstable_v2
func (ZwpTabletToolV2UpEvent) Opcode() uint16 { return 9 }

// MessageName returns the event name for zwp_tablet_tool_v2.up in tablet_unstable_v2
func (ZwpTabletToolV2UpEvent) MessageName() string { return "up" }

// Ensure ZwpTabletToolV2UpEvent implements Message.
var _ Message = ZwpTabletToolV2UpEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletToolV2UpEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure ZwpTabletToolV2UpEvent implements Event.
var _ Event = &ZwpTabletToolV2UpEvent{}

// ZwpTabletToolV2MotionEvent signals when motion event
//
// Sent whenever a tablet tool moves.
type ZwpTabletToolV2MotionEvent struct {
	// X contains surface-local x coordinate
	X Fixed

	// Y contains surface-local y coordinate
	Y Fixed
}

// Opcode returns the event opcode for zwp_tablet_tool_v2.motion in tablet_unstable_v2
func (ZwpTabletToolV2MotionEvent) Opcode() uint16 { return 10 }

// MessageName returns the event name for zwp_tablet_tool_v2.motion in tablet_unstable_v2
func (ZwpTabletToolV2MotionEvent) MessageName() string { return "motion" }

// Ensure ZwpTabletToolV2MotionEvent implements Message.
var _ Message = ZwpTabletToolV2MotionEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletToolV2MotionEvent) Scan(s *EventScanner) error {
	if v, err := s.Fixed(); err != nil {
		return err
	} else {
		e.X = v
	}
	if v, err := s.Fixed(); err != nil {
		return err
	} else {
		e.Y = v
	}
	return nil
}

// Ensure ZwpTabletToolV2MotionEvent implements Event.
var _ Event = &ZwpTabletToolV2MotionEvent{}

// ZwpTabletToolV2PressureEvent signals when pressure change event
//
// Sent whenever the pressure axis on a tool changes. The value of this
// event is normalized to a value between 0 and 65535.
//
// Note that pressure may be nonzero even when a tool is not in logical
// contact. See the down and up events for more details.
type ZwpTabletToolV2PressureEvent struct {
	// Pressure contains The current pressure value
	Pressure uint32
}

// Opcode returns the event opcode for zwp_tablet_tool_v2.pressure in tablet_unstable_v2
func (ZwpTabletToolV2PressureEvent) Opcode() uint16 { return 11 }

// MessageName returns the event name for zwp_tablet_tool_v2.pressure in tablet_unstable_v2
func (ZwpTabletToolV2PressureEvent) MessageName() string { return "pressure" }

// Ensure ZwpTabletToolV2PressureEvent implements Message.
var _ Message = ZwpTabletToolV2PressureEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletToolV2PressureEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Pressure = v
	}
	return nil
}

// Ensure ZwpTabletToolV2PressureEvent implements Event.
var _ Event = &ZwpTabletToolV2PressureEvent{}

// ZwpTabletToolV2DistanceEvent signals when distance change event
//
// Sent whenever the distance axis on a tool changes. The value of this
// event is normalized to a value between 0 and 65535.
//
// Note that distance may be nonzero even when a tool is not in logical
// contact. See the down and up events for more details.
type ZwpTabletToolV2DistanceEvent struct {
	// Distance contains The current distance value
	Distance uint32
}

// Opcode returns the event opcode for zwp_tablet_tool_v2.distance in tablet_unstable_v2
func (ZwpTabletToolV2DistanceEvent) Opcode() uint16 { return 12 }

// MessageName returns the event name for zwp_tablet_tool_v2.distance in tablet_unstable_v2
func (ZwpTabletToolV2DistanceEvent) MessageName() string { return "distance" }

// Ensure ZwpTabletToolV2DistanceEvent implements Message.
var _ Message = ZwpTabletToolV2DistanceEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletToolV2DistanceEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Distance = v
	}
	return nil
}

// Ensure ZwpTabletToolV2DistanceEvent implements Event.
var _ Event = &ZwpTabletToolV2DistanceEvent{}

// ZwpTabletToolV2TiltEvent signals when tilt change event
//
// Sent whenever one or both of the tilt axes on a tool change. Each tilt
// value is in degrees, relative to the z-axis of the tablet.
// The angle is positive when the top of a tool tilts along the
// positive x or y axis.
type ZwpTabletToolV2TiltEvent struct {
	// TiltX contains The current value of the X tilt axis
	TiltX Fixed

	// TiltY contains The current value of the Y tilt axis
	TiltY Fixed
}

// Opcode returns the event opcode for zwp_tablet_tool_v2.tilt in tablet_unstable_v2
func (ZwpTabletToolV2TiltEvent) Opcode() uint16 { return 13 }

// MessageName returns the event name for zwp_tablet_tool_v2.tilt in tablet_unstable_v2
func (ZwpTabletToolV2TiltEvent) MessageName() string { return "tilt" }

// Ensure ZwpTabletToolV2TiltEvent implements Message.
var _ Message = ZwpTabletToolV2TiltEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletToolV2TiltEvent) Scan(s *EventScanner) error {
	if v, err := s.Fixed(); err != nil {
		return err
	} else {
		e.TiltX = v
	}
	if v, err := s.Fixed(); err != nil {
		return err
	} else {
		e.TiltY = v
	}
	return nil
}

// Ensure ZwpTabletToolV2TiltEvent implements Event.
var _ Event = &ZwpTabletToolV2TiltEvent{}

// ZwpTabletToolV2RotationEvent signals when z-rotation change event
//
// Sent whenever the z-rotation axis on the tool changes. The
// rotation value is in degrees clockwise from the tool's
// logical neutral position.
type ZwpTabletToolV2RotationEvent struct {
	// Degrees contains The current rotation of the Z axis
	Degrees Fixed
}

// Opcode returns the event opcode for zwp_tablet_tool_v2.rotation in tablet_unstable_v2
func (ZwpTabletToolV2RotationEvent) Opcode() uint16 { return 14 }

// MessageName returns the event name for zwp_tablet_tool_v2.rotation in tablet_unstable_v2
func (ZwpTabletToolV2RotationEvent) MessageName() string { return "rotation" }

// Ensure ZwpTabletToolV2RotationEvent implements Message.
var _ Message = ZwpTabletToolV2RotationEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletToolV2RotationEvent) Scan(s *EventScanner) error {
	if v, err := s.Fixed(); err != nil {
		return err
	} else {
		e.Degrees = v
	}
	return nil
}

// Ensure ZwpTabletToolV2RotationEvent implements Event.
var _ Event = &ZwpTabletToolV2RotationEvent{}

// ZwpTabletToolV2SliderEvent signals when Slider position change event
//
// Sent whenever the slider position on the tool changes. The
// value is normalized between -65535 and 65535, with 0 as the logical
// neutral position of the slider.
//
// The slider is available on e.g. the Wacom Airbrush tool.
type ZwpTabletToolV2SliderEvent struct {
	// Position contains The current position of slider
	Position int32
}

// Opcode returns the event opcode for zwp_tablet_tool_v2.slider in tablet_unstable_v2
func (ZwpTabletToolV2SliderEvent) Opcode() uint16 { return 15 }

// MessageName returns the event name for zwp_tablet_tool_v2.slider in tablet_unstable_v2
func (ZwpTabletToolV2SliderEvent) MessageName() string { return "slider" }

// Ensure ZwpTabletToolV2SliderEvent implements Message.
var _ Message = ZwpTabletToolV2SliderEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletToolV2SliderEvent) Scan(s *EventScanner) error {
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.Position = v
	}
	return nil
}

// Ensure ZwpTabletToolV2SliderEvent implements Event.
var _ Event = &ZwpTabletToolV2SliderEvent{}

// ZwpTabletToolV2WheelEvent signals when Wheel delta event
//
// Sent whenever the wheel on the tool emits an event. This event
// contains two values for the same axis change. The degrees value is
// in the same orientation as the wl_pointer.vertical_scroll axis. The
// clicks value is in discrete logical clicks of the mouse wheel. This
// value may be zero if the movement of the wheel was less
// than one logical click.
//
// Clients should choose either value and avoid mixing degrees and
// clicks. The compositor may accumulate values smaller than a logical
// click and emulate click events when a certain threshold is met.
// Thus, wl_tablet_tool.wheel events with non-zero clicks values may
// have different degrees values.
type ZwpTabletToolV2WheelEvent struct {
	// Degrees contains The wheel delta in degrees
	Degrees Fixed

	// Clicks contains The wheel delta in discrete clicks
	Clicks int32
}

// Opcode returns the event opcode for zwp_tablet_tool_v2.wheel in tablet_unstable_v2
func (ZwpTabletToolV2WheelEvent) Opcode() uint16 { return 16 }

// MessageName returns the event name for zwp_tablet_tool_v2.wheel in tablet_unstable_v2
func (ZwpTabletToolV2WheelEvent) MessageName() string { return "wheel" }

// Ensure ZwpTabletToolV2WheelEvent implements Message.
var _ Message = ZwpTabletToolV2WheelEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletToolV2WheelEvent) Scan(s *EventScanner) error {
	if v, err := s.Fixed(); err != nil {
		return err
	} else {
		e.Degrees = v
	}
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.Clicks = v
	}
	return nil
}

// Ensure ZwpTabletToolV2WheelEvent implements Event.
var _ Event = &ZwpTabletToolV2WheelEvent{}

// ZwpTabletToolV2ButtonEvent signals when button event
//
// Sent whenever a button on the tool is pressed or released.
//
// If a button is held down when the tool moves in or out of proximity,
// button events are generated by the compositor. See
// wp_tablet_tool.proximity_in and wp_tablet_tool.proximity_out for
// details.
type ZwpTabletToolV2ButtonEvent struct {
	Serial uint32

	// Button contains The button whose state has changed
	Button uint32

	// State contains Whether the button was pressed or released
	State uint32
}

// Opcode returns the event opcode for zwp_tablet_tool_v2.button in tablet_unstable_v2
func (ZwpTabletToolV2ButtonEvent) Opcode() uint16 { return 17 }

// MessageName returns the event name for zwp_tablet_tool_v2.button in tablet_unstable_v2
func (ZwpTabletToolV2ButtonEvent) MessageName() string { return "button" }

// Ensure ZwpTabletToolV2ButtonEvent implements Message.
var _ Message = ZwpTabletToolV2ButtonEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletToolV2ButtonEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Serial = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Button = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.State = v
	}
	return nil
}

// Ensure ZwpTabletToolV2ButtonEvent implements Event.
var _ Event = &ZwpTabletToolV2ButtonEvent{}

// ZwpTabletToolV2FrameEvent signals when frame event
//
// Marks the end of a series of axis and/or button updates from the
// tablet. The Wayland protocol requires axis updates to be sent
// sequentially, however all events within a frame should be considered
// one hardware event.
type ZwpTabletToolV2FrameEvent struct {
	// Time contains The time of the event with millisecond granularity
	Time uint32
}

// Opcode returns the event opcode for zwp_tablet_tool_v2.frame in tablet_unstable_v2
func (ZwpTabletToolV2FrameEvent) Opcode() uint16 { return 18 }

// MessageName returns the event name for zwp_tablet_tool_v2.frame in tablet_unstable_v2
func (ZwpTabletToolV2FrameEvent) MessageName() string { return "frame" }

// Ensure ZwpTabletToolV2FrameEvent implements Message.
var _ Message = ZwpTabletToolV2FrameEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletToolV2FrameEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Time = v
	}
	return nil
}

// Ensure ZwpTabletToolV2FrameEvent implements Event.
var _ Event = &ZwpTabletToolV2FrameEvent{}

// ZwpTabletToolV2 a physical tablet tool
//
// An object that represents a physical tool that has been, or is
// currently in use with a tablet in this seat. Each wp_tablet_tool
// object stays valid until the client destroys it; the compositor
// reuses the wp_tablet_tool object to indicate that the object's
// respective physical tool has come into proximity of a tablet again.
//
// A wp_tablet_tool object's relation to a physical tool depends on the
// tablet's ability to report serial numbers. If the tablet supports
// this capability, then the object represents a specific physical tool
// and can be identified even when used on multiple tablets.
//
// A tablet tool has a number of static characteristics, e.g. tool type,
// hardware_serial and capabilities. These capabilities are sent in an
// event sequence after the wp_tablet_seat.tool_added event before any
// actual events from this tool. This initial event sequence is
// terminated by a wp_tablet_tool.done event.
//
// Tablet tool events are grouped by wp_tablet_tool.frame events.
// Any events received before a wp_tablet_tool.frame event should be
// considered part of the same hardware state change.
type ZwpTabletToolV2 struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *ZwpTabletToolV2) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (ZwpTabletToolV2) Descriptor() *InterfaceDescriptor {
	return &ZwpTabletToolV2Descriptor
}

// Dispatch returns an Event object for a given opcode.
func (ZwpTabletToolV2) Dispatch(opcode uint16) Event {
	switch opcode {
	case 0:
		return &ZwpTabletToolV2TypeEvent{}
	case 1:
		return &ZwpTabletToolV2HardwareSerialEvent{}
	case 2:
		return &ZwpTabletToolV2HardwareIDWacomEvent{}
	case 3:
		return &ZwpTabletToolV2CapabilityEvent{}
	case 4:
		return &ZwpTabletToolV2DoneEvent{}
	case 5:
		return &ZwpTabletToolV2RemovedEvent{}
	case 6:
		return &ZwpTabletToolV2ProximityInEvent{}
	case 7:
		return &ZwpTabletToolV2ProximityOutEvent{}
	case 8:
		return &ZwpTabletToolV2DownEvent{}
	case 9:
		return &ZwpTabletToolV2UpEvent{}
	case 10:
		return &ZwpTabletToolV2MotionEvent{}
	case 11:
		return &ZwpTabletToolV2PressureEvent{}
	case 12:
		return &ZwpTabletToolV2DistanceEvent{}
	case 13:
		return &ZwpTabletToolV2TiltEvent{}
	case 14:
		return &ZwpTabletToolV2RotationEvent{}
	case 15:
		return &ZwpTabletToolV2SliderEvent{}
	case 16:
		return &ZwpTabletToolV2WheelEvent{}
	case 17:
		return &ZwpTabletToolV2ButtonEvent{}
	case 18:
		return &ZwpTabletToolV2FrameEvent{}
	default:
		return nil
	}
}

// SetCursor requests to set the tablet tool's surface
//
// Sets the surface of the cursor used for this tool on the given
// tablet. This request only takes effect if the tool is in proximity
// of one of the requesting client's surfaces or the surface parameter
// is the current pointer surface. If there was a previous surface set
// with this request it is replaced. If surface is NULL, the cursor
// image is hidden.
//
// The parameters hotspot_x and hotspot_y define the position of the
// pointer surface relative to the pointer location. Its top-left corner
// is always at (x, y) - (hotspot_x, hotspot_y), where (x, y) are the
// coordinates of the pointer location, in surface-local coordinates.
//
// On surface.attach requests to the pointer surface, hotspot_x and
// hotspot_y are decremented by the x and y parameters passed to the
// request. Attach must be confirmed by wl_surface.commit as usual.
//
// The hotspot can also be updated by passing the currently set pointer
// surface to this request with new values for hotspot_x and hotspot_y.
//
// The current and pending input regions of the wl_surface are cleared,
// and wl_surface.set_input_region is ignored until the wl_surface is no
// longer used as the cursor. When the use as a cursor ends, the current
// and pending input regions become undefined, and the wl_surface is
// unmapped.
//
// This request gives the surface the role of a wp_tablet_tool cursor. A
// surface may only ever be used as the cursor surface for one
// wp_tablet_tool. If the surface already has another role or has
// previously been used as cursor surface for a different tool, a
// protocol error is raised.
func (proxy *ZwpTabletToolV2) SetCursor(connection Connection, aSerial uint32, aSurface ObjectID, aHotspotX int32, aHotspotY int32) (err error) {
	request := ZwpTabletToolV2SetCursorRequest{
		Serial:   aSerial,
		Surface:  aSurface,
		HotspotX: aHotspotX,
		HotspotY: aHotspotY,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Destroy requests to destroy the tool object
//
// This destroys the client's resource for this tool object.
func (proxy *ZwpTabletToolV2) Destroy(connection Connection) (err error) {
	request := ZwpTabletToolV2DestroyRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Ensure ZwpTabletToolV2 implements Proxy.
var _ Proxy = &ZwpTabletToolV2{}

// #endregion Interface tablet_unstable_v2.zwp_tablet_tool_v2

// ----------------------------------------------------------------------------
// #region Interface tablet_unstable_v2.zwp_tablet_v2

// ZwpTabletV2DestroyRequest requests to destroy the tablet object
//
// This destroys the client's resource for this tablet object.
type ZwpTabletV2DestroyRequest struct {
}

// Opcode returns the request opcode for zwp_tablet_v2.destroy in tablet_unstable_v2
func (ZwpTabletV2DestroyRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for zwp_tablet_v2.destroy in tablet_unstable_v2
func (ZwpTabletV2DestroyRequest) MessageName() string { return "destroy" }

// Ensure ZwpTabletV2DestroyRequest implements Message.
var _ Message = ZwpTabletV2DestroyRequest{}

// Emit emits the message to the emitter.
func (r *ZwpTabletV2DestroyRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure ZwpTabletV2DestroyRequest implements Request.
var _ Request = &ZwpTabletV2DestroyRequest{}

// ZwpTabletV2NameEvent signals when tablet device name
//
// This event is sent in the initial burst of events before the
// wp_tablet.done event.
type ZwpTabletV2NameEvent struct {
	// Name contains the device name
	Name string
}

// Opcode returns the event opcode for zwp_tablet_v2.name in tablet_unstable_v2
func (ZwpTabletV2NameEvent) Opcode() uint16 { return 0 }

// MessageName returns the event name for zwp_tablet_v2.name in tablet_unstable_v2
func (ZwpTabletV2NameEvent) MessageName() string { return "name" }

// Ensure ZwpTabletV2NameEvent implements Message.
var _ Message = ZwpTabletV2NameEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletV2NameEvent) Scan(s *EventScanner) error {
	if v, err := s.String(); err != nil {
		return err
	} else {
		e.Name = v
	}
	return nil
}

// Ensure ZwpTabletV2NameEvent implements Event.
var _ Event = &ZwpTabletV2NameEvent{}

// ZwpTabletV2IDEvent signals when tablet device USB vendor/product id
//
// This event is sent in the initial burst of events before the
// wp_tablet.done event.
type ZwpTabletV2IDEvent struct {
	// Vid contains USB vendor id
	Vid uint32

	// Pid contains USB product id
	Pid uint32
}

// Opcode returns the event opcode for zwp_tablet_v2.id in tablet_unstable_v2
func (ZwpTabletV2IDEvent) Opcode() uint16 { return 1 }

// MessageName returns the event name for zwp_tablet_v2.id in tablet_unstable_v2
func (ZwpTabletV2IDEvent) MessageName() string { return "id" }

// Ensure ZwpTabletV2IDEvent implements Message.
var _ Message = ZwpTabletV2IDEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletV2IDEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Vid = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Pid = v
	}
	return nil
}

// Ensure ZwpTabletV2IDEvent implements Event.
var _ Event = &ZwpTabletV2IDEvent{}

// ZwpTabletV2PathEvent signals when path to the device
//
// A system-specific device path that indicates which device is behind
// this wp_tablet. This information may be used to gather additional
// information about the device, e.g. through libwacom.
//
// A device may have more than one device path. If so, multiple
// wp_tablet.path events are sent. A device may be emulated and not
// have a device path, and in that case this event will not be sent.
//
// The format of the path is unspecified, it may be a device node, a
// sysfs path, or some other identifier. It is up to the client to
// identify the string provided.
//
// This event is sent in the initial burst of events before the
// wp_tablet.done event.
type ZwpTabletV2PathEvent struct {
	// Path contains path to local device
	Path string
}

// Opcode returns the event opcode for zwp_tablet_v2.path in tablet_unstable_v2
func (ZwpTabletV2PathEvent) Opcode() uint16 { return 2 }

// MessageName returns the event name for zwp_tablet_v2.path in tablet_unstable_v2
func (ZwpTabletV2PathEvent) MessageName() string { return "path" }

// Ensure ZwpTabletV2PathEvent implements Message.
var _ Message = ZwpTabletV2PathEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletV2PathEvent) Scan(s *EventScanner) error {
	if v, err := s.String(); err != nil {
		return err
	} else {
		e.Path = v
	}
	return nil
}

// Ensure ZwpTabletV2PathEvent implements Event.
var _ Event = &ZwpTabletV2PathEvent{}

// ZwpTabletV2DoneEvent signals when tablet description events sequence complete
//
// This event is sent immediately to signal the end of the initial
// burst of descriptive events. A client may consider the static
// description of the tablet to be complete and finalize initialization
// of the tablet.
type ZwpTabletV2DoneEvent struct {
}

// Opcode returns the event opcode for zwp_tablet_v2.done in tablet_unstable_v2
func (ZwpTabletV2DoneEvent) Opcode() uint16 { return 3 }

// MessageName returns the event name for zwp_tablet_v2.done in tablet_unstable_v2
func (ZwpTabletV2DoneEvent) MessageName() string { return "done" }

// Ensure ZwpTabletV2DoneEvent implements Message.
var _ Message = ZwpTabletV2DoneEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletV2DoneEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure ZwpTabletV2DoneEvent implements Event.
var _ Event = &ZwpTabletV2DoneEvent{}

// ZwpTabletV2RemovedEvent signals when tablet removed event
//
// Sent when the tablet has been removed from the system. When a tablet
// is removed, some tools may be removed.
//
// When this event is received, the client must wp_tablet.destroy
// the object.
type ZwpTabletV2RemovedEvent struct {
}

// Opcode returns the event opcode for zwp_tablet_v2.removed in tablet_unstable_v2
func (ZwpTabletV2RemovedEvent) Opcode() uint16 { return 4 }

// MessageName returns the event name for zwp_tablet_v2.removed in tablet_unstable_v2
func (ZwpTabletV2RemovedEvent) MessageName() string { return "removed" }

// Ensure ZwpTabletV2RemovedEvent implements Message.
var _ Message = ZwpTabletV2RemovedEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletV2RemovedEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure ZwpTabletV2RemovedEvent implements Event.
var _ Event = &ZwpTabletV2RemovedEvent{}

// ZwpTabletV2 graphics tablet device
//
// The wp_tablet interface represents one graphics tablet device. The
// tablet interface itself does not generate events; all events are
// generated by wp_tablet_tool objects when in proximity above a tablet.
//
// A tablet has a number of static characteristics, e.g. device name and
// pid/vid. These capabilities are sent in an event sequence after the
// wp_tablet_seat.tablet_added event. This initial event sequence is
// terminated by a wp_tablet.done event.
type ZwpTabletV2 struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *ZwpTabletV2) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (ZwpTabletV2) Descriptor() *InterfaceDescriptor {
	return &ZwpTabletV2Descriptor
}

// Dispatch returns an Event object for a given opcode.
func (ZwpTabletV2) Dispatch(opcode uint16) Event {
	switch opcode {
	case 0:
		return &ZwpTabletV2NameEvent{}
	case 1:
		return &ZwpTabletV2IDEvent{}
	case 2:
		return &ZwpTabletV2PathEvent{}
	case 3:
		return &ZwpTabletV2DoneEvent{}
	case 4:
		return &ZwpTabletV2RemovedEvent{}
	default:
		return nil
	}
}

// Destroy requests to destroy the tablet object
//
// This destroys the client's resource for this tablet object.
func (proxy *ZwpTabletV2) Destroy(connection Connection) (err error) {
	request := ZwpTabletV2DestroyRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Ensure ZwpTabletV2 implements Proxy.
var _ Proxy = &ZwpTabletV2{}

// #endregion Interface tablet_unstable_v2.zwp_tablet_v2

// ----------------------------------------------------------------------------
// #region Interface tablet_unstable_v2.zwp_tablet_pad_ring_v2

// ZwpTabletPadRingV2Source represents ring axis source
//
// Describes the source types for ring events. This indicates to the
// client how a ring event was physically generated; a client may
// adjust the user interface accordingly. For example, events
// from a "finger" source may trigger kinetic scrolling.
type ZwpTabletPadRingV2Source int

const (
	// ZwpTabletPadRingV2SourceFinger corresponds to finger
	ZwpTabletPadRingV2SourceFinger ZwpTabletPadRingV2Source = 1
)

// ZwpTabletPadRingV2SetFeedbackRequest requests to set compositor feedback
//
// Request that the compositor use the provided feedback string
// associated with this ring. This request should be issued immediately
// after a wp_tablet_pad_group.mode_switch event from the corresponding
// group is received, or whenever the ring is mapped to a different
// action. See wp_tablet_pad_group.mode_switch for more details.
//
// Clients are encouraged to provide context-aware descriptions for
// the actions associated with the ring; compositors may use this
// information to offer visual feedback about the button layout
// (eg. on-screen displays).
//
// The provided string 'description' is a UTF-8 encoded string to be
// associated with this ring, and is considered user-visible; general
// internationalization rules apply.
//
// The serial argument will be that of the last
// wp_tablet_pad_group.mode_switch event received for the group of this
// ring. Requests providing other serials than the most recent one will be
// ignored.
type ZwpTabletPadRingV2SetFeedbackRequest struct {
	// Description contains ring description
	Description string

	// Serial contains serial of the mode switch event
	Serial uint32
}

// Opcode returns the request opcode for zwp_tablet_pad_ring_v2.set_feedback in tablet_unstable_v2
func (ZwpTabletPadRingV2SetFeedbackRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for zwp_tablet_pad_ring_v2.set_feedback in tablet_unstable_v2
func (ZwpTabletPadRingV2SetFeedbackRequest) MessageName() string { return "set_feedback" }

// Ensure ZwpTabletPadRingV2SetFeedbackRequest implements Message.
var _ Message = ZwpTabletPadRingV2SetFeedbackRequest{}

// Emit emits the message to the emitter.
func (r *ZwpTabletPadRingV2SetFeedbackRequest) Emit(e *RequestEmitter) error {
	if err := e.PutString(r.Description); err != nil {
		return err
	}
	if err := e.PutUint(r.Serial); err != nil {
		return err
	}
	return nil
}

// Ensure ZwpTabletPadRingV2SetFeedbackRequest implements Request.
var _ Request = &ZwpTabletPadRingV2SetFeedbackRequest{}

// ZwpTabletPadRingV2DestroyRequest requests to destroy the ring object
//
// This destroys the client's resource for this ring object.
type ZwpTabletPadRingV2DestroyRequest struct {
}

// Opcode returns the request opcode for zwp_tablet_pad_ring_v2.destroy in tablet_unstable_v2
func (ZwpTabletPadRingV2DestroyRequest) Opcode() uint16 { return 1 }

// MessageName returns the request name for zwp_tablet_pad_ring_v2.destroy in tablet_unstable_v2
func (ZwpTabletPadRingV2DestroyRequest) MessageName() string { return "destroy" }

// Ensure ZwpTabletPadRingV2DestroyRequest implements Message.
var _ Message = ZwpTabletPadRingV2DestroyRequest{}

// Emit emits the message to the emitter.
func (r *ZwpTabletPadRingV2DestroyRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure ZwpTabletPadRingV2DestroyRequest implements Request.
var _ Request = &ZwpTabletPadRingV2DestroyRequest{}

// ZwpTabletPadRingV2SourceEvent signals when ring event source
//
// Source information for ring events.
//
// This event does not occur on its own. It is sent before a
// wp_tablet_pad_ring.frame event and carries the source information
// for all events within that frame.
//
// The source specifies how this event was generated. If the source is
// wp_tablet_pad_ring.source.finger, a wp_tablet_pad_ring.stop event
// will be sent when the user lifts the finger off the device.
//
// This event is optional. If the source is unknown for an interaction,
// no event is sent.
type ZwpTabletPadRingV2SourceEvent struct {
	// Source contains the event source
	Source uint32
}

// Opcode returns the event opcode for zwp_tablet_pad_ring_v2.source in tablet_unstable_v2
func (ZwpTabletPadRingV2SourceEvent) Opcode() uint16 { return 0 }

// MessageName returns the event name for zwp_tablet_pad_ring_v2.source in tablet_unstable_v2
func (ZwpTabletPadRingV2SourceEvent) MessageName() string { return "source" }

// Ensure ZwpTabletPadRingV2SourceEvent implements Message.
var _ Message = ZwpTabletPadRingV2SourceEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletPadRingV2SourceEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Source = v
	}
	return nil
}

// Ensure ZwpTabletPadRingV2SourceEvent implements Event.
var _ Event = &ZwpTabletPadRingV2SourceEvent{}

// ZwpTabletPadRingV2AngleEvent signals when angle changed
//
// Sent whenever the angle on a ring changes.
//
// The angle is provided in degrees clockwise from the logical
// north of the ring in the pad's current rotation.
type ZwpTabletPadRingV2AngleEvent struct {
	// Degrees contains the current angle in degrees
	Degrees Fixed
}

// Opcode returns the event opcode for zwp_tablet_pad_ring_v2.angle in tablet_unstable_v2
func (ZwpTabletPadRingV2AngleEvent) Opcode() uint16 { return 1 }

// MessageName returns the event name for zwp_tablet_pad_ring_v2.angle in tablet_unstable_v2
func (ZwpTabletPadRingV2AngleEvent) MessageName() string { return "angle" }

// Ensure ZwpTabletPadRingV2AngleEvent implements Message.
var _ Message = ZwpTabletPadRingV2AngleEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletPadRingV2AngleEvent) Scan(s *EventScanner) error {
	if v, err := s.Fixed(); err != nil {
		return err
	} else {
		e.Degrees = v
	}
	return nil
}

// Ensure ZwpTabletPadRingV2AngleEvent implements Event.
var _ Event = &ZwpTabletPadRingV2AngleEvent{}

// ZwpTabletPadRingV2StopEvent signals when interaction stopped
//
// Stop notification for ring events.
//
// For some wp_tablet_pad_ring.source types, a wp_tablet_pad_ring.stop
// event is sent to notify a client that the interaction with the ring
// has terminated. This enables the client to implement kinetic scrolling.
// See the wp_tablet_pad_ring.source documentation for information on
// when this event may be generated.
//
// Any wp_tablet_pad_ring.angle events with the same source after this
// event should be considered as the start of a new interaction.
type ZwpTabletPadRingV2StopEvent struct {
}

// Opcode returns the event opcode for zwp_tablet_pad_ring_v2.stop in tablet_unstable_v2
func (ZwpTabletPadRingV2StopEvent) Opcode() uint16 { return 2 }

// MessageName returns the event name for zwp_tablet_pad_ring_v2.stop in tablet_unstable_v2
func (ZwpTabletPadRingV2StopEvent) MessageName() string { return "stop" }

// Ensure ZwpTabletPadRingV2StopEvent implements Message.
var _ Message = ZwpTabletPadRingV2StopEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletPadRingV2StopEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure ZwpTabletPadRingV2StopEvent implements Event.
var _ Event = &ZwpTabletPadRingV2StopEvent{}

// ZwpTabletPadRingV2FrameEvent signals when end of a ring event sequence
//
// Indicates the end of a set of ring events that logically belong
// together. A client is expected to accumulate the data in all events
// within the frame before proceeding.
//
// All wp_tablet_pad_ring events before a wp_tablet_pad_ring.frame event belong
// logically together. For example, on termination of a finger interaction
// on a ring the compositor will send a wp_tablet_pad_ring.source event,
// a wp_tablet_pad_ring.stop event and a wp_tablet_pad_ring.frame event.
//
// A wp_tablet_pad_ring.frame event is sent for every logical event
// group, even if the group only contains a single wp_tablet_pad_ring
// event. Specifically, a client may get a sequence: angle, frame,
// angle, frame, etc.
type ZwpTabletPadRingV2FrameEvent struct {
	// Time contains timestamp with millisecond granularity
	Time uint32
}

// Opcode returns the event opcode for zwp_tablet_pad_ring_v2.frame in tablet_unstable_v2
func (ZwpTabletPadRingV2FrameEvent) Opcode() uint16 { return 3 }

// MessageName returns the event name for zwp_tablet_pad_ring_v2.frame in tablet_unstable_v2
func (ZwpTabletPadRingV2FrameEvent) MessageName() string { return "frame" }

// Ensure ZwpTabletPadRingV2FrameEvent implements Message.
var _ Message = ZwpTabletPadRingV2FrameEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletPadRingV2FrameEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Time = v
	}
	return nil
}

// Ensure ZwpTabletPadRingV2FrameEvent implements Event.
var _ Event = &ZwpTabletPadRingV2FrameEvent{}

// ZwpTabletPadRingV2 pad ring
//
// A circular interaction area, such as the touch ring on the Wacom Intuos
// Pro series tablets.
//
// Events on a ring are logically grouped by the wl_tablet_pad_ring.frame
// event.
type ZwpTabletPadRingV2 struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *ZwpTabletPadRingV2) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (ZwpTabletPadRingV2) Descriptor() *InterfaceDescriptor {
	return &ZwpTabletPadRingV2Descriptor
}

// Dispatch returns an Event object for a given opcode.
func (ZwpTabletPadRingV2) Dispatch(opcode uint16) Event {
	switch opcode {
	case 0:
		return &ZwpTabletPadRingV2SourceEvent{}
	case 1:
		return &ZwpTabletPadRingV2AngleEvent{}
	case 2:
		return &ZwpTabletPadRingV2StopEvent{}
	case 3:
		return &ZwpTabletPadRingV2FrameEvent{}
	default:
		return nil
	}
}

// SetFeedback requests to set compositor feedback
//
// Request that the compositor use the provided feedback string
// associated with this ring. This request should be issued immediately
// after a wp_tablet_pad_group.mode_switch event from the corresponding
// group is received, or whenever the ring is mapped to a different
// action. See wp_tablet_pad_group.mode_switch for more details.
//
// Clients are encouraged to provide context-aware descriptions for
// the actions associated with the ring; compositors may use this
// information to offer visual feedback about the button layout
// (eg. on-screen displays).
//
// The provided string 'description' is a UTF-8 encoded string to be
// associated with this ring, and is considered user-visible; general
// internationalization rules apply.
//
// The serial argument will be that of the last
// wp_tablet_pad_group.mode_switch event received for the group of this
// ring. Requests providing other serials than the most recent one will be
// ignored.
func (proxy *ZwpTabletPadRingV2) SetFeedback(connection Connection, aDescription string, aSerial uint32) (err error) {
	request := ZwpTabletPadRingV2SetFeedbackRequest{
		Description: aDescription,
		Serial:      aSerial,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Destroy requests to destroy the ring object
//
// This destroys the client's resource for this ring object.
func (proxy *ZwpTabletPadRingV2) Destroy(connection Connection) (err error) {
	request := ZwpTabletPadRingV2DestroyRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Ensure ZwpTabletPadRingV2 implements Proxy.
var _ Proxy = &ZwpTabletPadRingV2{}

// #endregion Interface tablet_unstable_v2.zwp_tablet_pad_ring_v2

// ----------------------------------------------------------------------------
// #region Interface tablet_unstable_v2.zwp_tablet_pad_strip_v2

// ZwpTabletPadStripV2Source represents strip axis source
//
// Describes the source types for strip events. This indicates to the
// client how a strip event was physically generated; a client may
// adjust the user interface accordingly. For example, events
// from a "finger" source may trigger kinetic scrolling.
type ZwpTabletPadStripV2Source int

const (
	// ZwpTabletPadStripV2SourceFinger corresponds to finger
	ZwpTabletPadStripV2SourceFinger ZwpTabletPadStripV2Source = 1
)

// ZwpTabletPadStripV2SetFeedbackRequest requests to set compositor feedback
//
// Requests the compositor to use the provided feedback string
// associated with this strip. This request should be issued immediately
// after a wp_tablet_pad_group.mode_switch event from the corresponding
// group is received, or whenever the strip is mapped to a different
// action. See wp_tablet_pad_group.mode_switch for more details.
//
// Clients are encouraged to provide context-aware descriptions for
// the actions associated with the strip, and compositors may use this
// information to offer visual feedback about the button layout
// (eg. on-screen displays).
//
// The provided string 'description' is a UTF-8 encoded string to be
// associated with this ring, and is considered user-visible; general
// internationalization rules apply.
//
// The serial argument will be that of the last
// wp_tablet_pad_group.mode_switch event received for the group of this
// strip. Requests providing other serials than the most recent one will be
// ignored.
type ZwpTabletPadStripV2SetFeedbackRequest struct {
	// Description contains strip description
	Description string

	// Serial contains serial of the mode switch event
	Serial uint32
}

// Opcode returns the request opcode for zwp_tablet_pad_strip_v2.set_feedback in tablet_unstable_v2
func (ZwpTabletPadStripV2SetFeedbackRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for zwp_tablet_pad_strip_v2.set_feedback in tablet_unstable_v2
func (ZwpTabletPadStripV2SetFeedbackRequest) MessageName() string { return "set_feedback" }

// Ensure ZwpTabletPadStripV2SetFeedbackRequest implements Message.
var _ Message = ZwpTabletPadStripV2SetFeedbackRequest{}

// Emit emits the message to the emitter.
func (r *ZwpTabletPadStripV2SetFeedbackRequest) Emit(e *RequestEmitter) error {
	if err := e.PutString(r.Description); err != nil {
		return err
	}
	if err := e.PutUint(r.Serial); err != nil {
		return err
	}
	return nil
}

// Ensure ZwpTabletPadStripV2SetFeedbackRequest implements Request.
var _ Request = &ZwpTabletPadStripV2SetFeedbackRequest{}

// ZwpTabletPadStripV2DestroyRequest requests to destroy the strip object
//
// This destroys the client's resource for this strip object.
type ZwpTabletPadStripV2DestroyRequest struct {
}

// Opcode returns the request opcode for zwp_tablet_pad_strip_v2.destroy in tablet_unstable_v2
func (ZwpTabletPadStripV2DestroyRequest) Opcode() uint16 { return 1 }

// MessageName returns the request name for zwp_tablet_pad_strip_v2.destroy in tablet_unstable_v2
func (ZwpTabletPadStripV2DestroyRequest) MessageName() string { return "destroy" }

// Ensure ZwpTabletPadStripV2DestroyRequest implements Message.
var _ Message = ZwpTabletPadStripV2DestroyRequest{}

// Emit emits the message to the emitter.
func (r *ZwpTabletPadStripV2DestroyRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure ZwpTabletPadStripV2DestroyRequest implements Request.
var _ Request = &ZwpTabletPadStripV2DestroyRequest{}

// ZwpTabletPadStripV2SourceEvent signals when strip event source
//
// Source information for strip events.
//
// This event does not occur on its own. It is sent before a
// wp_tablet_pad_strip.frame event and carries the source information
// for all events within that frame.
//
// The source specifies how this event was generated. If the source is
// wp_tablet_pad_strip.source.finger, a wp_tablet_pad_strip.stop event
// will be sent when the user lifts their finger off the device.
//
// This event is optional. If the source is unknown for an interaction,
// no event is sent.
type ZwpTabletPadStripV2SourceEvent struct {
	// Source contains the event source
	Source uint32
}

// Opcode returns the event opcode for zwp_tablet_pad_strip_v2.source in tablet_unstable_v2
func (ZwpTabletPadStripV2SourceEvent) Opcode() uint16 { return 0 }

// MessageName returns the event name for zwp_tablet_pad_strip_v2.source in tablet_unstable_v2
func (ZwpTabletPadStripV2SourceEvent) MessageName() string { return "source" }

// Ensure ZwpTabletPadStripV2SourceEvent implements Message.
var _ Message = ZwpTabletPadStripV2SourceEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletPadStripV2SourceEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Source = v
	}
	return nil
}

// Ensure ZwpTabletPadStripV2SourceEvent implements Event.
var _ Event = &ZwpTabletPadStripV2SourceEvent{}

// ZwpTabletPadStripV2PositionEvent signals when position changed
//
// Sent whenever the position on a strip changes.
//
// The position is normalized to a range of [0, 65535], the 0-value
// represents the top-most and/or left-most position of the strip in
// the pad's current rotation.
type ZwpTabletPadStripV2PositionEvent struct {
	// Position contains the current position
	Position uint32
}

// Opcode returns the event opcode for zwp_tablet_pad_strip_v2.position in tablet_unstable_v2
func (ZwpTabletPadStripV2PositionEvent) Opcode() uint16 { return 1 }

// MessageName returns the event name for zwp_tablet_pad_strip_v2.position in tablet_unstable_v2
func (ZwpTabletPadStripV2PositionEvent) MessageName() string { return "position" }

// Ensure ZwpTabletPadStripV2PositionEvent implements Message.
var _ Message = ZwpTabletPadStripV2PositionEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletPadStripV2PositionEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Position = v
	}
	return nil
}

// Ensure ZwpTabletPadStripV2PositionEvent implements Event.
var _ Event = &ZwpTabletPadStripV2PositionEvent{}

// ZwpTabletPadStripV2StopEvent signals when interaction stopped
//
// Stop notification for strip events.
//
// For some wp_tablet_pad_strip.source types, a wp_tablet_pad_strip.stop
// event is sent to notify a client that the interaction with the strip
// has terminated. This enables the client to implement kinetic
// scrolling. See the wp_tablet_pad_strip.source documentation for
// information on when this event may be generated.
//
// Any wp_tablet_pad_strip.position events with the same source after this
// event should be considered as the start of a new interaction.
type ZwpTabletPadStripV2StopEvent struct {
}

// Opcode returns the event opcode for zwp_tablet_pad_strip_v2.stop in tablet_unstable_v2
func (ZwpTabletPadStripV2StopEvent) Opcode() uint16 { return 2 }

// MessageName returns the event name for zwp_tablet_pad_strip_v2.stop in tablet_unstable_v2
func (ZwpTabletPadStripV2StopEvent) MessageName() string { return "stop" }

// Ensure ZwpTabletPadStripV2StopEvent implements Message.
var _ Message = ZwpTabletPadStripV2StopEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletPadStripV2StopEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure ZwpTabletPadStripV2StopEvent implements Event.
var _ Event = &ZwpTabletPadStripV2StopEvent{}

// ZwpTabletPadStripV2FrameEvent signals when end of a strip event sequence
//
// Indicates the end of a set of events that represent one logical
// hardware strip event. A client is expected to accumulate the data
// in all events within the frame before proceeding.
//
// All wp_tablet_pad_strip events before a wp_tablet_pad_strip.frame event belong
// logically together. For example, on termination of a finger interaction
// on a strip the compositor will send a wp_tablet_pad_strip.source event,
// a wp_tablet_pad_strip.stop event and a wp_tablet_pad_strip.frame
// event.
//
// A wp_tablet_pad_strip.frame event is sent for every logical event
// group, even if the group only contains a single wp_tablet_pad_strip
// event. Specifically, a client may get a sequence: position, frame,
// position, frame, etc.
type ZwpTabletPadStripV2FrameEvent struct {
	// Time contains timestamp with millisecond granularity
	Time uint32
}

// Opcode returns the event opcode for zwp_tablet_pad_strip_v2.frame in tablet_unstable_v2
func (ZwpTabletPadStripV2FrameEvent) Opcode() uint16 { return 3 }

// MessageName returns the event name for zwp_tablet_pad_strip_v2.frame in tablet_unstable_v2
func (ZwpTabletPadStripV2FrameEvent) MessageName() string { return "frame" }

// Ensure ZwpTabletPadStripV2FrameEvent implements Message.
var _ Message = ZwpTabletPadStripV2FrameEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletPadStripV2FrameEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Time = v
	}
	return nil
}

// Ensure ZwpTabletPadStripV2FrameEvent implements Event.
var _ Event = &ZwpTabletPadStripV2FrameEvent{}

// ZwpTabletPadStripV2 pad strip
//
// A linear interaction area, such as the strips found in Wacom Cintiq
// models.
//
// Events on a strip are logically grouped by the wl_tablet_pad_strip.frame
// event.
type ZwpTabletPadStripV2 struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *ZwpTabletPadStripV2) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (ZwpTabletPadStripV2) Descriptor() *InterfaceDescriptor {
	return &ZwpTabletPadStripV2Descriptor
}

// Dispatch returns an Event object for a given opcode.
func (ZwpTabletPadStripV2) Dispatch(opcode uint16) Event {
	switch opcode {
	case 0:
		return &ZwpTabletPadStripV2SourceEvent{}
	case 1:
		return &ZwpTabletPadStripV2PositionEvent{}
	case 2:
		return &ZwpTabletPadStripV2StopEvent{}
	case 3:
		return &ZwpTabletPadStripV2FrameEvent{}
	default:
		return nil
	}
}

// SetFeedback requests to set compositor feedback
//
// Requests the compositor to use the provided feedback string
// associated with this strip. This request should be issued immediately
// after a wp_tablet_pad_group.mode_switch event from the corresponding
// group is received, or whenever the strip is mapped to a different
// action. See wp_tablet_pad_group.mode_switch for more details.
//
// Clients are encouraged to provide context-aware descriptions for
// the actions associated with the strip, and compositors may use this
// information to offer visual feedback about the button layout
// (eg. on-screen displays).
//
// The provided string 'description' is a UTF-8 encoded string to be
// associated with this ring, and is considered user-visible; general
// internationalization rules apply.
//
// The serial argument will be that of the last
// wp_tablet_pad_group.mode_switch event received for the group of this
// strip. Requests providing other serials than the most recent one will be
// ignored.
func (proxy *ZwpTabletPadStripV2) SetFeedback(connection Connection, aDescription string, aSerial uint32) (err error) {
	request := ZwpTabletPadStripV2SetFeedbackRequest{
		Description: aDescription,
		Serial:      aSerial,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Destroy requests to destroy the strip object
//
// This destroys the client's resource for this strip object.
func (proxy *ZwpTabletPadStripV2) Destroy(connection Connection) (err error) {
	request := ZwpTabletPadStripV2DestroyRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Ensure ZwpTabletPadStripV2 implements Proxy.
var _ Proxy = &ZwpTabletPadStripV2{}

// #endregion Interface tablet_unstable_v2.zwp_tablet_pad_strip_v2

// ----------------------------------------------------------------------------
// #region Interface tablet_unstable_v2.zwp_tablet_pad_group_v2

// ZwpTabletPadGroupV2DestroyRequest requests to destroy the pad object
//
// Destroy the wp_tablet_pad_group object. Objects created from this object
// are unaffected and should be destroyed separately.
type ZwpTabletPadGroupV2DestroyRequest struct {
}

// Opcode returns the request opcode for zwp_tablet_pad_group_v2.destroy in tablet_unstable_v2
func (ZwpTabletPadGroupV2DestroyRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for zwp_tablet_pad_group_v2.destroy in tablet_unstable_v2
func (ZwpTabletPadGroupV2DestroyRequest) MessageName() string { return "destroy" }

// Ensure ZwpTabletPadGroupV2DestroyRequest implements Message.
var _ Message = ZwpTabletPadGroupV2DestroyRequest{}

// Emit emits the message to the emitter.
func (r *ZwpTabletPadGroupV2DestroyRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure ZwpTabletPadGroupV2DestroyRequest implements Request.
var _ Request = &ZwpTabletPadGroupV2DestroyRequest{}

// ZwpTabletPadGroupV2ButtonsEvent signals when buttons announced
//
// Sent on wp_tablet_pad_group initialization to announce the available
// buttons in the group. Button indices start at 0, a button may only be
// in one group at a time.
//
// This event is first sent in the initial burst of events before the
// wp_tablet_pad_group.done event.
//
// Some buttons are reserved by the compositor. These buttons may not be
// assigned to any wp_tablet_pad_group. Compositors may broadcast this
// event in the case of changes to the mapping of these reserved buttons.
// If the compositor happens to reserve all buttons in a group, this event
// will be sent with an empty array.
type ZwpTabletPadGroupV2ButtonsEvent struct {
	// Buttons contains buttons in this group
	Buttons []byte
}

// Opcode returns the event opcode for zwp_tablet_pad_group_v2.buttons in tablet_unstable_v2
func (ZwpTabletPadGroupV2ButtonsEvent) Opcode() uint16 { return 0 }

// MessageName returns the event name for zwp_tablet_pad_group_v2.buttons in tablet_unstable_v2
func (ZwpTabletPadGroupV2ButtonsEvent) MessageName() string { return "buttons" }

// Ensure ZwpTabletPadGroupV2ButtonsEvent implements Message.
var _ Message = ZwpTabletPadGroupV2ButtonsEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletPadGroupV2ButtonsEvent) Scan(s *EventScanner) error {
	if v, err := s.Array(); err != nil {
		return err
	} else {
		e.Buttons = v
	}
	return nil
}

// Ensure ZwpTabletPadGroupV2ButtonsEvent implements Event.
var _ Event = &ZwpTabletPadGroupV2ButtonsEvent{}

// ZwpTabletPadGroupV2RingEvent signals when ring announced
//
// Sent on wp_tablet_pad_group initialization to announce available rings.
// One event is sent for each ring available on this pad group.
//
// This event is sent in the initial burst of events before the
// wp_tablet_pad_group.done event.
type ZwpTabletPadGroupV2RingEvent struct {
	Ring ObjectID
}

// Opcode returns the event opcode for zwp_tablet_pad_group_v2.ring in tablet_unstable_v2
func (ZwpTabletPadGroupV2RingEvent) Opcode() uint16 { return 1 }

// MessageName returns the event name for zwp_tablet_pad_group_v2.ring in tablet_unstable_v2
func (ZwpTabletPadGroupV2RingEvent) MessageName() string { return "ring" }

// Ensure ZwpTabletPadGroupV2RingEvent implements Message.
var _ Message = ZwpTabletPadGroupV2RingEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletPadGroupV2RingEvent) Scan(s *EventScanner) error {
	if v, err := s.ObjectID(); err != nil {
		return err
	} else {
		e.Ring = v
	}
	return nil
}

// Ensure ZwpTabletPadGroupV2RingEvent implements Event.
var _ Event = &ZwpTabletPadGroupV2RingEvent{}

// ZwpTabletPadGroupV2StripEvent signals when strip announced
//
// Sent on wp_tablet_pad initialization to announce available strips.
// One event is sent for each strip available on this pad group.
//
// This event is sent in the initial burst of events before the
// wp_tablet_pad_group.done event.
type ZwpTabletPadGroupV2StripEvent struct {
	Strip ObjectID
}

// Opcode returns the event opcode for zwp_tablet_pad_group_v2.strip in tablet_unstable_v2
func (ZwpTabletPadGroupV2StripEvent) Opcode() uint16 { return 2 }

// MessageName returns the event name for zwp_tablet_pad_group_v2.strip in tablet_unstable_v2
func (ZwpTabletPadGroupV2StripEvent) MessageName() string { return "strip" }

// Ensure ZwpTabletPadGroupV2StripEvent implements Message.
var _ Message = ZwpTabletPadGroupV2StripEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletPadGroupV2StripEvent) Scan(s *EventScanner) error {
	if v, err := s.ObjectID(); err != nil {
		return err
	} else {
		e.Strip = v
	}
	return nil
}

// Ensure ZwpTabletPadGroupV2StripEvent implements Event.
var _ Event = &ZwpTabletPadGroupV2StripEvent{}

// ZwpTabletPadGroupV2ModesEvent signals when mode-switch ability announced
//
// Sent on wp_tablet_pad_group initialization to announce that the pad
// group may switch between modes. A client may use a mode to store a
// specific configuration for buttons, rings and strips and use the
// wl_tablet_pad_group.mode_switch event to toggle between these
// configurations. Mode indices start at 0.
//
// Switching modes is compositor-dependent. See the
// wp_tablet_pad_group.mode_switch event for more details.
//
// This event is sent in the initial burst of events before the
// wp_tablet_pad_group.done event. This event is only sent when more than
// more than one mode is available.
type ZwpTabletPadGroupV2ModesEvent struct {
	// Modes contains the number of modes
	Modes uint32
}

// Opcode returns the event opcode for zwp_tablet_pad_group_v2.modes in tablet_unstable_v2
func (ZwpTabletPadGroupV2ModesEvent) Opcode() uint16 { return 3 }

// MessageName returns the event name for zwp_tablet_pad_group_v2.modes in tablet_unstable_v2
func (ZwpTabletPadGroupV2ModesEvent) MessageName() string { return "modes" }

// Ensure ZwpTabletPadGroupV2ModesEvent implements Message.
var _ Message = ZwpTabletPadGroupV2ModesEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletPadGroupV2ModesEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Modes = v
	}
	return nil
}

// Ensure ZwpTabletPadGroupV2ModesEvent implements Event.
var _ Event = &ZwpTabletPadGroupV2ModesEvent{}

// ZwpTabletPadGroupV2DoneEvent signals when tablet group description events sequence complete
//
// This event is sent immediately to signal the end of the initial
// burst of descriptive events. A client may consider the static
// description of the tablet to be complete and finalize initialization
// of the tablet group.
type ZwpTabletPadGroupV2DoneEvent struct {
}

// Opcode returns the event opcode for zwp_tablet_pad_group_v2.done in tablet_unstable_v2
func (ZwpTabletPadGroupV2DoneEvent) Opcode() uint16 { return 4 }

// MessageName returns the event name for zwp_tablet_pad_group_v2.done in tablet_unstable_v2
func (ZwpTabletPadGroupV2DoneEvent) MessageName() string { return "done" }

// Ensure ZwpTabletPadGroupV2DoneEvent implements Message.
var _ Message = ZwpTabletPadGroupV2DoneEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletPadGroupV2DoneEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure ZwpTabletPadGroupV2DoneEvent implements Event.
var _ Event = &ZwpTabletPadGroupV2DoneEvent{}

// ZwpTabletPadGroupV2ModeSwitchEvent signals when mode switch event
//
// Notification that the mode was switched.
//
// A mode applies to all buttons, rings and strips in a group
// simultaneously, but a client is not required to assign different actions
// for each mode. For example, a client may have mode-specific button
// mappings but map the ring to vertical scrolling in all modes. Mode
// indices start at 0.
//
// Switching modes is compositor-dependent. The compositor may provide
// visual cues to the client about the mode, e.g. by toggling LEDs on
// the tablet device. Mode-switching may be software-controlled or
// controlled by one or more physical buttons. For example, on a Wacom
// Intuos Pro, the button inside the ring may be assigned to switch
// between modes.
//
// The compositor will also send this event after wp_tablet_pad.enter on
// each group in order to notify of the current mode. Groups that only
// feature one mode will use mode=0 when emitting this event.
//
// If a button action in the new mode differs from the action in the
// previous mode, the client should immediately issue a
// wp_tablet_pad.set_feedback request for each changed button.
//
// If a ring or strip action in the new mode differs from the action
// in the previous mode, the client should immediately issue a
// wp_tablet_ring.set_feedback or wp_tablet_strip.set_feedback request
// for each changed ring or strip.
type ZwpTabletPadGroupV2ModeSwitchEvent struct {
	// Time contains the time of the event with millisecond granularity
	Time uint32

	Serial uint32

	// Mode contains the new mode of the pad
	Mode uint32
}

// Opcode returns the event opcode for zwp_tablet_pad_group_v2.mode_switch in tablet_unstable_v2
func (ZwpTabletPadGroupV2ModeSwitchEvent) Opcode() uint16 { return 5 }

// MessageName returns the event name for zwp_tablet_pad_group_v2.mode_switch in tablet_unstable_v2
func (ZwpTabletPadGroupV2ModeSwitchEvent) MessageName() string { return "mode_switch" }

// Ensure ZwpTabletPadGroupV2ModeSwitchEvent implements Message.
var _ Message = ZwpTabletPadGroupV2ModeSwitchEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletPadGroupV2ModeSwitchEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Time = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Serial = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Mode = v
	}
	return nil
}

// Ensure ZwpTabletPadGroupV2ModeSwitchEvent implements Event.
var _ Event = &ZwpTabletPadGroupV2ModeSwitchEvent{}

// ZwpTabletPadGroupV2 a set of buttons, rings and strips
//
// A pad group describes a distinct (sub)set of buttons, rings and strips
// present in the tablet. The criteria of this grouping is usually positional,
// eg. if a tablet has buttons on the left and right side, 2 groups will be
// presented. The physical arrangement of groups is undisclosed and may
// change on the fly.
//
// Pad groups will announce their features during pad initialization. Between
// the corresponding wp_tablet_pad.group event and wp_tablet_pad_group.done, the
// pad group will announce the buttons, rings and strips contained in it,
// plus the number of supported modes.
//
// Modes are a mechanism to allow multiple groups of actions for every element
// in the pad group. The number of groups and available modes in each is
// persistent across device plugs. The current mode is user-switchable, it
// will be announced through the wp_tablet_pad_group.mode_switch event both
// whenever it is switched, and after wp_tablet_pad.enter.
//
// The current mode logically applies to all elements in the pad group,
// although it is at clients' discretion whether to actually perform different
// actions, and/or issue the respective .set_feedback requests to notify the
// compositor. See the wp_tablet_pad_group.mode_switch event for more details.
type ZwpTabletPadGroupV2 struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *ZwpTabletPadGroupV2) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (ZwpTabletPadGroupV2) Descriptor() *InterfaceDescriptor {
	return &ZwpTabletPadGroupV2Descriptor
}

// Dispatch returns an Event object for a given opcode.
func (ZwpTabletPadGroupV2) Dispatch(opcode uint16) Event {
	switch opcode {
	case 0:
		return &ZwpTabletPadGroupV2ButtonsEvent{}
	case 1:
		return &ZwpTabletPadGroupV2RingEvent{}
	case 2:
		return &ZwpTabletPadGroupV2StripEvent{}
	case 3:
		return &ZwpTabletPadGroupV2ModesEvent{}
	case 4:
		return &ZwpTabletPadGroupV2DoneEvent{}
	case 5:
		return &ZwpTabletPadGroupV2ModeSwitchEvent{}
	default:
		return nil
	}
}

// Destroy requests to destroy the pad object
//
// Destroy the wp_tablet_pad_group object. Objects created from this object
// are unaffected and should be destroyed separately.
func (proxy *ZwpTabletPadGroupV2) Destroy(connection Connection) (err error) {
	request := ZwpTabletPadGroupV2DestroyRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Ensure ZwpTabletPadGroupV2 implements Proxy.
var _ Proxy = &ZwpTabletPadGroupV2{}

// #endregion Interface tablet_unstable_v2.zwp_tablet_pad_group_v2

// ----------------------------------------------------------------------------
// #region Interface tablet_unstable_v2.zwp_tablet_pad_v2

// ZwpTabletPadV2ButtonState represents physical button state
//
// Describes the physical state of a button that caused the button
// event.
type ZwpTabletPadV2ButtonState int

const (
	// ZwpTabletPadV2ButtonStateReleased corresponds to the button is not pressed
	ZwpTabletPadV2ButtonStateReleased ZwpTabletPadV2ButtonState = 0

	// ZwpTabletPadV2ButtonStatePressed corresponds to the button is pressed
	ZwpTabletPadV2ButtonStatePressed ZwpTabletPadV2ButtonState = 1
)

// ZwpTabletPadV2SetFeedbackRequest requests to set compositor feedback
//
// Requests the compositor to use the provided feedback string
// associated with this button. This request should be issued immediately
// after a wp_tablet_pad_group.mode_switch event from the corresponding
// group is received, or whenever a button is mapped to a different
// action. See wp_tablet_pad_group.mode_switch for more details.
//
// Clients are encouraged to provide context-aware descriptions for
// the actions associated with each button, and compositors may use
// this information to offer visual feedback on the button layout
// (e.g. on-screen displays).
//
// Button indices start at 0. Setting the feedback string on a button
// that is reserved by the compositor (i.e. not belonging to any
// wp_tablet_pad_group) does not generate an error but the compositor
// is free to ignore the request.
//
// The provided string 'description' is a UTF-8 encoded string to be
// associated with this ring, and is considered user-visible; general
// internationalization rules apply.
//
// The serial argument will be that of the last
// wp_tablet_pad_group.mode_switch event received for the group of this
// button. Requests providing other serials than the most recent one will
// be ignored.
type ZwpTabletPadV2SetFeedbackRequest struct {
	// Button contains button index
	Button uint32

	// Description contains button description
	Description string

	// Serial contains serial of the mode switch event
	Serial uint32
}

// Opcode returns the request opcode for zwp_tablet_pad_v2.set_feedback in tablet_unstable_v2
func (ZwpTabletPadV2SetFeedbackRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for zwp_tablet_pad_v2.set_feedback in tablet_unstable_v2
func (ZwpTabletPadV2SetFeedbackRequest) MessageName() string { return "set_feedback" }

// Ensure ZwpTabletPadV2SetFeedbackRequest implements Message.
var _ Message = ZwpTabletPadV2SetFeedbackRequest{}

// Emit emits the message to the emitter.
func (r *ZwpTabletPadV2SetFeedbackRequest) Emit(e *RequestEmitter) error {
	if err := e.PutUint(r.Button); err != nil {
		return err
	}
	if err := e.PutString(r.Description); err != nil {
		return err
	}
	if err := e.PutUint(r.Serial); err != nil {
		return err
	}
	return nil
}

// Ensure ZwpTabletPadV2SetFeedbackRequest implements Request.
var _ Request = &ZwpTabletPadV2SetFeedbackRequest{}

// ZwpTabletPadV2DestroyRequest requests to destroy the pad object
//
// Destroy the wp_tablet_pad object. Objects created from this object
// are unaffected and should be destroyed separately.
type ZwpTabletPadV2DestroyRequest struct {
}

// Opcode returns the request opcode for zwp_tablet_pad_v2.destroy in tablet_unstable_v2
func (ZwpTabletPadV2DestroyRequest) Opcode() uint16 { return 1 }

// MessageName returns the request name for zwp_tablet_pad_v2.destroy in tablet_unstable_v2
func (ZwpTabletPadV2DestroyRequest) MessageName() string { return "destroy" }

// Ensure ZwpTabletPadV2DestroyRequest implements Message.
var _ Message = ZwpTabletPadV2DestroyRequest{}

// Emit emits the message to the emitter.
func (r *ZwpTabletPadV2DestroyRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure ZwpTabletPadV2DestroyRequest implements Request.
var _ Request = &ZwpTabletPadV2DestroyRequest{}

// ZwpTabletPadV2GroupEvent signals when group announced
//
// Sent on wp_tablet_pad initialization to announce available groups.
// One event is sent for each pad group available.
//
// This event is sent in the initial burst of events before the
// wp_tablet_pad.done event. At least one group will be announced.
type ZwpTabletPadV2GroupEvent struct {
	PadGroup ObjectID
}

// Opcode returns the event opcode for zwp_tablet_pad_v2.group in tablet_unstable_v2
func (ZwpTabletPadV2GroupEvent) Opcode() uint16 { return 0 }

// MessageName returns the event name for zwp_tablet_pad_v2.group in tablet_unstable_v2
func (ZwpTabletPadV2GroupEvent) MessageName() string { return "group" }

// Ensure ZwpTabletPadV2GroupEvent implements Message.
var _ Message = ZwpTabletPadV2GroupEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletPadV2GroupEvent) Scan(s *EventScanner) error {
	if v, err := s.ObjectID(); err != nil {
		return err
	} else {
		e.PadGroup = v
	}
	return nil
}

// Ensure ZwpTabletPadV2GroupEvent implements Event.
var _ Event = &ZwpTabletPadV2GroupEvent{}

// ZwpTabletPadV2PathEvent signals when path to the device
//
// A system-specific device path that indicates which device is behind
// this wp_tablet_pad. This information may be used to gather additional
// information about the device, e.g. through libwacom.
//
// The format of the path is unspecified, it may be a device node, a
// sysfs path, or some other identifier. It is up to the client to
// identify the string provided.
//
// This event is sent in the initial burst of events before the
// wp_tablet_pad.done event.
type ZwpTabletPadV2PathEvent struct {
	// Path contains path to local device
	Path string
}

// Opcode returns the event opcode for zwp_tablet_pad_v2.path in tablet_unstable_v2
func (ZwpTabletPadV2PathEvent) Opcode() uint16 { return 1 }

// MessageName returns the event name for zwp_tablet_pad_v2.path in tablet_unstable_v2
func (ZwpTabletPadV2PathEvent) MessageName() string { return "path" }

// Ensure ZwpTabletPadV2PathEvent implements Message.
var _ Message = ZwpTabletPadV2PathEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletPadV2PathEvent) Scan(s *EventScanner) error {
	if v, err := s.String(); err != nil {
		return err
	} else {
		e.Path = v
	}
	return nil
}

// Ensure ZwpTabletPadV2PathEvent implements Event.
var _ Event = &ZwpTabletPadV2PathEvent{}

// ZwpTabletPadV2ButtonsEvent signals when buttons announced
//
// Sent on wp_tablet_pad initialization to announce the available
// buttons.
//
// This event is sent in the initial burst of events before the
// wp_tablet_pad.done event. This event is only sent when at least one
// button is available.
type ZwpTabletPadV2ButtonsEvent struct {
	// Buttons contains the number of buttons
	Buttons uint32
}

// Opcode returns the event opcode for zwp_tablet_pad_v2.buttons in tablet_unstable_v2
func (ZwpTabletPadV2ButtonsEvent) Opcode() uint16 { return 2 }

// MessageName returns the event name for zwp_tablet_pad_v2.buttons in tablet_unstable_v2
func (ZwpTabletPadV2ButtonsEvent) MessageName() string { return "buttons" }

// Ensure ZwpTabletPadV2ButtonsEvent implements Message.
var _ Message = ZwpTabletPadV2ButtonsEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletPadV2ButtonsEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Buttons = v
	}
	return nil
}

// Ensure ZwpTabletPadV2ButtonsEvent implements Event.
var _ Event = &ZwpTabletPadV2ButtonsEvent{}

// ZwpTabletPadV2DoneEvent signals when pad description event sequence complete
//
// This event signals the end of the initial burst of descriptive
// events. A client may consider the static description of the pad to
// be complete and finalize initialization of the pad.
type ZwpTabletPadV2DoneEvent struct {
}

// Opcode returns the event opcode for zwp_tablet_pad_v2.done in tablet_unstable_v2
func (ZwpTabletPadV2DoneEvent) Opcode() uint16 { return 3 }

// MessageName returns the event name for zwp_tablet_pad_v2.done in tablet_unstable_v2
func (ZwpTabletPadV2DoneEvent) MessageName() string { return "done" }

// Ensure ZwpTabletPadV2DoneEvent implements Message.
var _ Message = ZwpTabletPadV2DoneEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletPadV2DoneEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure ZwpTabletPadV2DoneEvent implements Event.
var _ Event = &ZwpTabletPadV2DoneEvent{}

// ZwpTabletPadV2ButtonEvent signals when physical button state
//
// Sent whenever the physical state of a button changes.
type ZwpTabletPadV2ButtonEvent struct {
	// Time contains the time of the event with millisecond granularity
	Time uint32

	// Button contains the index of the button that changed state
	Button uint32

	State uint32
}

// Opcode returns the event opcode for zwp_tablet_pad_v2.button in tablet_unstable_v2
func (ZwpTabletPadV2ButtonEvent) Opcode() uint16 { return 4 }

// MessageName returns the event name for zwp_tablet_pad_v2.button in tablet_unstable_v2
func (ZwpTabletPadV2ButtonEvent) MessageName() string { return "button" }

// Ensure ZwpTabletPadV2ButtonEvent implements Message.
var _ Message = ZwpTabletPadV2ButtonEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletPadV2ButtonEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Time = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Button = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.State = v
	}
	return nil
}

// Ensure ZwpTabletPadV2ButtonEvent implements Event.
var _ Event = &ZwpTabletPadV2ButtonEvent{}

// ZwpTabletPadV2EnterEvent signals when enter event
//
// Notification that this pad is focused on the specified surface.
type ZwpTabletPadV2EnterEvent struct {
	// Serial contains serial number of the enter event
	Serial uint32

	// Tablet contains the tablet the pad is attached to
	Tablet ObjectID

	// Surface contains surface the pad is focused on
	Surface ObjectID
}

// Opcode returns the event opcode for zwp_tablet_pad_v2.enter in tablet_unstable_v2
func (ZwpTabletPadV2EnterEvent) Opcode() uint16 { return 5 }

// MessageName returns the event name for zwp_tablet_pad_v2.enter in tablet_unstable_v2
func (ZwpTabletPadV2EnterEvent) MessageName() string { return "enter" }

// Ensure ZwpTabletPadV2EnterEvent implements Message.
var _ Message = ZwpTabletPadV2EnterEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletPadV2EnterEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Serial = v
	}
	if v, err := s.ObjectID(); err != nil {
		return err
	} else {
		e.Tablet = v
	}
	if v, err := s.ObjectID(); err != nil {
		return err
	} else {
		e.Surface = v
	}
	return nil
}

// Ensure ZwpTabletPadV2EnterEvent implements Event.
var _ Event = &ZwpTabletPadV2EnterEvent{}

// ZwpTabletPadV2LeaveEvent signals when enter event
//
// Notification that this pad is no longer focused on the specified
// surface.
type ZwpTabletPadV2LeaveEvent struct {
	// Serial contains serial number of the leave event
	Serial uint32

	// Surface contains surface the pad is no longer focused on
	Surface ObjectID
}

// Opcode returns the event opcode for zwp_tablet_pad_v2.leave in tablet_unstable_v2
func (ZwpTabletPadV2LeaveEvent) Opcode() uint16 { return 6 }

// MessageName returns the event name for zwp_tablet_pad_v2.leave in tablet_unstable_v2
func (ZwpTabletPadV2LeaveEvent) MessageName() string { return "leave" }

// Ensure ZwpTabletPadV2LeaveEvent implements Message.
var _ Message = ZwpTabletPadV2LeaveEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletPadV2LeaveEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Serial = v
	}
	if v, err := s.ObjectID(); err != nil {
		return err
	} else {
		e.Surface = v
	}
	return nil
}

// Ensure ZwpTabletPadV2LeaveEvent implements Event.
var _ Event = &ZwpTabletPadV2LeaveEvent{}

// ZwpTabletPadV2RemovedEvent signals when pad removed event
//
// Sent when the pad has been removed from the system. When a tablet
// is removed its pad(s) will be removed too.
//
// When this event is received, the client must destroy all rings, strips
// and groups that were offered by this pad, and issue wp_tablet_pad.destroy
// the pad itself.
type ZwpTabletPadV2RemovedEvent struct {
}

// Opcode returns the event opcode for zwp_tablet_pad_v2.removed in tablet_unstable_v2
func (ZwpTabletPadV2RemovedEvent) Opcode() uint16 { return 7 }

// MessageName returns the event name for zwp_tablet_pad_v2.removed in tablet_unstable_v2
func (ZwpTabletPadV2RemovedEvent) MessageName() string { return "removed" }

// Ensure ZwpTabletPadV2RemovedEvent implements Message.
var _ Message = ZwpTabletPadV2RemovedEvent{}

// Scan scans the event from the socket.
func (e *ZwpTabletPadV2RemovedEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure ZwpTabletPadV2RemovedEvent implements Event.
var _ Event = &ZwpTabletPadV2RemovedEvent{}

// ZwpTabletPadV2 a set of buttons, rings and strips
//
// A pad device is a set of buttons, rings and strips
// usually physically present on the tablet device itself. Some
// exceptions exist where the pad device is physically detached, e.g. the
// Wacom ExpressKey Remote.
//
// Pad devices have no axes that control the cursor and are generally
// auxiliary devices to the tool devices used on the tablet surface.
//
// A pad device has a number of static characteristics, e.g. the number
// of rings. These capabilities are sent in an event sequence after the
// wp_tablet_seat.pad_added event before any actual events from this pad.
// This initial event sequence is terminated by a wp_tablet_pad.done
// event.
//
// All pad features (buttons, rings and strips) are logically divided into
// groups and all pads have at least one group. The available groups are
// notified through the wp_tablet_pad.group event; the compositor will
// emit one event per group before emitting wp_tablet_pad.done.
//
// Groups may have multiple modes. Modes allow clients to map multiple
// actions to a single pad feature. Only one mode can be active per group,
// although different groups may have different active modes.
type ZwpTabletPadV2 struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *ZwpTabletPadV2) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (ZwpTabletPadV2) Descriptor() *InterfaceDescriptor {
	return &ZwpTabletPadV2Descriptor
}

// Dispatch returns an Event object for a given opcode.
func (ZwpTabletPadV2) Dispatch(opcode uint16) Event {
	switch opcode {
	case 0:
		return &ZwpTabletPadV2GroupEvent{}
	case 1:
		return &ZwpTabletPadV2PathEvent{}
	case 2:
		return &ZwpTabletPadV2ButtonsEvent{}
	case 3:
		return &ZwpTabletPadV2DoneEvent{}
	case 4:
		return &ZwpTabletPadV2ButtonEvent{}
	case 5:
		return &ZwpTabletPadV2EnterEvent{}
	case 6:
		return &ZwpTabletPadV2LeaveEvent{}
	case 7:
		return &ZwpTabletPadV2RemovedEvent{}
	default:
		return nil
	}
}

// SetFeedback requests to set compositor feedback
//
// Requests the compositor to use the provided feedback string
// associated with this button. This request should be issued immediately
// after a wp_tablet_pad_group.mode_switch event from the corresponding
// group is received, or whenever a button is mapped to a different
// action. See wp_tablet_pad_group.mode_switch for more details.
//
// Clients are encouraged to provide context-aware descriptions for
// the actions associated with each button, and compositors may use
// this information to offer visual feedback on the button layout
// (e.g. on-screen displays).
//
// Button indices start at 0. Setting the feedback string on a button
// that is reserved by the compositor (i.e. not belonging to any
// wp_tablet_pad_group) does not generate an error but the compositor
// is free to ignore the request.
//
// The provided string 'description' is a UTF-8 encoded string to be
// associated with this ring, and is considered user-visible; general
// internationalization rules apply.
//
// The serial argument will be that of the last
// wp_tablet_pad_group.mode_switch event received for the group of this
// button. Requests providing other serials than the most recent one will
// be ignored.
func (proxy *ZwpTabletPadV2) SetFeedback(connection Connection, aButton uint32, aDescription string, aSerial uint32) (err error) {
	request := ZwpTabletPadV2SetFeedbackRequest{
		Button:      aButton,
		Description: aDescription,
		Serial:      aSerial,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Destroy requests to destroy the pad object
//
// Destroy the wp_tablet_pad object. Objects created from this object
// are unaffected and should be destroyed separately.
func (proxy *ZwpTabletPadV2) Destroy(connection Connection) (err error) {
	request := ZwpTabletPadV2DestroyRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Ensure ZwpTabletPadV2 implements Proxy.
var _ Proxy = &ZwpTabletPadV2{}

// #endregion Interface tablet_unstable_v2.zwp_tablet_pad_v2

////////////////////////////////////////////////////////////////////////////////
// #endregion Protocol tablet_unstable_v2

////////////////////////////////////////////////////////////////////////////////
// #region Protocol text_input_unstable_v1

// ----------------------------------------------------------------------------
// #region Interface text_input_unstable_v1.zwp_text_input_v1

// ZwpTextInputV1ContentHint represents content hint
//
// Content hint is a bitmask to allow to modify the behavior of the text
// input.
type ZwpTextInputV1ContentHint uint

const (
	// ZwpTextInputV1ContentHintNone corresponds to no special behaviour
	ZwpTextInputV1ContentHintNone ZwpTextInputV1ContentHint = 0x0

	// ZwpTextInputV1ContentHintDefault corresponds to auto completion, correction and capitalization
	ZwpTextInputV1ContentHintDefault ZwpTextInputV1ContentHint = 0x7

	// ZwpTextInputV1ContentHintPassword corresponds to hidden and sensitive text
	ZwpTextInputV1ContentHintPassword ZwpTextInputV1ContentHint = 0xc0

	// ZwpTextInputV1ContentHintAutoCompletion corresponds to suggest word completions
	ZwpTextInputV1ContentHintAutoCompletion ZwpTextInputV1ContentHint = 0x1

	// ZwpTextInputV1ContentHintAutoCorrection corresponds to suggest word corrections
	ZwpTextInputV1ContentHintAutoCorrection ZwpTextInputV1ContentHint = 0x2

	// ZwpTextInputV1ContentHintAutoCapitalization corresponds to switch to uppercase letters at the start of a sentence
	ZwpTextInputV1ContentHintAutoCapitalization ZwpTextInputV1ContentHint = 0x4

	// ZwpTextInputV1ContentHintLowercase corresponds to prefer lowercase letters
	ZwpTextInputV1ContentHintLowercase ZwpTextInputV1ContentHint = 0x8

	// ZwpTextInputV1ContentHintUppercase corresponds to prefer uppercase letters
	ZwpTextInputV1ContentHintUppercase ZwpTextInputV1ContentHint = 0x10

	// ZwpTextInputV1ContentHintTitlecase corresponds to prefer casing for titles and headings (can be language dependent)
	ZwpTextInputV1ContentHintTitlecase ZwpTextInputV1ContentHint = 0x20

	// ZwpTextInputV1ContentHintHiddenText corresponds to characters should be hidden
	ZwpTextInputV1ContentHintHiddenText ZwpTextInputV1ContentHint = 0x40

	// ZwpTextInputV1ContentHintSensitiveData corresponds to typed text should not be stored
	ZwpTextInputV1ContentHintSensitiveData ZwpTextInputV1ContentHint = 0x80

	// ZwpTextInputV1ContentHintLatin corresponds to just latin characters should be entered
	ZwpTextInputV1ContentHintLatin ZwpTextInputV1ContentHint = 0x100

	// ZwpTextInputV1ContentHintMultiline corresponds to the text input is multiline
	ZwpTextInputV1ContentHintMultiline ZwpTextInputV1ContentHint = 0x200
)

// ZwpTextInputV1ContentPurpose represents content purpose
//
// The content purpose allows to specify the primary purpose of a text
// input.
//
// This allows an input method to show special purpose input panels with
// extra characters or to disallow some characters.
type ZwpTextInputV1ContentPurpose int

const (
	// ZwpTextInputV1ContentPurposeNormal corresponds to default input, allowing all characters
	ZwpTextInputV1ContentPurposeNormal ZwpTextInputV1ContentPurpose = 0

	// ZwpTextInputV1ContentPurposeAlpha corresponds to allow only alphabetic characters
	ZwpTextInputV1ContentPurposeAlpha ZwpTextInputV1ContentPurpose = 1

	// ZwpTextInputV1ContentPurposeDigits corresponds to allow only digits
	ZwpTextInputV1ContentPurposeDigits ZwpTextInputV1ContentPurpose = 2

	// ZwpTextInputV1ContentPurposeNumber corresponds to input a number (including decimal separator and sign)
	ZwpTextInputV1ContentPurposeNumber ZwpTextInputV1ContentPurpose = 3

	// ZwpTextInputV1ContentPurposePhone corresponds to input a phone number
	ZwpTextInputV1ContentPurposePhone ZwpTextInputV1ContentPurpose = 4

	// ZwpTextInputV1ContentPurposeUrl corresponds to input an URL
	ZwpTextInputV1ContentPurposeUrl ZwpTextInputV1ContentPurpose = 5

	// ZwpTextInputV1ContentPurposeEmail corresponds to input an email address
	ZwpTextInputV1ContentPurposeEmail ZwpTextInputV1ContentPurpose = 6

	// ZwpTextInputV1ContentPurposeName corresponds to input a name of a person
	ZwpTextInputV1ContentPurposeName ZwpTextInputV1ContentPurpose = 7

	// ZwpTextInputV1ContentPurposePassword corresponds to input a password (combine with password or sensitive_data hint)
	ZwpTextInputV1ContentPurposePassword ZwpTextInputV1ContentPurpose = 8

	// ZwpTextInputV1ContentPurposeDate corresponds to input a date
	ZwpTextInputV1ContentPurposeDate ZwpTextInputV1ContentPurpose = 9

	// ZwpTextInputV1ContentPurposeTime corresponds to input a time
	ZwpTextInputV1ContentPurposeTime ZwpTextInputV1ContentPurpose = 10

	// ZwpTextInputV1ContentPurposeDatetime corresponds to input a date and time
	ZwpTextInputV1ContentPurposeDatetime ZwpTextInputV1ContentPurpose = 11

	// ZwpTextInputV1ContentPurposeTerminal corresponds to input for a terminal
	ZwpTextInputV1ContentPurposeTerminal ZwpTextInputV1ContentPurpose = 12
)

type ZwpTextInputV1PreeditStyle int

const (
	// ZwpTextInputV1PreeditStyleDefault corresponds to default style for composing text
	ZwpTextInputV1PreeditStyleDefault ZwpTextInputV1PreeditStyle = 0

	// ZwpTextInputV1PreeditStyleNone corresponds to style should be the same as in non-composing text
	ZwpTextInputV1PreeditStyleNone ZwpTextInputV1PreeditStyle = 1

	ZwpTextInputV1PreeditStyleActive ZwpTextInputV1PreeditStyle = 2

	ZwpTextInputV1PreeditStyleInactive ZwpTextInputV1PreeditStyle = 3

	ZwpTextInputV1PreeditStyleHighlight ZwpTextInputV1PreeditStyle = 4

	ZwpTextInputV1PreeditStyleUnderline ZwpTextInputV1PreeditStyle = 5

	ZwpTextInputV1PreeditStyleSelection ZwpTextInputV1PreeditStyle = 6

	ZwpTextInputV1PreeditStyleIncorrect ZwpTextInputV1PreeditStyle = 7
)

type ZwpTextInputV1TextDirection int

const (
	// ZwpTextInputV1TextDirectionAuto corresponds to automatic text direction based on text and language
	ZwpTextInputV1TextDirectionAuto ZwpTextInputV1TextDirection = 0

	// ZwpTextInputV1TextDirectionLtr corresponds to left-to-right
	ZwpTextInputV1TextDirectionLtr ZwpTextInputV1TextDirection = 1

	// ZwpTextInputV1TextDirectionRtl corresponds to right-to-left
	ZwpTextInputV1TextDirectionRtl ZwpTextInputV1TextDirection = 2
)

// ZwpTextInputV1ActivateRequest requests to request activation
//
// Requests the text_input object to be activated (typically when the
// text entry gets focus).
//
// The seat argument is a wl_seat which maintains the focus for this
// activation. The surface argument is a wl_surface assigned to the
// text_input object and tracked for focus lost. The enter event
// is emitted on successful activation.
type ZwpTextInputV1ActivateRequest struct {
	Seat ObjectID

	Surface ObjectID
}

// Opcode returns the request opcode for zwp_text_input_v1.activate in text_input_unstable_v1
func (ZwpTextInputV1ActivateRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for zwp_text_input_v1.activate in text_input_unstable_v1
func (ZwpTextInputV1ActivateRequest) MessageName() string { return "activate" }

// Ensure ZwpTextInputV1ActivateRequest implements Message.
var _ Message = ZwpTextInputV1ActivateRequest{}

// Emit emits the message to the emitter.
func (r *ZwpTextInputV1ActivateRequest) Emit(e *RequestEmitter) error {
	if err := e.PutObjectID(r.Seat); err != nil {
		return err
	}
	if err := e.PutObjectID(r.Surface); err != nil {
		return err
	}
	return nil
}

// Ensure ZwpTextInputV1ActivateRequest implements Request.
var _ Request = &ZwpTextInputV1ActivateRequest{}

// ZwpTextInputV1DeactivateRequest requests to request deactivation
//
// Requests the text_input object to be deactivated (typically when the
// text entry lost focus). The seat argument is a wl_seat which was used
// for activation.
type ZwpTextInputV1DeactivateRequest struct {
	Seat ObjectID
}

// Opcode returns the request opcode for zwp_text_input_v1.deactivate in text_input_unstable_v1
func (ZwpTextInputV1DeactivateRequest) Opcode() uint16 { return 1 }

// MessageName returns the request name for zwp_text_input_v1.deactivate in text_input_unstable_v1
func (ZwpTextInputV1DeactivateRequest) MessageName() string { return "deactivate" }

// Ensure ZwpTextInputV1DeactivateRequest implements Message.
var _ Message = ZwpTextInputV1DeactivateRequest{}

// Emit emits the message to the emitter.
func (r *ZwpTextInputV1DeactivateRequest) Emit(e *RequestEmitter) error {
	if err := e.PutObjectID(r.Seat); err != nil {
		return err
	}
	return nil
}

// Ensure ZwpTextInputV1DeactivateRequest implements Request.
var _ Request = &ZwpTextInputV1DeactivateRequest{}

// ZwpTextInputV1ShowInputPanelRequest requests to show input panels
//
// Requests input panels (virtual keyboard) to show.
type ZwpTextInputV1ShowInputPanelRequest struct {
}

// Opcode returns the request opcode for zwp_text_input_v1.show_input_panel in text_input_unstable_v1
func (ZwpTextInputV1ShowInputPanelRequest) Opcode() uint16 { return 2 }

// MessageName returns the request name for zwp_text_input_v1.show_input_panel in text_input_unstable_v1
func (ZwpTextInputV1ShowInputPanelRequest) MessageName() string { return "show_input_panel" }

// Ensure ZwpTextInputV1ShowInputPanelRequest implements Message.
var _ Message = ZwpTextInputV1ShowInputPanelRequest{}

// Emit emits the message to the emitter.
func (r *ZwpTextInputV1ShowInputPanelRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure ZwpTextInputV1ShowInputPanelRequest implements Request.
var _ Request = &ZwpTextInputV1ShowInputPanelRequest{}

// ZwpTextInputV1HideInputPanelRequest requests to hide input panels
//
// Requests input panels (virtual keyboard) to hide.
type ZwpTextInputV1HideInputPanelRequest struct {
}

// Opcode returns the request opcode for zwp_text_input_v1.hide_input_panel in text_input_unstable_v1
func (ZwpTextInputV1HideInputPanelRequest) Opcode() uint16 { return 3 }

// MessageName returns the request name for zwp_text_input_v1.hide_input_panel in text_input_unstable_v1
func (ZwpTextInputV1HideInputPanelRequest) MessageName() string { return "hide_input_panel" }

// Ensure ZwpTextInputV1HideInputPanelRequest implements Message.
var _ Message = ZwpTextInputV1HideInputPanelRequest{}

// Emit emits the message to the emitter.
func (r *ZwpTextInputV1HideInputPanelRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure ZwpTextInputV1HideInputPanelRequest implements Request.
var _ Request = &ZwpTextInputV1HideInputPanelRequest{}

// ZwpTextInputV1ResetRequest requests to reset
//
// Should be called by an editor widget when the input state should be
// reset, for example after the text was changed outside of the normal
// input method flow.
type ZwpTextInputV1ResetRequest struct {
}

// Opcode returns the request opcode for zwp_text_input_v1.reset in text_input_unstable_v1
func (ZwpTextInputV1ResetRequest) Opcode() uint16 { return 4 }

// MessageName returns the request name for zwp_text_input_v1.reset in text_input_unstable_v1
func (ZwpTextInputV1ResetRequest) MessageName() string { return "reset" }

// Ensure ZwpTextInputV1ResetRequest implements Message.
var _ Message = ZwpTextInputV1ResetRequest{}

// Emit emits the message to the emitter.
func (r *ZwpTextInputV1ResetRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure ZwpTextInputV1ResetRequest implements Request.
var _ Request = &ZwpTextInputV1ResetRequest{}

// ZwpTextInputV1SetSurroundingTextRequest requests to sets the surrounding text
//
// Sets the plain surrounding text around the input position. Text is
// UTF-8 encoded. Cursor is the byte offset within the
// surrounding text. Anchor is the byte offset of the
// selection anchor within the surrounding text. If there is no selected
// text anchor, then it is the same as cursor.
type ZwpTextInputV1SetSurroundingTextRequest struct {
	Text string

	Cursor uint32

	Anchor uint32
}

// Opcode returns the request opcode for zwp_text_input_v1.set_surrounding_text in text_input_unstable_v1
func (ZwpTextInputV1SetSurroundingTextRequest) Opcode() uint16 { return 5 }

// MessageName returns the request name for zwp_text_input_v1.set_surrounding_text in text_input_unstable_v1
func (ZwpTextInputV1SetSurroundingTextRequest) MessageName() string { return "set_surrounding_text" }

// Ensure ZwpTextInputV1SetSurroundingTextRequest implements Message.
var _ Message = ZwpTextInputV1SetSurroundingTextRequest{}

// Emit emits the message to the emitter.
func (r *ZwpTextInputV1SetSurroundingTextRequest) Emit(e *RequestEmitter) error {
	if err := e.PutString(r.Text); err != nil {
		return err
	}
	if err := e.PutUint(r.Cursor); err != nil {
		return err
	}
	if err := e.PutUint(r.Anchor); err != nil {
		return err
	}
	return nil
}

// Ensure ZwpTextInputV1SetSurroundingTextRequest implements Request.
var _ Request = &ZwpTextInputV1SetSurroundingTextRequest{}

// ZwpTextInputV1SetContentTypeRequest requests to set content purpose and hint
//
// Sets the content purpose and content hint. While the purpose is the
// basic purpose of an input field, the hint flags allow to modify some
// of the behavior.
//
// When no content type is explicitly set, a normal content purpose with
// default hints (auto completion, auto correction, auto capitalization)
// should be assumed.
type ZwpTextInputV1SetContentTypeRequest struct {
	Hint uint32

	Purpose uint32
}

// Opcode returns the request opcode for zwp_text_input_v1.set_content_type in text_input_unstable_v1
func (ZwpTextInputV1SetContentTypeRequest) Opcode() uint16 { return 6 }

// MessageName returns the request name for zwp_text_input_v1.set_content_type in text_input_unstable_v1
func (ZwpTextInputV1SetContentTypeRequest) MessageName() string { return "set_content_type" }

// Ensure ZwpTextInputV1SetContentTypeRequest implements Message.
var _ Message = ZwpTextInputV1SetContentTypeRequest{}

// Emit emits the message to the emitter.
func (r *ZwpTextInputV1SetContentTypeRequest) Emit(e *RequestEmitter) error {
	if err := e.PutUint(r.Hint); err != nil {
		return err
	}
	if err := e.PutUint(r.Purpose); err != nil {
		return err
	}
	return nil
}

// Ensure ZwpTextInputV1SetContentTypeRequest implements Request.
var _ Request = &ZwpTextInputV1SetContentTypeRequest{}

type ZwpTextInputV1SetCursorRectangleRequest struct {
	X int32

	Y int32

	Width int32

	Height int32
}

// Opcode returns the request opcode for zwp_text_input_v1.set_cursor_rectangle in text_input_unstable_v1
func (ZwpTextInputV1SetCursorRectangleRequest) Opcode() uint16 { return 7 }

// MessageName returns the request name for zwp_text_input_v1.set_cursor_rectangle in text_input_unstable_v1
func (ZwpTextInputV1SetCursorRectangleRequest) MessageName() string { return "set_cursor_rectangle" }

// Ensure ZwpTextInputV1SetCursorRectangleRequest implements Message.
var _ Message = ZwpTextInputV1SetCursorRectangleRequest{}

// Emit emits the message to the emitter.
func (r *ZwpTextInputV1SetCursorRectangleRequest) Emit(e *RequestEmitter) error {
	if err := e.PutInt(r.X); err != nil {
		return err
	}
	if err := e.PutInt(r.Y); err != nil {
		return err
	}
	if err := e.PutInt(r.Width); err != nil {
		return err
	}
	if err := e.PutInt(r.Height); err != nil {
		return err
	}
	return nil
}

// Ensure ZwpTextInputV1SetCursorRectangleRequest implements Request.
var _ Request = &ZwpTextInputV1SetCursorRectangleRequest{}

// ZwpTextInputV1SetPreferredLanguageRequest requests to sets preferred language
//
// Sets a specific language. This allows for example a virtual keyboard to
// show a language specific layout. The "language" argument is an RFC-3066
// format language tag.
//
// It could be used for example in a word processor to indicate the
// language of the currently edited document or in an instant message
// application which tracks languages of contacts.
type ZwpTextInputV1SetPreferredLanguageRequest struct {
	Language string
}

// Opcode returns the request opcode for zwp_text_input_v1.set_preferred_language in text_input_unstable_v1
func (ZwpTextInputV1SetPreferredLanguageRequest) Opcode() uint16 { return 8 }

// MessageName returns the request name for zwp_text_input_v1.set_preferred_language in text_input_unstable_v1
func (ZwpTextInputV1SetPreferredLanguageRequest) MessageName() string {
	return "set_preferred_language"
}

// Ensure ZwpTextInputV1SetPreferredLanguageRequest implements Message.
var _ Message = ZwpTextInputV1SetPreferredLanguageRequest{}

// Emit emits the message to the emitter.
func (r *ZwpTextInputV1SetPreferredLanguageRequest) Emit(e *RequestEmitter) error {
	if err := e.PutString(r.Language); err != nil {
		return err
	}
	return nil
}

// Ensure ZwpTextInputV1SetPreferredLanguageRequest implements Request.
var _ Request = &ZwpTextInputV1SetPreferredLanguageRequest{}

type ZwpTextInputV1CommitStateRequest struct {
	// Serial contains used to identify the known state
	Serial uint32
}

// Opcode returns the request opcode for zwp_text_input_v1.commit_state in text_input_unstable_v1
func (ZwpTextInputV1CommitStateRequest) Opcode() uint16 { return 9 }

// MessageName returns the request name for zwp_text_input_v1.commit_state in text_input_unstable_v1
func (ZwpTextInputV1CommitStateRequest) MessageName() string { return "commit_state" }

// Ensure ZwpTextInputV1CommitStateRequest implements Message.
var _ Message = ZwpTextInputV1CommitStateRequest{}

// Emit emits the message to the emitter.
func (r *ZwpTextInputV1CommitStateRequest) Emit(e *RequestEmitter) error {
	if err := e.PutUint(r.Serial); err != nil {
		return err
	}
	return nil
}

// Ensure ZwpTextInputV1CommitStateRequest implements Request.
var _ Request = &ZwpTextInputV1CommitStateRequest{}

type ZwpTextInputV1InvokeActionRequest struct {
	Button uint32

	Index uint32
}

// Opcode returns the request opcode for zwp_text_input_v1.invoke_action in text_input_unstable_v1
func (ZwpTextInputV1InvokeActionRequest) Opcode() uint16 { return 10 }

// MessageName returns the request name for zwp_text_input_v1.invoke_action in text_input_unstable_v1
func (ZwpTextInputV1InvokeActionRequest) MessageName() string { return "invoke_action" }

// Ensure ZwpTextInputV1InvokeActionRequest implements Message.
var _ Message = ZwpTextInputV1InvokeActionRequest{}

// Emit emits the message to the emitter.
func (r *ZwpTextInputV1InvokeActionRequest) Emit(e *RequestEmitter) error {
	if err := e.PutUint(r.Button); err != nil {
		return err
	}
	if err := e.PutUint(r.Index); err != nil {
		return err
	}
	return nil
}

// Ensure ZwpTextInputV1InvokeActionRequest implements Request.
var _ Request = &ZwpTextInputV1InvokeActionRequest{}

// ZwpTextInputV1EnterEvent signals when enter event
//
// Notify the text_input object when it received focus. Typically in
// response to an activate request.
type ZwpTextInputV1EnterEvent struct {
	Surface ObjectID
}

// Opcode returns the event opcode for zwp_text_input_v1.enter in text_input_unstable_v1
func (ZwpTextInputV1EnterEvent) Opcode() uint16 { return 0 }

// MessageName returns the event name for zwp_text_input_v1.enter in text_input_unstable_v1
func (ZwpTextInputV1EnterEvent) MessageName() string { return "enter" }

// Ensure ZwpTextInputV1EnterEvent implements Message.
var _ Message = ZwpTextInputV1EnterEvent{}

// Scan scans the event from the socket.
func (e *ZwpTextInputV1EnterEvent) Scan(s *EventScanner) error {
	if v, err := s.ObjectID(); err != nil {
		return err
	} else {
		e.Surface = v
	}
	return nil
}

// Ensure ZwpTextInputV1EnterEvent implements Event.
var _ Event = &ZwpTextInputV1EnterEvent{}

// ZwpTextInputV1LeaveEvent signals when leave event
//
// Notify the text_input object when it lost focus. Either in response
// to a deactivate request or when the assigned surface lost focus or was
// destroyed.
type ZwpTextInputV1LeaveEvent struct {
}

// Opcode returns the event opcode for zwp_text_input_v1.leave in text_input_unstable_v1
func (ZwpTextInputV1LeaveEvent) Opcode() uint16 { return 1 }

// MessageName returns the event name for zwp_text_input_v1.leave in text_input_unstable_v1
func (ZwpTextInputV1LeaveEvent) MessageName() string { return "leave" }

// Ensure ZwpTextInputV1LeaveEvent implements Message.
var _ Message = ZwpTextInputV1LeaveEvent{}

// Scan scans the event from the socket.
func (e *ZwpTextInputV1LeaveEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure ZwpTextInputV1LeaveEvent implements Event.
var _ Event = &ZwpTextInputV1LeaveEvent{}

// ZwpTextInputV1ModifiersMapEvent signals when modifiers map
//
// Transfer an array of 0-terminated modifier names. The position in
// the array is the index of the modifier as used in the modifiers
// bitmask in the keysym event.
type ZwpTextInputV1ModifiersMapEvent struct {
	Map []byte
}

// Opcode returns the event opcode for zwp_text_input_v1.modifiers_map in text_input_unstable_v1
func (ZwpTextInputV1ModifiersMapEvent) Opcode() uint16 { return 2 }

// MessageName returns the event name for zwp_text_input_v1.modifiers_map in text_input_unstable_v1
func (ZwpTextInputV1ModifiersMapEvent) MessageName() string { return "modifiers_map" }

// Ensure ZwpTextInputV1ModifiersMapEvent implements Message.
var _ Message = ZwpTextInputV1ModifiersMapEvent{}

// Scan scans the event from the socket.
func (e *ZwpTextInputV1ModifiersMapEvent) Scan(s *EventScanner) error {
	if v, err := s.Array(); err != nil {
		return err
	} else {
		e.Map = v
	}
	return nil
}

// Ensure ZwpTextInputV1ModifiersMapEvent implements Event.
var _ Event = &ZwpTextInputV1ModifiersMapEvent{}

// ZwpTextInputV1InputPanelStateEvent signals when state of the input panel
//
// Notify when the visibility state of the input panel changed.
type ZwpTextInputV1InputPanelStateEvent struct {
	State uint32
}

// Opcode returns the event opcode for zwp_text_input_v1.input_panel_state in text_input_unstable_v1
func (ZwpTextInputV1InputPanelStateEvent) Opcode() uint16 { return 3 }

// MessageName returns the event name for zwp_text_input_v1.input_panel_state in text_input_unstable_v1
func (ZwpTextInputV1InputPanelStateEvent) MessageName() string { return "input_panel_state" }

// Ensure ZwpTextInputV1InputPanelStateEvent implements Message.
var _ Message = ZwpTextInputV1InputPanelStateEvent{}

// Scan scans the event from the socket.
func (e *ZwpTextInputV1InputPanelStateEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.State = v
	}
	return nil
}

// Ensure ZwpTextInputV1InputPanelStateEvent implements Event.
var _ Event = &ZwpTextInputV1InputPanelStateEvent{}

// ZwpTextInputV1PreeditStringEvent signals when pre-edit
//
// Notify when a new composing text (pre-edit) should be set around the
// current cursor position. Any previously set composing text should
// be removed.
//
// The commit text can be used to replace the preedit text on reset
// (for example on unfocus).
//
// The text input should also handle all preedit_style and preedit_cursor
// events occurring directly before preedit_string.
type ZwpTextInputV1PreeditStringEvent struct {
	// Serial contains serial of the latest known text input state
	Serial uint32

	Text string

	Commit string
}

// Opcode returns the event opcode for zwp_text_input_v1.preedit_string in text_input_unstable_v1
func (ZwpTextInputV1PreeditStringEvent) Opcode() uint16 { return 4 }

// MessageName returns the event name for zwp_text_input_v1.preedit_string in text_input_unstable_v1
func (ZwpTextInputV1PreeditStringEvent) MessageName() string { return "preedit_string" }

// Ensure ZwpTextInputV1PreeditStringEvent implements Message.
var _ Message = ZwpTextInputV1PreeditStringEvent{}

// Scan scans the event from the socket.
func (e *ZwpTextInputV1PreeditStringEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Serial = v
	}
	if v, err := s.String(); err != nil {
		return err
	} else {
		e.Text = v
	}
	if v, err := s.String(); err != nil {
		return err
	} else {
		e.Commit = v
	}
	return nil
}

// Ensure ZwpTextInputV1PreeditStringEvent implements Event.
var _ Event = &ZwpTextInputV1PreeditStringEvent{}

// ZwpTextInputV1PreeditStylingEvent signals when pre-edit styling
//
// Sets styling information on composing text. The style is applied for
// length bytes from index relative to the beginning of the composing
// text (as byte offset). Multiple styles can
// be applied to a composing text by sending multiple preedit_styling
// events.
//
// This event is handled as part of a following preedit_string event.
type ZwpTextInputV1PreeditStylingEvent struct {
	Index uint32

	Length uint32

	Style uint32
}

// Opcode returns the event opcode for zwp_text_input_v1.preedit_styling in text_input_unstable_v1
func (ZwpTextInputV1PreeditStylingEvent) Opcode() uint16 { return 5 }

// MessageName returns the event name for zwp_text_input_v1.preedit_styling in text_input_unstable_v1
func (ZwpTextInputV1PreeditStylingEvent) MessageName() string { return "preedit_styling" }

// Ensure ZwpTextInputV1PreeditStylingEvent implements Message.
var _ Message = ZwpTextInputV1PreeditStylingEvent{}

// Scan scans the event from the socket.
func (e *ZwpTextInputV1PreeditStylingEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Index = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Length = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Style = v
	}
	return nil
}

// Ensure ZwpTextInputV1PreeditStylingEvent implements Event.
var _ Event = &ZwpTextInputV1PreeditStylingEvent{}

// ZwpTextInputV1PreeditCursorEvent signals when pre-edit cursor
//
// Sets the cursor position inside the composing text (as byte
// offset) relative to the start of the composing text. When index is a
// negative number no cursor is shown.
//
// This event is handled as part of a following preedit_string event.
type ZwpTextInputV1PreeditCursorEvent struct {
	Index int32
}

// Opcode returns the event opcode for zwp_text_input_v1.preedit_cursor in text_input_unstable_v1
func (ZwpTextInputV1PreeditCursorEvent) Opcode() uint16 { return 6 }

// MessageName returns the event name for zwp_text_input_v1.preedit_cursor in text_input_unstable_v1
func (ZwpTextInputV1PreeditCursorEvent) MessageName() string { return "preedit_cursor" }

// Ensure ZwpTextInputV1PreeditCursorEvent implements Message.
var _ Message = ZwpTextInputV1PreeditCursorEvent{}

// Scan scans the event from the socket.
func (e *ZwpTextInputV1PreeditCursorEvent) Scan(s *EventScanner) error {
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.Index = v
	}
	return nil
}

// Ensure ZwpTextInputV1PreeditCursorEvent implements Event.
var _ Event = &ZwpTextInputV1PreeditCursorEvent{}

// ZwpTextInputV1CommitStringEvent signals when commit
//
// Notify when text should be inserted into the editor widget. The text to
// commit could be either just a single character after a key press or the
// result of some composing (pre-edit). It could also be an empty text
// when some text should be removed (see delete_surrounding_text) or when
// the input cursor should be moved (see cursor_position).
//
// Any previously set composing text should be removed.
type ZwpTextInputV1CommitStringEvent struct {
	// Serial contains serial of the latest known text input state
	Serial uint32

	Text string
}

// Opcode returns the event opcode for zwp_text_input_v1.commit_string in text_input_unstable_v1
func (ZwpTextInputV1CommitStringEvent) Opcode() uint16 { return 7 }

// MessageName returns the event name for zwp_text_input_v1.commit_string in text_input_unstable_v1
func (ZwpTextInputV1CommitStringEvent) MessageName() string { return "commit_string" }

// Ensure ZwpTextInputV1CommitStringEvent implements Message.
var _ Message = ZwpTextInputV1CommitStringEvent{}

// Scan scans the event from the socket.
func (e *ZwpTextInputV1CommitStringEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Serial = v
	}
	if v, err := s.String(); err != nil {
		return err
	} else {
		e.Text = v
	}
	return nil
}

// Ensure ZwpTextInputV1CommitStringEvent implements Event.
var _ Event = &ZwpTextInputV1CommitStringEvent{}

// ZwpTextInputV1CursorPositionEvent signals when set cursor to new position
//
// Notify when the cursor or anchor position should be modified.
//
// This event should be handled as part of a following commit_string
// event.
type ZwpTextInputV1CursorPositionEvent struct {
	Index int32

	Anchor int32
}

// Opcode returns the event opcode for zwp_text_input_v1.cursor_position in text_input_unstable_v1
func (ZwpTextInputV1CursorPositionEvent) Opcode() uint16 { return 8 }

// MessageName returns the event name for zwp_text_input_v1.cursor_position in text_input_unstable_v1
func (ZwpTextInputV1CursorPositionEvent) MessageName() string { return "cursor_position" }

// Ensure ZwpTextInputV1CursorPositionEvent implements Message.
var _ Message = ZwpTextInputV1CursorPositionEvent{}

// Scan scans the event from the socket.
func (e *ZwpTextInputV1CursorPositionEvent) Scan(s *EventScanner) error {
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.Index = v
	}
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.Anchor = v
	}
	return nil
}

// Ensure ZwpTextInputV1CursorPositionEvent implements Event.
var _ Event = &ZwpTextInputV1CursorPositionEvent{}

// ZwpTextInputV1DeleteSurroundingTextEvent signals when delete surrounding text
//
// Notify when the text around the current cursor position should be
// deleted.
//
// Index is relative to the current cursor (in bytes).
// Length is the length of deleted text (in bytes).
//
// This event should be handled as part of a following commit_string
// event.
type ZwpTextInputV1DeleteSurroundingTextEvent struct {
	Index int32

	Length uint32
}

// Opcode returns the event opcode for zwp_text_input_v1.delete_surrounding_text in text_input_unstable_v1
func (ZwpTextInputV1DeleteSurroundingTextEvent) Opcode() uint16 { return 9 }

// MessageName returns the event name for zwp_text_input_v1.delete_surrounding_text in text_input_unstable_v1
func (ZwpTextInputV1DeleteSurroundingTextEvent) MessageName() string {
	return "delete_surrounding_text"
}

// Ensure ZwpTextInputV1DeleteSurroundingTextEvent implements Message.
var _ Message = ZwpTextInputV1DeleteSurroundingTextEvent{}

// Scan scans the event from the socket.
func (e *ZwpTextInputV1DeleteSurroundingTextEvent) Scan(s *EventScanner) error {
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.Index = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Length = v
	}
	return nil
}

// Ensure ZwpTextInputV1DeleteSurroundingTextEvent implements Event.
var _ Event = &ZwpTextInputV1DeleteSurroundingTextEvent{}

// ZwpTextInputV1KeysymEvent signals when keysym
//
// Notify when a key event was sent. Key events should not be used
// for normal text input operations, which should be done with
// commit_string, delete_surrounding_text, etc. The key event follows
// the wl_keyboard key event convention. Sym is an XKB keysym, state a
// wl_keyboard key_state. Modifiers are a mask for effective modifiers
// (where the modifier indices are set by the modifiers_map event)
type ZwpTextInputV1KeysymEvent struct {
	// Serial contains serial of the latest known text input state
	Serial uint32

	Time uint32

	Sym uint32

	State uint32

	Modifiers uint32
}

// Opcode returns the event opcode for zwp_text_input_v1.keysym in text_input_unstable_v1
func (ZwpTextInputV1KeysymEvent) Opcode() uint16 { return 10 }

// MessageName returns the event name for zwp_text_input_v1.keysym in text_input_unstable_v1
func (ZwpTextInputV1KeysymEvent) MessageName() string { return "keysym" }

// Ensure ZwpTextInputV1KeysymEvent implements Message.
var _ Message = ZwpTextInputV1KeysymEvent{}

// Scan scans the event from the socket.
func (e *ZwpTextInputV1KeysymEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Serial = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Time = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Sym = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.State = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Modifiers = v
	}
	return nil
}

// Ensure ZwpTextInputV1KeysymEvent implements Event.
var _ Event = &ZwpTextInputV1KeysymEvent{}

// ZwpTextInputV1LanguageEvent signals when language
//
// Sets the language of the input text. The "language" argument is an
// RFC-3066 format language tag.
type ZwpTextInputV1LanguageEvent struct {
	// Serial contains serial of the latest known text input state
	Serial uint32

	Language string
}

// Opcode returns the event opcode for zwp_text_input_v1.language in text_input_unstable_v1
func (ZwpTextInputV1LanguageEvent) Opcode() uint16 { return 11 }

// MessageName returns the event name for zwp_text_input_v1.language in text_input_unstable_v1
func (ZwpTextInputV1LanguageEvent) MessageName() string { return "language" }

// Ensure ZwpTextInputV1LanguageEvent implements Message.
var _ Message = ZwpTextInputV1LanguageEvent{}

// Scan scans the event from the socket.
func (e *ZwpTextInputV1LanguageEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Serial = v
	}
	if v, err := s.String(); err != nil {
		return err
	} else {
		e.Language = v
	}
	return nil
}

// Ensure ZwpTextInputV1LanguageEvent implements Event.
var _ Event = &ZwpTextInputV1LanguageEvent{}

// ZwpTextInputV1TextDirectionEvent signals when text direction
//
// Sets the text direction of input text.
//
// It is mainly needed for showing an input cursor on the correct side of
// the editor when there is no input done yet and making sure neutral
// direction text is laid out properly.
type ZwpTextInputV1TextDirectionEvent struct {
	// Serial contains serial of the latest known text input state
	Serial uint32

	Direction uint32
}

// Opcode returns the event opcode for zwp_text_input_v1.text_direction in text_input_unstable_v1
func (ZwpTextInputV1TextDirectionEvent) Opcode() uint16 { return 12 }

// MessageName returns the event name for zwp_text_input_v1.text_direction in text_input_unstable_v1
func (ZwpTextInputV1TextDirectionEvent) MessageName() string { return "text_direction" }

// Ensure ZwpTextInputV1TextDirectionEvent implements Message.
var _ Message = ZwpTextInputV1TextDirectionEvent{}

// Scan scans the event from the socket.
func (e *ZwpTextInputV1TextDirectionEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Serial = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Direction = v
	}
	return nil
}

// Ensure ZwpTextInputV1TextDirectionEvent implements Event.
var _ Event = &ZwpTextInputV1TextDirectionEvent{}

// ZwpTextInputV1 text input
//
// An object used for text input. Adds support for text input and input
// methods to applications. A text_input object is created from a
// wl_text_input_manager and corresponds typically to a text entry in an
// application.
//
// Requests are used to activate/deactivate the text_input object and set
// state information like surrounding and selected text or the content type.
// The information about entered text is sent to the text_input object via
// the pre-edit and commit events. Using this interface removes the need
// for applications to directly process hardware key events and compose text
// out of them.
//
// Text is generally UTF-8 encoded, indices and lengths are in bytes.
//
// Serials are used to synchronize the state between the text input and
// an input method. New serials are sent by the text input in the
// commit_state request and are used by the input method to indicate
// the known text input state in events like preedit_string, commit_string,
// and keysym. The text input can then ignore events from the input method
// which are based on an outdated state (for example after a reset).
//
// Warning! The protocol described in this file is experimental and
// backward incompatible changes may be made. Backward compatible changes
// may be added together with the corresponding interface version bump.
// Backward incompatible changes are done by bumping the version number in
// the protocol and interface names and resetting the interface version.
// Once the protocol is to be declared stable, the 'z' prefix and the
// version number in the protocol and interface names are removed and the
// interface version number is reset.
type ZwpTextInputV1 struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *ZwpTextInputV1) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (ZwpTextInputV1) Descriptor() *InterfaceDescriptor {
	return &ZwpTextInputV1Descriptor
}

// Dispatch returns an Event object for a given opcode.
func (ZwpTextInputV1) Dispatch(opcode uint16) Event {
	switch opcode {
	case 0:
		return &ZwpTextInputV1EnterEvent{}
	case 1:
		return &ZwpTextInputV1LeaveEvent{}
	case 2:
		return &ZwpTextInputV1ModifiersMapEvent{}
	case 3:
		return &ZwpTextInputV1InputPanelStateEvent{}
	case 4:
		return &ZwpTextInputV1PreeditStringEvent{}
	case 5:
		return &ZwpTextInputV1PreeditStylingEvent{}
	case 6:
		return &ZwpTextInputV1PreeditCursorEvent{}
	case 7:
		return &ZwpTextInputV1CommitStringEvent{}
	case 8:
		return &ZwpTextInputV1CursorPositionEvent{}
	case 9:
		return &ZwpTextInputV1DeleteSurroundingTextEvent{}
	case 10:
		return &ZwpTextInputV1KeysymEvent{}
	case 11:
		return &ZwpTextInputV1LanguageEvent{}
	case 12:
		return &ZwpTextInputV1TextDirectionEvent{}
	default:
		return nil
	}
}

// Activate requests to request activation
//
// Requests the text_input object to be activated (typically when the
// text entry gets focus).
//
// The seat argument is a wl_seat which maintains the focus for this
// activation. The surface argument is a wl_surface assigned to the
// text_input object and tracked for focus lost. The enter event
// is emitted on successful activation.
func (proxy *ZwpTextInputV1) Activate(connection Connection, aSeat ObjectID, aSurface ObjectID) (err error) {
	request := ZwpTextInputV1ActivateRequest{
		Seat:    aSeat,
		Surface: aSurface,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Deactivate requests to request deactivation
//
// Requests the text_input object to be deactivated (typically when the
// text entry lost focus). The seat argument is a wl_seat which was used
// for activation.
func (proxy *ZwpTextInputV1) Deactivate(connection Connection, aSeat ObjectID) (err error) {
	request := ZwpTextInputV1DeactivateRequest{
		Seat: aSeat,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// ShowInputPanel requests to show input panels
//
// Requests input panels (virtual keyboard) to show.
func (proxy *ZwpTextInputV1) ShowInputPanel(connection Connection) (err error) {
	request := ZwpTextInputV1ShowInputPanelRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// HideInputPanel requests to hide input panels
//
// Requests input panels (virtual keyboard) to hide.
func (proxy *ZwpTextInputV1) HideInputPanel(connection Connection) (err error) {
	request := ZwpTextInputV1HideInputPanelRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Reset requests to reset
//
// Should be called by an editor widget when the input state should be
// reset, for example after the text was changed outside of the normal
// input method flow.
func (proxy *ZwpTextInputV1) Reset(connection Connection) (err error) {
	request := ZwpTextInputV1ResetRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// SetSurroundingText requests to sets the surrounding text
//
// Sets the plain surrounding text around the input position. Text is
// UTF-8 encoded. Cursor is the byte offset within the
// surrounding text. Anchor is the byte offset of the
// selection anchor within the surrounding text. If there is no selected
// text anchor, then it is the same as cursor.
func (proxy *ZwpTextInputV1) SetSurroundingText(connection Connection, aText string, aCursor uint32, aAnchor uint32) (err error) {
	request := ZwpTextInputV1SetSurroundingTextRequest{
		Text:   aText,
		Cursor: aCursor,
		Anchor: aAnchor,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// SetContentType requests to set content purpose and hint
//
// Sets the content purpose and content hint. While the purpose is the
// basic purpose of an input field, the hint flags allow to modify some
// of the behavior.
//
// When no content type is explicitly set, a normal content purpose with
// default hints (auto completion, auto correction, auto capitalization)
// should be assumed.
func (proxy *ZwpTextInputV1) SetContentType(connection Connection, aHint uint32, aPurpose uint32) (err error) {
	request := ZwpTextInputV1SetContentTypeRequest{
		Hint:    aHint,
		Purpose: aPurpose,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

func (proxy *ZwpTextInputV1) SetCursorRectangle(connection Connection, aX int32, aY int32, aWidth int32, aHeight int32) (err error) {
	request := ZwpTextInputV1SetCursorRectangleRequest{
		X:      aX,
		Y:      aY,
		Width:  aWidth,
		Height: aHeight,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// SetPreferredLanguage requests to sets preferred language
//
// Sets a specific language. This allows for example a virtual keyboard to
// show a language specific layout. The "language" argument is an RFC-3066
// format language tag.
//
// It could be used for example in a word processor to indicate the
// language of the currently edited document or in an instant message
// application which tracks languages of contacts.
func (proxy *ZwpTextInputV1) SetPreferredLanguage(connection Connection, aLanguage string) (err error) {
	request := ZwpTextInputV1SetPreferredLanguageRequest{
		Language: aLanguage,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

func (proxy *ZwpTextInputV1) CommitState(connection Connection, aSerial uint32) (err error) {
	request := ZwpTextInputV1CommitStateRequest{
		Serial: aSerial,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

func (proxy *ZwpTextInputV1) InvokeAction(connection Connection, aButton uint32, aIndex uint32) (err error) {
	request := ZwpTextInputV1InvokeActionRequest{
		Button: aButton,
		Index:  aIndex,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Ensure ZwpTextInputV1 implements Proxy.
var _ Proxy = &ZwpTextInputV1{}

// #endregion Interface text_input_unstable_v1.zwp_text_input_v1

// ----------------------------------------------------------------------------
// #region Interface text_input_unstable_v1.zwp_text_input_manager_v1

// ZwpTextInputManagerV1CreateTextInputRequest requests to create text input
//
// Creates a new text_input object.
type ZwpTextInputManagerV1CreateTextInputRequest struct {
	ID ObjectID
}

// Opcode returns the request opcode for zwp_text_input_manager_v1.create_text_input in text_input_unstable_v1
func (ZwpTextInputManagerV1CreateTextInputRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for zwp_text_input_manager_v1.create_text_input in text_input_unstable_v1
func (ZwpTextInputManagerV1CreateTextInputRequest) MessageName() string { return "create_text_input" }

// Ensure ZwpTextInputManagerV1CreateTextInputRequest implements Message.
var _ Message = ZwpTextInputManagerV1CreateTextInputRequest{}

// Emit emits the message to the emitter.
func (r *ZwpTextInputManagerV1CreateTextInputRequest) Emit(e *RequestEmitter) error {
	if err := e.PutObjectID(r.ID); err != nil {
		return err
	}
	return nil
}

// Ensure ZwpTextInputManagerV1CreateTextInputRequest implements Request.
var _ Request = &ZwpTextInputManagerV1CreateTextInputRequest{}

// ZwpTextInputManagerV1 text input manager
//
// A factory for text_input objects. This object is a global singleton.
type ZwpTextInputManagerV1 struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *ZwpTextInputManagerV1) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (ZwpTextInputManagerV1) Descriptor() *InterfaceDescriptor {
	return &ZwpTextInputManagerV1Descriptor
}

// Dispatch returns an Event object for a given opcode.
func (ZwpTextInputManagerV1) Dispatch(opcode uint16) Event {
	switch opcode {
	default:
		return nil
	}
}

// CreateTextInput requests to create text input
//
// Creates a new text_input object.
func (proxy *ZwpTextInputManagerV1) CreateTextInput(connection Connection) (aID *ZwpTextInputV1, err error) {
	aID = &ZwpTextInputV1{connection.NewID()}
	request := ZwpTextInputManagerV1CreateTextInputRequest{
		ID: aID.id,
	}
	err = connection.SendRequest(proxy.id, &request)
	if err == nil {
		connection.RegisterProxy(aID)
	}
	return
}

// Ensure ZwpTextInputManagerV1 implements Proxy.
var _ Proxy = &ZwpTextInputManagerV1{}

// #endregion Interface text_input_unstable_v1.zwp_text_input_manager_v1

////////////////////////////////////////////////////////////////////////////////
// #endregion Protocol text_input_unstable_v1

////////////////////////////////////////////////////////////////////////////////
// #region Protocol text_input_unstable_v3

// ----------------------------------------------------------------------------
// #region Interface text_input_unstable_v3.zwp_text_input_v3

// ZwpTextInputV3ChangeCause represents text change reason
//
// Reason for the change of surrounding text or cursor posision.
type ZwpTextInputV3ChangeCause int

const (
	// ZwpTextInputV3ChangeCauseInputMethod corresponds to input method caused the change
	ZwpTextInputV3ChangeCauseInputMethod ZwpTextInputV3ChangeCause = 0

	// ZwpTextInputV3ChangeCauseOther corresponds to something else than the input method caused the change
	ZwpTextInputV3ChangeCauseOther ZwpTextInputV3ChangeCause = 1
)

// ZwpTextInputV3ContentHint represents content hint
//
// Content hint is a bitmask to allow to modify the behavior of the text
// input.
type ZwpTextInputV3ContentHint uint

const (
	// ZwpTextInputV3ContentHintNone corresponds to no special behavior
	ZwpTextInputV3ContentHintNone ZwpTextInputV3ContentHint = 0x0

	// ZwpTextInputV3ContentHintCompletion corresponds to suggest word completions
	ZwpTextInputV3ContentHintCompletion ZwpTextInputV3ContentHint = 0x1

	// ZwpTextInputV3ContentHintSpellcheck corresponds to suggest word corrections
	ZwpTextInputV3ContentHintSpellcheck ZwpTextInputV3ContentHint = 0x2

	// ZwpTextInputV3ContentHintAutoCapitalization corresponds to switch to uppercase letters at the start of a sentence
	ZwpTextInputV3ContentHintAutoCapitalization ZwpTextInputV3ContentHint = 0x4

	// ZwpTextInputV3ContentHintLowercase corresponds to prefer lowercase letters
	ZwpTextInputV3ContentHintLowercase ZwpTextInputV3ContentHint = 0x8

	// ZwpTextInputV3ContentHintUppercase corresponds to prefer uppercase letters
	ZwpTextInputV3ContentHintUppercase ZwpTextInputV3ContentHint = 0x10

	// ZwpTextInputV3ContentHintTitlecase corresponds to prefer casing for titles and headings (can be language dependent)
	ZwpTextInputV3ContentHintTitlecase ZwpTextInputV3ContentHint = 0x20

	// ZwpTextInputV3ContentHintHiddenText corresponds to characters should be hidden
	ZwpTextInputV3ContentHintHiddenText ZwpTextInputV3ContentHint = 0x40

	// ZwpTextInputV3ContentHintSensitiveData corresponds to typed text should not be stored
	ZwpTextInputV3ContentHintSensitiveData ZwpTextInputV3ContentHint = 0x80

	// ZwpTextInputV3ContentHintLatin corresponds to just Latin characters should be entered
	ZwpTextInputV3ContentHintLatin ZwpTextInputV3ContentHint = 0x100

	// ZwpTextInputV3ContentHintMultiline corresponds to the text input is multiline
	ZwpTextInputV3ContentHintMultiline ZwpTextInputV3ContentHint = 0x200
)

// ZwpTextInputV3ContentPurpose represents content purpose
//
// The content purpose allows to specify the primary purpose of a text
// input.
//
// This allows an input method to show special purpose input panels with
// extra characters or to disallow some characters.
type ZwpTextInputV3ContentPurpose int

const (
	// ZwpTextInputV3ContentPurposeNormal corresponds to default input, allowing all characters
	ZwpTextInputV3ContentPurposeNormal ZwpTextInputV3ContentPurpose = 0

	// ZwpTextInputV3ContentPurposeAlpha corresponds to allow only alphabetic characters
	ZwpTextInputV3ContentPurposeAlpha ZwpTextInputV3ContentPurpose = 1

	// ZwpTextInputV3ContentPurposeDigits corresponds to allow only digits
	ZwpTextInputV3ContentPurposeDigits ZwpTextInputV3ContentPurpose = 2

	// ZwpTextInputV3ContentPurposeNumber corresponds to input a number (including decimal separator and sign)
	ZwpTextInputV3ContentPurposeNumber ZwpTextInputV3ContentPurpose = 3

	// ZwpTextInputV3ContentPurposePhone corresponds to input a phone number
	ZwpTextInputV3ContentPurposePhone ZwpTextInputV3ContentPurpose = 4

	// ZwpTextInputV3ContentPurposeUrl corresponds to input an URL
	ZwpTextInputV3ContentPurposeUrl ZwpTextInputV3ContentPurpose = 5

	// ZwpTextInputV3ContentPurposeEmail corresponds to input an email address
	ZwpTextInputV3ContentPurposeEmail ZwpTextInputV3ContentPurpose = 6

	// ZwpTextInputV3ContentPurposeName corresponds to input a name of a person
	ZwpTextInputV3ContentPurposeName ZwpTextInputV3ContentPurpose = 7

	// ZwpTextInputV3ContentPurposePassword corresponds to input a password (combine with sensitive_data hint)
	ZwpTextInputV3ContentPurposePassword ZwpTextInputV3ContentPurpose = 8

	// ZwpTextInputV3ContentPurposePin corresponds to input is a numeric password (combine with sensitive_data hint)
	ZwpTextInputV3ContentPurposePin ZwpTextInputV3ContentPurpose = 9

	// ZwpTextInputV3ContentPurposeDate corresponds to input a date
	ZwpTextInputV3ContentPurposeDate ZwpTextInputV3ContentPurpose = 10

	// ZwpTextInputV3ContentPurposeTime corresponds to input a time
	ZwpTextInputV3ContentPurposeTime ZwpTextInputV3ContentPurpose = 11

	// ZwpTextInputV3ContentPurposeDatetime corresponds to input a date and time
	ZwpTextInputV3ContentPurposeDatetime ZwpTextInputV3ContentPurpose = 12

	// ZwpTextInputV3ContentPurposeTerminal corresponds to input for a terminal
	ZwpTextInputV3ContentPurposeTerminal ZwpTextInputV3ContentPurpose = 13
)

// ZwpTextInputV3DestroyRequest requests to Destroy the wp_text_input
//
// Destroy the wp_text_input object. Also disables all surfaces enabled
// through this wp_text_input object.
type ZwpTextInputV3DestroyRequest struct {
}

// Opcode returns the request opcode for zwp_text_input_v3.destroy in text_input_unstable_v3
func (ZwpTextInputV3DestroyRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for zwp_text_input_v3.destroy in text_input_unstable_v3
func (ZwpTextInputV3DestroyRequest) MessageName() string { return "destroy" }

// Ensure ZwpTextInputV3DestroyRequest implements Message.
var _ Message = ZwpTextInputV3DestroyRequest{}

// Emit emits the message to the emitter.
func (r *ZwpTextInputV3DestroyRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure ZwpTextInputV3DestroyRequest implements Request.
var _ Request = &ZwpTextInputV3DestroyRequest{}

// ZwpTextInputV3EnableRequest requests to Request text input to be enabled
//
// Requests text input on the surface previously obtained from the enter
// event.
//
// This request must be issued every time the active text input changes
// to a new one, including within the current surface. Use
// zwp_text_input_v3.disable when there is no longer any input focus on
// the current surface.
//
// Clients must not enable more than one text input on the single seat
// and should disable the current text input before enabling the new one.
// At most one instance of text input may be in enabled state per instance,
// Requests to enable the another text input when some text input is active
// must be ignored by compositor.
//
// This request resets all state associated with previous enable, disable,
// set_surrounding_text, set_text_change_cause, set_content_type, and
// set_cursor_rectangle requests, as well as the state associated with
// preedit_string, commit_string, and delete_surrounding_text events.
//
// The set_surrounding_text, set_content_type and set_cursor_rectangle
// requests must follow if the text input supports the necessary
// functionality.
//
// State set with this request is double-buffered. It will get applied on
// the next zwp_text_input_v3.commit request, and stay valid until the
// next committed enable or disable request.
//
// The changes must be applied by the compositor after issuing a
// zwp_text_input_v3.commit request.
type ZwpTextInputV3EnableRequest struct {
}

// Opcode returns the request opcode for zwp_text_input_v3.enable in text_input_unstable_v3
func (ZwpTextInputV3EnableRequest) Opcode() uint16 { return 1 }

// MessageName returns the request name for zwp_text_input_v3.enable in text_input_unstable_v3
func (ZwpTextInputV3EnableRequest) MessageName() string { return "enable" }

// Ensure ZwpTextInputV3EnableRequest implements Message.
var _ Message = ZwpTextInputV3EnableRequest{}

// Emit emits the message to the emitter.
func (r *ZwpTextInputV3EnableRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure ZwpTextInputV3EnableRequest implements Request.
var _ Request = &ZwpTextInputV3EnableRequest{}

// ZwpTextInputV3DisableRequest requests to Disable text input on a surface
//
// Explicitly disable text input on the current surface (typically when
// there is no focus on any text entry inside the surface).
//
// State set with this request is double-buffered. It will get applied on
// the next zwp_text_input_v3.commit request.
type ZwpTextInputV3DisableRequest struct {
}

// Opcode returns the request opcode for zwp_text_input_v3.disable in text_input_unstable_v3
func (ZwpTextInputV3DisableRequest) Opcode() uint16 { return 2 }

// MessageName returns the request name for zwp_text_input_v3.disable in text_input_unstable_v3
func (ZwpTextInputV3DisableRequest) MessageName() string { return "disable" }

// Ensure ZwpTextInputV3DisableRequest implements Message.
var _ Message = ZwpTextInputV3DisableRequest{}

// Emit emits the message to the emitter.
func (r *ZwpTextInputV3DisableRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure ZwpTextInputV3DisableRequest implements Request.
var _ Request = &ZwpTextInputV3DisableRequest{}

// ZwpTextInputV3SetSurroundingTextRequest requests to sets the surrounding text
//
// Sets the surrounding plain text around the input, excluding the preedit
// text.
//
// The client should notify the compositor of any changes in any of the
// values carried with this request, including changes caused by handling
// incoming text-input events as well as changes caused by other
// mechanisms like keyboard typing.
//
// If the client is unaware of the text around the cursor, it should not
// issue this request, to signify lack of support to the compositor.
//
// Text is UTF-8 encoded, and should include the cursor position, the
// complete selection and additional characters before and after them.
// There is a maximum length of wayland messages, so text can not be
// longer than 4000 bytes.
//
// Cursor is the byte offset of the cursor within text buffer.
//
// Anchor is the byte offset of the selection anchor within text buffer.
// If there is no selected text, anchor is the same as cursor.
//
// If any preedit text is present, it is replaced with a cursor for the
// purpose of this event.
//
// Values set with this request are double-buffered. They will get applied
// on the next zwp_text_input_v3.commit request, and stay valid until the
// next committed enable or disable request.
//
// The initial state for affected fields is empty, meaning that the text
// input does not support sending surrounding text. If the empty values
// get applied, subsequent attempts to change them may have no effect.
type ZwpTextInputV3SetSurroundingTextRequest struct {
	Text string

	Cursor int32

	Anchor int32
}

// Opcode returns the request opcode for zwp_text_input_v3.set_surrounding_text in text_input_unstable_v3
func (ZwpTextInputV3SetSurroundingTextRequest) Opcode() uint16 { return 3 }

// MessageName returns the request name for zwp_text_input_v3.set_surrounding_text in text_input_unstable_v3
func (ZwpTextInputV3SetSurroundingTextRequest) MessageName() string { return "set_surrounding_text" }

// Ensure ZwpTextInputV3SetSurroundingTextRequest implements Message.
var _ Message = ZwpTextInputV3SetSurroundingTextRequest{}

// Emit emits the message to the emitter.
func (r *ZwpTextInputV3SetSurroundingTextRequest) Emit(e *RequestEmitter) error {
	if err := e.PutString(r.Text); err != nil {
		return err
	}
	if err := e.PutInt(r.Cursor); err != nil {
		return err
	}
	if err := e.PutInt(r.Anchor); err != nil {
		return err
	}
	return nil
}

// Ensure ZwpTextInputV3SetSurroundingTextRequest implements Request.
var _ Request = &ZwpTextInputV3SetSurroundingTextRequest{}

// ZwpTextInputV3SetTextChangeCauseRequest requests to indicates the cause of surrounding text change
//
// Tells the compositor why the text surrounding the cursor changed.
//
// Whenever the client detects an external change in text, cursor, or
// anchor posision, it must issue this request to the compositor. This
// request is intended to give the input method a chance to update the
// preedit text in an appropriate way, e.g. by removing it when the user
// starts typing with a keyboard.
//
// cause describes the source of the change.
//
// The value set with this request is double-buffered. It must be applied
// and reset to initial at the next zwp_text_input_v3.commit request.
//
// The initial value of cause is input_method.
type ZwpTextInputV3SetTextChangeCauseRequest struct {
	Cause uint32
}

// Opcode returns the request opcode for zwp_text_input_v3.set_text_change_cause in text_input_unstable_v3
func (ZwpTextInputV3SetTextChangeCauseRequest) Opcode() uint16 { return 4 }

// MessageName returns the request name for zwp_text_input_v3.set_text_change_cause in text_input_unstable_v3
func (ZwpTextInputV3SetTextChangeCauseRequest) MessageName() string { return "set_text_change_cause" }

// Ensure ZwpTextInputV3SetTextChangeCauseRequest implements Message.
var _ Message = ZwpTextInputV3SetTextChangeCauseRequest{}

// Emit emits the message to the emitter.
func (r *ZwpTextInputV3SetTextChangeCauseRequest) Emit(e *RequestEmitter) error {
	if err := e.PutUint(r.Cause); err != nil {
		return err
	}
	return nil
}

// Ensure ZwpTextInputV3SetTextChangeCauseRequest implements Request.
var _ Request = &ZwpTextInputV3SetTextChangeCauseRequest{}

// ZwpTextInputV3SetContentTypeRequest requests to set content purpose and hint
//
// Sets the content purpose and content hint. While the purpose is the
// basic purpose of an input field, the hint flags allow to modify some of
// the behavior.
//
// Values set with this request are double-buffered. They will get applied
// on the next zwp_text_input_v3.commit request.
// Subsequent attempts to update them may have no effect. The values
// remain valid until the next committed enable or disable request.
//
// The initial value for hint is none, and the initial value for purpose
// is normal.
type ZwpTextInputV3SetContentTypeRequest struct {
	Hint uint32

	Purpose uint32
}

// Opcode returns the request opcode for zwp_text_input_v3.set_content_type in text_input_unstable_v3
func (ZwpTextInputV3SetContentTypeRequest) Opcode() uint16 { return 5 }

// MessageName returns the request name for zwp_text_input_v3.set_content_type in text_input_unstable_v3
func (ZwpTextInputV3SetContentTypeRequest) MessageName() string { return "set_content_type" }

// Ensure ZwpTextInputV3SetContentTypeRequest implements Message.
var _ Message = ZwpTextInputV3SetContentTypeRequest{}

// Emit emits the message to the emitter.
func (r *ZwpTextInputV3SetContentTypeRequest) Emit(e *RequestEmitter) error {
	if err := e.PutUint(r.Hint); err != nil {
		return err
	}
	if err := e.PutUint(r.Purpose); err != nil {
		return err
	}
	return nil
}

// Ensure ZwpTextInputV3SetContentTypeRequest implements Request.
var _ Request = &ZwpTextInputV3SetContentTypeRequest{}

// ZwpTextInputV3SetCursorRectangleRequest requests to set cursor position
//
// Marks an area around the cursor as a x, y, width, height rectangle in
// surface local coordinates.
//
// Allows the compositor to put a window with word suggestions near the
// cursor, without obstructing the text being input.
//
// If the client is unaware of the position of edited text, it should not
// issue this request, to signify lack of support to the compositor.
//
// Values set with this request are double-buffered. They will get applied
// on the next zwp_text_input_v3.commit request, and stay valid until the
// next committed enable or disable request.
//
// The initial values describing a cursor rectangle are empty. That means
// the text input does not support describing the cursor area. If the
// empty values get applied, subsequent attempts to change them may have
// no effect.
type ZwpTextInputV3SetCursorRectangleRequest struct {
	X int32

	Y int32

	Width int32

	Height int32
}

// Opcode returns the request opcode for zwp_text_input_v3.set_cursor_rectangle in text_input_unstable_v3
func (ZwpTextInputV3SetCursorRectangleRequest) Opcode() uint16 { return 6 }

// MessageName returns the request name for zwp_text_input_v3.set_cursor_rectangle in text_input_unstable_v3
func (ZwpTextInputV3SetCursorRectangleRequest) MessageName() string { return "set_cursor_rectangle" }

// Ensure ZwpTextInputV3SetCursorRectangleRequest implements Message.
var _ Message = ZwpTextInputV3SetCursorRectangleRequest{}

// Emit emits the message to the emitter.
func (r *ZwpTextInputV3SetCursorRectangleRequest) Emit(e *RequestEmitter) error {
	if err := e.PutInt(r.X); err != nil {
		return err
	}
	if err := e.PutInt(r.Y); err != nil {
		return err
	}
	if err := e.PutInt(r.Width); err != nil {
		return err
	}
	if err := e.PutInt(r.Height); err != nil {
		return err
	}
	return nil
}

// Ensure ZwpTextInputV3SetCursorRectangleRequest implements Request.
var _ Request = &ZwpTextInputV3SetCursorRectangleRequest{}

// ZwpTextInputV3CommitRequest requests to commit state
//
// Atomically applies state changes recently sent to the compositor.
//
// The commit request establishes and updates the state of the client, and
// must be issued after any changes to apply them.
//
// Text input state (enabled status, content purpose, content hint,
// surrounding text and change cause, cursor rectangle) is conceptually
// double-buffered within the context of a text input, i.e. between a
// committed enable request and the following committed enable or disable
// request.
//
// Protocol requests modify the pending state, as opposed to the current
// state in use by the input method. A commit request atomically applies
// all pending state, replacing the current state. After commit, the new
// pending state is as documented for each related request.
//
// Requests are applied in the order of arrival.
//
// Neither current nor pending state are modified unless noted otherwise.
//
// The compositor must count the number of commit requests coming from
// each zwp_text_input_v3 object and use the count as the serial in done
// events.
type ZwpTextInputV3CommitRequest struct {
}

// Opcode returns the request opcode for zwp_text_input_v3.commit in text_input_unstable_v3
func (ZwpTextInputV3CommitRequest) Opcode() uint16 { return 7 }

// MessageName returns the request name for zwp_text_input_v3.commit in text_input_unstable_v3
func (ZwpTextInputV3CommitRequest) MessageName() string { return "commit" }

// Ensure ZwpTextInputV3CommitRequest implements Message.
var _ Message = ZwpTextInputV3CommitRequest{}

// Emit emits the message to the emitter.
func (r *ZwpTextInputV3CommitRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure ZwpTextInputV3CommitRequest implements Request.
var _ Request = &ZwpTextInputV3CommitRequest{}

// ZwpTextInputV3EnterEvent signals when enter event
//
// Notification that this seat's text-input focus is on a certain surface.
//
// If client has created multiple text input objects, compositor must send
// this event to all of them.
//
// When the seat has the keyboard capability the text-input focus follows
// the keyboard focus. This event sets the current surface for the
// text-input object.
type ZwpTextInputV3EnterEvent struct {
	Surface ObjectID
}

// Opcode returns the event opcode for zwp_text_input_v3.enter in text_input_unstable_v3
func (ZwpTextInputV3EnterEvent) Opcode() uint16 { return 0 }

// MessageName returns the event name for zwp_text_input_v3.enter in text_input_unstable_v3
func (ZwpTextInputV3EnterEvent) MessageName() string { return "enter" }

// Ensure ZwpTextInputV3EnterEvent implements Message.
var _ Message = ZwpTextInputV3EnterEvent{}

// Scan scans the event from the socket.
func (e *ZwpTextInputV3EnterEvent) Scan(s *EventScanner) error {
	if v, err := s.ObjectID(); err != nil {
		return err
	} else {
		e.Surface = v
	}
	return nil
}

// Ensure ZwpTextInputV3EnterEvent implements Event.
var _ Event = &ZwpTextInputV3EnterEvent{}

// ZwpTextInputV3LeaveEvent signals when leave event
//
// Notification that this seat's text-input focus is no longer on a
// certain surface. The client should reset any preedit string previously
// set.
//
// The leave notification clears the current surface. It is sent before
// the enter notification for the new focus. After leave event, compositor
// must ignore requests from any text input instances until next enter
// event.
//
// When the seat has the keyboard capability the text-input focus follows
// the keyboard focus.
type ZwpTextInputV3LeaveEvent struct {
	Surface ObjectID
}

// Opcode returns the event opcode for zwp_text_input_v3.leave in text_input_unstable_v3
func (ZwpTextInputV3LeaveEvent) Opcode() uint16 { return 1 }

// MessageName returns the event name for zwp_text_input_v3.leave in text_input_unstable_v3
func (ZwpTextInputV3LeaveEvent) MessageName() string { return "leave" }

// Ensure ZwpTextInputV3LeaveEvent implements Message.
var _ Message = ZwpTextInputV3LeaveEvent{}

// Scan scans the event from the socket.
func (e *ZwpTextInputV3LeaveEvent) Scan(s *EventScanner) error {
	if v, err := s.ObjectID(); err != nil {
		return err
	} else {
		e.Surface = v
	}
	return nil
}

// Ensure ZwpTextInputV3LeaveEvent implements Event.
var _ Event = &ZwpTextInputV3LeaveEvent{}

// ZwpTextInputV3PreeditStringEvent signals when pre-edit
//
// Notify when a new composing text (pre-edit) should be set at the
// current cursor position. Any previously set composing text must be
// removed. Any previously existing selected text must be removed.
//
// The argument text contains the pre-edit string buffer.
//
// The parameters cursor_begin and cursor_end are counted in bytes
// relative to the beginning of the submitted text buffer. Cursor should
// be hidden when both are equal to -1.
//
// They could be represented by the client as a line if both values are
// the same, or as a text highlight otherwise.
//
// Values set with this event are double-buffered. They must be applied
// and reset to initial on the next zwp_text_input_v3.done event.
//
// The initial value of text is an empty string, and cursor_begin,
// cursor_end and cursor_hidden are all 0.
type ZwpTextInputV3PreeditStringEvent struct {
	Text string

	CursorBegin int32

	CursorEnd int32
}

// Opcode returns the event opcode for zwp_text_input_v3.preedit_string in text_input_unstable_v3
func (ZwpTextInputV3PreeditStringEvent) Opcode() uint16 { return 2 }

// MessageName returns the event name for zwp_text_input_v3.preedit_string in text_input_unstable_v3
func (ZwpTextInputV3PreeditStringEvent) MessageName() string { return "preedit_string" }

// Ensure ZwpTextInputV3PreeditStringEvent implements Message.
var _ Message = ZwpTextInputV3PreeditStringEvent{}

// Scan scans the event from the socket.
func (e *ZwpTextInputV3PreeditStringEvent) Scan(s *EventScanner) error {
	if v, err := s.String(); err != nil {
		return err
	} else {
		e.Text = v
	}
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.CursorBegin = v
	}
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.CursorEnd = v
	}
	return nil
}

// Ensure ZwpTextInputV3PreeditStringEvent implements Event.
var _ Event = &ZwpTextInputV3PreeditStringEvent{}

// ZwpTextInputV3CommitStringEvent signals when text commit
//
// Notify when text should be inserted into the editor widget. The text to
// commit could be either just a single character after a key press or the
// result of some composing (pre-edit).
//
// Values set with this event are double-buffered. They must be applied
// and reset to initial on the next zwp_text_input_v3.done event.
//
// The initial value of text is an empty string.
type ZwpTextInputV3CommitStringEvent struct {
	Text string
}

// Opcode returns the event opcode for zwp_text_input_v3.commit_string in text_input_unstable_v3
func (ZwpTextInputV3CommitStringEvent) Opcode() uint16 { return 3 }

// MessageName returns the event name for zwp_text_input_v3.commit_string in text_input_unstable_v3
func (ZwpTextInputV3CommitStringEvent) MessageName() string { return "commit_string" }

// Ensure ZwpTextInputV3CommitStringEvent implements Message.
var _ Message = ZwpTextInputV3CommitStringEvent{}

// Scan scans the event from the socket.
func (e *ZwpTextInputV3CommitStringEvent) Scan(s *EventScanner) error {
	if v, err := s.String(); err != nil {
		return err
	} else {
		e.Text = v
	}
	return nil
}

// Ensure ZwpTextInputV3CommitStringEvent implements Event.
var _ Event = &ZwpTextInputV3CommitStringEvent{}

// ZwpTextInputV3DeleteSurroundingTextEvent signals when delete surrounding text
//
// Notify when the text around the current cursor position should be
// deleted.
//
// Before_length and after_length are the number of bytes before and after
// the current cursor index (excluding the selection) to delete.
//
// If a preedit text is present, in effect before_length is counted from
// the beginning of it, and after_length from its end (see done event
// sequence).
//
// Values set with this event are double-buffered. They must be applied
// and reset to initial on the next zwp_text_input_v3.done event.
//
// The initial values of both before_length and after_length are 0.
type ZwpTextInputV3DeleteSurroundingTextEvent struct {
	// BeforeLength contains length of text before current cursor position
	BeforeLength uint32

	// AfterLength contains length of text after current cursor position
	AfterLength uint32
}

// Opcode returns the event opcode for zwp_text_input_v3.delete_surrounding_text in text_input_unstable_v3
func (ZwpTextInputV3DeleteSurroundingTextEvent) Opcode() uint16 { return 4 }

// MessageName returns the event name for zwp_text_input_v3.delete_surrounding_text in text_input_unstable_v3
func (ZwpTextInputV3DeleteSurroundingTextEvent) MessageName() string {
	return "delete_surrounding_text"
}

// Ensure ZwpTextInputV3DeleteSurroundingTextEvent implements Message.
var _ Message = ZwpTextInputV3DeleteSurroundingTextEvent{}

// Scan scans the event from the socket.
func (e *ZwpTextInputV3DeleteSurroundingTextEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.BeforeLength = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.AfterLength = v
	}
	return nil
}

// Ensure ZwpTextInputV3DeleteSurroundingTextEvent implements Event.
var _ Event = &ZwpTextInputV3DeleteSurroundingTextEvent{}

// ZwpTextInputV3DoneEvent signals when apply changes
//
// Instruct the application to apply changes to state requested by the
// preedit_string, commit_string and delete_surrounding_text events. The
// state relating to these events is double-buffered, and each one
// modifies the pending state. This event replaces the current state with
// the pending state.
//
// The application must proceed by evaluating the changes in the following
// order:
//
// 1. Replace existing preedit string with the cursor.
// 2. Delete requested surrounding text.
// 3. Insert commit string with the cursor at its end.
// 4. Calculate surrounding text to send.
// 5. Insert new preedit text in cursor position.
// 6. Place cursor inside preedit text.
//
// The serial number reflects the last state of the zwp_text_input_v3
// object known to the compositor. The value of the serial argument must
// be equal to the number of commit requests already issued on that object.
// When the client receives a done event with a serial different than the
// number of past commit requests, it must proceed as normal, except it
// should not change the current state of the zwp_text_input_v3 object.
type ZwpTextInputV3DoneEvent struct {
	Serial uint32
}

// Opcode returns the event opcode for zwp_text_input_v3.done in text_input_unstable_v3
func (ZwpTextInputV3DoneEvent) Opcode() uint16 { return 5 }

// MessageName returns the event name for zwp_text_input_v3.done in text_input_unstable_v3
func (ZwpTextInputV3DoneEvent) MessageName() string { return "done" }

// Ensure ZwpTextInputV3DoneEvent implements Message.
var _ Message = ZwpTextInputV3DoneEvent{}

// Scan scans the event from the socket.
func (e *ZwpTextInputV3DoneEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Serial = v
	}
	return nil
}

// Ensure ZwpTextInputV3DoneEvent implements Event.
var _ Event = &ZwpTextInputV3DoneEvent{}

// ZwpTextInputV3 text input
//
// The zwp_text_input_v3 interface represents text input and input methods
// associated with a seat. It provides enter/leave events to follow the
// text input focus for a seat.
//
// Requests are used to enable/disable the text-input object and set
// state information like surrounding and selected text or the content type.
// The information about the entered text is sent to the text-input object
// via the preedit_string and commit_string events.
//
// Text is valid UTF-8 encoded, indices and lengths are in bytes. Indices
// must not point to middle bytes inside a code point: they must either
// point to the first byte of a code point or to the end of the buffer.
// Lengths must be measured between two valid indices.
//
// Focus moving throughout surfaces will result in the emission of
// zwp_text_input_v3.enter and zwp_text_input_v3.leave events. The focused
// surface must commit zwp_text_input_v3.enable and
// zwp_text_input_v3.disable requests as the keyboard focus moves across
// editable and non-editable elements of the UI. Those two requests are not
// expected to be paired with each other, the compositor must be able to
// handle consecutive series of the same request.
//
// State is sent by the state requests (set_surrounding_text,
// set_content_type and set_cursor_rectangle) and a commit request. After an
// enter event or disable request all state information is invalidated and
// needs to be resent by the client.
type ZwpTextInputV3 struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *ZwpTextInputV3) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (ZwpTextInputV3) Descriptor() *InterfaceDescriptor {
	return &ZwpTextInputV3Descriptor
}

// Dispatch returns an Event object for a given opcode.
func (ZwpTextInputV3) Dispatch(opcode uint16) Event {
	switch opcode {
	case 0:
		return &ZwpTextInputV3EnterEvent{}
	case 1:
		return &ZwpTextInputV3LeaveEvent{}
	case 2:
		return &ZwpTextInputV3PreeditStringEvent{}
	case 3:
		return &ZwpTextInputV3CommitStringEvent{}
	case 4:
		return &ZwpTextInputV3DeleteSurroundingTextEvent{}
	case 5:
		return &ZwpTextInputV3DoneEvent{}
	default:
		return nil
	}
}

// Destroy requests to Destroy the wp_text_input
//
// Destroy the wp_text_input object. Also disables all surfaces enabled
// through this wp_text_input object.
func (proxy *ZwpTextInputV3) Destroy(connection Connection) (err error) {
	request := ZwpTextInputV3DestroyRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Enable requests to Request text input to be enabled
//
// Requests text input on the surface previously obtained from the enter
// event.
//
// This request must be issued every time the active text input changes
// to a new one, including within the current surface. Use
// zwp_text_input_v3.disable when there is no longer any input focus on
// the current surface.
//
// Clients must not enable more than one text input on the single seat
// and should disable the current text input before enabling the new one.
// At most one instance of text input may be in enabled state per instance,
// Requests to enable the another text input when some text input is active
// must be ignored by compositor.
//
// This request resets all state associated with previous enable, disable,
// set_surrounding_text, set_text_change_cause, set_content_type, and
// set_cursor_rectangle requests, as well as the state associated with
// preedit_string, commit_string, and delete_surrounding_text events.
//
// The set_surrounding_text, set_content_type and set_cursor_rectangle
// requests must follow if the text input supports the necessary
// functionality.
//
// State set with this request is double-buffered. It will get applied on
// the next zwp_text_input_v3.commit request, and stay valid until the
// next committed enable or disable request.
//
// The changes must be applied by the compositor after issuing a
// zwp_text_input_v3.commit request.
func (proxy *ZwpTextInputV3) Enable(connection Connection) (err error) {
	request := ZwpTextInputV3EnableRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Disable requests to Disable text input on a surface
//
// Explicitly disable text input on the current surface (typically when
// there is no focus on any text entry inside the surface).
//
// State set with this request is double-buffered. It will get applied on
// the next zwp_text_input_v3.commit request.
func (proxy *ZwpTextInputV3) Disable(connection Connection) (err error) {
	request := ZwpTextInputV3DisableRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// SetSurroundingText requests to sets the surrounding text
//
// Sets the surrounding plain text around the input, excluding the preedit
// text.
//
// The client should notify the compositor of any changes in any of the
// values carried with this request, including changes caused by handling
// incoming text-input events as well as changes caused by other
// mechanisms like keyboard typing.
//
// If the client is unaware of the text around the cursor, it should not
// issue this request, to signify lack of support to the compositor.
//
// Text is UTF-8 encoded, and should include the cursor position, the
// complete selection and additional characters before and after them.
// There is a maximum length of wayland messages, so text can not be
// longer than 4000 bytes.
//
// Cursor is the byte offset of the cursor within text buffer.
//
// Anchor is the byte offset of the selection anchor within text buffer.
// If there is no selected text, anchor is the same as cursor.
//
// If any preedit text is present, it is replaced with a cursor for the
// purpose of this event.
//
// Values set with this request are double-buffered. They will get applied
// on the next zwp_text_input_v3.commit request, and stay valid until the
// next committed enable or disable request.
//
// The initial state for affected fields is empty, meaning that the text
// input does not support sending surrounding text. If the empty values
// get applied, subsequent attempts to change them may have no effect.
func (proxy *ZwpTextInputV3) SetSurroundingText(connection Connection, aText string, aCursor int32, aAnchor int32) (err error) {
	request := ZwpTextInputV3SetSurroundingTextRequest{
		Text:   aText,
		Cursor: aCursor,
		Anchor: aAnchor,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// SetTextChangeCause requests to indicates the cause of surrounding text change
//
// Tells the compositor why the text surrounding the cursor changed.
//
// Whenever the client detects an external change in text, cursor, or
// anchor posision, it must issue this request to the compositor. This
// request is intended to give the input method a chance to update the
// preedit text in an appropriate way, e.g. by removing it when the user
// starts typing with a keyboard.
//
// cause describes the source of the change.
//
// The value set with this request is double-buffered. It must be applied
// and reset to initial at the next zwp_text_input_v3.commit request.
//
// The initial value of cause is input_method.
func (proxy *ZwpTextInputV3) SetTextChangeCause(connection Connection, aCause uint32) (err error) {
	request := ZwpTextInputV3SetTextChangeCauseRequest{
		Cause: aCause,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// SetContentType requests to set content purpose and hint
//
// Sets the content purpose and content hint. While the purpose is the
// basic purpose of an input field, the hint flags allow to modify some of
// the behavior.
//
// Values set with this request are double-buffered. They will get applied
// on the next zwp_text_input_v3.commit request.
// Subsequent attempts to update them may have no effect. The values
// remain valid until the next committed enable or disable request.
//
// The initial value for hint is none, and the initial value for purpose
// is normal.
func (proxy *ZwpTextInputV3) SetContentType(connection Connection, aHint uint32, aPurpose uint32) (err error) {
	request := ZwpTextInputV3SetContentTypeRequest{
		Hint:    aHint,
		Purpose: aPurpose,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// SetCursorRectangle requests to set cursor position
//
// Marks an area around the cursor as a x, y, width, height rectangle in
// surface local coordinates.
//
// Allows the compositor to put a window with word suggestions near the
// cursor, without obstructing the text being input.
//
// If the client is unaware of the position of edited text, it should not
// issue this request, to signify lack of support to the compositor.
//
// Values set with this request are double-buffered. They will get applied
// on the next zwp_text_input_v3.commit request, and stay valid until the
// next committed enable or disable request.
//
// The initial values describing a cursor rectangle are empty. That means
// the text input does not support describing the cursor area. If the
// empty values get applied, subsequent attempts to change them may have
// no effect.
func (proxy *ZwpTextInputV3) SetCursorRectangle(connection Connection, aX int32, aY int32, aWidth int32, aHeight int32) (err error) {
	request := ZwpTextInputV3SetCursorRectangleRequest{
		X:      aX,
		Y:      aY,
		Width:  aWidth,
		Height: aHeight,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Commit requests to commit state
//
// Atomically applies state changes recently sent to the compositor.
//
// The commit request establishes and updates the state of the client, and
// must be issued after any changes to apply them.
//
// Text input state (enabled status, content purpose, content hint,
// surrounding text and change cause, cursor rectangle) is conceptually
// double-buffered within the context of a text input, i.e. between a
// committed enable request and the following committed enable or disable
// request.
//
// Protocol requests modify the pending state, as opposed to the current
// state in use by the input method. A commit request atomically applies
// all pending state, replacing the current state. After commit, the new
// pending state is as documented for each related request.
//
// Requests are applied in the order of arrival.
//
// Neither current nor pending state are modified unless noted otherwise.
//
// The compositor must count the number of commit requests coming from
// each zwp_text_input_v3 object and use the count as the serial in done
// events.
func (proxy *ZwpTextInputV3) Commit(connection Connection) (err error) {
	request := ZwpTextInputV3CommitRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Ensure ZwpTextInputV3 implements Proxy.
var _ Proxy = &ZwpTextInputV3{}

// #endregion Interface text_input_unstable_v3.zwp_text_input_v3

// ----------------------------------------------------------------------------
// #region Interface text_input_unstable_v3.zwp_text_input_manager_v3

// ZwpTextInputManagerV3DestroyRequest requests to Destroy the wp_text_input_manager
//
// Destroy the wp_text_input_manager object.
type ZwpTextInputManagerV3DestroyRequest struct {
}

// Opcode returns the request opcode for zwp_text_input_manager_v3.destroy in text_input_unstable_v3
func (ZwpTextInputManagerV3DestroyRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for zwp_text_input_manager_v3.destroy in text_input_unstable_v3
func (ZwpTextInputManagerV3DestroyRequest) MessageName() string { return "destroy" }

// Ensure ZwpTextInputManagerV3DestroyRequest implements Message.
var _ Message = ZwpTextInputManagerV3DestroyRequest{}

// Emit emits the message to the emitter.
func (r *ZwpTextInputManagerV3DestroyRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure ZwpTextInputManagerV3DestroyRequest implements Request.
var _ Request = &ZwpTextInputManagerV3DestroyRequest{}

// ZwpTextInputManagerV3GetTextInputRequest requests to create a new text input object
//
// Creates a new text-input object for a given seat.
type ZwpTextInputManagerV3GetTextInputRequest struct {
	ID ObjectID

	Seat ObjectID
}

// Opcode returns the request opcode for zwp_text_input_manager_v3.get_text_input in text_input_unstable_v3
func (ZwpTextInputManagerV3GetTextInputRequest) Opcode() uint16 { return 1 }

// MessageName returns the request name for zwp_text_input_manager_v3.get_text_input in text_input_unstable_v3
func (ZwpTextInputManagerV3GetTextInputRequest) MessageName() string { return "get_text_input" }

// Ensure ZwpTextInputManagerV3GetTextInputRequest implements Message.
var _ Message = ZwpTextInputManagerV3GetTextInputRequest{}

// Emit emits the message to the emitter.
func (r *ZwpTextInputManagerV3GetTextInputRequest) Emit(e *RequestEmitter) error {
	if err := e.PutObjectID(r.ID); err != nil {
		return err
	}
	if err := e.PutObjectID(r.Seat); err != nil {
		return err
	}
	return nil
}

// Ensure ZwpTextInputManagerV3GetTextInputRequest implements Request.
var _ Request = &ZwpTextInputManagerV3GetTextInputRequest{}

// ZwpTextInputManagerV3 text input manager
//
// A factory for text-input objects. This object is a global singleton.
type ZwpTextInputManagerV3 struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *ZwpTextInputManagerV3) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (ZwpTextInputManagerV3) Descriptor() *InterfaceDescriptor {
	return &ZwpTextInputManagerV3Descriptor
}

// Dispatch returns an Event object for a given opcode.
func (ZwpTextInputManagerV3) Dispatch(opcode uint16) Event {
	switch opcode {
	default:
		return nil
	}
}

// Destroy requests to Destroy the wp_text_input_manager
//
// Destroy the wp_text_input_manager object.
func (proxy *ZwpTextInputManagerV3) Destroy(connection Connection) (err error) {
	request := ZwpTextInputManagerV3DestroyRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// GetTextInput requests to create a new text input object
//
// Creates a new text-input object for a given seat.
func (proxy *ZwpTextInputManagerV3) GetTextInput(connection Connection, aSeat ObjectID) (aID *ZwpTextInputV3, err error) {
	aID = &ZwpTextInputV3{connection.NewID()}
	request := ZwpTextInputManagerV3GetTextInputRequest{
		ID:   aID.id,
		Seat: aSeat,
	}
	err = connection.SendRequest(proxy.id, &request)
	if err == nil {
		connection.RegisterProxy(aID)
	}
	return
}

// Ensure ZwpTextInputManagerV3 implements Proxy.
var _ Proxy = &ZwpTextInputManagerV3{}

// #endregion Interface text_input_unstable_v3.zwp_text_input_manager_v3

////////////////////////////////////////////////////////////////////////////////
// #endregion Protocol text_input_unstable_v3

////////////////////////////////////////////////////////////////////////////////
// #region Protocol viewporter

// ----------------------------------------------------------------------------
// #region Interface viewporter.wp_viewporter

type WpViewporterError int

const (
	// WpViewporterErrorViewportExists corresponds to the surface already has a viewport object associated
	WpViewporterErrorViewportExists WpViewporterError = 0
)

// WpViewporterDestroyRequest requests to unbind from the cropping and scaling interface
//
// Informs the server that the client will not be using this
// protocol object anymore. This does not affect any other objects,
// wp_viewport objects included.
type WpViewporterDestroyRequest struct {
}

// Opcode returns the request opcode for wp_viewporter.destroy in viewporter
func (WpViewporterDestroyRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for wp_viewporter.destroy in viewporter
func (WpViewporterDestroyRequest) MessageName() string { return "destroy" }

// Ensure WpViewporterDestroyRequest implements Message.
var _ Message = WpViewporterDestroyRequest{}

// Emit emits the message to the emitter.
func (r *WpViewporterDestroyRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure WpViewporterDestroyRequest implements Request.
var _ Request = &WpViewporterDestroyRequest{}

// WpViewporterGetViewportRequest requests to extend surface interface for crop and scale
//
// Instantiate an interface extension for the given wl_surface to
// crop and scale its content. If the given wl_surface already has
// a wp_viewport object associated, the viewport_exists
// protocol error is raised.
type WpViewporterGetViewportRequest struct {
	// ID contains the new viewport interface id
	ID ObjectID

	// Surface contains the surface
	Surface ObjectID
}

// Opcode returns the request opcode for wp_viewporter.get_viewport in viewporter
func (WpViewporterGetViewportRequest) Opcode() uint16 { return 1 }

// MessageName returns the request name for wp_viewporter.get_viewport in viewporter
func (WpViewporterGetViewportRequest) MessageName() string { return "get_viewport" }

// Ensure WpViewporterGetViewportRequest implements Message.
var _ Message = WpViewporterGetViewportRequest{}

// Emit emits the message to the emitter.
func (r *WpViewporterGetViewportRequest) Emit(e *RequestEmitter) error {
	if err := e.PutObjectID(r.ID); err != nil {
		return err
	}
	if err := e.PutObjectID(r.Surface); err != nil {
		return err
	}
	return nil
}

// Ensure WpViewporterGetViewportRequest implements Request.
var _ Request = &WpViewporterGetViewportRequest{}

// WpViewporter surface cropping and scaling
//
// The global interface exposing surface cropping and scaling
// capabilities is used to instantiate an interface extension for a
// wl_surface object. This extended interface will then allow
// cropping and scaling the surface contents, effectively
// disconnecting the direct relationship between the buffer and the
// surface size.
type WpViewporter struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *WpViewporter) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (WpViewporter) Descriptor() *InterfaceDescriptor {
	return &WpViewporterDescriptor
}

// Dispatch returns an Event object for a given opcode.
func (WpViewporter) Dispatch(opcode uint16) Event {
	switch opcode {
	default:
		return nil
	}
}

// Destroy requests to unbind from the cropping and scaling interface
//
// Informs the server that the client will not be using this
// protocol object anymore. This does not affect any other objects,
// wp_viewport objects included.
func (proxy *WpViewporter) Destroy(connection Connection) (err error) {
	request := WpViewporterDestroyRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// GetViewport requests to extend surface interface for crop and scale
//
// Instantiate an interface extension for the given wl_surface to
// crop and scale its content. If the given wl_surface already has
// a wp_viewport object associated, the viewport_exists
// protocol error is raised.
func (proxy *WpViewporter) GetViewport(connection Connection, aSurface ObjectID) (aID *WpViewport, err error) {
	aID = &WpViewport{connection.NewID()}
	request := WpViewporterGetViewportRequest{
		ID:      aID.id,
		Surface: aSurface,
	}
	err = connection.SendRequest(proxy.id, &request)
	if err == nil {
		connection.RegisterProxy(aID)
	}
	return
}

// Ensure WpViewporter implements Proxy.
var _ Proxy = &WpViewporter{}

// #endregion Interface viewporter.wp_viewporter

// ----------------------------------------------------------------------------
// #region Interface viewporter.wp_viewport

type WpViewportError int

const (
	// WpViewportErrorBadValue corresponds to negative or zero values in width or height
	WpViewportErrorBadValue WpViewportError = 0

	// WpViewportErrorBadSize corresponds to destination size is not integer
	WpViewportErrorBadSize WpViewportError = 1

	// WpViewportErrorOutOfBuffer corresponds to source rectangle extends outside of the content area
	WpViewportErrorOutOfBuffer WpViewportError = 2

	// WpViewportErrorNoSurface corresponds to the wl_surface was destroyed
	WpViewportErrorNoSurface WpViewportError = 3
)

// WpViewportDestroyRequest requests to remove scaling and cropping from the surface
//
// The associated wl_surface's crop and scale state is removed.
// The change is applied on the next wl_surface.commit.
type WpViewportDestroyRequest struct {
}

// Opcode returns the request opcode for wp_viewport.destroy in viewporter
func (WpViewportDestroyRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for wp_viewport.destroy in viewporter
func (WpViewportDestroyRequest) MessageName() string { return "destroy" }

// Ensure WpViewportDestroyRequest implements Message.
var _ Message = WpViewportDestroyRequest{}

// Emit emits the message to the emitter.
func (r *WpViewportDestroyRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure WpViewportDestroyRequest implements Request.
var _ Request = &WpViewportDestroyRequest{}

// WpViewportSetSourceRequest requests to set the source rectangle for cropping
//
// Set the source rectangle of the associated wl_surface. See
// wp_viewport for the description, and relation to the wl_buffer
// size.
//
// If all of x, y, width and height are -1.0, the source rectangle is
// unset instead. Any other set of values where width or height are zero
// or negative, or x or y are negative, raise the bad_value protocol
// error.
//
// The crop and scale state is double-buffered state, and will be
// applied on the next wl_surface.commit.
type WpViewportSetSourceRequest struct {
	// X contains source rectangle x
	X Fixed

	// Y contains source rectangle y
	Y Fixed

	// Width contains source rectangle width
	Width Fixed

	// Height contains source rectangle height
	Height Fixed
}

// Opcode returns the request opcode for wp_viewport.set_source in viewporter
func (WpViewportSetSourceRequest) Opcode() uint16 { return 1 }

// MessageName returns the request name for wp_viewport.set_source in viewporter
func (WpViewportSetSourceRequest) MessageName() string { return "set_source" }

// Ensure WpViewportSetSourceRequest implements Message.
var _ Message = WpViewportSetSourceRequest{}

// Emit emits the message to the emitter.
func (r *WpViewportSetSourceRequest) Emit(e *RequestEmitter) error {
	if err := e.PutFixed(r.X); err != nil {
		return err
	}
	if err := e.PutFixed(r.Y); err != nil {
		return err
	}
	if err := e.PutFixed(r.Width); err != nil {
		return err
	}
	if err := e.PutFixed(r.Height); err != nil {
		return err
	}
	return nil
}

// Ensure WpViewportSetSourceRequest implements Request.
var _ Request = &WpViewportSetSourceRequest{}

// WpViewportSetDestinationRequest requests to set the surface size for scaling
//
// Set the destination size of the associated wl_surface. See
// wp_viewport for the description, and relation to the wl_buffer
// size.
//
// If width is -1 and height is -1, the destination size is unset
// instead. Any other pair of values for width and height that
// contains zero or negative values raises the bad_value protocol
// error.
//
// The crop and scale state is double-buffered state, and will be
// applied on the next wl_surface.commit.
type WpViewportSetDestinationRequest struct {
	// Width contains surface width
	Width int32

	// Height contains surface height
	Height int32
}

// Opcode returns the request opcode for wp_viewport.set_destination in viewporter
func (WpViewportSetDestinationRequest) Opcode() uint16 { return 2 }

// MessageName returns the request name for wp_viewport.set_destination in viewporter
func (WpViewportSetDestinationRequest) MessageName() string { return "set_destination" }

// Ensure WpViewportSetDestinationRequest implements Message.
var _ Message = WpViewportSetDestinationRequest{}

// Emit emits the message to the emitter.
func (r *WpViewportSetDestinationRequest) Emit(e *RequestEmitter) error {
	if err := e.PutInt(r.Width); err != nil {
		return err
	}
	if err := e.PutInt(r.Height); err != nil {
		return err
	}
	return nil
}

// Ensure WpViewportSetDestinationRequest implements Request.
var _ Request = &WpViewportSetDestinationRequest{}

// WpViewport crop and scale interface to a wl_surface
//
// An additional interface to a wl_surface object, which allows the
// client to specify the cropping and scaling of the surface
// contents.
//
// This interface works with two concepts: the source rectangle (src_x,
// src_y, src_width, src_height), and the destination size (dst_width,
// dst_height). The contents of the source rectangle are scaled to the
// destination size, and content outside the source rectangle is ignored.
// This state is double-buffered, and is applied on the next
// wl_surface.commit.
//
// The two parts of crop and scale state are independent: the source
// rectangle, and the destination size. Initially both are unset, that
// is, no scaling is applied. The whole of the current wl_buffer is
// used as the source, and the surface size is as defined in
// wl_surface.attach.
//
// If the destination size is set, it causes the surface size to become
// dst_width, dst_height. The source (rectangle) is scaled to exactly
// this size. This overrides whatever the attached wl_buffer size is,
// unless the wl_buffer is NULL. If the wl_buffer is NULL, the surface
// has no content and therefore no size. Otherwise, the size is always
// at least 1x1 in surface local coordinates.
//
// If the source rectangle is set, it defines what area of the wl_buffer is
// taken as the source. If the source rectangle is set and the destination
// size is not set, then src_width and src_height must be integers, and the
// surface size becomes the source rectangle size. This results in cropping
// without scaling. If src_width or src_height are not integers and
// destination size is not set, the bad_size protocol error is raised when
// the surface state is applied.
//
// The coordinate transformations from buffer pixel coordinates up to
// the surface-local coordinates happen in the following order:
// 1. buffer_transform (wl_surface.set_buffer_transform)
// 2. buffer_scale (wl_surface.set_buffer_scale)
// 3. crop and scale (wp_viewport.set*)
// This means, that the source rectangle coordinates of crop and scale
// are given in the coordinates after the buffer transform and scale,
// i.e. in the coordinates that would be the surface-local coordinates
// if the crop and scale was not applied.
//
// If src_x or src_y are negative, the bad_value protocol error is raised.
// Otherwise, if the source rectangle is partially or completely outside of
// the non-NULL wl_buffer, then the out_of_buffer protocol error is raised
// when the surface state is applied. A NULL wl_buffer does not raise the
// out_of_buffer error.
//
// The x, y arguments of wl_surface.attach are applied as normal to
// the surface. They indicate how many pixels to remove from the
// surface size from the left and the top. In other words, they are
// still in the surface-local coordinate system, just like dst_width
// and dst_height are.
//
// If the wl_surface associated with the wp_viewport is destroyed,
// all wp_viewport requests except 'destroy' raise the protocol error
// no_surface.
//
// If the wp_viewport object is destroyed, the crop and scale
// state is removed from the wl_surface. The change will be applied
// on the next wl_surface.commit.
type WpViewport struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *WpViewport) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (WpViewport) Descriptor() *InterfaceDescriptor {
	return &WpViewportDescriptor
}

// Dispatch returns an Event object for a given opcode.
func (WpViewport) Dispatch(opcode uint16) Event {
	switch opcode {
	default:
		return nil
	}
}

// Destroy requests to remove scaling and cropping from the surface
//
// The associated wl_surface's crop and scale state is removed.
// The change is applied on the next wl_surface.commit.
func (proxy *WpViewport) Destroy(connection Connection) (err error) {
	request := WpViewportDestroyRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// SetSource requests to set the source rectangle for cropping
//
// Set the source rectangle of the associated wl_surface. See
// wp_viewport for the description, and relation to the wl_buffer
// size.
//
// If all of x, y, width and height are -1.0, the source rectangle is
// unset instead. Any other set of values where width or height are zero
// or negative, or x or y are negative, raise the bad_value protocol
// error.
//
// The crop and scale state is double-buffered state, and will be
// applied on the next wl_surface.commit.
func (proxy *WpViewport) SetSource(connection Connection, aX Fixed, aY Fixed, aWidth Fixed, aHeight Fixed) (err error) {
	request := WpViewportSetSourceRequest{
		X:      aX,
		Y:      aY,
		Width:  aWidth,
		Height: aHeight,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// SetDestination requests to set the surface size for scaling
//
// Set the destination size of the associated wl_surface. See
// wp_viewport for the description, and relation to the wl_buffer
// size.
//
// If width is -1 and height is -1, the destination size is unset
// instead. Any other pair of values for width and height that
// contains zero or negative values raises the bad_value protocol
// error.
//
// The crop and scale state is double-buffered state, and will be
// applied on the next wl_surface.commit.
func (proxy *WpViewport) SetDestination(connection Connection, aWidth int32, aHeight int32) (err error) {
	request := WpViewportSetDestinationRequest{
		Width:  aWidth,
		Height: aHeight,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Ensure WpViewport implements Proxy.
var _ Proxy = &WpViewport{}

// #endregion Interface viewporter.wp_viewport

////////////////////////////////////////////////////////////////////////////////
// #endregion Protocol viewporter

////////////////////////////////////////////////////////////////////////////////
// #region Protocol wayland

// ----------------------------------------------------------------------------
// #region Interface wayland.wl_display

// WlDisplayError represents global error values
//
// These errors are global and can be emitted in response to any
// server request.
type WlDisplayError int

const (
	// WlDisplayErrorInvalidObject corresponds to server couldn't find object
	WlDisplayErrorInvalidObject WlDisplayError = 0

	// WlDisplayErrorInvalidMethod corresponds to method doesn't exist on the specified interface or malformed request
	WlDisplayErrorInvalidMethod WlDisplayError = 1

	// WlDisplayErrorNoMemory corresponds to server is out of memory
	WlDisplayErrorNoMemory WlDisplayError = 2

	// WlDisplayErrorImplementation corresponds to implementation error in compositor
	WlDisplayErrorImplementation WlDisplayError = 3
)

// WlDisplaySyncRequest requests to asynchronous roundtrip
//
// The sync request asks the server to emit the 'done' event
// on the returned wl_callback object.  Since requests are
// handled in-order and events are delivered in-order, this can
// be used as a barrier to ensure all previous requests and the
// resulting events have been handled.
//
// The object returned by this request will be destroyed by the
// compositor after the callback is fired and as such the client must not
// attempt to use it after that point.
//
// The callback_data passed in the callback is the event serial.
type WlDisplaySyncRequest struct {
	// Callback contains callback object for the sync request
	Callback ObjectID
}

// Opcode returns the request opcode for wl_display.sync in wayland
func (WlDisplaySyncRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for wl_display.sync in wayland
func (WlDisplaySyncRequest) MessageName() string { return "sync" }

// Ensure WlDisplaySyncRequest implements Message.
var _ Message = WlDisplaySyncRequest{}

// Emit emits the message to the emitter.
func (r *WlDisplaySyncRequest) Emit(e *RequestEmitter) error {
	if err := e.PutObjectID(r.Callback); err != nil {
		return err
	}
	return nil
}

// Ensure WlDisplaySyncRequest implements Request.
var _ Request = &WlDisplaySyncRequest{}

// WlDisplayGetRegistryRequest requests to get global registry object
//
// This request creates a registry object that allows the client
// to list and bind the global objects available from the
// compositor.
//
// It should be noted that the server side resources consumed in
// response to a get_registry request can only be released when the
// client disconnects, not when the client side proxy is destroyed.
// Therefore, clients should invoke get_registry as infrequently as
// possible to avoid wasting memory.
type WlDisplayGetRegistryRequest struct {
	// Registry contains global registry object
	Registry ObjectID
}

// Opcode returns the request opcode for wl_display.get_registry in wayland
func (WlDisplayGetRegistryRequest) Opcode() uint16 { return 1 }

// MessageName returns the request name for wl_display.get_registry in wayland
func (WlDisplayGetRegistryRequest) MessageName() string { return "get_registry" }

// Ensure WlDisplayGetRegistryRequest implements Message.
var _ Message = WlDisplayGetRegistryRequest{}

// Emit emits the message to the emitter.
func (r *WlDisplayGetRegistryRequest) Emit(e *RequestEmitter) error {
	if err := e.PutObjectID(r.Registry); err != nil {
		return err
	}
	return nil
}

// Ensure WlDisplayGetRegistryRequest implements Request.
var _ Request = &WlDisplayGetRegistryRequest{}

// WlDisplayErrorEvent signals when fatal error event
//
// The error event is sent out when a fatal (non-recoverable)
// error has occurred.  The object_id argument is the object
// where the error occurred, most often in response to a request
// to that object.  The code identifies the error and is defined
// by the object interface.  As such, each interface defines its
// own set of error codes.  The message is a brief description
// of the error, for (debugging) convenience.
type WlDisplayErrorEvent struct {
	// ObjectID contains object where the error occurred
	ObjectID ObjectID

	// Code contains error code
	Code uint32

	// Message contains error description
	Message string
}

// Opcode returns the event opcode for wl_display.error in wayland
func (WlDisplayErrorEvent) Opcode() uint16 { return 0 }

// MessageName returns the event name for wl_display.error in wayland
func (WlDisplayErrorEvent) MessageName() string { return "error" }

// Ensure WlDisplayErrorEvent implements Message.
var _ Message = WlDisplayErrorEvent{}

// Scan scans the event from the socket.
func (e *WlDisplayErrorEvent) Scan(s *EventScanner) error {
	if v, err := s.ObjectID(); err != nil {
		return err
	} else {
		e.ObjectID = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Code = v
	}
	if v, err := s.String(); err != nil {
		return err
	} else {
		e.Message = v
	}
	return nil
}

// Ensure WlDisplayErrorEvent implements Event.
var _ Event = &WlDisplayErrorEvent{}

// WlDisplayDeleteIDEvent signals when acknowledge object ID deletion
//
// This event is used internally by the object ID management
// logic. When a client deletes an object that it had created,
// the server will send this event to acknowledge that it has
// seen the delete request. When the client receives this event,
// it will know that it can safely reuse the object ID.
type WlDisplayDeleteIDEvent struct {
	// ID contains deleted object ID
	ID uint32
}

// Opcode returns the event opcode for wl_display.delete_id in wayland
func (WlDisplayDeleteIDEvent) Opcode() uint16 { return 1 }

// MessageName returns the event name for wl_display.delete_id in wayland
func (WlDisplayDeleteIDEvent) MessageName() string { return "delete_id" }

// Ensure WlDisplayDeleteIDEvent implements Message.
var _ Message = WlDisplayDeleteIDEvent{}

// Scan scans the event from the socket.
func (e *WlDisplayDeleteIDEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.ID = v
	}
	return nil
}

// Ensure WlDisplayDeleteIDEvent implements Event.
var _ Event = &WlDisplayDeleteIDEvent{}

// WlDisplay core global object
//
// The core global object.  This is a special singleton object.  It
// is used for internal Wayland protocol features.
type WlDisplay struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *WlDisplay) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (WlDisplay) Descriptor() *InterfaceDescriptor {
	return &WlDisplayDescriptor
}

// Dispatch returns an Event object for a given opcode.
func (WlDisplay) Dispatch(opcode uint16) Event {
	switch opcode {
	case 0:
		return &WlDisplayErrorEvent{}
	case 1:
		return &WlDisplayDeleteIDEvent{}
	default:
		return nil
	}
}

// Sync requests to asynchronous roundtrip
//
// The sync request asks the server to emit the 'done' event
// on the returned wl_callback object.  Since requests are
// handled in-order and events are delivered in-order, this can
// be used as a barrier to ensure all previous requests and the
// resulting events have been handled.
//
// The object returned by this request will be destroyed by the
// compositor after the callback is fired and as such the client must not
// attempt to use it after that point.
//
// The callback_data passed in the callback is the event serial.
func (proxy *WlDisplay) Sync(connection Connection) (aCallback *WlCallback, err error) {
	aCallback = &WlCallback{connection.NewID()}
	request := WlDisplaySyncRequest{
		Callback: aCallback.id,
	}
	err = connection.SendRequest(proxy.id, &request)
	if err == nil {
		connection.RegisterProxy(aCallback)
	}
	return
}

// GetRegistry requests to get global registry object
//
// This request creates a registry object that allows the client
// to list and bind the global objects available from the
// compositor.
//
// It should be noted that the server side resources consumed in
// response to a get_registry request can only be released when the
// client disconnects, not when the client side proxy is destroyed.
// Therefore, clients should invoke get_registry as infrequently as
// possible to avoid wasting memory.
func (proxy *WlDisplay) GetRegistry(connection Connection) (aRegistry *WlRegistry, err error) {
	aRegistry = &WlRegistry{connection.NewID()}
	request := WlDisplayGetRegistryRequest{
		Registry: aRegistry.id,
	}
	err = connection.SendRequest(proxy.id, &request)
	if err == nil {
		connection.RegisterProxy(aRegistry)
	}
	return
}

// Ensure WlDisplay implements Proxy.
var _ Proxy = &WlDisplay{}

// #endregion Interface wayland.wl_display

// ----------------------------------------------------------------------------
// #region Interface wayland.wl_registry

// WlRegistryBindRequest requests to bind an object to the display
//
// Binds a new, client-created object to the server using the
// specified name as the identifier.
type WlRegistryBindRequest struct {
	// Name contains unique numeric name of the object
	Name uint32

	// ID contains bounded object
	ID ObjectID
}

// Opcode returns the request opcode for wl_registry.bind in wayland
func (WlRegistryBindRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for wl_registry.bind in wayland
func (WlRegistryBindRequest) MessageName() string { return "bind" }

// Ensure WlRegistryBindRequest implements Message.
var _ Message = WlRegistryBindRequest{}

// Emit emits the message to the emitter.
func (r *WlRegistryBindRequest) Emit(e *RequestEmitter) error {
	if err := e.PutUint(r.Name); err != nil {
		return err
	}
	if err := e.PutObjectID(r.ID); err != nil {
		return err
	}
	return nil
}

// Ensure WlRegistryBindRequest implements Request.
var _ Request = &WlRegistryBindRequest{}

// WlRegistryGlobalEvent signals when announce global object
//
// Notify the client of global objects.
//
// The event notifies the client that a global object with
// the given name is now available, and it implements the
// given version of the given interface.
type WlRegistryGlobalEvent struct {
	// Name contains numeric name of the global object
	Name uint32

	// Interface contains interface implemented by the object
	Interface string

	// Version contains interface version
	Version uint32
}

// Opcode returns the event opcode for wl_registry.global in wayland
func (WlRegistryGlobalEvent) Opcode() uint16 { return 0 }

// MessageName returns the event name for wl_registry.global in wayland
func (WlRegistryGlobalEvent) MessageName() string { return "global" }

// Ensure WlRegistryGlobalEvent implements Message.
var _ Message = WlRegistryGlobalEvent{}

// Scan scans the event from the socket.
func (e *WlRegistryGlobalEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Name = v
	}
	if v, err := s.String(); err != nil {
		return err
	} else {
		e.Interface = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Version = v
	}
	return nil
}

// Ensure WlRegistryGlobalEvent implements Event.
var _ Event = &WlRegistryGlobalEvent{}

// WlRegistryGlobalRemoveEvent signals when announce removal of global object
//
// Notify the client of removed global objects.
//
// This event notifies the client that the global identified
// by name is no longer available.  If the client bound to
// the global using the bind request, the client should now
// destroy that object.
//
// The object remains valid and requests to the object will be
// ignored until the client destroys it, to avoid races between
// the global going away and a client sending a request to it.
type WlRegistryGlobalRemoveEvent struct {
	// Name contains numeric name of the global object
	Name uint32
}

// Opcode returns the event opcode for wl_registry.global_remove in wayland
func (WlRegistryGlobalRemoveEvent) Opcode() uint16 { return 1 }

// MessageName returns the event name for wl_registry.global_remove in wayland
func (WlRegistryGlobalRemoveEvent) MessageName() string { return "global_remove" }

// Ensure WlRegistryGlobalRemoveEvent implements Message.
var _ Message = WlRegistryGlobalRemoveEvent{}

// Scan scans the event from the socket.
func (e *WlRegistryGlobalRemoveEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Name = v
	}
	return nil
}

// Ensure WlRegistryGlobalRemoveEvent implements Event.
var _ Event = &WlRegistryGlobalRemoveEvent{}

// WlRegistry global registry object
//
// The singleton global registry object.  The server has a number of
// global objects that are available to all clients.  These objects
// typically represent an actual object in the server (for example,
// an input device) or they are singleton objects that provide
// extension functionality.
//
// When a client creates a registry object, the registry object
// will emit a global event for each global currently in the
// registry.  Globals come and go as a result of device or
// monitor hotplugs, reconfiguration or other events, and the
// registry will send out global and global_remove events to
// keep the client up to date with the changes.  To mark the end
// of the initial burst of events, the client can use the
// wl_display.sync request immediately after calling
// wl_display.get_registry.
//
// A client can bind to a global object by using the bind
// request.  This creates a client-side handle that lets the object
// emit events to the client and lets the client invoke requests on
// the object.
type WlRegistry struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *WlRegistry) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (WlRegistry) Descriptor() *InterfaceDescriptor {
	return &WlRegistryDescriptor
}

// Dispatch returns an Event object for a given opcode.
func (WlRegistry) Dispatch(opcode uint16) Event {
	switch opcode {
	case 0:
		return &WlRegistryGlobalEvent{}
	case 1:
		return &WlRegistryGlobalRemoveEvent{}
	default:
		return nil
	}
}

// Bind requests to bind an object to the display
//
// Binds a new, client-created object to the server using the
// specified name as the identifier.
func (proxy *WlRegistry) Bind(connection Connection, aName uint32) (aID ObjectID, err error) {
	aID = connection.NewID()
	request := WlRegistryBindRequest{
		Name: aName,
		ID:   aID,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Ensure WlRegistry implements Proxy.
var _ Proxy = &WlRegistry{}

// #endregion Interface wayland.wl_registry

// ----------------------------------------------------------------------------
// #region Interface wayland.wl_callback

// WlCallbackDoneEvent signals when done event
//
// Notify the client when the related request is done.
type WlCallbackDoneEvent struct {
	// CallbackData contains request-specific data for the callback
	CallbackData uint32
}

// Opcode returns the event opcode for wl_callback.done in wayland
func (WlCallbackDoneEvent) Opcode() uint16 { return 0 }

// MessageName returns the event name for wl_callback.done in wayland
func (WlCallbackDoneEvent) MessageName() string { return "done" }

// Ensure WlCallbackDoneEvent implements Message.
var _ Message = WlCallbackDoneEvent{}

// Scan scans the event from the socket.
func (e *WlCallbackDoneEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.CallbackData = v
	}
	return nil
}

// Ensure WlCallbackDoneEvent implements Event.
var _ Event = &WlCallbackDoneEvent{}

// WlCallback callback object
//
// Clients can handle the 'done' event to get notified when
// the related request is done.
type WlCallback struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *WlCallback) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (WlCallback) Descriptor() *InterfaceDescriptor {
	return &WlCallbackDescriptor
}

// Dispatch returns an Event object for a given opcode.
func (WlCallback) Dispatch(opcode uint16) Event {
	switch opcode {
	case 0:
		return &WlCallbackDoneEvent{}
	default:
		return nil
	}
}

// Ensure WlCallback implements Proxy.
var _ Proxy = &WlCallback{}

// #endregion Interface wayland.wl_callback

// ----------------------------------------------------------------------------
// #region Interface wayland.wl_compositor

// WlCompositorCreateSurfaceRequest requests to create new surface
//
// Ask the compositor to create a new surface.
type WlCompositorCreateSurfaceRequest struct {
	// ID contains the new surface
	ID ObjectID
}

// Opcode returns the request opcode for wl_compositor.create_surface in wayland
func (WlCompositorCreateSurfaceRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for wl_compositor.create_surface in wayland
func (WlCompositorCreateSurfaceRequest) MessageName() string { return "create_surface" }

// Ensure WlCompositorCreateSurfaceRequest implements Message.
var _ Message = WlCompositorCreateSurfaceRequest{}

// Emit emits the message to the emitter.
func (r *WlCompositorCreateSurfaceRequest) Emit(e *RequestEmitter) error {
	if err := e.PutObjectID(r.ID); err != nil {
		return err
	}
	return nil
}

// Ensure WlCompositorCreateSurfaceRequest implements Request.
var _ Request = &WlCompositorCreateSurfaceRequest{}

// WlCompositorCreateRegionRequest requests to create new region
//
// Ask the compositor to create a new region.
type WlCompositorCreateRegionRequest struct {
	// ID contains the new region
	ID ObjectID
}

// Opcode returns the request opcode for wl_compositor.create_region in wayland
func (WlCompositorCreateRegionRequest) Opcode() uint16 { return 1 }

// MessageName returns the request name for wl_compositor.create_region in wayland
func (WlCompositorCreateRegionRequest) MessageName() string { return "create_region" }

// Ensure WlCompositorCreateRegionRequest implements Message.
var _ Message = WlCompositorCreateRegionRequest{}

// Emit emits the message to the emitter.
func (r *WlCompositorCreateRegionRequest) Emit(e *RequestEmitter) error {
	if err := e.PutObjectID(r.ID); err != nil {
		return err
	}
	return nil
}

// Ensure WlCompositorCreateRegionRequest implements Request.
var _ Request = &WlCompositorCreateRegionRequest{}

// WlCompositor the compositor singleton
//
// A compositor.  This object is a singleton global.  The
// compositor is in charge of combining the contents of multiple
// surfaces into one displayable output.
type WlCompositor struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *WlCompositor) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (WlCompositor) Descriptor() *InterfaceDescriptor {
	return &WlCompositorDescriptor
}

// Dispatch returns an Event object for a given opcode.
func (WlCompositor) Dispatch(opcode uint16) Event {
	switch opcode {
	default:
		return nil
	}
}

// CreateSurface requests to create new surface
//
// Ask the compositor to create a new surface.
func (proxy *WlCompositor) CreateSurface(connection Connection) (aID *WlSurface, err error) {
	aID = &WlSurface{connection.NewID()}
	request := WlCompositorCreateSurfaceRequest{
		ID: aID.id,
	}
	err = connection.SendRequest(proxy.id, &request)
	if err == nil {
		connection.RegisterProxy(aID)
	}
	return
}

// CreateRegion requests to create new region
//
// Ask the compositor to create a new region.
func (proxy *WlCompositor) CreateRegion(connection Connection) (aID *WlRegion, err error) {
	aID = &WlRegion{connection.NewID()}
	request := WlCompositorCreateRegionRequest{
		ID: aID.id,
	}
	err = connection.SendRequest(proxy.id, &request)
	if err == nil {
		connection.RegisterProxy(aID)
	}
	return
}

// Ensure WlCompositor implements Proxy.
var _ Proxy = &WlCompositor{}

// #endregion Interface wayland.wl_compositor

// ----------------------------------------------------------------------------
// #region Interface wayland.wl_shm_pool

// WlShmPoolCreateBufferRequest requests to create a buffer from the pool
//
// Create a wl_buffer object from the pool.
//
// The buffer is created offset bytes into the pool and has
// width and height as specified.  The stride argument specifies
// the number of bytes from the beginning of one row to the beginning
// of the next.  The format is the pixel format of the buffer and
// must be one of those advertised through the wl_shm.format event.
//
// A buffer will keep a reference to the pool it was created from
// so it is valid to destroy the pool immediately after creating
// a buffer from it.
type WlShmPoolCreateBufferRequest struct {
	// ID contains buffer to create
	ID ObjectID

	// Offset contains buffer byte offset within the pool
	Offset int32

	// Width contains buffer width, in pixels
	Width int32

	// Height contains buffer height, in pixels
	Height int32

	// Stride contains number of bytes from the beginning of one row to the beginning of the next row
	Stride int32

	// Format contains buffer pixel format
	Format uint32
}

// Opcode returns the request opcode for wl_shm_pool.create_buffer in wayland
func (WlShmPoolCreateBufferRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for wl_shm_pool.create_buffer in wayland
func (WlShmPoolCreateBufferRequest) MessageName() string { return "create_buffer" }

// Ensure WlShmPoolCreateBufferRequest implements Message.
var _ Message = WlShmPoolCreateBufferRequest{}

// Emit emits the message to the emitter.
func (r *WlShmPoolCreateBufferRequest) Emit(e *RequestEmitter) error {
	if err := e.PutObjectID(r.ID); err != nil {
		return err
	}
	if err := e.PutInt(r.Offset); err != nil {
		return err
	}
	if err := e.PutInt(r.Width); err != nil {
		return err
	}
	if err := e.PutInt(r.Height); err != nil {
		return err
	}
	if err := e.PutInt(r.Stride); err != nil {
		return err
	}
	if err := e.PutUint(r.Format); err != nil {
		return err
	}
	return nil
}

// Ensure WlShmPoolCreateBufferRequest implements Request.
var _ Request = &WlShmPoolCreateBufferRequest{}

// WlShmPoolDestroyRequest requests to destroy the pool
//
// Destroy the shared memory pool.
//
// The mmapped memory will be released when all
// buffers that have been created from this pool
// are gone.
type WlShmPoolDestroyRequest struct {
}

// Opcode returns the request opcode for wl_shm_pool.destroy in wayland
func (WlShmPoolDestroyRequest) Opcode() uint16 { return 1 }

// MessageName returns the request name for wl_shm_pool.destroy in wayland
func (WlShmPoolDestroyRequest) MessageName() string { return "destroy" }

// Ensure WlShmPoolDestroyRequest implements Message.
var _ Message = WlShmPoolDestroyRequest{}

// Emit emits the message to the emitter.
func (r *WlShmPoolDestroyRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure WlShmPoolDestroyRequest implements Request.
var _ Request = &WlShmPoolDestroyRequest{}

// WlShmPoolResizeRequest requests to change the size of the pool mapping
//
// This request will cause the server to remap the backing memory
// for the pool from the file descriptor passed when the pool was
// created, but using the new size.  This request can only be
// used to make the pool bigger.
type WlShmPoolResizeRequest struct {
	// Size contains new size of the pool, in bytes
	Size int32
}

// Opcode returns the request opcode for wl_shm_pool.resize in wayland
func (WlShmPoolResizeRequest) Opcode() uint16 { return 2 }

// MessageName returns the request name for wl_shm_pool.resize in wayland
func (WlShmPoolResizeRequest) MessageName() string { return "resize" }

// Ensure WlShmPoolResizeRequest implements Message.
var _ Message = WlShmPoolResizeRequest{}

// Emit emits the message to the emitter.
func (r *WlShmPoolResizeRequest) Emit(e *RequestEmitter) error {
	if err := e.PutInt(r.Size); err != nil {
		return err
	}
	return nil
}

// Ensure WlShmPoolResizeRequest implements Request.
var _ Request = &WlShmPoolResizeRequest{}

// WlShmPool a shared memory pool
//
// The wl_shm_pool object encapsulates a piece of memory shared
// between the compositor and client.  Through the wl_shm_pool
// object, the client can allocate shared memory wl_buffer objects.
// All objects created through the same pool share the same
// underlying mapped memory. Reusing the mapped memory avoids the
// setup/teardown overhead and is useful when interactively resizing
// a surface or for many small buffers.
type WlShmPool struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *WlShmPool) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (WlShmPool) Descriptor() *InterfaceDescriptor {
	return &WlShmPoolDescriptor
}

// Dispatch returns an Event object for a given opcode.
func (WlShmPool) Dispatch(opcode uint16) Event {
	switch opcode {
	default:
		return nil
	}
}

// CreateBuffer requests to create a buffer from the pool
//
// Create a wl_buffer object from the pool.
//
// The buffer is created offset bytes into the pool and has
// width and height as specified.  The stride argument specifies
// the number of bytes from the beginning of one row to the beginning
// of the next.  The format is the pixel format of the buffer and
// must be one of those advertised through the wl_shm.format event.
//
// A buffer will keep a reference to the pool it was created from
// so it is valid to destroy the pool immediately after creating
// a buffer from it.
func (proxy *WlShmPool) CreateBuffer(connection Connection, aOffset int32, aWidth int32, aHeight int32, aStride int32, aFormat uint32) (aID *WlBuffer, err error) {
	aID = &WlBuffer{connection.NewID()}
	request := WlShmPoolCreateBufferRequest{
		ID:     aID.id,
		Offset: aOffset,
		Width:  aWidth,
		Height: aHeight,
		Stride: aStride,
		Format: aFormat,
	}
	err = connection.SendRequest(proxy.id, &request)
	if err == nil {
		connection.RegisterProxy(aID)
	}
	return
}

// Destroy requests to destroy the pool
//
// Destroy the shared memory pool.
//
// The mmapped memory will be released when all
// buffers that have been created from this pool
// are gone.
func (proxy *WlShmPool) Destroy(connection Connection) (err error) {
	request := WlShmPoolDestroyRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Resize requests to change the size of the pool mapping
//
// This request will cause the server to remap the backing memory
// for the pool from the file descriptor passed when the pool was
// created, but using the new size.  This request can only be
// used to make the pool bigger.
func (proxy *WlShmPool) Resize(connection Connection, aSize int32) (err error) {
	request := WlShmPoolResizeRequest{
		Size: aSize,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Ensure WlShmPool implements Proxy.
var _ Proxy = &WlShmPool{}

// #endregion Interface wayland.wl_shm_pool

// ----------------------------------------------------------------------------
// #region Interface wayland.wl_shm

// WlShmError represents wl_shm error values
//
// These errors can be emitted in response to wl_shm requests.
type WlShmError int

const (
	// WlShmErrorInvalidFormat corresponds to buffer format is not known
	WlShmErrorInvalidFormat WlShmError = 0

	// WlShmErrorInvalidStride corresponds to invalid size or stride during pool or buffer creation
	WlShmErrorInvalidStride WlShmError = 1

	// WlShmErrorInvalidFD corresponds to mmapping the file descriptor failed
	WlShmErrorInvalidFD WlShmError = 2
)

// WlShmFormat represents pixel formats
//
// This describes the memory layout of an individual pixel.
//
// All renderers should support argb8888 and xrgb8888 but any other
// formats are optional and may not be supported by the particular
// renderer in use.
//
// The drm format codes match the macros defined in drm_fourcc.h, except
// argb8888 and xrgb8888. The formats actually supported by the compositor
// will be reported by the format event.
type WlShmFormat int

const (
	// WlShmFormatArgb8888 corresponds to 32-bit ARGB format, [31:0] A:R:G:B 8:8:8:8 little endian
	WlShmFormatArgb8888 WlShmFormat = 0

	// WlShmFormatXrgb8888 corresponds to 32-bit RGB format, [31:0] x:R:G:B 8:8:8:8 little endian
	WlShmFormatXrgb8888 WlShmFormat = 1

	// WlShmFormatC8 corresponds to 8-bit color index format, [7:0] C
	WlShmFormatC8 WlShmFormat = 0x20203843

	// WlShmFormatRgb332 corresponds to 8-bit RGB format, [7:0] R:G:B 3:3:2
	WlShmFormatRgb332 WlShmFormat = 0x38424752

	// WlShmFormatBgr233 corresponds to 8-bit BGR format, [7:0] B:G:R 2:3:3
	WlShmFormatBgr233 WlShmFormat = 0x38524742

	// WlShmFormatXrgb4444 corresponds to 16-bit xRGB format, [15:0] x:R:G:B 4:4:4:4 little endian
	WlShmFormatXrgb4444 WlShmFormat = 0x32315258

	// WlShmFormatXbgr4444 corresponds to 16-bit xBGR format, [15:0] x:B:G:R 4:4:4:4 little endian
	WlShmFormatXbgr4444 WlShmFormat = 0x32314258

	// WlShmFormatRgbx4444 corresponds to 16-bit RGBx format, [15:0] R:G:B:x 4:4:4:4 little endian
	WlShmFormatRgbx4444 WlShmFormat = 0x32315852

	// WlShmFormatBgrx4444 corresponds to 16-bit BGRx format, [15:0] B:G:R:x 4:4:4:4 little endian
	WlShmFormatBgrx4444 WlShmFormat = 0x32315842

	// WlShmFormatArgb4444 corresponds to 16-bit ARGB format, [15:0] A:R:G:B 4:4:4:4 little endian
	WlShmFormatArgb4444 WlShmFormat = 0x32315241

	// WlShmFormatAbgr4444 corresponds to 16-bit ABGR format, [15:0] A:B:G:R 4:4:4:4 little endian
	WlShmFormatAbgr4444 WlShmFormat = 0x32314241

	// WlShmFormatRgba4444 corresponds to 16-bit RBGA format, [15:0] R:G:B:A 4:4:4:4 little endian
	WlShmFormatRgba4444 WlShmFormat = 0x32314152

	// WlShmFormatBgra4444 corresponds to 16-bit BGRA format, [15:0] B:G:R:A 4:4:4:4 little endian
	WlShmFormatBgra4444 WlShmFormat = 0x32314142

	// WlShmFormatXrgb1555 corresponds to 16-bit xRGB format, [15:0] x:R:G:B 1:5:5:5 little endian
	WlShmFormatXrgb1555 WlShmFormat = 0x35315258

	// WlShmFormatXbgr1555 corresponds to 16-bit xBGR 1555 format, [15:0] x:B:G:R 1:5:5:5 little endian
	WlShmFormatXbgr1555 WlShmFormat = 0x35314258

	// WlShmFormatRgbx5551 corresponds to 16-bit RGBx 5551 format, [15:0] R:G:B:x 5:5:5:1 little endian
	WlShmFormatRgbx5551 WlShmFormat = 0x35315852

	// WlShmFormatBgrx5551 corresponds to 16-bit BGRx 5551 format, [15:0] B:G:R:x 5:5:5:1 little endian
	WlShmFormatBgrx5551 WlShmFormat = 0x35315842

	// WlShmFormatArgb1555 corresponds to 16-bit ARGB 1555 format, [15:0] A:R:G:B 1:5:5:5 little endian
	WlShmFormatArgb1555 WlShmFormat = 0x35315241

	// WlShmFormatAbgr1555 corresponds to 16-bit ABGR 1555 format, [15:0] A:B:G:R 1:5:5:5 little endian
	WlShmFormatAbgr1555 WlShmFormat = 0x35314241

	// WlShmFormatRgba5551 corresponds to 16-bit RGBA 5551 format, [15:0] R:G:B:A 5:5:5:1 little endian
	WlShmFormatRgba5551 WlShmFormat = 0x35314152

	// WlShmFormatBgra5551 corresponds to 16-bit BGRA 5551 format, [15:0] B:G:R:A 5:5:5:1 little endian
	WlShmFormatBgra5551 WlShmFormat = 0x35314142

	// WlShmFormatRgb565 corresponds to 16-bit RGB 565 format, [15:0] R:G:B 5:6:5 little endian
	WlShmFormatRgb565 WlShmFormat = 0x36314752

	// WlShmFormatBgr565 corresponds to 16-bit BGR 565 format, [15:0] B:G:R 5:6:5 little endian
	WlShmFormatBgr565 WlShmFormat = 0x36314742

	// WlShmFormatRgb888 corresponds to 24-bit RGB format, [23:0] R:G:B little endian
	WlShmFormatRgb888 WlShmFormat = 0x34324752

	// WlShmFormatBgr888 corresponds to 24-bit BGR format, [23:0] B:G:R little endian
	WlShmFormatBgr888 WlShmFormat = 0x34324742

	// WlShmFormatXbgr8888 corresponds to 32-bit xBGR format, [31:0] x:B:G:R 8:8:8:8 little endian
	WlShmFormatXbgr8888 WlShmFormat = 0x34324258

	// WlShmFormatRgbx8888 corresponds to 32-bit RGBx format, [31:0] R:G:B:x 8:8:8:8 little endian
	WlShmFormatRgbx8888 WlShmFormat = 0x34325852

	// WlShmFormatBgrx8888 corresponds to 32-bit BGRx format, [31:0] B:G:R:x 8:8:8:8 little endian
	WlShmFormatBgrx8888 WlShmFormat = 0x34325842

	// WlShmFormatAbgr8888 corresponds to 32-bit ABGR format, [31:0] A:B:G:R 8:8:8:8 little endian
	WlShmFormatAbgr8888 WlShmFormat = 0x34324241

	// WlShmFormatRgba8888 corresponds to 32-bit RGBA format, [31:0] R:G:B:A 8:8:8:8 little endian
	WlShmFormatRgba8888 WlShmFormat = 0x34324152

	// WlShmFormatBgra8888 corresponds to 32-bit BGRA format, [31:0] B:G:R:A 8:8:8:8 little endian
	WlShmFormatBgra8888 WlShmFormat = 0x34324142

	// WlShmFormatXrgb2101010 corresponds to 32-bit xRGB format, [31:0] x:R:G:B 2:10:10:10 little endian
	WlShmFormatXrgb2101010 WlShmFormat = 0x30335258

	// WlShmFormatXbgr2101010 corresponds to 32-bit xBGR format, [31:0] x:B:G:R 2:10:10:10 little endian
	WlShmFormatXbgr2101010 WlShmFormat = 0x30334258

	// WlShmFormatRgbx1010102 corresponds to 32-bit RGBx format, [31:0] R:G:B:x 10:10:10:2 little endian
	WlShmFormatRgbx1010102 WlShmFormat = 0x30335852

	// WlShmFormatBgrx1010102 corresponds to 32-bit BGRx format, [31:0] B:G:R:x 10:10:10:2 little endian
	WlShmFormatBgrx1010102 WlShmFormat = 0x30335842

	// WlShmFormatArgb2101010 corresponds to 32-bit ARGB format, [31:0] A:R:G:B 2:10:10:10 little endian
	WlShmFormatArgb2101010 WlShmFormat = 0x30335241

	// WlShmFormatAbgr2101010 corresponds to 32-bit ABGR format, [31:0] A:B:G:R 2:10:10:10 little endian
	WlShmFormatAbgr2101010 WlShmFormat = 0x30334241

	// WlShmFormatRgba1010102 corresponds to 32-bit RGBA format, [31:0] R:G:B:A 10:10:10:2 little endian
	WlShmFormatRgba1010102 WlShmFormat = 0x30334152

	// WlShmFormatBgra1010102 corresponds to 32-bit BGRA format, [31:0] B:G:R:A 10:10:10:2 little endian
	WlShmFormatBgra1010102 WlShmFormat = 0x30334142

	// WlShmFormatYuyv corresponds to packed YCbCr format, [31:0] Cr0:Y1:Cb0:Y0 8:8:8:8 little endian
	WlShmFormatYuyv WlShmFormat = 0x56595559

	// WlShmFormatYvyu corresponds to packed YCbCr format, [31:0] Cb0:Y1:Cr0:Y0 8:8:8:8 little endian
	WlShmFormatYvyu WlShmFormat = 0x55595659

	// WlShmFormatUyvy corresponds to packed YCbCr format, [31:0] Y1:Cr0:Y0:Cb0 8:8:8:8 little endian
	WlShmFormatUyvy WlShmFormat = 0x59565955

	// WlShmFormatVyuy corresponds to packed YCbCr format, [31:0] Y1:Cb0:Y0:Cr0 8:8:8:8 little endian
	WlShmFormatVyuy WlShmFormat = 0x59555956

	// WlShmFormatAyuv corresponds to packed AYCbCr format, [31:0] A:Y:Cb:Cr 8:8:8:8 little endian
	WlShmFormatAyuv WlShmFormat = 0x56555941

	// WlShmFormatNv12 corresponds to 2 plane YCbCr Cr:Cb format, 2x2 subsampled Cr:Cb plane
	WlShmFormatNv12 WlShmFormat = 0x3231564e

	// WlShmFormatNv21 corresponds to 2 plane YCbCr Cb:Cr format, 2x2 subsampled Cb:Cr plane
	WlShmFormatNv21 WlShmFormat = 0x3132564e

	// WlShmFormatNv16 corresponds to 2 plane YCbCr Cr:Cb format, 2x1 subsampled Cr:Cb plane
	WlShmFormatNv16 WlShmFormat = 0x3631564e

	// WlShmFormatNv61 corresponds to 2 plane YCbCr Cb:Cr format, 2x1 subsampled Cb:Cr plane
	WlShmFormatNv61 WlShmFormat = 0x3136564e

	// WlShmFormatYuv410 corresponds to 3 plane YCbCr format, 4x4 subsampled Cb (1) and Cr (2) planes
	WlShmFormatYuv410 WlShmFormat = 0x39565559

	// WlShmFormatYvu410 corresponds to 3 plane YCbCr format, 4x4 subsampled Cr (1) and Cb (2) planes
	WlShmFormatYvu410 WlShmFormat = 0x39555659

	// WlShmFormatYuv411 corresponds to 3 plane YCbCr format, 4x1 subsampled Cb (1) and Cr (2) planes
	WlShmFormatYuv411 WlShmFormat = 0x31315559

	// WlShmFormatYvu411 corresponds to 3 plane YCbCr format, 4x1 subsampled Cr (1) and Cb (2) planes
	WlShmFormatYvu411 WlShmFormat = 0x31315659

	// WlShmFormatYuv420 corresponds to 3 plane YCbCr format, 2x2 subsampled Cb (1) and Cr (2) planes
	WlShmFormatYuv420 WlShmFormat = 0x32315559

	// WlShmFormatYvu420 corresponds to 3 plane YCbCr format, 2x2 subsampled Cr (1) and Cb (2) planes
	WlShmFormatYvu420 WlShmFormat = 0x32315659

	// WlShmFormatYuv422 corresponds to 3 plane YCbCr format, 2x1 subsampled Cb (1) and Cr (2) planes
	WlShmFormatYuv422 WlShmFormat = 0x36315559

	// WlShmFormatYvu422 corresponds to 3 plane YCbCr format, 2x1 subsampled Cr (1) and Cb (2) planes
	WlShmFormatYvu422 WlShmFormat = 0x36315659

	// WlShmFormatYuv444 corresponds to 3 plane YCbCr format, non-subsampled Cb (1) and Cr (2) planes
	WlShmFormatYuv444 WlShmFormat = 0x34325559

	// WlShmFormatYvu444 corresponds to 3 plane YCbCr format, non-subsampled Cr (1) and Cb (2) planes
	WlShmFormatYvu444 WlShmFormat = 0x34325659

	// WlShmFormatR8 corresponds to [7:0] R
	WlShmFormatR8 WlShmFormat = 0x20203852

	// WlShmFormatR16 corresponds to [15:0] R little endian
	WlShmFormatR16 WlShmFormat = 0x20363152

	// WlShmFormatRg88 corresponds to [15:0] R:G 8:8 little endian
	WlShmFormatRg88 WlShmFormat = 0x38384752

	// WlShmFormatGr88 corresponds to [15:0] G:R 8:8 little endian
	WlShmFormatGr88 WlShmFormat = 0x38385247

	// WlShmFormatRg1616 corresponds to [31:0] R:G 16:16 little endian
	WlShmFormatRg1616 WlShmFormat = 0x32334752

	// WlShmFormatGr1616 corresponds to [31:0] G:R 16:16 little endian
	WlShmFormatGr1616 WlShmFormat = 0x32335247

	// WlShmFormatXrgb16161616f corresponds to [63:0] x:R:G:B 16:16:16:16 little endian
	WlShmFormatXrgb16161616f WlShmFormat = 0x48345258

	// WlShmFormatXbgr16161616f corresponds to [63:0] x:B:G:R 16:16:16:16 little endian
	WlShmFormatXbgr16161616f WlShmFormat = 0x48344258

	// WlShmFormatArgb16161616f corresponds to [63:0] A:R:G:B 16:16:16:16 little endian
	WlShmFormatArgb16161616f WlShmFormat = 0x48345241

	// WlShmFormatAbgr16161616f corresponds to [63:0] A:B:G:R 16:16:16:16 little endian
	WlShmFormatAbgr16161616f WlShmFormat = 0x48344241

	// WlShmFormatXyuv8888 corresponds to [31:0] X:Y:Cb:Cr 8:8:8:8 little endian
	WlShmFormatXyuv8888 WlShmFormat = 0x56555958

	// WlShmFormatVuy888 corresponds to [23:0] Cr:Cb:Y 8:8:8 little endian
	WlShmFormatVuy888 WlShmFormat = 0x34325556

	// WlShmFormatVuy101010 corresponds to Y followed by U then V, 10:10:10. Non-linear modifier only
	WlShmFormatVuy101010 WlShmFormat = 0x30335556

	// WlShmFormatY210 corresponds to [63:0] Cr0:0:Y1:0:Cb0:0:Y0:0 10:6:10:6:10:6:10:6 little endian per 2 Y pixels
	WlShmFormatY210 WlShmFormat = 0x30313259

	// WlShmFormatY212 corresponds to [63:0] Cr0:0:Y1:0:Cb0:0:Y0:0 12:4:12:4:12:4:12:4 little endian per 2 Y pixels
	WlShmFormatY212 WlShmFormat = 0x32313259

	// WlShmFormatY216 corresponds to [63:0] Cr0:Y1:Cb0:Y0 16:16:16:16 little endian per 2 Y pixels
	WlShmFormatY216 WlShmFormat = 0x36313259

	// WlShmFormatY410 corresponds to [31:0] A:Cr:Y:Cb 2:10:10:10 little endian
	WlShmFormatY410 WlShmFormat = 0x30313459

	// WlShmFormatY412 corresponds to [63:0] A:0:Cr:0:Y:0:Cb:0 12:4:12:4:12:4:12:4 little endian
	WlShmFormatY412 WlShmFormat = 0x32313459

	// WlShmFormatY416 corresponds to [63:0] A:Cr:Y:Cb 16:16:16:16 little endian
	WlShmFormatY416 WlShmFormat = 0x36313459

	// WlShmFormatXvyu2101010 corresponds to [31:0] X:Cr:Y:Cb 2:10:10:10 little endian
	WlShmFormatXvyu2101010 WlShmFormat = 0x30335658

	// WlShmFormatXvyu1216161616 corresponds to [63:0] X:0:Cr:0:Y:0:Cb:0 12:4:12:4:12:4:12:4 little endian
	WlShmFormatXvyu1216161616 WlShmFormat = 0x36335658

	// WlShmFormatXvyu16161616 corresponds to [63:0] X:Cr:Y:Cb 16:16:16:16 little endian
	WlShmFormatXvyu16161616 WlShmFormat = 0x38345658

	// WlShmFormatY0l0 corresponds to [63:0] A3:A2:Y3:0:Cr0:0:Y2:0:A1:A0:Y1:0:Cb0:0:Y0:0 1:1:8:2:8:2:8:2:1:1:8:2:8:2:8:2 little endian
	WlShmFormatY0l0 WlShmFormat = 0x304c3059

	// WlShmFormatX0l0 corresponds to [63:0] X3:X2:Y3:0:Cr0:0:Y2:0:X1:X0:Y1:0:Cb0:0:Y0:0 1:1:8:2:8:2:8:2:1:1:8:2:8:2:8:2 little endian
	WlShmFormatX0l0 WlShmFormat = 0x304c3058

	// WlShmFormatY0l2 corresponds to [63:0] A3:A2:Y3:Cr0:Y2:A1:A0:Y1:Cb0:Y0 1:1:10:10:10:1:1:10:10:10 little endian
	WlShmFormatY0l2 WlShmFormat = 0x324c3059

	// WlShmFormatX0l2 corresponds to [63:0] X3:X2:Y3:Cr0:Y2:X1:X0:Y1:Cb0:Y0 1:1:10:10:10:1:1:10:10:10 little endian
	WlShmFormatX0l2 WlShmFormat = 0x324c3058

	WlShmFormatYuv4208bit WlShmFormat = 0x38305559

	WlShmFormatYuv42010bit WlShmFormat = 0x30315559

	WlShmFormatXrgb8888A8 WlShmFormat = 0x38415258

	WlShmFormatXbgr8888A8 WlShmFormat = 0x38414258

	WlShmFormatRgbx8888A8 WlShmFormat = 0x38415852

	WlShmFormatBgrx8888A8 WlShmFormat = 0x38415842

	WlShmFormatRgb888A8 WlShmFormat = 0x38413852

	WlShmFormatBgr888A8 WlShmFormat = 0x38413842

	WlShmFormatRgb565A8 WlShmFormat = 0x38413552

	WlShmFormatBgr565A8 WlShmFormat = 0x38413542

	// WlShmFormatNv24 corresponds to non-subsampled Cr:Cb plane
	WlShmFormatNv24 WlShmFormat = 0x3432564e

	// WlShmFormatNv42 corresponds to non-subsampled Cb:Cr plane
	WlShmFormatNv42 WlShmFormat = 0x3234564e

	// WlShmFormatP210 corresponds to 2x1 subsampled Cr:Cb plane, 10 bit per channel
	WlShmFormatP210 WlShmFormat = 0x30313250

	// WlShmFormatP010 corresponds to 2x2 subsampled Cr:Cb plane 10 bits per channel
	WlShmFormatP010 WlShmFormat = 0x30313050

	// WlShmFormatP012 corresponds to 2x2 subsampled Cr:Cb plane 12 bits per channel
	WlShmFormatP012 WlShmFormat = 0x32313050

	// WlShmFormatP016 corresponds to 2x2 subsampled Cr:Cb plane 16 bits per channel
	WlShmFormatP016 WlShmFormat = 0x36313050

	// WlShmFormatAxbxgxrx106106106106 corresponds to [63:0] A:x:B:x:G:x:R:x 10:6:10:6:10:6:10:6 little endian
	WlShmFormatAxbxgxrx106106106106 WlShmFormat = 0x30314241

	// WlShmFormatNv15 corresponds to 2x2 subsampled Cr:Cb plane
	WlShmFormatNv15 WlShmFormat = 0x3531564e

	WlShmFormatQ410 WlShmFormat = 0x30313451

	WlShmFormatQ401 WlShmFormat = 0x31303451
)

// WlShmCreatePoolRequest requests to create a shm pool
//
// Create a new wl_shm_pool object.
//
// The pool can be used to create shared memory based buffer
// objects.  The server will mmap size bytes of the passed file
// descriptor, to use as backing memory for the pool.
type WlShmCreatePoolRequest struct {
	// ID contains pool to create
	ID ObjectID

	// FD contains file descriptor for the pool
	FD FD

	// Size contains pool size, in bytes
	Size int32
}

// Opcode returns the request opcode for wl_shm.create_pool in wayland
func (WlShmCreatePoolRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for wl_shm.create_pool in wayland
func (WlShmCreatePoolRequest) MessageName() string { return "create_pool" }

// Ensure WlShmCreatePoolRequest implements Message.
var _ Message = WlShmCreatePoolRequest{}

// Emit emits the message to the emitter.
func (r *WlShmCreatePoolRequest) Emit(e *RequestEmitter) error {
	if err := e.PutObjectID(r.ID); err != nil {
		return err
	}
	if err := e.PutFD(r.FD); err != nil {
		return err
	}
	if err := e.PutInt(r.Size); err != nil {
		return err
	}
	return nil
}

// Ensure WlShmCreatePoolRequest implements Request.
var _ Request = &WlShmCreatePoolRequest{}

// WlShmFormatEvent signals when pixel format description
//
// Informs the client about a valid pixel format that
// can be used for buffers. Known formats include
// argb8888 and xrgb8888.
type WlShmFormatEvent struct {
	// Format contains buffer pixel format
	Format uint32
}

// Opcode returns the event opcode for wl_shm.format in wayland
func (WlShmFormatEvent) Opcode() uint16 { return 0 }

// MessageName returns the event name for wl_shm.format in wayland
func (WlShmFormatEvent) MessageName() string { return "format" }

// Ensure WlShmFormatEvent implements Message.
var _ Message = WlShmFormatEvent{}

// Scan scans the event from the socket.
func (e *WlShmFormatEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Format = v
	}
	return nil
}

// Ensure WlShmFormatEvent implements Event.
var _ Event = &WlShmFormatEvent{}

// WlShm shared memory support
//
// A singleton global object that provides support for shared
// memory.
//
// Clients can create wl_shm_pool objects using the create_pool
// request.
//
// At connection setup time, the wl_shm object emits one or more
// format events to inform clients about the valid pixel formats
// that can be used for buffers.
type WlShm struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *WlShm) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (WlShm) Descriptor() *InterfaceDescriptor {
	return &WlShmDescriptor
}

// Dispatch returns an Event object for a given opcode.
func (WlShm) Dispatch(opcode uint16) Event {
	switch opcode {
	case 0:
		return &WlShmFormatEvent{}
	default:
		return nil
	}
}

// CreatePool requests to create a shm pool
//
// Create a new wl_shm_pool object.
//
// The pool can be used to create shared memory based buffer
// objects.  The server will mmap size bytes of the passed file
// descriptor, to use as backing memory for the pool.
func (proxy *WlShm) CreatePool(connection Connection, aFD FD, aSize int32) (aID *WlShmPool, err error) {
	aID = &WlShmPool{connection.NewID()}
	request := WlShmCreatePoolRequest{
		ID:   aID.id,
		FD:   aFD,
		Size: aSize,
	}
	err = connection.SendRequest(proxy.id, &request)
	if err == nil {
		connection.RegisterProxy(aID)
	}
	return
}

// Ensure WlShm implements Proxy.
var _ Proxy = &WlShm{}

// #endregion Interface wayland.wl_shm

// ----------------------------------------------------------------------------
// #region Interface wayland.wl_buffer

// WlBufferDestroyRequest requests to destroy a buffer
//
// Destroy a buffer. If and how you need to release the backing
// storage is defined by the buffer factory interface.
//
// For possible side-effects to a surface, see wl_surface.attach.
type WlBufferDestroyRequest struct {
}

// Opcode returns the request opcode for wl_buffer.destroy in wayland
func (WlBufferDestroyRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for wl_buffer.destroy in wayland
func (WlBufferDestroyRequest) MessageName() string { return "destroy" }

// Ensure WlBufferDestroyRequest implements Message.
var _ Message = WlBufferDestroyRequest{}

// Emit emits the message to the emitter.
func (r *WlBufferDestroyRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure WlBufferDestroyRequest implements Request.
var _ Request = &WlBufferDestroyRequest{}

// WlBufferReleaseEvent signals when compositor releases buffer
//
// Sent when this wl_buffer is no longer used by the compositor.
// The client is now free to reuse or destroy this buffer and its
// backing storage.
//
// If a client receives a release event before the frame callback
// requested in the same wl_surface.commit that attaches this
// wl_buffer to a surface, then the client is immediately free to
// reuse the buffer and its backing storage, and does not need a
// second buffer for the next surface content update. Typically
// this is possible, when the compositor maintains a copy of the
// wl_surface contents, e.g. as a GL texture. This is an important
// optimization for GL(ES) compositors with wl_shm clients.
type WlBufferReleaseEvent struct {
}

// Opcode returns the event opcode for wl_buffer.release in wayland
func (WlBufferReleaseEvent) Opcode() uint16 { return 0 }

// MessageName returns the event name for wl_buffer.release in wayland
func (WlBufferReleaseEvent) MessageName() string { return "release" }

// Ensure WlBufferReleaseEvent implements Message.
var _ Message = WlBufferReleaseEvent{}

// Scan scans the event from the socket.
func (e *WlBufferReleaseEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure WlBufferReleaseEvent implements Event.
var _ Event = &WlBufferReleaseEvent{}

// WlBuffer content for a wl_surface
//
// A buffer provides the content for a wl_surface. Buffers are
// created through factory interfaces such as wl_shm, wp_linux_buffer_params
// (from the linux-dmabuf protocol extension) or similar. It has a width and
// a height and can be attached to a wl_surface, but the mechanism by which a
// client provides and updates the contents is defined by the buffer factory
// interface.
//
// If the buffer uses a format that has an alpha channel, the alpha channel
// is assumed to be premultiplied in the color channels unless otherwise
// specified.
type WlBuffer struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *WlBuffer) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (WlBuffer) Descriptor() *InterfaceDescriptor {
	return &WlBufferDescriptor
}

// Dispatch returns an Event object for a given opcode.
func (WlBuffer) Dispatch(opcode uint16) Event {
	switch opcode {
	case 0:
		return &WlBufferReleaseEvent{}
	default:
		return nil
	}
}

// Destroy requests to destroy a buffer
//
// Destroy a buffer. If and how you need to release the backing
// storage is defined by the buffer factory interface.
//
// For possible side-effects to a surface, see wl_surface.attach.
func (proxy *WlBuffer) Destroy(connection Connection) (err error) {
	request := WlBufferDestroyRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Ensure WlBuffer implements Proxy.
var _ Proxy = &WlBuffer{}

// #endregion Interface wayland.wl_buffer

// ----------------------------------------------------------------------------
// #region Interface wayland.wl_data_offer

type WlDataOfferError int

const (
	// WlDataOfferErrorInvalidFinish corresponds to finish request was called untimely
	WlDataOfferErrorInvalidFinish WlDataOfferError = 0

	// WlDataOfferErrorInvalidActionMask corresponds to action mask contains invalid values
	WlDataOfferErrorInvalidActionMask WlDataOfferError = 1

	// WlDataOfferErrorInvalidAction corresponds to action argument has an invalid value
	WlDataOfferErrorInvalidAction WlDataOfferError = 2

	// WlDataOfferErrorInvalidOffer corresponds to offer doesn't accept this request
	WlDataOfferErrorInvalidOffer WlDataOfferError = 3
)

// WlDataOfferAcceptRequest requests to accept one of the offered mime types
//
// Indicate that the client can accept the given mime type, or
// NULL for not accepted.
//
// For objects of version 2 or older, this request is used by the
// client to give feedback whether the client can receive the given
// mime type, or NULL if none is accepted; the feedback does not
// determine whether the drag-and-drop operation succeeds or not.
//
// For objects of version 3 or newer, this request determines the
// final result of the drag-and-drop operation. If the end result
// is that no mime types were accepted, the drag-and-drop operation
// will be cancelled and the corresponding drag source will receive
// wl_data_source.cancelled. Clients may still use this event in
// conjunction with wl_data_source.action for feedback.
type WlDataOfferAcceptRequest struct {
	// Serial contains serial number of the accept request
	Serial uint32

	// MimeType contains mime type accepted by the client
	MimeType string
}

// Opcode returns the request opcode for wl_data_offer.accept in wayland
func (WlDataOfferAcceptRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for wl_data_offer.accept in wayland
func (WlDataOfferAcceptRequest) MessageName() string { return "accept" }

// Ensure WlDataOfferAcceptRequest implements Message.
var _ Message = WlDataOfferAcceptRequest{}

// Emit emits the message to the emitter.
func (r *WlDataOfferAcceptRequest) Emit(e *RequestEmitter) error {
	if err := e.PutUint(r.Serial); err != nil {
		return err
	}
	if err := e.PutString(r.MimeType); err != nil {
		return err
	}
	return nil
}

// Ensure WlDataOfferAcceptRequest implements Request.
var _ Request = &WlDataOfferAcceptRequest{}

// WlDataOfferReceiveRequest requests to request that the data is transferred
//
// To transfer the offered data, the client issues this request
// and indicates the mime type it wants to receive.  The transfer
// happens through the passed file descriptor (typically created
// with the pipe system call).  The source client writes the data
// in the mime type representation requested and then closes the
// file descriptor.
//
// The receiving client reads from the read end of the pipe until
// EOF and then closes its end, at which point the transfer is
// complete.
//
// This request may happen multiple times for different mime types,
// both before and after wl_data_device.drop. Drag-and-drop destination
// clients may preemptively fetch data or examine it more closely to
// determine acceptance.
type WlDataOfferReceiveRequest struct {
	// MimeType contains mime type desired by receiver
	MimeType string

	// FD contains file descriptor for data transfer
	FD FD
}

// Opcode returns the request opcode for wl_data_offer.receive in wayland
func (WlDataOfferReceiveRequest) Opcode() uint16 { return 1 }

// MessageName returns the request name for wl_data_offer.receive in wayland
func (WlDataOfferReceiveRequest) MessageName() string { return "receive" }

// Ensure WlDataOfferReceiveRequest implements Message.
var _ Message = WlDataOfferReceiveRequest{}

// Emit emits the message to the emitter.
func (r *WlDataOfferReceiveRequest) Emit(e *RequestEmitter) error {
	if err := e.PutString(r.MimeType); err != nil {
		return err
	}
	if err := e.PutFD(r.FD); err != nil {
		return err
	}
	return nil
}

// Ensure WlDataOfferReceiveRequest implements Request.
var _ Request = &WlDataOfferReceiveRequest{}

// WlDataOfferDestroyRequest requests to destroy data offer
//
// Destroy the data offer.
type WlDataOfferDestroyRequest struct {
}

// Opcode returns the request opcode for wl_data_offer.destroy in wayland
func (WlDataOfferDestroyRequest) Opcode() uint16 { return 2 }

// MessageName returns the request name for wl_data_offer.destroy in wayland
func (WlDataOfferDestroyRequest) MessageName() string { return "destroy" }

// Ensure WlDataOfferDestroyRequest implements Message.
var _ Message = WlDataOfferDestroyRequest{}

// Emit emits the message to the emitter.
func (r *WlDataOfferDestroyRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure WlDataOfferDestroyRequest implements Request.
var _ Request = &WlDataOfferDestroyRequest{}

// WlDataOfferFinishRequest requests to the offer will no longer be used
//
// Notifies the compositor that the drag destination successfully
// finished the drag-and-drop operation.
//
// Upon receiving this request, the compositor will emit
// wl_data_source.dnd_finished on the drag source client.
//
// It is a client error to perform other requests than
// wl_data_offer.destroy after this one. It is also an error to perform
// this request after a NULL mime type has been set in
// wl_data_offer.accept or no action was received through
// wl_data_offer.action.
//
// If wl_data_offer.finish request is received for a non drag and drop
// operation, the invalid_finish protocol error is raised.
type WlDataOfferFinishRequest struct {
}

// Opcode returns the request opcode for wl_data_offer.finish in wayland
func (WlDataOfferFinishRequest) Opcode() uint16 { return 3 }

// MessageName returns the request name for wl_data_offer.finish in wayland
func (WlDataOfferFinishRequest) MessageName() string { return "finish" }

// Ensure WlDataOfferFinishRequest implements Message.
var _ Message = WlDataOfferFinishRequest{}

// Emit emits the message to the emitter.
func (r *WlDataOfferFinishRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure WlDataOfferFinishRequest implements Request.
var _ Request = &WlDataOfferFinishRequest{}

// WlDataOfferSetActionsRequest requests to set the available/preferred drag-and-drop actions
//
// Sets the actions that the destination side client supports for
// this operation. This request may trigger the emission of
// wl_data_source.action and wl_data_offer.action events if the compositor
// needs to change the selected action.
//
// This request can be called multiple times throughout the
// drag-and-drop operation, typically in response to wl_data_device.enter
// or wl_data_device.motion events.
//
// This request determines the final result of the drag-and-drop
// operation. If the end result is that no action is accepted,
// the drag source will receive wl_data_source.cancelled.
//
// The dnd_actions argument must contain only values expressed in the
// wl_data_device_manager.dnd_actions enum, and the preferred_action
// argument must only contain one of those values set, otherwise it
// will result in a protocol error.
//
// While managing an "ask" action, the destination drag-and-drop client
// may perform further wl_data_offer.receive requests, and is expected
// to perform one last wl_data_offer.set_actions request with a preferred
// action other than "ask" (and optionally wl_data_offer.accept) before
// requesting wl_data_offer.finish, in order to convey the action selected
// by the user. If the preferred action is not in the
// wl_data_offer.source_actions mask, an error will be raised.
//
// If the "ask" action is dismissed (e.g. user cancellation), the client
// is expected to perform wl_data_offer.destroy right away.
//
// This request can only be made on drag-and-drop offers, a protocol error
// will be raised otherwise.
type WlDataOfferSetActionsRequest struct {
	// DndActions contains actions supported by the destination client
	DndActions uint32

	// PreferredAction contains action preferred by the destination client
	PreferredAction uint32
}

// Opcode returns the request opcode for wl_data_offer.set_actions in wayland
func (WlDataOfferSetActionsRequest) Opcode() uint16 { return 4 }

// MessageName returns the request name for wl_data_offer.set_actions in wayland
func (WlDataOfferSetActionsRequest) MessageName() string { return "set_actions" }

// Ensure WlDataOfferSetActionsRequest implements Message.
var _ Message = WlDataOfferSetActionsRequest{}

// Emit emits the message to the emitter.
func (r *WlDataOfferSetActionsRequest) Emit(e *RequestEmitter) error {
	if err := e.PutUint(r.DndActions); err != nil {
		return err
	}
	if err := e.PutUint(r.PreferredAction); err != nil {
		return err
	}
	return nil
}

// Ensure WlDataOfferSetActionsRequest implements Request.
var _ Request = &WlDataOfferSetActionsRequest{}

// WlDataOfferOfferEvent signals when advertise offered mime type
//
// Sent immediately after creating the wl_data_offer object.  One
// event per offered mime type.
type WlDataOfferOfferEvent struct {
	// MimeType contains offered mime type
	MimeType string
}

// Opcode returns the event opcode for wl_data_offer.offer in wayland
func (WlDataOfferOfferEvent) Opcode() uint16 { return 0 }

// MessageName returns the event name for wl_data_offer.offer in wayland
func (WlDataOfferOfferEvent) MessageName() string { return "offer" }

// Ensure WlDataOfferOfferEvent implements Message.
var _ Message = WlDataOfferOfferEvent{}

// Scan scans the event from the socket.
func (e *WlDataOfferOfferEvent) Scan(s *EventScanner) error {
	if v, err := s.String(); err != nil {
		return err
	} else {
		e.MimeType = v
	}
	return nil
}

// Ensure WlDataOfferOfferEvent implements Event.
var _ Event = &WlDataOfferOfferEvent{}

// WlDataOfferSourceActionsEvent signals when notify the source-side available actions
//
// This event indicates the actions offered by the data source. It
// will be sent right after wl_data_device.enter, or anytime the source
// side changes its offered actions through wl_data_source.set_actions.
type WlDataOfferSourceActionsEvent struct {
	// SourceActions contains actions offered by the data source
	SourceActions uint32
}

// Opcode returns the event opcode for wl_data_offer.source_actions in wayland
func (WlDataOfferSourceActionsEvent) Opcode() uint16 { return 1 }

// MessageName returns the event name for wl_data_offer.source_actions in wayland
func (WlDataOfferSourceActionsEvent) MessageName() string { return "source_actions" }

// Ensure WlDataOfferSourceActionsEvent implements Message.
var _ Message = WlDataOfferSourceActionsEvent{}

// Scan scans the event from the socket.
func (e *WlDataOfferSourceActionsEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.SourceActions = v
	}
	return nil
}

// Ensure WlDataOfferSourceActionsEvent implements Event.
var _ Event = &WlDataOfferSourceActionsEvent{}

// WlDataOfferActionEvent signals when notify the selected action
//
// This event indicates the action selected by the compositor after
// matching the source/destination side actions. Only one action (or
// none) will be offered here.
//
// This event can be emitted multiple times during the drag-and-drop
// operation in response to destination side action changes through
// wl_data_offer.set_actions.
//
// This event will no longer be emitted after wl_data_device.drop
// happened on the drag-and-drop destination, the client must
// honor the last action received, or the last preferred one set
// through wl_data_offer.set_actions when handling an "ask" action.
//
// Compositors may also change the selected action on the fly, mainly
// in response to keyboard modifier changes during the drag-and-drop
// operation.
//
// The most recent action received is always the valid one. Prior to
// receiving wl_data_device.drop, the chosen action may change (e.g.
// due to keyboard modifiers being pressed). At the time of receiving
// wl_data_device.drop the drag-and-drop destination must honor the
// last action received.
//
// Action changes may still happen after wl_data_device.drop,
// especially on "ask" actions, where the drag-and-drop destination
// may choose another action afterwards. Action changes happening
// at this stage are always the result of inter-client negotiation, the
// compositor shall no longer be able to induce a different action.
//
// Upon "ask" actions, it is expected that the drag-and-drop destination
// may potentially choose a different action and/or mime type,
// based on wl_data_offer.source_actions and finally chosen by the
// user (e.g. popping up a menu with the available options). The
// final wl_data_offer.set_actions and wl_data_offer.accept requests
// must happen before the call to wl_data_offer.finish.
type WlDataOfferActionEvent struct {
	// DndAction contains action selected by the compositor
	DndAction uint32
}

// Opcode returns the event opcode for wl_data_offer.action in wayland
func (WlDataOfferActionEvent) Opcode() uint16 { return 2 }

// MessageName returns the event name for wl_data_offer.action in wayland
func (WlDataOfferActionEvent) MessageName() string { return "action" }

// Ensure WlDataOfferActionEvent implements Message.
var _ Message = WlDataOfferActionEvent{}

// Scan scans the event from the socket.
func (e *WlDataOfferActionEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.DndAction = v
	}
	return nil
}

// Ensure WlDataOfferActionEvent implements Event.
var _ Event = &WlDataOfferActionEvent{}

// WlDataOffer offer to transfer data
//
// A wl_data_offer represents a piece of data offered for transfer
// by another client (the source client).  It is used by the
// copy-and-paste and drag-and-drop mechanisms.  The offer
// describes the different mime types that the data can be
// converted to and provides the mechanism for transferring the
// data directly from the source client.
type WlDataOffer struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *WlDataOffer) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (WlDataOffer) Descriptor() *InterfaceDescriptor {
	return &WlDataOfferDescriptor
}

// Dispatch returns an Event object for a given opcode.
func (WlDataOffer) Dispatch(opcode uint16) Event {
	switch opcode {
	case 0:
		return &WlDataOfferOfferEvent{}
	case 1:
		return &WlDataOfferSourceActionsEvent{}
	case 2:
		return &WlDataOfferActionEvent{}
	default:
		return nil
	}
}

// Accept requests to accept one of the offered mime types
//
// Indicate that the client can accept the given mime type, or
// NULL for not accepted.
//
// For objects of version 2 or older, this request is used by the
// client to give feedback whether the client can receive the given
// mime type, or NULL if none is accepted; the feedback does not
// determine whether the drag-and-drop operation succeeds or not.
//
// For objects of version 3 or newer, this request determines the
// final result of the drag-and-drop operation. If the end result
// is that no mime types were accepted, the drag-and-drop operation
// will be cancelled and the corresponding drag source will receive
// wl_data_source.cancelled. Clients may still use this event in
// conjunction with wl_data_source.action for feedback.
func (proxy *WlDataOffer) Accept(connection Connection, aSerial uint32, aMimeType string) (err error) {
	request := WlDataOfferAcceptRequest{
		Serial:   aSerial,
		MimeType: aMimeType,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Receive requests to request that the data is transferred
//
// To transfer the offered data, the client issues this request
// and indicates the mime type it wants to receive.  The transfer
// happens through the passed file descriptor (typically created
// with the pipe system call).  The source client writes the data
// in the mime type representation requested and then closes the
// file descriptor.
//
// The receiving client reads from the read end of the pipe until
// EOF and then closes its end, at which point the transfer is
// complete.
//
// This request may happen multiple times for different mime types,
// both before and after wl_data_device.drop. Drag-and-drop destination
// clients may preemptively fetch data or examine it more closely to
// determine acceptance.
func (proxy *WlDataOffer) Receive(connection Connection, aMimeType string, aFD FD) (err error) {
	request := WlDataOfferReceiveRequest{
		MimeType: aMimeType,
		FD:       aFD,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Destroy requests to destroy data offer
//
// Destroy the data offer.
func (proxy *WlDataOffer) Destroy(connection Connection) (err error) {
	request := WlDataOfferDestroyRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Finish requests to the offer will no longer be used
//
// Notifies the compositor that the drag destination successfully
// finished the drag-and-drop operation.
//
// Upon receiving this request, the compositor will emit
// wl_data_source.dnd_finished on the drag source client.
//
// It is a client error to perform other requests than
// wl_data_offer.destroy after this one. It is also an error to perform
// this request after a NULL mime type has been set in
// wl_data_offer.accept or no action was received through
// wl_data_offer.action.
//
// If wl_data_offer.finish request is received for a non drag and drop
// operation, the invalid_finish protocol error is raised.
func (proxy *WlDataOffer) Finish(connection Connection) (err error) {
	request := WlDataOfferFinishRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// SetActions requests to set the available/preferred drag-and-drop actions
//
// Sets the actions that the destination side client supports for
// this operation. This request may trigger the emission of
// wl_data_source.action and wl_data_offer.action events if the compositor
// needs to change the selected action.
//
// This request can be called multiple times throughout the
// drag-and-drop operation, typically in response to wl_data_device.enter
// or wl_data_device.motion events.
//
// This request determines the final result of the drag-and-drop
// operation. If the end result is that no action is accepted,
// the drag source will receive wl_data_source.cancelled.
//
// The dnd_actions argument must contain only values expressed in the
// wl_data_device_manager.dnd_actions enum, and the preferred_action
// argument must only contain one of those values set, otherwise it
// will result in a protocol error.
//
// While managing an "ask" action, the destination drag-and-drop client
// may perform further wl_data_offer.receive requests, and is expected
// to perform one last wl_data_offer.set_actions request with a preferred
// action other than "ask" (and optionally wl_data_offer.accept) before
// requesting wl_data_offer.finish, in order to convey the action selected
// by the user. If the preferred action is not in the
// wl_data_offer.source_actions mask, an error will be raised.
//
// If the "ask" action is dismissed (e.g. user cancellation), the client
// is expected to perform wl_data_offer.destroy right away.
//
// This request can only be made on drag-and-drop offers, a protocol error
// will be raised otherwise.
func (proxy *WlDataOffer) SetActions(connection Connection, aDndActions uint32, aPreferredAction uint32) (err error) {
	request := WlDataOfferSetActionsRequest{
		DndActions:      aDndActions,
		PreferredAction: aPreferredAction,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Ensure WlDataOffer implements Proxy.
var _ Proxy = &WlDataOffer{}

// #endregion Interface wayland.wl_data_offer

// ----------------------------------------------------------------------------
// #region Interface wayland.wl_data_source

type WlDataSourceError int

const (
	// WlDataSourceErrorInvalidActionMask corresponds to action mask contains invalid values
	WlDataSourceErrorInvalidActionMask WlDataSourceError = 0

	// WlDataSourceErrorInvalidSource corresponds to source doesn't accept this request
	WlDataSourceErrorInvalidSource WlDataSourceError = 1
)

// WlDataSourceOfferRequest requests to add an offered mime type
//
// This request adds a mime type to the set of mime types
// advertised to targets.  Can be called several times to offer
// multiple types.
type WlDataSourceOfferRequest struct {
	// MimeType contains mime type offered by the data source
	MimeType string
}

// Opcode returns the request opcode for wl_data_source.offer in wayland
func (WlDataSourceOfferRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for wl_data_source.offer in wayland
func (WlDataSourceOfferRequest) MessageName() string { return "offer" }

// Ensure WlDataSourceOfferRequest implements Message.
var _ Message = WlDataSourceOfferRequest{}

// Emit emits the message to the emitter.
func (r *WlDataSourceOfferRequest) Emit(e *RequestEmitter) error {
	if err := e.PutString(r.MimeType); err != nil {
		return err
	}
	return nil
}

// Ensure WlDataSourceOfferRequest implements Request.
var _ Request = &WlDataSourceOfferRequest{}

// WlDataSourceDestroyRequest requests to destroy the data source
//
// Destroy the data source.
type WlDataSourceDestroyRequest struct {
}

// Opcode returns the request opcode for wl_data_source.destroy in wayland
func (WlDataSourceDestroyRequest) Opcode() uint16 { return 1 }

// MessageName returns the request name for wl_data_source.destroy in wayland
func (WlDataSourceDestroyRequest) MessageName() string { return "destroy" }

// Ensure WlDataSourceDestroyRequest implements Message.
var _ Message = WlDataSourceDestroyRequest{}

// Emit emits the message to the emitter.
func (r *WlDataSourceDestroyRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure WlDataSourceDestroyRequest implements Request.
var _ Request = &WlDataSourceDestroyRequest{}

// WlDataSourceSetActionsRequest requests to set the available drag-and-drop actions
//
// Sets the actions that the source side client supports for this
// operation. This request may trigger wl_data_source.action and
// wl_data_offer.action events if the compositor needs to change the
// selected action.
//
// The dnd_actions argument must contain only values expressed in the
// wl_data_device_manager.dnd_actions enum, otherwise it will result
// in a protocol error.
//
// This request must be made once only, and can only be made on sources
// used in drag-and-drop, so it must be performed before
// wl_data_device.start_drag. Attempting to use the source other than
// for drag-and-drop will raise a protocol error.
type WlDataSourceSetActionsRequest struct {
	// DndActions contains actions supported by the data source
	DndActions uint32
}

// Opcode returns the request opcode for wl_data_source.set_actions in wayland
func (WlDataSourceSetActionsRequest) Opcode() uint16 { return 2 }

// MessageName returns the request name for wl_data_source.set_actions in wayland
func (WlDataSourceSetActionsRequest) MessageName() string { return "set_actions" }

// Ensure WlDataSourceSetActionsRequest implements Message.
var _ Message = WlDataSourceSetActionsRequest{}

// Emit emits the message to the emitter.
func (r *WlDataSourceSetActionsRequest) Emit(e *RequestEmitter) error {
	if err := e.PutUint(r.DndActions); err != nil {
		return err
	}
	return nil
}

// Ensure WlDataSourceSetActionsRequest implements Request.
var _ Request = &WlDataSourceSetActionsRequest{}

// WlDataSourceTargetEvent signals when a target accepts an offered mime type
//
// Sent when a target accepts pointer_focus or motion events.  If
// a target does not accept any of the offered types, type is NULL.
//
// Used for feedback during drag-and-drop.
type WlDataSourceTargetEvent struct {
	// MimeType contains mime type accepted by the target
	MimeType string
}

// Opcode returns the event opcode for wl_data_source.target in wayland
func (WlDataSourceTargetEvent) Opcode() uint16 { return 0 }

// MessageName returns the event name for wl_data_source.target in wayland
func (WlDataSourceTargetEvent) MessageName() string { return "target" }

// Ensure WlDataSourceTargetEvent implements Message.
var _ Message = WlDataSourceTargetEvent{}

// Scan scans the event from the socket.
func (e *WlDataSourceTargetEvent) Scan(s *EventScanner) error {
	if v, err := s.String(); err != nil {
		return err
	} else {
		e.MimeType = v
	}
	return nil
}

// Ensure WlDataSourceTargetEvent implements Event.
var _ Event = &WlDataSourceTargetEvent{}

// WlDataSourceSendEvent signals when send the data
//
// Request for data from the client.  Send the data as the
// specified mime type over the passed file descriptor, then
// close it.
type WlDataSourceSendEvent struct {
	// MimeType contains mime type for the data
	MimeType string

	// FD contains file descriptor for the data
	FD FD
}

// Opcode returns the event opcode for wl_data_source.send in wayland
func (WlDataSourceSendEvent) Opcode() uint16 { return 1 }

// MessageName returns the event name for wl_data_source.send in wayland
func (WlDataSourceSendEvent) MessageName() string { return "send" }

// Ensure WlDataSourceSendEvent implements Message.
var _ Message = WlDataSourceSendEvent{}

// Scan scans the event from the socket.
func (e *WlDataSourceSendEvent) Scan(s *EventScanner) error {
	if v, err := s.String(); err != nil {
		return err
	} else {
		e.MimeType = v
	}
	if v, err := s.FD(); err != nil {
		return err
	} else {
		e.FD = v
	}
	return nil
}

// Ensure WlDataSourceSendEvent implements Event.
var _ Event = &WlDataSourceSendEvent{}

// WlDataSourceCancelledEvent signals when selection was cancelled
//
// This data source is no longer valid. There are several reasons why
// this could happen:
//
// - The data source has been replaced by another data source.
// - The drag-and-drop operation was performed, but the drop destination
// did not accept any of the mime types offered through
// wl_data_source.target.
// - The drag-and-drop operation was performed, but the drop destination
// did not select any of the actions present in the mask offered through
// wl_data_source.action.
// - The drag-and-drop operation was performed but didn't happen over a
// surface.
// - The compositor cancelled the drag-and-drop operation (e.g. compositor
// dependent timeouts to avoid stale drag-and-drop transfers).
//
// The client should clean up and destroy this data source.
//
// For objects of version 2 or older, wl_data_source.cancelled will
// only be emitted if the data source was replaced by another data
// source.
type WlDataSourceCancelledEvent struct {
}

// Opcode returns the event opcode for wl_data_source.cancelled in wayland
func (WlDataSourceCancelledEvent) Opcode() uint16 { return 2 }

// MessageName returns the event name for wl_data_source.cancelled in wayland
func (WlDataSourceCancelledEvent) MessageName() string { return "cancelled" }

// Ensure WlDataSourceCancelledEvent implements Message.
var _ Message = WlDataSourceCancelledEvent{}

// Scan scans the event from the socket.
func (e *WlDataSourceCancelledEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure WlDataSourceCancelledEvent implements Event.
var _ Event = &WlDataSourceCancelledEvent{}

// WlDataSourceDndDropPerformedEvent signals when the drag-and-drop operation physically finished
//
// The user performed the drop action. This event does not indicate
// acceptance, wl_data_source.cancelled may still be emitted afterwards
// if the drop destination does not accept any mime type.
//
// However, this event might however not be received if the compositor
// cancelled the drag-and-drop operation before this event could happen.
//
// Note that the data_source may still be used in the future and should
// not be destroyed here.
type WlDataSourceDndDropPerformedEvent struct {
}

// Opcode returns the event opcode for wl_data_source.dnd_drop_performed in wayland
func (WlDataSourceDndDropPerformedEvent) Opcode() uint16 { return 3 }

// MessageName returns the event name for wl_data_source.dnd_drop_performed in wayland
func (WlDataSourceDndDropPerformedEvent) MessageName() string { return "dnd_drop_performed" }

// Ensure WlDataSourceDndDropPerformedEvent implements Message.
var _ Message = WlDataSourceDndDropPerformedEvent{}

// Scan scans the event from the socket.
func (e *WlDataSourceDndDropPerformedEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure WlDataSourceDndDropPerformedEvent implements Event.
var _ Event = &WlDataSourceDndDropPerformedEvent{}

// WlDataSourceDndFinishedEvent signals when the drag-and-drop operation concluded
//
// The drop destination finished interoperating with this data
// source, so the client is now free to destroy this data source and
// free all associated data.
//
// If the action used to perform the operation was "move", the
// source can now delete the transferred data.
type WlDataSourceDndFinishedEvent struct {
}

// Opcode returns the event opcode for wl_data_source.dnd_finished in wayland
func (WlDataSourceDndFinishedEvent) Opcode() uint16 { return 4 }

// MessageName returns the event name for wl_data_source.dnd_finished in wayland
func (WlDataSourceDndFinishedEvent) MessageName() string { return "dnd_finished" }

// Ensure WlDataSourceDndFinishedEvent implements Message.
var _ Message = WlDataSourceDndFinishedEvent{}

// Scan scans the event from the socket.
func (e *WlDataSourceDndFinishedEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure WlDataSourceDndFinishedEvent implements Event.
var _ Event = &WlDataSourceDndFinishedEvent{}

// WlDataSourceActionEvent signals when notify the selected action
//
// This event indicates the action selected by the compositor after
// matching the source/destination side actions. Only one action (or
// none) will be offered here.
//
// This event can be emitted multiple times during the drag-and-drop
// operation, mainly in response to destination side changes through
// wl_data_offer.set_actions, and as the data device enters/leaves
// surfaces.
//
// It is only possible to receive this event after
// wl_data_source.dnd_drop_performed if the drag-and-drop operation
// ended in an "ask" action, in which case the final wl_data_source.action
// event will happen immediately before wl_data_source.dnd_finished.
//
// Compositors may also change the selected action on the fly, mainly
// in response to keyboard modifier changes during the drag-and-drop
// operation.
//
// The most recent action received is always the valid one. The chosen
// action may change alongside negotiation (e.g. an "ask" action can turn
// into a "move" operation), so the effects of the final action must
// always be applied in wl_data_offer.dnd_finished.
//
// Clients can trigger cursor surface changes from this point, so
// they reflect the current action.
type WlDataSourceActionEvent struct {
	// DndAction contains action selected by the compositor
	DndAction uint32
}

// Opcode returns the event opcode for wl_data_source.action in wayland
func (WlDataSourceActionEvent) Opcode() uint16 { return 5 }

// MessageName returns the event name for wl_data_source.action in wayland
func (WlDataSourceActionEvent) MessageName() string { return "action" }

// Ensure WlDataSourceActionEvent implements Message.
var _ Message = WlDataSourceActionEvent{}

// Scan scans the event from the socket.
func (e *WlDataSourceActionEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.DndAction = v
	}
	return nil
}

// Ensure WlDataSourceActionEvent implements Event.
var _ Event = &WlDataSourceActionEvent{}

// WlDataSource offer to transfer data
//
// The wl_data_source object is the source side of a wl_data_offer.
// It is created by the source client in a data transfer and
// provides a way to describe the offered data and a way to respond
// to requests to transfer the data.
type WlDataSource struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *WlDataSource) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (WlDataSource) Descriptor() *InterfaceDescriptor {
	return &WlDataSourceDescriptor
}

// Dispatch returns an Event object for a given opcode.
func (WlDataSource) Dispatch(opcode uint16) Event {
	switch opcode {
	case 0:
		return &WlDataSourceTargetEvent{}
	case 1:
		return &WlDataSourceSendEvent{}
	case 2:
		return &WlDataSourceCancelledEvent{}
	case 3:
		return &WlDataSourceDndDropPerformedEvent{}
	case 4:
		return &WlDataSourceDndFinishedEvent{}
	case 5:
		return &WlDataSourceActionEvent{}
	default:
		return nil
	}
}

// Offer requests to add an offered mime type
//
// This request adds a mime type to the set of mime types
// advertised to targets.  Can be called several times to offer
// multiple types.
func (proxy *WlDataSource) Offer(connection Connection, aMimeType string) (err error) {
	request := WlDataSourceOfferRequest{
		MimeType: aMimeType,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Destroy requests to destroy the data source
//
// Destroy the data source.
func (proxy *WlDataSource) Destroy(connection Connection) (err error) {
	request := WlDataSourceDestroyRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// SetActions requests to set the available drag-and-drop actions
//
// Sets the actions that the source side client supports for this
// operation. This request may trigger wl_data_source.action and
// wl_data_offer.action events if the compositor needs to change the
// selected action.
//
// The dnd_actions argument must contain only values expressed in the
// wl_data_device_manager.dnd_actions enum, otherwise it will result
// in a protocol error.
//
// This request must be made once only, and can only be made on sources
// used in drag-and-drop, so it must be performed before
// wl_data_device.start_drag. Attempting to use the source other than
// for drag-and-drop will raise a protocol error.
func (proxy *WlDataSource) SetActions(connection Connection, aDndActions uint32) (err error) {
	request := WlDataSourceSetActionsRequest{
		DndActions: aDndActions,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Ensure WlDataSource implements Proxy.
var _ Proxy = &WlDataSource{}

// #endregion Interface wayland.wl_data_source

// ----------------------------------------------------------------------------
// #region Interface wayland.wl_data_device

type WlDataDeviceError int

const (
	// WlDataDeviceErrorRole corresponds to given wl_surface has another role
	WlDataDeviceErrorRole WlDataDeviceError = 0
)

// WlDataDeviceStartDragRequest requests to start drag-and-drop operation
//
// This request asks the compositor to start a drag-and-drop
// operation on behalf of the client.
//
// The source argument is the data source that provides the data
// for the eventual data transfer. If source is NULL, enter, leave
// and motion events are sent only to the client that initiated the
// drag and the client is expected to handle the data passing
// internally. If source is destroyed, the drag-and-drop session will be
// cancelled.
//
// The origin surface is the surface where the drag originates and
// the client must have an active implicit grab that matches the
// serial.
//
// The icon surface is an optional (can be NULL) surface that
// provides an icon to be moved around with the cursor.  Initially,
// the top-left corner of the icon surface is placed at the cursor
// hotspot, but subsequent wl_surface.attach request can move the
// relative position. Attach requests must be confirmed with
// wl_surface.commit as usual. The icon surface is given the role of
// a drag-and-drop icon. If the icon surface already has another role,
// it raises a protocol error.
//
// The current and pending input regions of the icon wl_surface are
// cleared, and wl_surface.set_input_region is ignored until the
// wl_surface is no longer used as the icon surface. When the use
// as an icon ends, the current and pending input regions become
// undefined, and the wl_surface is unmapped.
type WlDataDeviceStartDragRequest struct {
	// Source contains data source for the eventual transfer
	Source ObjectID

	// Origin contains surface where the drag originates
	Origin ObjectID

	// Icon contains drag-and-drop icon surface
	Icon ObjectID

	// Serial contains serial number of the implicit grab on the origin
	Serial uint32
}

// Opcode returns the request opcode for wl_data_device.start_drag in wayland
func (WlDataDeviceStartDragRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for wl_data_device.start_drag in wayland
func (WlDataDeviceStartDragRequest) MessageName() string { return "start_drag" }

// Ensure WlDataDeviceStartDragRequest implements Message.
var _ Message = WlDataDeviceStartDragRequest{}

// Emit emits the message to the emitter.
func (r *WlDataDeviceStartDragRequest) Emit(e *RequestEmitter) error {
	if err := e.PutObjectID(r.Source); err != nil {
		return err
	}
	if err := e.PutObjectID(r.Origin); err != nil {
		return err
	}
	if err := e.PutObjectID(r.Icon); err != nil {
		return err
	}
	if err := e.PutUint(r.Serial); err != nil {
		return err
	}
	return nil
}

// Ensure WlDataDeviceStartDragRequest implements Request.
var _ Request = &WlDataDeviceStartDragRequest{}

// WlDataDeviceSetSelectionRequest requests to copy data to the selection
//
// This request asks the compositor to set the selection
// to the data from the source on behalf of the client.
//
// To unset the selection, set the source to NULL.
type WlDataDeviceSetSelectionRequest struct {
	// Source contains data source for the selection
	Source ObjectID

	// Serial contains serial number of the event that triggered this request
	Serial uint32
}

// Opcode returns the request opcode for wl_data_device.set_selection in wayland
func (WlDataDeviceSetSelectionRequest) Opcode() uint16 { return 1 }

// MessageName returns the request name for wl_data_device.set_selection in wayland
func (WlDataDeviceSetSelectionRequest) MessageName() string { return "set_selection" }

// Ensure WlDataDeviceSetSelectionRequest implements Message.
var _ Message = WlDataDeviceSetSelectionRequest{}

// Emit emits the message to the emitter.
func (r *WlDataDeviceSetSelectionRequest) Emit(e *RequestEmitter) error {
	if err := e.PutObjectID(r.Source); err != nil {
		return err
	}
	if err := e.PutUint(r.Serial); err != nil {
		return err
	}
	return nil
}

// Ensure WlDataDeviceSetSelectionRequest implements Request.
var _ Request = &WlDataDeviceSetSelectionRequest{}

// WlDataDeviceReleaseRequest requests to destroy data device
//
// This request destroys the data device.
type WlDataDeviceReleaseRequest struct {
}

// Opcode returns the request opcode for wl_data_device.release in wayland
func (WlDataDeviceReleaseRequest) Opcode() uint16 { return 2 }

// MessageName returns the request name for wl_data_device.release in wayland
func (WlDataDeviceReleaseRequest) MessageName() string { return "release" }

// Ensure WlDataDeviceReleaseRequest implements Message.
var _ Message = WlDataDeviceReleaseRequest{}

// Emit emits the message to the emitter.
func (r *WlDataDeviceReleaseRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure WlDataDeviceReleaseRequest implements Request.
var _ Request = &WlDataDeviceReleaseRequest{}

// WlDataDeviceDataOfferEvent signals when introduce a new wl_data_offer
//
// The data_offer event introduces a new wl_data_offer object,
// which will subsequently be used in either the
// data_device.enter event (for drag-and-drop) or the
// data_device.selection event (for selections).  Immediately
// following the data_device_data_offer event, the new data_offer
// object will send out data_offer.offer events to describe the
// mime types it offers.
type WlDataDeviceDataOfferEvent struct {
	// ID contains the new data_offer object
	ID ObjectID
}

// Opcode returns the event opcode for wl_data_device.data_offer in wayland
func (WlDataDeviceDataOfferEvent) Opcode() uint16 { return 0 }

// MessageName returns the event name for wl_data_device.data_offer in wayland
func (WlDataDeviceDataOfferEvent) MessageName() string { return "data_offer" }

// Ensure WlDataDeviceDataOfferEvent implements Message.
var _ Message = WlDataDeviceDataOfferEvent{}

// Scan scans the event from the socket.
func (e *WlDataDeviceDataOfferEvent) Scan(s *EventScanner) error {
	if v, err := s.ObjectID(); err != nil {
		return err
	} else {
		e.ID = v
	}
	return nil
}

// Ensure WlDataDeviceDataOfferEvent implements Event.
var _ Event = &WlDataDeviceDataOfferEvent{}

// WlDataDeviceEnterEvent signals when initiate drag-and-drop session
//
// This event is sent when an active drag-and-drop pointer enters
// a surface owned by the client.  The position of the pointer at
// enter time is provided by the x and y arguments, in surface-local
// coordinates.
type WlDataDeviceEnterEvent struct {
	// Serial contains serial number of the enter event
	Serial uint32

	// Surface contains client surface entered
	Surface ObjectID

	// X contains surface-local x coordinate
	X Fixed

	// Y contains surface-local y coordinate
	Y Fixed

	// ID contains source data_offer object
	ID ObjectID
}

// Opcode returns the event opcode for wl_data_device.enter in wayland
func (WlDataDeviceEnterEvent) Opcode() uint16 { return 1 }

// MessageName returns the event name for wl_data_device.enter in wayland
func (WlDataDeviceEnterEvent) MessageName() string { return "enter" }

// Ensure WlDataDeviceEnterEvent implements Message.
var _ Message = WlDataDeviceEnterEvent{}

// Scan scans the event from the socket.
func (e *WlDataDeviceEnterEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Serial = v
	}
	if v, err := s.ObjectID(); err != nil {
		return err
	} else {
		e.Surface = v
	}
	if v, err := s.Fixed(); err != nil {
		return err
	} else {
		e.X = v
	}
	if v, err := s.Fixed(); err != nil {
		return err
	} else {
		e.Y = v
	}
	if v, err := s.ObjectID(); err != nil {
		return err
	} else {
		e.ID = v
	}
	return nil
}

// Ensure WlDataDeviceEnterEvent implements Event.
var _ Event = &WlDataDeviceEnterEvent{}

// WlDataDeviceLeaveEvent signals when end drag-and-drop session
//
// This event is sent when the drag-and-drop pointer leaves the
// surface and the session ends.  The client must destroy the
// wl_data_offer introduced at enter time at this point.
type WlDataDeviceLeaveEvent struct {
}

// Opcode returns the event opcode for wl_data_device.leave in wayland
func (WlDataDeviceLeaveEvent) Opcode() uint16 { return 2 }

// MessageName returns the event name for wl_data_device.leave in wayland
func (WlDataDeviceLeaveEvent) MessageName() string { return "leave" }

// Ensure WlDataDeviceLeaveEvent implements Message.
var _ Message = WlDataDeviceLeaveEvent{}

// Scan scans the event from the socket.
func (e *WlDataDeviceLeaveEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure WlDataDeviceLeaveEvent implements Event.
var _ Event = &WlDataDeviceLeaveEvent{}

// WlDataDeviceMotionEvent signals when drag-and-drop session motion
//
// This event is sent when the drag-and-drop pointer moves within
// the currently focused surface. The new position of the pointer
// is provided by the x and y arguments, in surface-local
// coordinates.
type WlDataDeviceMotionEvent struct {
	// Time contains timestamp with millisecond granularity
	Time uint32

	// X contains surface-local x coordinate
	X Fixed

	// Y contains surface-local y coordinate
	Y Fixed
}

// Opcode returns the event opcode for wl_data_device.motion in wayland
func (WlDataDeviceMotionEvent) Opcode() uint16 { return 3 }

// MessageName returns the event name for wl_data_device.motion in wayland
func (WlDataDeviceMotionEvent) MessageName() string { return "motion" }

// Ensure WlDataDeviceMotionEvent implements Message.
var _ Message = WlDataDeviceMotionEvent{}

// Scan scans the event from the socket.
func (e *WlDataDeviceMotionEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Time = v
	}
	if v, err := s.Fixed(); err != nil {
		return err
	} else {
		e.X = v
	}
	if v, err := s.Fixed(); err != nil {
		return err
	} else {
		e.Y = v
	}
	return nil
}

// Ensure WlDataDeviceMotionEvent implements Event.
var _ Event = &WlDataDeviceMotionEvent{}

// WlDataDeviceDropEvent signals when end drag-and-drop session successfully
//
// The event is sent when a drag-and-drop operation is ended
// because the implicit grab is removed.
//
// The drag-and-drop destination is expected to honor the last action
// received through wl_data_offer.action, if the resulting action is
// "copy" or "move", the destination can still perform
// wl_data_offer.receive requests, and is expected to end all
// transfers with a wl_data_offer.finish request.
//
// If the resulting action is "ask", the action will not be considered
// final. The drag-and-drop destination is expected to perform one last
// wl_data_offer.set_actions request, or wl_data_offer.destroy in order
// to cancel the operation.
type WlDataDeviceDropEvent struct {
}

// Opcode returns the event opcode for wl_data_device.drop in wayland
func (WlDataDeviceDropEvent) Opcode() uint16 { return 4 }

// MessageName returns the event name for wl_data_device.drop in wayland
func (WlDataDeviceDropEvent) MessageName() string { return "drop" }

// Ensure WlDataDeviceDropEvent implements Message.
var _ Message = WlDataDeviceDropEvent{}

// Scan scans the event from the socket.
func (e *WlDataDeviceDropEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure WlDataDeviceDropEvent implements Event.
var _ Event = &WlDataDeviceDropEvent{}

// WlDataDeviceSelectionEvent signals when advertise new selection
//
// The selection event is sent out to notify the client of a new
// wl_data_offer for the selection for this device.  The
// data_device.data_offer and the data_offer.offer events are
// sent out immediately before this event to introduce the data
// offer object.  The selection event is sent to a client
// immediately before receiving keyboard focus and when a new
// selection is set while the client has keyboard focus.  The
// data_offer is valid until a new data_offer or NULL is received
// or until the client loses keyboard focus.  The client must
// destroy the previous selection data_offer, if any, upon receiving
// this event.
type WlDataDeviceSelectionEvent struct {
	// ID contains selection data_offer object
	ID ObjectID
}

// Opcode returns the event opcode for wl_data_device.selection in wayland
func (WlDataDeviceSelectionEvent) Opcode() uint16 { return 5 }

// MessageName returns the event name for wl_data_device.selection in wayland
func (WlDataDeviceSelectionEvent) MessageName() string { return "selection" }

// Ensure WlDataDeviceSelectionEvent implements Message.
var _ Message = WlDataDeviceSelectionEvent{}

// Scan scans the event from the socket.
func (e *WlDataDeviceSelectionEvent) Scan(s *EventScanner) error {
	if v, err := s.ObjectID(); err != nil {
		return err
	} else {
		e.ID = v
	}
	return nil
}

// Ensure WlDataDeviceSelectionEvent implements Event.
var _ Event = &WlDataDeviceSelectionEvent{}

// WlDataDevice data transfer device
//
// There is one wl_data_device per seat which can be obtained
// from the global wl_data_device_manager singleton.
//
// A wl_data_device provides access to inter-client data transfer
// mechanisms such as copy-and-paste and drag-and-drop.
type WlDataDevice struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *WlDataDevice) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (WlDataDevice) Descriptor() *InterfaceDescriptor {
	return &WlDataDeviceDescriptor
}

// Dispatch returns an Event object for a given opcode.
func (WlDataDevice) Dispatch(opcode uint16) Event {
	switch opcode {
	case 0:
		return &WlDataDeviceDataOfferEvent{}
	case 1:
		return &WlDataDeviceEnterEvent{}
	case 2:
		return &WlDataDeviceLeaveEvent{}
	case 3:
		return &WlDataDeviceMotionEvent{}
	case 4:
		return &WlDataDeviceDropEvent{}
	case 5:
		return &WlDataDeviceSelectionEvent{}
	default:
		return nil
	}
}

// StartDrag requests to start drag-and-drop operation
//
// This request asks the compositor to start a drag-and-drop
// operation on behalf of the client.
//
// The source argument is the data source that provides the data
// for the eventual data transfer. If source is NULL, enter, leave
// and motion events are sent only to the client that initiated the
// drag and the client is expected to handle the data passing
// internally. If source is destroyed, the drag-and-drop session will be
// cancelled.
//
// The origin surface is the surface where the drag originates and
// the client must have an active implicit grab that matches the
// serial.
//
// The icon surface is an optional (can be NULL) surface that
// provides an icon to be moved around with the cursor.  Initially,
// the top-left corner of the icon surface is placed at the cursor
// hotspot, but subsequent wl_surface.attach request can move the
// relative position. Attach requests must be confirmed with
// wl_surface.commit as usual. The icon surface is given the role of
// a drag-and-drop icon. If the icon surface already has another role,
// it raises a protocol error.
//
// The current and pending input regions of the icon wl_surface are
// cleared, and wl_surface.set_input_region is ignored until the
// wl_surface is no longer used as the icon surface. When the use
// as an icon ends, the current and pending input regions become
// undefined, and the wl_surface is unmapped.
func (proxy *WlDataDevice) StartDrag(connection Connection, aSource ObjectID, aOrigin ObjectID, aIcon ObjectID, aSerial uint32) (err error) {
	request := WlDataDeviceStartDragRequest{
		Source: aSource,
		Origin: aOrigin,
		Icon:   aIcon,
		Serial: aSerial,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// SetSelection requests to copy data to the selection
//
// This request asks the compositor to set the selection
// to the data from the source on behalf of the client.
//
// To unset the selection, set the source to NULL.
func (proxy *WlDataDevice) SetSelection(connection Connection, aSource ObjectID, aSerial uint32) (err error) {
	request := WlDataDeviceSetSelectionRequest{
		Source: aSource,
		Serial: aSerial,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Release requests to destroy data device
//
// This request destroys the data device.
func (proxy *WlDataDevice) Release(connection Connection) (err error) {
	request := WlDataDeviceReleaseRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Ensure WlDataDevice implements Proxy.
var _ Proxy = &WlDataDevice{}

// #endregion Interface wayland.wl_data_device

// ----------------------------------------------------------------------------
// #region Interface wayland.wl_data_device_manager

// WlDataDeviceManagerDndAction represents drag and drop actions
//
// This is a bitmask of the available/preferred actions in a
// drag-and-drop operation.
//
// In the compositor, the selected action is a result of matching the
// actions offered by the source and destination sides.  "action" events
// with a "none" action will be sent to both source and destination if
// there is no match. All further checks will effectively happen on
// (source actions ∩ destination actions).
//
// In addition, compositors may also pick different actions in
// reaction to key modifiers being pressed. One common design that
// is used in major toolkits (and the behavior recommended for
// compositors) is:
//
// - If no modifiers are pressed, the first match (in bit order)
// will be used.
// - Pressing Shift selects "move", if enabled in the mask.
// - Pressing Control selects "copy", if enabled in the mask.
//
// Behavior beyond that is considered implementation-dependent.
// Compositors may for example bind other modifiers (like Alt/Meta)
// or drags initiated with other buttons than BTN_LEFT to specific
// actions (e.g. "ask").
type WlDataDeviceManagerDndAction uint

const (
	// WlDataDeviceManagerDndActionNone corresponds to no action
	WlDataDeviceManagerDndActionNone WlDataDeviceManagerDndAction = 0

	// WlDataDeviceManagerDndActionCopy corresponds to copy action
	WlDataDeviceManagerDndActionCopy WlDataDeviceManagerDndAction = 1

	// WlDataDeviceManagerDndActionMove corresponds to move action
	WlDataDeviceManagerDndActionMove WlDataDeviceManagerDndAction = 2

	// WlDataDeviceManagerDndActionAsk corresponds to ask action
	WlDataDeviceManagerDndActionAsk WlDataDeviceManagerDndAction = 4
)

// WlDataDeviceManagerCreateDataSourceRequest requests to create a new data source
//
// Create a new data source.
type WlDataDeviceManagerCreateDataSourceRequest struct {
	// ID contains data source to create
	ID ObjectID
}

// Opcode returns the request opcode for wl_data_device_manager.create_data_source in wayland
func (WlDataDeviceManagerCreateDataSourceRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for wl_data_device_manager.create_data_source in wayland
func (WlDataDeviceManagerCreateDataSourceRequest) MessageName() string { return "create_data_source" }

// Ensure WlDataDeviceManagerCreateDataSourceRequest implements Message.
var _ Message = WlDataDeviceManagerCreateDataSourceRequest{}

// Emit emits the message to the emitter.
func (r *WlDataDeviceManagerCreateDataSourceRequest) Emit(e *RequestEmitter) error {
	if err := e.PutObjectID(r.ID); err != nil {
		return err
	}
	return nil
}

// Ensure WlDataDeviceManagerCreateDataSourceRequest implements Request.
var _ Request = &WlDataDeviceManagerCreateDataSourceRequest{}

// WlDataDeviceManagerGetDataDeviceRequest requests to create a new data device
//
// Create a new data device for a given seat.
type WlDataDeviceManagerGetDataDeviceRequest struct {
	// ID contains data device to create
	ID ObjectID

	// Seat contains seat associated with the data device
	Seat ObjectID
}

// Opcode returns the request opcode for wl_data_device_manager.get_data_device in wayland
func (WlDataDeviceManagerGetDataDeviceRequest) Opcode() uint16 { return 1 }

// MessageName returns the request name for wl_data_device_manager.get_data_device in wayland
func (WlDataDeviceManagerGetDataDeviceRequest) MessageName() string { return "get_data_device" }

// Ensure WlDataDeviceManagerGetDataDeviceRequest implements Message.
var _ Message = WlDataDeviceManagerGetDataDeviceRequest{}

// Emit emits the message to the emitter.
func (r *WlDataDeviceManagerGetDataDeviceRequest) Emit(e *RequestEmitter) error {
	if err := e.PutObjectID(r.ID); err != nil {
		return err
	}
	if err := e.PutObjectID(r.Seat); err != nil {
		return err
	}
	return nil
}

// Ensure WlDataDeviceManagerGetDataDeviceRequest implements Request.
var _ Request = &WlDataDeviceManagerGetDataDeviceRequest{}

// WlDataDeviceManager data transfer interface
//
// The wl_data_device_manager is a singleton global object that
// provides access to inter-client data transfer mechanisms such as
// copy-and-paste and drag-and-drop.  These mechanisms are tied to
// a wl_seat and this interface lets a client get a wl_data_device
// corresponding to a wl_seat.
//
// Depending on the version bound, the objects created from the bound
// wl_data_device_manager object will have different requirements for
// functioning properly. See wl_data_source.set_actions,
// wl_data_offer.accept and wl_data_offer.finish for details.
type WlDataDeviceManager struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *WlDataDeviceManager) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (WlDataDeviceManager) Descriptor() *InterfaceDescriptor {
	return &WlDataDeviceManagerDescriptor
}

// Dispatch returns an Event object for a given opcode.
func (WlDataDeviceManager) Dispatch(opcode uint16) Event {
	switch opcode {
	default:
		return nil
	}
}

// CreateDataSource requests to create a new data source
//
// Create a new data source.
func (proxy *WlDataDeviceManager) CreateDataSource(connection Connection) (aID *WlDataSource, err error) {
	aID = &WlDataSource{connection.NewID()}
	request := WlDataDeviceManagerCreateDataSourceRequest{
		ID: aID.id,
	}
	err = connection.SendRequest(proxy.id, &request)
	if err == nil {
		connection.RegisterProxy(aID)
	}
	return
}

// GetDataDevice requests to create a new data device
//
// Create a new data device for a given seat.
func (proxy *WlDataDeviceManager) GetDataDevice(connection Connection, aSeat ObjectID) (aID *WlDataDevice, err error) {
	aID = &WlDataDevice{connection.NewID()}
	request := WlDataDeviceManagerGetDataDeviceRequest{
		ID:   aID.id,
		Seat: aSeat,
	}
	err = connection.SendRequest(proxy.id, &request)
	if err == nil {
		connection.RegisterProxy(aID)
	}
	return
}

// Ensure WlDataDeviceManager implements Proxy.
var _ Proxy = &WlDataDeviceManager{}

// #endregion Interface wayland.wl_data_device_manager

// ----------------------------------------------------------------------------
// #region Interface wayland.wl_shell

type WlShellError int

const (
	// WlShellErrorRole corresponds to given wl_surface has another role
	WlShellErrorRole WlShellError = 0
)

// WlShellGetShellSurfaceRequest requests to create a shell surface from a surface
//
// Create a shell surface for an existing surface. This gives
// the wl_surface the role of a shell surface. If the wl_surface
// already has another role, it raises a protocol error.
//
// Only one shell surface can be associated with a given surface.
type WlShellGetShellSurfaceRequest struct {
	// ID contains shell surface to create
	ID ObjectID

	// Surface contains surface to be given the shell surface role
	Surface ObjectID
}

// Opcode returns the request opcode for wl_shell.get_shell_surface in wayland
func (WlShellGetShellSurfaceRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for wl_shell.get_shell_surface in wayland
func (WlShellGetShellSurfaceRequest) MessageName() string { return "get_shell_surface" }

// Ensure WlShellGetShellSurfaceRequest implements Message.
var _ Message = WlShellGetShellSurfaceRequest{}

// Emit emits the message to the emitter.
func (r *WlShellGetShellSurfaceRequest) Emit(e *RequestEmitter) error {
	if err := e.PutObjectID(r.ID); err != nil {
		return err
	}
	if err := e.PutObjectID(r.Surface); err != nil {
		return err
	}
	return nil
}

// Ensure WlShellGetShellSurfaceRequest implements Request.
var _ Request = &WlShellGetShellSurfaceRequest{}

// WlShell create desktop-style surfaces
//
// This interface is implemented by servers that provide
// desktop-style user interfaces.
//
// It allows clients to associate a wl_shell_surface with
// a basic surface.
//
// Note! This protocol is deprecated and not intended for production use.
// For desktop-style user interfaces, use xdg_shell.
type WlShell struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *WlShell) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (WlShell) Descriptor() *InterfaceDescriptor {
	return &WlShellDescriptor
}

// Dispatch returns an Event object for a given opcode.
func (WlShell) Dispatch(opcode uint16) Event {
	switch opcode {
	default:
		return nil
	}
}

// GetShellSurface requests to create a shell surface from a surface
//
// Create a shell surface for an existing surface. This gives
// the wl_surface the role of a shell surface. If the wl_surface
// already has another role, it raises a protocol error.
//
// Only one shell surface can be associated with a given surface.
func (proxy *WlShell) GetShellSurface(connection Connection, aSurface ObjectID) (aID *WlShellSurface, err error) {
	aID = &WlShellSurface{connection.NewID()}
	request := WlShellGetShellSurfaceRequest{
		ID:      aID.id,
		Surface: aSurface,
	}
	err = connection.SendRequest(proxy.id, &request)
	if err == nil {
		connection.RegisterProxy(aID)
	}
	return
}

// Ensure WlShell implements Proxy.
var _ Proxy = &WlShell{}

// #endregion Interface wayland.wl_shell

// ----------------------------------------------------------------------------
// #region Interface wayland.wl_shell_surface

// WlShellSurfaceResize represents edge values for resizing
//
// These values are used to indicate which edge of a surface
// is being dragged in a resize operation. The server may
// use this information to adapt its behavior, e.g. choose
// an appropriate cursor image.
type WlShellSurfaceResize uint

const (
	// WlShellSurfaceResizeNone corresponds to no edge
	WlShellSurfaceResizeNone WlShellSurfaceResize = 0

	// WlShellSurfaceResizeTop corresponds to top edge
	WlShellSurfaceResizeTop WlShellSurfaceResize = 1

	// WlShellSurfaceResizeBottom corresponds to bottom edge
	WlShellSurfaceResizeBottom WlShellSurfaceResize = 2

	// WlShellSurfaceResizeLeft corresponds to left edge
	WlShellSurfaceResizeLeft WlShellSurfaceResize = 4

	// WlShellSurfaceResizeTopLeft corresponds to top and left edges
	WlShellSurfaceResizeTopLeft WlShellSurfaceResize = 5

	// WlShellSurfaceResizeBottomLeft corresponds to bottom and left edges
	WlShellSurfaceResizeBottomLeft WlShellSurfaceResize = 6

	// WlShellSurfaceResizeRight corresponds to right edge
	WlShellSurfaceResizeRight WlShellSurfaceResize = 8

	// WlShellSurfaceResizeTopRight corresponds to top and right edges
	WlShellSurfaceResizeTopRight WlShellSurfaceResize = 9

	// WlShellSurfaceResizeBottomRight corresponds to bottom and right edges
	WlShellSurfaceResizeBottomRight WlShellSurfaceResize = 10
)

// WlShellSurfaceTransient represents details of transient behaviour
//
// These flags specify details of the expected behaviour
// of transient surfaces. Used in the set_transient request.
type WlShellSurfaceTransient uint

const (
	// WlShellSurfaceTransientInactive corresponds to do not set keyboard focus
	WlShellSurfaceTransientInactive WlShellSurfaceTransient = 0x1
)

// WlShellSurfaceFullscreenMethod represents different method to set the surface fullscreen
//
// Hints to indicate to the compositor how to deal with a conflict
// between the dimensions of the surface and the dimensions of the
// output. The compositor is free to ignore this parameter.
type WlShellSurfaceFullscreenMethod int

const (
	// WlShellSurfaceFullscreenMethodDefault corresponds to no preference, apply default policy
	WlShellSurfaceFullscreenMethodDefault WlShellSurfaceFullscreenMethod = 0

	// WlShellSurfaceFullscreenMethodScale corresponds to scale, preserve the surface's aspect ratio and center on output
	WlShellSurfaceFullscreenMethodScale WlShellSurfaceFullscreenMethod = 1

	// WlShellSurfaceFullscreenMethodDriver corresponds to switch output mode to the smallest mode that can fit the surface, add black borders to compensate size mismatch
	WlShellSurfaceFullscreenMethodDriver WlShellSurfaceFullscreenMethod = 2

	// WlShellSurfaceFullscreenMethodFill corresponds to no upscaling, center on output and add black borders to compensate size mismatch
	WlShellSurfaceFullscreenMethodFill WlShellSurfaceFullscreenMethod = 3
)

// WlShellSurfacePongRequest requests to respond to a ping event
//
// A client must respond to a ping event with a pong request or
// the client may be deemed unresponsive.
type WlShellSurfacePongRequest struct {
	// Serial contains serial number of the ping event
	Serial uint32
}

// Opcode returns the request opcode for wl_shell_surface.pong in wayland
func (WlShellSurfacePongRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for wl_shell_surface.pong in wayland
func (WlShellSurfacePongRequest) MessageName() string { return "pong" }

// Ensure WlShellSurfacePongRequest implements Message.
var _ Message = WlShellSurfacePongRequest{}

// Emit emits the message to the emitter.
func (r *WlShellSurfacePongRequest) Emit(e *RequestEmitter) error {
	if err := e.PutUint(r.Serial); err != nil {
		return err
	}
	return nil
}

// Ensure WlShellSurfacePongRequest implements Request.
var _ Request = &WlShellSurfacePongRequest{}

// WlShellSurfaceMoveRequest requests to start an interactive move
//
// Start a pointer-driven move of the surface.
//
// This request must be used in response to a button press event.
// The server may ignore move requests depending on the state of
// the surface (e.g. fullscreen or maximized).
type WlShellSurfaceMoveRequest struct {
	// Seat contains seat whose pointer is used
	Seat ObjectID

	// Serial contains serial number of the implicit grab on the pointer
	Serial uint32
}

// Opcode returns the request opcode for wl_shell_surface.move in wayland
func (WlShellSurfaceMoveRequest) Opcode() uint16 { return 1 }

// MessageName returns the request name for wl_shell_surface.move in wayland
func (WlShellSurfaceMoveRequest) MessageName() string { return "move" }

// Ensure WlShellSurfaceMoveRequest implements Message.
var _ Message = WlShellSurfaceMoveRequest{}

// Emit emits the message to the emitter.
func (r *WlShellSurfaceMoveRequest) Emit(e *RequestEmitter) error {
	if err := e.PutObjectID(r.Seat); err != nil {
		return err
	}
	if err := e.PutUint(r.Serial); err != nil {
		return err
	}
	return nil
}

// Ensure WlShellSurfaceMoveRequest implements Request.
var _ Request = &WlShellSurfaceMoveRequest{}

// WlShellSurfaceResizeRequest requests to start an interactive resize
//
// Start a pointer-driven resizing of the surface.
//
// This request must be used in response to a button press event.
// The server may ignore resize requests depending on the state of
// the surface (e.g. fullscreen or maximized).
type WlShellSurfaceResizeRequest struct {
	// Seat contains seat whose pointer is used
	Seat ObjectID

	// Serial contains serial number of the implicit grab on the pointer
	Serial uint32

	// Edges contains which edge or corner is being dragged
	Edges uint32
}

// Opcode returns the request opcode for wl_shell_surface.resize in wayland
func (WlShellSurfaceResizeRequest) Opcode() uint16 { return 2 }

// MessageName returns the request name for wl_shell_surface.resize in wayland
func (WlShellSurfaceResizeRequest) MessageName() string { return "resize" }

// Ensure WlShellSurfaceResizeRequest implements Message.
var _ Message = WlShellSurfaceResizeRequest{}

// Emit emits the message to the emitter.
func (r *WlShellSurfaceResizeRequest) Emit(e *RequestEmitter) error {
	if err := e.PutObjectID(r.Seat); err != nil {
		return err
	}
	if err := e.PutUint(r.Serial); err != nil {
		return err
	}
	if err := e.PutUint(r.Edges); err != nil {
		return err
	}
	return nil
}

// Ensure WlShellSurfaceResizeRequest implements Request.
var _ Request = &WlShellSurfaceResizeRequest{}

// WlShellSurfaceSetToplevelRequest requests to make the surface a toplevel surface
//
// Map the surface as a toplevel surface.
//
// A toplevel surface is not fullscreen, maximized or transient.
type WlShellSurfaceSetToplevelRequest struct {
}

// Opcode returns the request opcode for wl_shell_surface.set_toplevel in wayland
func (WlShellSurfaceSetToplevelRequest) Opcode() uint16 { return 3 }

// MessageName returns the request name for wl_shell_surface.set_toplevel in wayland
func (WlShellSurfaceSetToplevelRequest) MessageName() string { return "set_toplevel" }

// Ensure WlShellSurfaceSetToplevelRequest implements Message.
var _ Message = WlShellSurfaceSetToplevelRequest{}

// Emit emits the message to the emitter.
func (r *WlShellSurfaceSetToplevelRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure WlShellSurfaceSetToplevelRequest implements Request.
var _ Request = &WlShellSurfaceSetToplevelRequest{}

// WlShellSurfaceSetTransientRequest requests to make the surface a transient surface
//
// Map the surface relative to an existing surface.
//
// The x and y arguments specify the location of the upper left
// corner of the surface relative to the upper left corner of the
// parent surface, in surface-local coordinates.
//
// The flags argument controls details of the transient behaviour.
type WlShellSurfaceSetTransientRequest struct {
	// Parent contains parent surface
	Parent ObjectID

	// X contains surface-local x coordinate
	X int32

	// Y contains surface-local y coordinate
	Y int32

	// Flags contains transient surface behavior
	Flags uint32
}

// Opcode returns the request opcode for wl_shell_surface.set_transient in wayland
func (WlShellSurfaceSetTransientRequest) Opcode() uint16 { return 4 }

// MessageName returns the request name for wl_shell_surface.set_transient in wayland
func (WlShellSurfaceSetTransientRequest) MessageName() string { return "set_transient" }

// Ensure WlShellSurfaceSetTransientRequest implements Message.
var _ Message = WlShellSurfaceSetTransientRequest{}

// Emit emits the message to the emitter.
func (r *WlShellSurfaceSetTransientRequest) Emit(e *RequestEmitter) error {
	if err := e.PutObjectID(r.Parent); err != nil {
		return err
	}
	if err := e.PutInt(r.X); err != nil {
		return err
	}
	if err := e.PutInt(r.Y); err != nil {
		return err
	}
	if err := e.PutUint(r.Flags); err != nil {
		return err
	}
	return nil
}

// Ensure WlShellSurfaceSetTransientRequest implements Request.
var _ Request = &WlShellSurfaceSetTransientRequest{}

// WlShellSurfaceSetFullscreenRequest requests to make the surface a fullscreen surface
//
// Map the surface as a fullscreen surface.
//
// If an output parameter is given then the surface will be made
// fullscreen on that output. If the client does not specify the
// output then the compositor will apply its policy - usually
// choosing the output on which the surface has the biggest surface
// area.
//
// The client may specify a method to resolve a size conflict
// between the output size and the surface size - this is provided
// through the method parameter.
//
// The framerate parameter is used only when the method is set
// to "driver", to indicate the preferred framerate. A value of 0
// indicates that the client does not care about framerate.  The
// framerate is specified in mHz, that is framerate of 60000 is 60Hz.
//
// A method of "scale" or "driver" implies a scaling operation of
// the surface, either via a direct scaling operation or a change of
// the output mode. This will override any kind of output scaling, so
// that mapping a surface with a buffer size equal to the mode can
// fill the screen independent of buffer_scale.
//
// A method of "fill" means we don't scale up the buffer, however
// any output scale is applied. This means that you may run into
// an edge case where the application maps a buffer with the same
// size of the output mode but buffer_scale 1 (thus making a
// surface larger than the output). In this case it is allowed to
// downscale the results to fit the screen.
//
// The compositor must reply to this request with a configure event
// with the dimensions for the output on which the surface will
// be made fullscreen.
type WlShellSurfaceSetFullscreenRequest struct {
	// Method contains method for resolving size conflict
	Method uint32

	// Framerate contains framerate in mHz
	Framerate uint32

	// Output contains output on which the surface is to be fullscreen
	Output ObjectID
}

// Opcode returns the request opcode for wl_shell_surface.set_fullscreen in wayland
func (WlShellSurfaceSetFullscreenRequest) Opcode() uint16 { return 5 }

// MessageName returns the request name for wl_shell_surface.set_fullscreen in wayland
func (WlShellSurfaceSetFullscreenRequest) MessageName() string { return "set_fullscreen" }

// Ensure WlShellSurfaceSetFullscreenRequest implements Message.
var _ Message = WlShellSurfaceSetFullscreenRequest{}

// Emit emits the message to the emitter.
func (r *WlShellSurfaceSetFullscreenRequest) Emit(e *RequestEmitter) error {
	if err := e.PutUint(r.Method); err != nil {
		return err
	}
	if err := e.PutUint(r.Framerate); err != nil {
		return err
	}
	if err := e.PutObjectID(r.Output); err != nil {
		return err
	}
	return nil
}

// Ensure WlShellSurfaceSetFullscreenRequest implements Request.
var _ Request = &WlShellSurfaceSetFullscreenRequest{}

// WlShellSurfaceSetPopupRequest requests to make the surface a popup surface
//
// Map the surface as a popup.
//
// A popup surface is a transient surface with an added pointer
// grab.
//
// An existing implicit grab will be changed to owner-events mode,
// and the popup grab will continue after the implicit grab ends
// (i.e. releasing the mouse button does not cause the popup to
// be unmapped).
//
// The popup grab continues until the window is destroyed or a
// mouse button is pressed in any other client's window. A click
// in any of the client's surfaces is reported as normal, however,
// clicks in other clients' surfaces will be discarded and trigger
// the callback.
//
// The x and y arguments specify the location of the upper left
// corner of the surface relative to the upper left corner of the
// parent surface, in surface-local coordinates.
type WlShellSurfaceSetPopupRequest struct {
	// Seat contains seat whose pointer is used
	Seat ObjectID

	// Serial contains serial number of the implicit grab on the pointer
	Serial uint32

	// Parent contains parent surface
	Parent ObjectID

	// X contains surface-local x coordinate
	X int32

	// Y contains surface-local y coordinate
	Y int32

	// Flags contains transient surface behavior
	Flags uint32
}

// Opcode returns the request opcode for wl_shell_surface.set_popup in wayland
func (WlShellSurfaceSetPopupRequest) Opcode() uint16 { return 6 }

// MessageName returns the request name for wl_shell_surface.set_popup in wayland
func (WlShellSurfaceSetPopupRequest) MessageName() string { return "set_popup" }

// Ensure WlShellSurfaceSetPopupRequest implements Message.
var _ Message = WlShellSurfaceSetPopupRequest{}

// Emit emits the message to the emitter.
func (r *WlShellSurfaceSetPopupRequest) Emit(e *RequestEmitter) error {
	if err := e.PutObjectID(r.Seat); err != nil {
		return err
	}
	if err := e.PutUint(r.Serial); err != nil {
		return err
	}
	if err := e.PutObjectID(r.Parent); err != nil {
		return err
	}
	if err := e.PutInt(r.X); err != nil {
		return err
	}
	if err := e.PutInt(r.Y); err != nil {
		return err
	}
	if err := e.PutUint(r.Flags); err != nil {
		return err
	}
	return nil
}

// Ensure WlShellSurfaceSetPopupRequest implements Request.
var _ Request = &WlShellSurfaceSetPopupRequest{}

// WlShellSurfaceSetMaximizedRequest requests to make the surface a maximized surface
//
// Map the surface as a maximized surface.
//
// If an output parameter is given then the surface will be
// maximized on that output. If the client does not specify the
// output then the compositor will apply its policy - usually
// choosing the output on which the surface has the biggest surface
// area.
//
// The compositor will reply with a configure event telling
// the expected new surface size. The operation is completed
// on the next buffer attach to this surface.
//
// A maximized surface typically fills the entire output it is
// bound to, except for desktop elements such as panels. This is
// the main difference between a maximized shell surface and a
// fullscreen shell surface.
//
// The details depend on the compositor implementation.
type WlShellSurfaceSetMaximizedRequest struct {
	// Output contains output on which the surface is to be maximized
	Output ObjectID
}

// Opcode returns the request opcode for wl_shell_surface.set_maximized in wayland
func (WlShellSurfaceSetMaximizedRequest) Opcode() uint16 { return 7 }

// MessageName returns the request name for wl_shell_surface.set_maximized in wayland
func (WlShellSurfaceSetMaximizedRequest) MessageName() string { return "set_maximized" }

// Ensure WlShellSurfaceSetMaximizedRequest implements Message.
var _ Message = WlShellSurfaceSetMaximizedRequest{}

// Emit emits the message to the emitter.
func (r *WlShellSurfaceSetMaximizedRequest) Emit(e *RequestEmitter) error {
	if err := e.PutObjectID(r.Output); err != nil {
		return err
	}
	return nil
}

// Ensure WlShellSurfaceSetMaximizedRequest implements Request.
var _ Request = &WlShellSurfaceSetMaximizedRequest{}

// WlShellSurfaceSetTitleRequest requests to set surface title
//
// Set a short title for the surface.
//
// This string may be used to identify the surface in a task bar,
// window list, or other user interface elements provided by the
// compositor.
//
// The string must be encoded in UTF-8.
type WlShellSurfaceSetTitleRequest struct {
	// Title contains surface title
	Title string
}

// Opcode returns the request opcode for wl_shell_surface.set_title in wayland
func (WlShellSurfaceSetTitleRequest) Opcode() uint16 { return 8 }

// MessageName returns the request name for wl_shell_surface.set_title in wayland
func (WlShellSurfaceSetTitleRequest) MessageName() string { return "set_title" }

// Ensure WlShellSurfaceSetTitleRequest implements Message.
var _ Message = WlShellSurfaceSetTitleRequest{}

// Emit emits the message to the emitter.
func (r *WlShellSurfaceSetTitleRequest) Emit(e *RequestEmitter) error {
	if err := e.PutString(r.Title); err != nil {
		return err
	}
	return nil
}

// Ensure WlShellSurfaceSetTitleRequest implements Request.
var _ Request = &WlShellSurfaceSetTitleRequest{}

// WlShellSurfaceSetClassRequest requests to set surface class
//
// Set a class for the surface.
//
// The surface class identifies the general class of applications
// to which the surface belongs. A common convention is to use the
// file name (or the full path if it is a non-standard location) of
// the application's .desktop file as the class.
type WlShellSurfaceSetClassRequest struct {
	// Class contains surface class
	Class string
}

// Opcode returns the request opcode for wl_shell_surface.set_class in wayland
func (WlShellSurfaceSetClassRequest) Opcode() uint16 { return 9 }

// MessageName returns the request name for wl_shell_surface.set_class in wayland
func (WlShellSurfaceSetClassRequest) MessageName() string { return "set_class" }

// Ensure WlShellSurfaceSetClassRequest implements Message.
var _ Message = WlShellSurfaceSetClassRequest{}

// Emit emits the message to the emitter.
func (r *WlShellSurfaceSetClassRequest) Emit(e *RequestEmitter) error {
	if err := e.PutString(r.Class); err != nil {
		return err
	}
	return nil
}

// Ensure WlShellSurfaceSetClassRequest implements Request.
var _ Request = &WlShellSurfaceSetClassRequest{}

// WlShellSurfacePingEvent signals when ping client
//
// Ping a client to check if it is receiving events and sending
// requests. A client is expected to reply with a pong request.
type WlShellSurfacePingEvent struct {
	// Serial contains serial number of the ping
	Serial uint32
}

// Opcode returns the event opcode for wl_shell_surface.ping in wayland
func (WlShellSurfacePingEvent) Opcode() uint16 { return 0 }

// MessageName returns the event name for wl_shell_surface.ping in wayland
func (WlShellSurfacePingEvent) MessageName() string { return "ping" }

// Ensure WlShellSurfacePingEvent implements Message.
var _ Message = WlShellSurfacePingEvent{}

// Scan scans the event from the socket.
func (e *WlShellSurfacePingEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Serial = v
	}
	return nil
}

// Ensure WlShellSurfacePingEvent implements Event.
var _ Event = &WlShellSurfacePingEvent{}

// WlShellSurfaceConfigureEvent signals when suggest resize
//
// The configure event asks the client to resize its surface.
//
// The size is a hint, in the sense that the client is free to
// ignore it if it doesn't resize, pick a smaller size (to
// satisfy aspect ratio or resize in steps of NxM pixels).
//
// The edges parameter provides a hint about how the surface
// was resized. The client may use this information to decide
// how to adjust its content to the new size (e.g. a scrolling
// area might adjust its content position to leave the viewable
// content unmoved).
//
// The client is free to dismiss all but the last configure
// event it received.
//
// The width and height arguments specify the size of the window
// in surface-local coordinates.
type WlShellSurfaceConfigureEvent struct {
	// Edges contains how the surface was resized
	Edges uint32

	// Width contains new width of the surface
	Width int32

	// Height contains new height of the surface
	Height int32
}

// Opcode returns the event opcode for wl_shell_surface.configure in wayland
func (WlShellSurfaceConfigureEvent) Opcode() uint16 { return 1 }

// MessageName returns the event name for wl_shell_surface.configure in wayland
func (WlShellSurfaceConfigureEvent) MessageName() string { return "configure" }

// Ensure WlShellSurfaceConfigureEvent implements Message.
var _ Message = WlShellSurfaceConfigureEvent{}

// Scan scans the event from the socket.
func (e *WlShellSurfaceConfigureEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Edges = v
	}
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.Width = v
	}
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.Height = v
	}
	return nil
}

// Ensure WlShellSurfaceConfigureEvent implements Event.
var _ Event = &WlShellSurfaceConfigureEvent{}

// WlShellSurfacePopupDoneEvent signals when popup interaction is done
//
// The popup_done event is sent out when a popup grab is broken,
// that is, when the user clicks a surface that doesn't belong
// to the client owning the popup surface.
type WlShellSurfacePopupDoneEvent struct {
}

// Opcode returns the event opcode for wl_shell_surface.popup_done in wayland
func (WlShellSurfacePopupDoneEvent) Opcode() uint16 { return 2 }

// MessageName returns the event name for wl_shell_surface.popup_done in wayland
func (WlShellSurfacePopupDoneEvent) MessageName() string { return "popup_done" }

// Ensure WlShellSurfacePopupDoneEvent implements Message.
var _ Message = WlShellSurfacePopupDoneEvent{}

// Scan scans the event from the socket.
func (e *WlShellSurfacePopupDoneEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure WlShellSurfacePopupDoneEvent implements Event.
var _ Event = &WlShellSurfacePopupDoneEvent{}

// WlShellSurface desktop-style metadata interface
//
// An interface that may be implemented by a wl_surface, for
// implementations that provide a desktop-style user interface.
//
// It provides requests to treat surfaces like toplevel, fullscreen
// or popup windows, move, resize or maximize them, associate
// metadata like title and class, etc.
//
// On the server side the object is automatically destroyed when
// the related wl_surface is destroyed. On the client side,
// wl_shell_surface_destroy() must be called before destroying
// the wl_surface object.
type WlShellSurface struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *WlShellSurface) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (WlShellSurface) Descriptor() *InterfaceDescriptor {
	return &WlShellSurfaceDescriptor
}

// Dispatch returns an Event object for a given opcode.
func (WlShellSurface) Dispatch(opcode uint16) Event {
	switch opcode {
	case 0:
		return &WlShellSurfacePingEvent{}
	case 1:
		return &WlShellSurfaceConfigureEvent{}
	case 2:
		return &WlShellSurfacePopupDoneEvent{}
	default:
		return nil
	}
}

// Pong requests to respond to a ping event
//
// A client must respond to a ping event with a pong request or
// the client may be deemed unresponsive.
func (proxy *WlShellSurface) Pong(connection Connection, aSerial uint32) (err error) {
	request := WlShellSurfacePongRequest{
		Serial: aSerial,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Move requests to start an interactive move
//
// Start a pointer-driven move of the surface.
//
// This request must be used in response to a button press event.
// The server may ignore move requests depending on the state of
// the surface (e.g. fullscreen or maximized).
func (proxy *WlShellSurface) Move(connection Connection, aSeat ObjectID, aSerial uint32) (err error) {
	request := WlShellSurfaceMoveRequest{
		Seat:   aSeat,
		Serial: aSerial,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Resize requests to start an interactive resize
//
// Start a pointer-driven resizing of the surface.
//
// This request must be used in response to a button press event.
// The server may ignore resize requests depending on the state of
// the surface (e.g. fullscreen or maximized).
func (proxy *WlShellSurface) Resize(connection Connection, aSeat ObjectID, aSerial uint32, aEdges uint32) (err error) {
	request := WlShellSurfaceResizeRequest{
		Seat:   aSeat,
		Serial: aSerial,
		Edges:  aEdges,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// SetToplevel requests to make the surface a toplevel surface
//
// Map the surface as a toplevel surface.
//
// A toplevel surface is not fullscreen, maximized or transient.
func (proxy *WlShellSurface) SetToplevel(connection Connection) (err error) {
	request := WlShellSurfaceSetToplevelRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// SetTransient requests to make the surface a transient surface
//
// Map the surface relative to an existing surface.
//
// The x and y arguments specify the location of the upper left
// corner of the surface relative to the upper left corner of the
// parent surface, in surface-local coordinates.
//
// The flags argument controls details of the transient behaviour.
func (proxy *WlShellSurface) SetTransient(connection Connection, aParent ObjectID, aX int32, aY int32, aFlags uint32) (err error) {
	request := WlShellSurfaceSetTransientRequest{
		Parent: aParent,
		X:      aX,
		Y:      aY,
		Flags:  aFlags,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// SetFullscreen requests to make the surface a fullscreen surface
//
// Map the surface as a fullscreen surface.
//
// If an output parameter is given then the surface will be made
// fullscreen on that output. If the client does not specify the
// output then the compositor will apply its policy - usually
// choosing the output on which the surface has the biggest surface
// area.
//
// The client may specify a method to resolve a size conflict
// between the output size and the surface size - this is provided
// through the method parameter.
//
// The framerate parameter is used only when the method is set
// to "driver", to indicate the preferred framerate. A value of 0
// indicates that the client does not care about framerate.  The
// framerate is specified in mHz, that is framerate of 60000 is 60Hz.
//
// A method of "scale" or "driver" implies a scaling operation of
// the surface, either via a direct scaling operation or a change of
// the output mode. This will override any kind of output scaling, so
// that mapping a surface with a buffer size equal to the mode can
// fill the screen independent of buffer_scale.
//
// A method of "fill" means we don't scale up the buffer, however
// any output scale is applied. This means that you may run into
// an edge case where the application maps a buffer with the same
// size of the output mode but buffer_scale 1 (thus making a
// surface larger than the output). In this case it is allowed to
// downscale the results to fit the screen.
//
// The compositor must reply to this request with a configure event
// with the dimensions for the output on which the surface will
// be made fullscreen.
func (proxy *WlShellSurface) SetFullscreen(connection Connection, aMethod uint32, aFramerate uint32, aOutput ObjectID) (err error) {
	request := WlShellSurfaceSetFullscreenRequest{
		Method:    aMethod,
		Framerate: aFramerate,
		Output:    aOutput,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// SetPopup requests to make the surface a popup surface
//
// Map the surface as a popup.
//
// A popup surface is a transient surface with an added pointer
// grab.
//
// An existing implicit grab will be changed to owner-events mode,
// and the popup grab will continue after the implicit grab ends
// (i.e. releasing the mouse button does not cause the popup to
// be unmapped).
//
// The popup grab continues until the window is destroyed or a
// mouse button is pressed in any other client's window. A click
// in any of the client's surfaces is reported as normal, however,
// clicks in other clients' surfaces will be discarded and trigger
// the callback.
//
// The x and y arguments specify the location of the upper left
// corner of the surface relative to the upper left corner of the
// parent surface, in surface-local coordinates.
func (proxy *WlShellSurface) SetPopup(connection Connection, aSeat ObjectID, aSerial uint32, aParent ObjectID, aX int32, aY int32, aFlags uint32) (err error) {
	request := WlShellSurfaceSetPopupRequest{
		Seat:   aSeat,
		Serial: aSerial,
		Parent: aParent,
		X:      aX,
		Y:      aY,
		Flags:  aFlags,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// SetMaximized requests to make the surface a maximized surface
//
// Map the surface as a maximized surface.
//
// If an output parameter is given then the surface will be
// maximized on that output. If the client does not specify the
// output then the compositor will apply its policy - usually
// choosing the output on which the surface has the biggest surface
// area.
//
// The compositor will reply with a configure event telling
// the expected new surface size. The operation is completed
// on the next buffer attach to this surface.
//
// A maximized surface typically fills the entire output it is
// bound to, except for desktop elements such as panels. This is
// the main difference between a maximized shell surface and a
// fullscreen shell surface.
//
// The details depend on the compositor implementation.
func (proxy *WlShellSurface) SetMaximized(connection Connection, aOutput ObjectID) (err error) {
	request := WlShellSurfaceSetMaximizedRequest{
		Output: aOutput,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// SetTitle requests to set surface title
//
// Set a short title for the surface.
//
// This string may be used to identify the surface in a task bar,
// window list, or other user interface elements provided by the
// compositor.
//
// The string must be encoded in UTF-8.
func (proxy *WlShellSurface) SetTitle(connection Connection, aTitle string) (err error) {
	request := WlShellSurfaceSetTitleRequest{
		Title: aTitle,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// SetClass requests to set surface class
//
// Set a class for the surface.
//
// The surface class identifies the general class of applications
// to which the surface belongs. A common convention is to use the
// file name (or the full path if it is a non-standard location) of
// the application's .desktop file as the class.
func (proxy *WlShellSurface) SetClass(connection Connection, aClass string) (err error) {
	request := WlShellSurfaceSetClassRequest{
		Class: aClass,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Ensure WlShellSurface implements Proxy.
var _ Proxy = &WlShellSurface{}

// #endregion Interface wayland.wl_shell_surface

// ----------------------------------------------------------------------------
// #region Interface wayland.wl_surface

// WlSurfaceError represents wl_surface error values
//
// These errors can be emitted in response to wl_surface requests.
type WlSurfaceError int

const (
	// WlSurfaceErrorInvalidScale corresponds to buffer scale value is invalid
	WlSurfaceErrorInvalidScale WlSurfaceError = 0

	// WlSurfaceErrorInvalidTransform corresponds to buffer transform value is invalid
	WlSurfaceErrorInvalidTransform WlSurfaceError = 1

	// WlSurfaceErrorInvalidSize corresponds to buffer size is invalid
	WlSurfaceErrorInvalidSize WlSurfaceError = 2
)

// WlSurfaceDestroyRequest requests to delete surface
//
// Deletes the surface and invalidates its object ID.
type WlSurfaceDestroyRequest struct {
}

// Opcode returns the request opcode for wl_surface.destroy in wayland
func (WlSurfaceDestroyRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for wl_surface.destroy in wayland
func (WlSurfaceDestroyRequest) MessageName() string { return "destroy" }

// Ensure WlSurfaceDestroyRequest implements Message.
var _ Message = WlSurfaceDestroyRequest{}

// Emit emits the message to the emitter.
func (r *WlSurfaceDestroyRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure WlSurfaceDestroyRequest implements Request.
var _ Request = &WlSurfaceDestroyRequest{}

// WlSurfaceAttachRequest requests to set the surface contents
//
// Set a buffer as the content of this surface.
//
// The new size of the surface is calculated based on the buffer
// size transformed by the inverse buffer_transform and the
// inverse buffer_scale. This means that at commit time the supplied
// buffer size must be an integer multiple of the buffer_scale. If
// that's not the case, an invalid_size error is sent.
//
// The x and y arguments specify the location of the new pending
// buffer's upper left corner, relative to the current buffer's upper
// left corner, in surface-local coordinates. In other words, the
// x and y, combined with the new surface size define in which
// directions the surface's size changes.
//
// Surface contents are double-buffered state, see wl_surface.commit.
//
// The initial surface contents are void; there is no content.
// wl_surface.attach assigns the given wl_buffer as the pending
// wl_buffer. wl_surface.commit makes the pending wl_buffer the new
// surface contents, and the size of the surface becomes the size
// calculated from the wl_buffer, as described above. After commit,
// there is no pending buffer until the next attach.
//
// Committing a pending wl_buffer allows the compositor to read the
// pixels in the wl_buffer. The compositor may access the pixels at
// any time after the wl_surface.commit request. When the compositor
// will not access the pixels anymore, it will send the
// wl_buffer.release event. Only after receiving wl_buffer.release,
// the client may reuse the wl_buffer. A wl_buffer that has been
// attached and then replaced by another attach instead of committed
// will not receive a release event, and is not used by the
// compositor.
//
// If a pending wl_buffer has been committed to more than one wl_surface,
// the delivery of wl_buffer.release events becomes undefined. A well
// behaved client should not rely on wl_buffer.release events in this
// case. Alternatively, a client could create multiple wl_buffer objects
// from the same backing storage or use wp_linux_buffer_release.
//
// Destroying the wl_buffer after wl_buffer.release does not change
// the surface contents. Destroying the wl_buffer before wl_buffer.release
// is allowed as long as the underlying buffer storage isn't re-used (this
// can happen e.g. on client process termination). However, if the client
// destroys the wl_buffer before receiving the wl_buffer.release event and
// mutates the underlying buffer storage, the surface contents become
// undefined immediately.
//
// If wl_surface.attach is sent with a NULL wl_buffer, the
// following wl_surface.commit will remove the surface content.
type WlSurfaceAttachRequest struct {
	// Buffer contains buffer of surface contents
	Buffer ObjectID

	// X contains surface-local x coordinate
	X int32

	// Y contains surface-local y coordinate
	Y int32
}

// Opcode returns the request opcode for wl_surface.attach in wayland
func (WlSurfaceAttachRequest) Opcode() uint16 { return 1 }

// MessageName returns the request name for wl_surface.attach in wayland
func (WlSurfaceAttachRequest) MessageName() string { return "attach" }

// Ensure WlSurfaceAttachRequest implements Message.
var _ Message = WlSurfaceAttachRequest{}

// Emit emits the message to the emitter.
func (r *WlSurfaceAttachRequest) Emit(e *RequestEmitter) error {
	if err := e.PutObjectID(r.Buffer); err != nil {
		return err
	}
	if err := e.PutInt(r.X); err != nil {
		return err
	}
	if err := e.PutInt(r.Y); err != nil {
		return err
	}
	return nil
}

// Ensure WlSurfaceAttachRequest implements Request.
var _ Request = &WlSurfaceAttachRequest{}

// WlSurfaceDamageRequest requests to mark part of the surface damaged
//
// This request is used to describe the regions where the pending
// buffer is different from the current surface contents, and where
// the surface therefore needs to be repainted. The compositor
// ignores the parts of the damage that fall outside of the surface.
//
// Damage is double-buffered state, see wl_surface.commit.
//
// The damage rectangle is specified in surface-local coordinates,
// where x and y specify the upper left corner of the damage rectangle.
//
// The initial value for pending damage is empty: no damage.
// wl_surface.damage adds pending damage: the new pending damage
// is the union of old pending damage and the given rectangle.
//
// wl_surface.commit assigns pending damage as the current damage,
// and clears pending damage. The server will clear the current
// damage as it repaints the surface.
//
// Note! New clients should not use this request. Instead damage can be
// posted with wl_surface.damage_buffer which uses buffer coordinates
// instead of surface coordinates.
type WlSurfaceDamageRequest struct {
	// X contains surface-local x coordinate
	X int32

	// Y contains surface-local y coordinate
	Y int32

	// Width contains width of damage rectangle
	Width int32

	// Height contains height of damage rectangle
	Height int32
}

// Opcode returns the request opcode for wl_surface.damage in wayland
func (WlSurfaceDamageRequest) Opcode() uint16 { return 2 }

// MessageName returns the request name for wl_surface.damage in wayland
func (WlSurfaceDamageRequest) MessageName() string { return "damage" }

// Ensure WlSurfaceDamageRequest implements Message.
var _ Message = WlSurfaceDamageRequest{}

// Emit emits the message to the emitter.
func (r *WlSurfaceDamageRequest) Emit(e *RequestEmitter) error {
	if err := e.PutInt(r.X); err != nil {
		return err
	}
	if err := e.PutInt(r.Y); err != nil {
		return err
	}
	if err := e.PutInt(r.Width); err != nil {
		return err
	}
	if err := e.PutInt(r.Height); err != nil {
		return err
	}
	return nil
}

// Ensure WlSurfaceDamageRequest implements Request.
var _ Request = &WlSurfaceDamageRequest{}

// WlSurfaceFrameRequest requests to request a frame throttling hint
//
// Request a notification when it is a good time to start drawing a new
// frame, by creating a frame callback. This is useful for throttling
// redrawing operations, and driving animations.
//
// When a client is animating on a wl_surface, it can use the 'frame'
// request to get notified when it is a good time to draw and commit the
// next frame of animation. If the client commits an update earlier than
// that, it is likely that some updates will not make it to the display,
// and the client is wasting resources by drawing too often.
//
// The frame request will take effect on the next wl_surface.commit.
// The notification will only be posted for one frame unless
// requested again. For a wl_surface, the notifications are posted in
// the order the frame requests were committed.
//
// The server must send the notifications so that a client
// will not send excessive updates, while still allowing
// the highest possible update rate for clients that wait for the reply
// before drawing again. The server should give some time for the client
// to draw and commit after sending the frame callback events to let it
// hit the next output refresh.
//
// A server should avoid signaling the frame callbacks if the
// surface is not visible in any way, e.g. the surface is off-screen,
// or completely obscured by other opaque surfaces.
//
// The object returned by this request will be destroyed by the
// compositor after the callback is fired and as such the client must not
// attempt to use it after that point.
//
// The callback_data passed in the callback is the current time, in
// milliseconds, with an undefined base.
type WlSurfaceFrameRequest struct {
	// Callback contains callback object for the frame request
	Callback ObjectID
}

// Opcode returns the request opcode for wl_surface.frame in wayland
func (WlSurfaceFrameRequest) Opcode() uint16 { return 3 }

// MessageName returns the request name for wl_surface.frame in wayland
func (WlSurfaceFrameRequest) MessageName() string { return "frame" }

// Ensure WlSurfaceFrameRequest implements Message.
var _ Message = WlSurfaceFrameRequest{}

// Emit emits the message to the emitter.
func (r *WlSurfaceFrameRequest) Emit(e *RequestEmitter) error {
	if err := e.PutObjectID(r.Callback); err != nil {
		return err
	}
	return nil
}

// Ensure WlSurfaceFrameRequest implements Request.
var _ Request = &WlSurfaceFrameRequest{}

// WlSurfaceSetOpaqueRegionRequest requests to set opaque region
//
// This request sets the region of the surface that contains
// opaque content.
//
// The opaque region is an optimization hint for the compositor
// that lets it optimize the redrawing of content behind opaque
// regions.  Setting an opaque region is not required for correct
// behaviour, but marking transparent content as opaque will result
// in repaint artifacts.
//
// The opaque region is specified in surface-local coordinates.
//
// The compositor ignores the parts of the opaque region that fall
// outside of the surface.
//
// Opaque region is double-buffered state, see wl_surface.commit.
//
// wl_surface.set_opaque_region changes the pending opaque region.
// wl_surface.commit copies the pending region to the current region.
// Otherwise, the pending and current regions are never changed.
//
// The initial value for an opaque region is empty. Setting the pending
// opaque region has copy semantics, and the wl_region object can be
// destroyed immediately. A NULL wl_region causes the pending opaque
// region to be set to empty.
type WlSurfaceSetOpaqueRegionRequest struct {
	// Region contains opaque region of the surface
	Region ObjectID
}

// Opcode returns the request opcode for wl_surface.set_opaque_region in wayland
func (WlSurfaceSetOpaqueRegionRequest) Opcode() uint16 { return 4 }

// MessageName returns the request name for wl_surface.set_opaque_region in wayland
func (WlSurfaceSetOpaqueRegionRequest) MessageName() string { return "set_opaque_region" }

// Ensure WlSurfaceSetOpaqueRegionRequest implements Message.
var _ Message = WlSurfaceSetOpaqueRegionRequest{}

// Emit emits the message to the emitter.
func (r *WlSurfaceSetOpaqueRegionRequest) Emit(e *RequestEmitter) error {
	if err := e.PutObjectID(r.Region); err != nil {
		return err
	}
	return nil
}

// Ensure WlSurfaceSetOpaqueRegionRequest implements Request.
var _ Request = &WlSurfaceSetOpaqueRegionRequest{}

// WlSurfaceSetInputRegionRequest requests to set input region
//
// This request sets the region of the surface that can receive
// pointer and touch events.
//
// Input events happening outside of this region will try the next
// surface in the server surface stack. The compositor ignores the
// parts of the input region that fall outside of the surface.
//
// The input region is specified in surface-local coordinates.
//
// Input region is double-buffered state, see wl_surface.commit.
//
// wl_surface.set_input_region changes the pending input region.
// wl_surface.commit copies the pending region to the current region.
// Otherwise the pending and current regions are never changed,
// except cursor and icon surfaces are special cases, see
// wl_pointer.set_cursor and wl_data_device.start_drag.
//
// The initial value for an input region is infinite. That means the
// whole surface will accept input. Setting the pending input region
// has copy semantics, and the wl_region object can be destroyed
// immediately. A NULL wl_region causes the input region to be set
// to infinite.
type WlSurfaceSetInputRegionRequest struct {
	// Region contains input region of the surface
	Region ObjectID
}

// Opcode returns the request opcode for wl_surface.set_input_region in wayland
func (WlSurfaceSetInputRegionRequest) Opcode() uint16 { return 5 }

// MessageName returns the request name for wl_surface.set_input_region in wayland
func (WlSurfaceSetInputRegionRequest) MessageName() string { return "set_input_region" }

// Ensure WlSurfaceSetInputRegionRequest implements Message.
var _ Message = WlSurfaceSetInputRegionRequest{}

// Emit emits the message to the emitter.
func (r *WlSurfaceSetInputRegionRequest) Emit(e *RequestEmitter) error {
	if err := e.PutObjectID(r.Region); err != nil {
		return err
	}
	return nil
}

// Ensure WlSurfaceSetInputRegionRequest implements Request.
var _ Request = &WlSurfaceSetInputRegionRequest{}

// WlSurfaceCommitRequest requests to commit pending surface state
//
// Surface state (input, opaque, and damage regions, attached buffers,
// etc.) is double-buffered. Protocol requests modify the pending state,
// as opposed to the current state in use by the compositor. A commit
// request atomically applies all pending state, replacing the current
// state. After commit, the new pending state is as documented for each
// related request.
//
// On commit, a pending wl_buffer is applied first, and all other state
// second. This means that all coordinates in double-buffered state are
// relative to the new wl_buffer coming into use, except for
// wl_surface.attach itself. If there is no pending wl_buffer, the
// coordinates are relative to the current surface contents.
//
// All requests that need a commit to become effective are documented
// to affect double-buffered state.
//
// Other interfaces may add further double-buffered surface state.
type WlSurfaceCommitRequest struct {
}

// Opcode returns the request opcode for wl_surface.commit in wayland
func (WlSurfaceCommitRequest) Opcode() uint16 { return 6 }

// MessageName returns the request name for wl_surface.commit in wayland
func (WlSurfaceCommitRequest) MessageName() string { return "commit" }

// Ensure WlSurfaceCommitRequest implements Message.
var _ Message = WlSurfaceCommitRequest{}

// Emit emits the message to the emitter.
func (r *WlSurfaceCommitRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure WlSurfaceCommitRequest implements Request.
var _ Request = &WlSurfaceCommitRequest{}

// WlSurfaceSetBufferTransformRequest requests to sets the buffer transformation
//
// This request sets an optional transformation on how the compositor
// interprets the contents of the buffer attached to the surface. The
// accepted values for the transform parameter are the values for
// wl_output.transform.
//
// Buffer transform is double-buffered state, see wl_surface.commit.
//
// A newly created surface has its buffer transformation set to normal.
//
// wl_surface.set_buffer_transform changes the pending buffer
// transformation. wl_surface.commit copies the pending buffer
// transformation to the current one. Otherwise, the pending and current
// values are never changed.
//
// The purpose of this request is to allow clients to render content
// according to the output transform, thus permitting the compositor to
// use certain optimizations even if the display is rotated. Using
// hardware overlays and scanning out a client buffer for fullscreen
// surfaces are examples of such optimizations. Those optimizations are
// highly dependent on the compositor implementation, so the use of this
// request should be considered on a case-by-case basis.
//
// Note that if the transform value includes 90 or 270 degree rotation,
// the width of the buffer will become the surface height and the height
// of the buffer will become the surface width.
//
// If transform is not one of the values from the
// wl_output.transform enum the invalid_transform protocol error
// is raised.
type WlSurfaceSetBufferTransformRequest struct {
	// Transform contains transform for interpreting buffer contents
	Transform int32
}

// Opcode returns the request opcode for wl_surface.set_buffer_transform in wayland
func (WlSurfaceSetBufferTransformRequest) Opcode() uint16 { return 7 }

// MessageName returns the request name for wl_surface.set_buffer_transform in wayland
func (WlSurfaceSetBufferTransformRequest) MessageName() string { return "set_buffer_transform" }

// Ensure WlSurfaceSetBufferTransformRequest implements Message.
var _ Message = WlSurfaceSetBufferTransformRequest{}

// Emit emits the message to the emitter.
func (r *WlSurfaceSetBufferTransformRequest) Emit(e *RequestEmitter) error {
	if err := e.PutInt(r.Transform); err != nil {
		return err
	}
	return nil
}

// Ensure WlSurfaceSetBufferTransformRequest implements Request.
var _ Request = &WlSurfaceSetBufferTransformRequest{}

// WlSurfaceSetBufferScaleRequest requests to sets the buffer scaling factor
//
// This request sets an optional scaling factor on how the compositor
// interprets the contents of the buffer attached to the window.
//
// Buffer scale is double-buffered state, see wl_surface.commit.
//
// A newly created surface has its buffer scale set to 1.
//
// wl_surface.set_buffer_scale changes the pending buffer scale.
// wl_surface.commit copies the pending buffer scale to the current one.
// Otherwise, the pending and current values are never changed.
//
// The purpose of this request is to allow clients to supply higher
// resolution buffer data for use on high resolution outputs. It is
// intended that you pick the same buffer scale as the scale of the
// output that the surface is displayed on. This means the compositor
// can avoid scaling when rendering the surface on that output.
//
// Note that if the scale is larger than 1, then you have to attach
// a buffer that is larger (by a factor of scale in each dimension)
// than the desired surface size.
//
// If scale is not positive the invalid_scale protocol error is
// raised.
type WlSurfaceSetBufferScaleRequest struct {
	// Scale contains positive scale for interpreting buffer contents
	Scale int32
}

// Opcode returns the request opcode for wl_surface.set_buffer_scale in wayland
func (WlSurfaceSetBufferScaleRequest) Opcode() uint16 { return 8 }

// MessageName returns the request name for wl_surface.set_buffer_scale in wayland
func (WlSurfaceSetBufferScaleRequest) MessageName() string { return "set_buffer_scale" }

// Ensure WlSurfaceSetBufferScaleRequest implements Message.
var _ Message = WlSurfaceSetBufferScaleRequest{}

// Emit emits the message to the emitter.
func (r *WlSurfaceSetBufferScaleRequest) Emit(e *RequestEmitter) error {
	if err := e.PutInt(r.Scale); err != nil {
		return err
	}
	return nil
}

// Ensure WlSurfaceSetBufferScaleRequest implements Request.
var _ Request = &WlSurfaceSetBufferScaleRequest{}

// WlSurfaceDamageBufferRequest requests to mark part of the surface damaged using buffer coordinates
//
// This request is used to describe the regions where the pending
// buffer is different from the current surface contents, and where
// the surface therefore needs to be repainted. The compositor
// ignores the parts of the damage that fall outside of the surface.
//
// Damage is double-buffered state, see wl_surface.commit.
//
// The damage rectangle is specified in buffer coordinates,
// where x and y specify the upper left corner of the damage rectangle.
//
// The initial value for pending damage is empty: no damage.
// wl_surface.damage_buffer adds pending damage: the new pending
// damage is the union of old pending damage and the given rectangle.
//
// wl_surface.commit assigns pending damage as the current damage,
// and clears pending damage. The server will clear the current
// damage as it repaints the surface.
//
// This request differs from wl_surface.damage in only one way - it
// takes damage in buffer coordinates instead of surface-local
// coordinates. While this generally is more intuitive than surface
// coordinates, it is especially desirable when using wp_viewport
// or when a drawing library (like EGL) is unaware of buffer scale
// and buffer transform.
//
// Note: Because buffer transformation changes and damage requests may
// be interleaved in the protocol stream, it is impossible to determine
// the actual mapping between surface and buffer damage until
// wl_surface.commit time. Therefore, compositors wishing to take both
// kinds of damage into account will have to accumulate damage from the
// two requests separately and only transform from one to the other
// after receiving the wl_surface.commit.
type WlSurfaceDamageBufferRequest struct {
	// X contains buffer-local x coordinate
	X int32

	// Y contains buffer-local y coordinate
	Y int32

	// Width contains width of damage rectangle
	Width int32

	// Height contains height of damage rectangle
	Height int32
}

// Opcode returns the request opcode for wl_surface.damage_buffer in wayland
func (WlSurfaceDamageBufferRequest) Opcode() uint16 { return 9 }

// MessageName returns the request name for wl_surface.damage_buffer in wayland
func (WlSurfaceDamageBufferRequest) MessageName() string { return "damage_buffer" }

// Ensure WlSurfaceDamageBufferRequest implements Message.
var _ Message = WlSurfaceDamageBufferRequest{}

// Emit emits the message to the emitter.
func (r *WlSurfaceDamageBufferRequest) Emit(e *RequestEmitter) error {
	if err := e.PutInt(r.X); err != nil {
		return err
	}
	if err := e.PutInt(r.Y); err != nil {
		return err
	}
	if err := e.PutInt(r.Width); err != nil {
		return err
	}
	if err := e.PutInt(r.Height); err != nil {
		return err
	}
	return nil
}

// Ensure WlSurfaceDamageBufferRequest implements Request.
var _ Request = &WlSurfaceDamageBufferRequest{}

// WlSurfaceEnterEvent signals when surface enters an output
//
// This is emitted whenever a surface's creation, movement, or resizing
// results in some part of it being within the scanout region of an
// output.
//
// Note that a surface may be overlapping with zero or more outputs.
type WlSurfaceEnterEvent struct {
	// Output contains output entered by the surface
	Output ObjectID
}

// Opcode returns the event opcode for wl_surface.enter in wayland
func (WlSurfaceEnterEvent) Opcode() uint16 { return 0 }

// MessageName returns the event name for wl_surface.enter in wayland
func (WlSurfaceEnterEvent) MessageName() string { return "enter" }

// Ensure WlSurfaceEnterEvent implements Message.
var _ Message = WlSurfaceEnterEvent{}

// Scan scans the event from the socket.
func (e *WlSurfaceEnterEvent) Scan(s *EventScanner) error {
	if v, err := s.ObjectID(); err != nil {
		return err
	} else {
		e.Output = v
	}
	return nil
}

// Ensure WlSurfaceEnterEvent implements Event.
var _ Event = &WlSurfaceEnterEvent{}

// WlSurfaceLeaveEvent signals when surface leaves an output
//
// This is emitted whenever a surface's creation, movement, or resizing
// results in it no longer having any part of it within the scanout region
// of an output.
//
// Clients should not use the number of outputs the surface is on for frame
// throttling purposes. The surface might be hidden even if no leave event
// has been sent, and the compositor might expect new surface content
// updates even if no enter event has been sent. The frame event should be
// used instead.
type WlSurfaceLeaveEvent struct {
	// Output contains output left by the surface
	Output ObjectID
}

// Opcode returns the event opcode for wl_surface.leave in wayland
func (WlSurfaceLeaveEvent) Opcode() uint16 { return 1 }

// MessageName returns the event name for wl_surface.leave in wayland
func (WlSurfaceLeaveEvent) MessageName() string { return "leave" }

// Ensure WlSurfaceLeaveEvent implements Message.
var _ Message = WlSurfaceLeaveEvent{}

// Scan scans the event from the socket.
func (e *WlSurfaceLeaveEvent) Scan(s *EventScanner) error {
	if v, err := s.ObjectID(); err != nil {
		return err
	} else {
		e.Output = v
	}
	return nil
}

// Ensure WlSurfaceLeaveEvent implements Event.
var _ Event = &WlSurfaceLeaveEvent{}

// WlSurface an onscreen surface
//
// A surface is a rectangular area that may be displayed on zero
// or more outputs, and shown any number of times at the compositor's
// discretion. They can present wl_buffers, receive user input, and
// define a local coordinate system.
//
// The size of a surface (and relative positions on it) is described
// in surface-local coordinates, which may differ from the buffer
// coordinates of the pixel content, in case a buffer_transform
// or a buffer_scale is used.
//
// A surface without a "role" is fairly useless: a compositor does
// not know where, when or how to present it. The role is the
// purpose of a wl_surface. Examples of roles are a cursor for a
// pointer (as set by wl_pointer.set_cursor), a drag icon
// (wl_data_device.start_drag), a sub-surface
// (wl_subcompositor.get_subsurface), and a window as defined by a
// shell protocol (e.g. wl_shell.get_shell_surface).
//
// A surface can have only one role at a time. Initially a
// wl_surface does not have a role. Once a wl_surface is given a
// role, it is set permanently for the whole lifetime of the
// wl_surface object. Giving the current role again is allowed,
// unless explicitly forbidden by the relevant interface
// specification.
//
// Surface roles are given by requests in other interfaces such as
// wl_pointer.set_cursor. The request should explicitly mention
// that this request gives a role to a wl_surface. Often, this
// request also creates a new protocol object that represents the
// role and adds additional functionality to wl_surface. When a
// client wants to destroy a wl_surface, they must destroy this 'role
// object' before the wl_surface.
//
// Destroying the role object does not remove the role from the
// wl_surface, but it may stop the wl_surface from "playing the role".
// For instance, if a wl_subsurface object is destroyed, the wl_surface
// it was created for will be unmapped and forget its position and
// z-order. It is allowed to create a wl_subsurface for the same
// wl_surface again, but it is not allowed to use the wl_surface as
// a cursor (cursor is a different role than sub-surface, and role
// switching is not allowed).
type WlSurface struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *WlSurface) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (WlSurface) Descriptor() *InterfaceDescriptor {
	return &WlSurfaceDescriptor
}

// Dispatch returns an Event object for a given opcode.
func (WlSurface) Dispatch(opcode uint16) Event {
	switch opcode {
	case 0:
		return &WlSurfaceEnterEvent{}
	case 1:
		return &WlSurfaceLeaveEvent{}
	default:
		return nil
	}
}

// Destroy requests to delete surface
//
// Deletes the surface and invalidates its object ID.
func (proxy *WlSurface) Destroy(connection Connection) (err error) {
	request := WlSurfaceDestroyRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Attach requests to set the surface contents
//
// Set a buffer as the content of this surface.
//
// The new size of the surface is calculated based on the buffer
// size transformed by the inverse buffer_transform and the
// inverse buffer_scale. This means that at commit time the supplied
// buffer size must be an integer multiple of the buffer_scale. If
// that's not the case, an invalid_size error is sent.
//
// The x and y arguments specify the location of the new pending
// buffer's upper left corner, relative to the current buffer's upper
// left corner, in surface-local coordinates. In other words, the
// x and y, combined with the new surface size define in which
// directions the surface's size changes.
//
// Surface contents are double-buffered state, see wl_surface.commit.
//
// The initial surface contents are void; there is no content.
// wl_surface.attach assigns the given wl_buffer as the pending
// wl_buffer. wl_surface.commit makes the pending wl_buffer the new
// surface contents, and the size of the surface becomes the size
// calculated from the wl_buffer, as described above. After commit,
// there is no pending buffer until the next attach.
//
// Committing a pending wl_buffer allows the compositor to read the
// pixels in the wl_buffer. The compositor may access the pixels at
// any time after the wl_surface.commit request. When the compositor
// will not access the pixels anymore, it will send the
// wl_buffer.release event. Only after receiving wl_buffer.release,
// the client may reuse the wl_buffer. A wl_buffer that has been
// attached and then replaced by another attach instead of committed
// will not receive a release event, and is not used by the
// compositor.
//
// If a pending wl_buffer has been committed to more than one wl_surface,
// the delivery of wl_buffer.release events becomes undefined. A well
// behaved client should not rely on wl_buffer.release events in this
// case. Alternatively, a client could create multiple wl_buffer objects
// from the same backing storage or use wp_linux_buffer_release.
//
// Destroying the wl_buffer after wl_buffer.release does not change
// the surface contents. Destroying the wl_buffer before wl_buffer.release
// is allowed as long as the underlying buffer storage isn't re-used (this
// can happen e.g. on client process termination). However, if the client
// destroys the wl_buffer before receiving the wl_buffer.release event and
// mutates the underlying buffer storage, the surface contents become
// undefined immediately.
//
// If wl_surface.attach is sent with a NULL wl_buffer, the
// following wl_surface.commit will remove the surface content.
func (proxy *WlSurface) Attach(connection Connection, aBuffer ObjectID, aX int32, aY int32) (err error) {
	request := WlSurfaceAttachRequest{
		Buffer: aBuffer,
		X:      aX,
		Y:      aY,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Damage requests to mark part of the surface damaged
//
// This request is used to describe the regions where the pending
// buffer is different from the current surface contents, and where
// the surface therefore needs to be repainted. The compositor
// ignores the parts of the damage that fall outside of the surface.
//
// Damage is double-buffered state, see wl_surface.commit.
//
// The damage rectangle is specified in surface-local coordinates,
// where x and y specify the upper left corner of the damage rectangle.
//
// The initial value for pending damage is empty: no damage.
// wl_surface.damage adds pending damage: the new pending damage
// is the union of old pending damage and the given rectangle.
//
// wl_surface.commit assigns pending damage as the current damage,
// and clears pending damage. The server will clear the current
// damage as it repaints the surface.
//
// Note! New clients should not use this request. Instead damage can be
// posted with wl_surface.damage_buffer which uses buffer coordinates
// instead of surface coordinates.
func (proxy *WlSurface) Damage(connection Connection, aX int32, aY int32, aWidth int32, aHeight int32) (err error) {
	request := WlSurfaceDamageRequest{
		X:      aX,
		Y:      aY,
		Width:  aWidth,
		Height: aHeight,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Frame requests to request a frame throttling hint
//
// Request a notification when it is a good time to start drawing a new
// frame, by creating a frame callback. This is useful for throttling
// redrawing operations, and driving animations.
//
// When a client is animating on a wl_surface, it can use the 'frame'
// request to get notified when it is a good time to draw and commit the
// next frame of animation. If the client commits an update earlier than
// that, it is likely that some updates will not make it to the display,
// and the client is wasting resources by drawing too often.
//
// The frame request will take effect on the next wl_surface.commit.
// The notification will only be posted for one frame unless
// requested again. For a wl_surface, the notifications are posted in
// the order the frame requests were committed.
//
// The server must send the notifications so that a client
// will not send excessive updates, while still allowing
// the highest possible update rate for clients that wait for the reply
// before drawing again. The server should give some time for the client
// to draw and commit after sending the frame callback events to let it
// hit the next output refresh.
//
// A server should avoid signaling the frame callbacks if the
// surface is not visible in any way, e.g. the surface is off-screen,
// or completely obscured by other opaque surfaces.
//
// The object returned by this request will be destroyed by the
// compositor after the callback is fired and as such the client must not
// attempt to use it after that point.
//
// The callback_data passed in the callback is the current time, in
// milliseconds, with an undefined base.
func (proxy *WlSurface) Frame(connection Connection) (aCallback *WlCallback, err error) {
	aCallback = &WlCallback{connection.NewID()}
	request := WlSurfaceFrameRequest{
		Callback: aCallback.id,
	}
	err = connection.SendRequest(proxy.id, &request)
	if err == nil {
		connection.RegisterProxy(aCallback)
	}
	return
}

// SetOpaqueRegion requests to set opaque region
//
// This request sets the region of the surface that contains
// opaque content.
//
// The opaque region is an optimization hint for the compositor
// that lets it optimize the redrawing of content behind opaque
// regions.  Setting an opaque region is not required for correct
// behaviour, but marking transparent content as opaque will result
// in repaint artifacts.
//
// The opaque region is specified in surface-local coordinates.
//
// The compositor ignores the parts of the opaque region that fall
// outside of the surface.
//
// Opaque region is double-buffered state, see wl_surface.commit.
//
// wl_surface.set_opaque_region changes the pending opaque region.
// wl_surface.commit copies the pending region to the current region.
// Otherwise, the pending and current regions are never changed.
//
// The initial value for an opaque region is empty. Setting the pending
// opaque region has copy semantics, and the wl_region object can be
// destroyed immediately. A NULL wl_region causes the pending opaque
// region to be set to empty.
func (proxy *WlSurface) SetOpaqueRegion(connection Connection, aRegion ObjectID) (err error) {
	request := WlSurfaceSetOpaqueRegionRequest{
		Region: aRegion,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// SetInputRegion requests to set input region
//
// This request sets the region of the surface that can receive
// pointer and touch events.
//
// Input events happening outside of this region will try the next
// surface in the server surface stack. The compositor ignores the
// parts of the input region that fall outside of the surface.
//
// The input region is specified in surface-local coordinates.
//
// Input region is double-buffered state, see wl_surface.commit.
//
// wl_surface.set_input_region changes the pending input region.
// wl_surface.commit copies the pending region to the current region.
// Otherwise the pending and current regions are never changed,
// except cursor and icon surfaces are special cases, see
// wl_pointer.set_cursor and wl_data_device.start_drag.
//
// The initial value for an input region is infinite. That means the
// whole surface will accept input. Setting the pending input region
// has copy semantics, and the wl_region object can be destroyed
// immediately. A NULL wl_region causes the input region to be set
// to infinite.
func (proxy *WlSurface) SetInputRegion(connection Connection, aRegion ObjectID) (err error) {
	request := WlSurfaceSetInputRegionRequest{
		Region: aRegion,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Commit requests to commit pending surface state
//
// Surface state (input, opaque, and damage regions, attached buffers,
// etc.) is double-buffered. Protocol requests modify the pending state,
// as opposed to the current state in use by the compositor. A commit
// request atomically applies all pending state, replacing the current
// state. After commit, the new pending state is as documented for each
// related request.
//
// On commit, a pending wl_buffer is applied first, and all other state
// second. This means that all coordinates in double-buffered state are
// relative to the new wl_buffer coming into use, except for
// wl_surface.attach itself. If there is no pending wl_buffer, the
// coordinates are relative to the current surface contents.
//
// All requests that need a commit to become effective are documented
// to affect double-buffered state.
//
// Other interfaces may add further double-buffered surface state.
func (proxy *WlSurface) Commit(connection Connection) (err error) {
	request := WlSurfaceCommitRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// SetBufferTransform requests to sets the buffer transformation
//
// This request sets an optional transformation on how the compositor
// interprets the contents of the buffer attached to the surface. The
// accepted values for the transform parameter are the values for
// wl_output.transform.
//
// Buffer transform is double-buffered state, see wl_surface.commit.
//
// A newly created surface has its buffer transformation set to normal.
//
// wl_surface.set_buffer_transform changes the pending buffer
// transformation. wl_surface.commit copies the pending buffer
// transformation to the current one. Otherwise, the pending and current
// values are never changed.
//
// The purpose of this request is to allow clients to render content
// according to the output transform, thus permitting the compositor to
// use certain optimizations even if the display is rotated. Using
// hardware overlays and scanning out a client buffer for fullscreen
// surfaces are examples of such optimizations. Those optimizations are
// highly dependent on the compositor implementation, so the use of this
// request should be considered on a case-by-case basis.
//
// Note that if the transform value includes 90 or 270 degree rotation,
// the width of the buffer will become the surface height and the height
// of the buffer will become the surface width.
//
// If transform is not one of the values from the
// wl_output.transform enum the invalid_transform protocol error
// is raised.
func (proxy *WlSurface) SetBufferTransform(connection Connection, aTransform int32) (err error) {
	request := WlSurfaceSetBufferTransformRequest{
		Transform: aTransform,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// SetBufferScale requests to sets the buffer scaling factor
//
// This request sets an optional scaling factor on how the compositor
// interprets the contents of the buffer attached to the window.
//
// Buffer scale is double-buffered state, see wl_surface.commit.
//
// A newly created surface has its buffer scale set to 1.
//
// wl_surface.set_buffer_scale changes the pending buffer scale.
// wl_surface.commit copies the pending buffer scale to the current one.
// Otherwise, the pending and current values are never changed.
//
// The purpose of this request is to allow clients to supply higher
// resolution buffer data for use on high resolution outputs. It is
// intended that you pick the same buffer scale as the scale of the
// output that the surface is displayed on. This means the compositor
// can avoid scaling when rendering the surface on that output.
//
// Note that if the scale is larger than 1, then you have to attach
// a buffer that is larger (by a factor of scale in each dimension)
// than the desired surface size.
//
// If scale is not positive the invalid_scale protocol error is
// raised.
func (proxy *WlSurface) SetBufferScale(connection Connection, aScale int32) (err error) {
	request := WlSurfaceSetBufferScaleRequest{
		Scale: aScale,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// DamageBuffer requests to mark part of the surface damaged using buffer coordinates
//
// This request is used to describe the regions where the pending
// buffer is different from the current surface contents, and where
// the surface therefore needs to be repainted. The compositor
// ignores the parts of the damage that fall outside of the surface.
//
// Damage is double-buffered state, see wl_surface.commit.
//
// The damage rectangle is specified in buffer coordinates,
// where x and y specify the upper left corner of the damage rectangle.
//
// The initial value for pending damage is empty: no damage.
// wl_surface.damage_buffer adds pending damage: the new pending
// damage is the union of old pending damage and the given rectangle.
//
// wl_surface.commit assigns pending damage as the current damage,
// and clears pending damage. The server will clear the current
// damage as it repaints the surface.
//
// This request differs from wl_surface.damage in only one way - it
// takes damage in buffer coordinates instead of surface-local
// coordinates. While this generally is more intuitive than surface
// coordinates, it is especially desirable when using wp_viewport
// or when a drawing library (like EGL) is unaware of buffer scale
// and buffer transform.
//
// Note: Because buffer transformation changes and damage requests may
// be interleaved in the protocol stream, it is impossible to determine
// the actual mapping between surface and buffer damage until
// wl_surface.commit time. Therefore, compositors wishing to take both
// kinds of damage into account will have to accumulate damage from the
// two requests separately and only transform from one to the other
// after receiving the wl_surface.commit.
func (proxy *WlSurface) DamageBuffer(connection Connection, aX int32, aY int32, aWidth int32, aHeight int32) (err error) {
	request := WlSurfaceDamageBufferRequest{
		X:      aX,
		Y:      aY,
		Width:  aWidth,
		Height: aHeight,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Ensure WlSurface implements Proxy.
var _ Proxy = &WlSurface{}

// #endregion Interface wayland.wl_surface

// ----------------------------------------------------------------------------
// #region Interface wayland.wl_seat

// WlSeatCapability represents seat capability bitmask
//
// This is a bitmask of capabilities this seat has; if a member is
// set, then it is present on the seat.
type WlSeatCapability uint

const (
	// WlSeatCapabilityPointer corresponds to the seat has pointer devices
	WlSeatCapabilityPointer WlSeatCapability = 1

	// WlSeatCapabilityKeyboard corresponds to the seat has one or more keyboards
	WlSeatCapabilityKeyboard WlSeatCapability = 2

	// WlSeatCapabilityTouch corresponds to the seat has touch devices
	WlSeatCapabilityTouch WlSeatCapability = 4
)

// WlSeatError represents wl_seat error values
//
// These errors can be emitted in response to wl_seat requests.
type WlSeatError int

const (
	// WlSeatErrorMissingCapability corresponds to get_pointer, get_keyboard or get_touch called on seat without the matching capability
	WlSeatErrorMissingCapability WlSeatError = 0
)

// WlSeatGetPointerRequest requests to return pointer object
//
// The ID provided will be initialized to the wl_pointer interface
// for this seat.
//
// This request only takes effect if the seat has the pointer
// capability, or has had the pointer capability in the past.
// It is a protocol violation to issue this request on a seat that has
// never had the pointer capability. The missing_capability error will
// be sent in this case.
type WlSeatGetPointerRequest struct {
	// ID contains seat pointer
	ID ObjectID
}

// Opcode returns the request opcode for wl_seat.get_pointer in wayland
func (WlSeatGetPointerRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for wl_seat.get_pointer in wayland
func (WlSeatGetPointerRequest) MessageName() string { return "get_pointer" }

// Ensure WlSeatGetPointerRequest implements Message.
var _ Message = WlSeatGetPointerRequest{}

// Emit emits the message to the emitter.
func (r *WlSeatGetPointerRequest) Emit(e *RequestEmitter) error {
	if err := e.PutObjectID(r.ID); err != nil {
		return err
	}
	return nil
}

// Ensure WlSeatGetPointerRequest implements Request.
var _ Request = &WlSeatGetPointerRequest{}

// WlSeatGetKeyboardRequest requests to return keyboard object
//
// The ID provided will be initialized to the wl_keyboard interface
// for this seat.
//
// This request only takes effect if the seat has the keyboard
// capability, or has had the keyboard capability in the past.
// It is a protocol violation to issue this request on a seat that has
// never had the keyboard capability. The missing_capability error will
// be sent in this case.
type WlSeatGetKeyboardRequest struct {
	// ID contains seat keyboard
	ID ObjectID
}

// Opcode returns the request opcode for wl_seat.get_keyboard in wayland
func (WlSeatGetKeyboardRequest) Opcode() uint16 { return 1 }

// MessageName returns the request name for wl_seat.get_keyboard in wayland
func (WlSeatGetKeyboardRequest) MessageName() string { return "get_keyboard" }

// Ensure WlSeatGetKeyboardRequest implements Message.
var _ Message = WlSeatGetKeyboardRequest{}

// Emit emits the message to the emitter.
func (r *WlSeatGetKeyboardRequest) Emit(e *RequestEmitter) error {
	if err := e.PutObjectID(r.ID); err != nil {
		return err
	}
	return nil
}

// Ensure WlSeatGetKeyboardRequest implements Request.
var _ Request = &WlSeatGetKeyboardRequest{}

// WlSeatGetTouchRequest requests to return touch object
//
// The ID provided will be initialized to the wl_touch interface
// for this seat.
//
// This request only takes effect if the seat has the touch
// capability, or has had the touch capability in the past.
// It is a protocol violation to issue this request on a seat that has
// never had the touch capability. The missing_capability error will
// be sent in this case.
type WlSeatGetTouchRequest struct {
	// ID contains seat touch interface
	ID ObjectID
}

// Opcode returns the request opcode for wl_seat.get_touch in wayland
func (WlSeatGetTouchRequest) Opcode() uint16 { return 2 }

// MessageName returns the request name for wl_seat.get_touch in wayland
func (WlSeatGetTouchRequest) MessageName() string { return "get_touch" }

// Ensure WlSeatGetTouchRequest implements Message.
var _ Message = WlSeatGetTouchRequest{}

// Emit emits the message to the emitter.
func (r *WlSeatGetTouchRequest) Emit(e *RequestEmitter) error {
	if err := e.PutObjectID(r.ID); err != nil {
		return err
	}
	return nil
}

// Ensure WlSeatGetTouchRequest implements Request.
var _ Request = &WlSeatGetTouchRequest{}

// WlSeatReleaseRequest requests to release the seat object
//
// Using this request a client can tell the server that it is not going to
// use the seat object anymore.
type WlSeatReleaseRequest struct {
}

// Opcode returns the request opcode for wl_seat.release in wayland
func (WlSeatReleaseRequest) Opcode() uint16 { return 3 }

// MessageName returns the request name for wl_seat.release in wayland
func (WlSeatReleaseRequest) MessageName() string { return "release" }

// Ensure WlSeatReleaseRequest implements Message.
var _ Message = WlSeatReleaseRequest{}

// Emit emits the message to the emitter.
func (r *WlSeatReleaseRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure WlSeatReleaseRequest implements Request.
var _ Request = &WlSeatReleaseRequest{}

// WlSeatCapabilitiesEvent signals when seat capabilities changed
//
// This is emitted whenever a seat gains or loses the pointer,
// keyboard or touch capabilities.  The argument is a capability
// enum containing the complete set of capabilities this seat has.
//
// When the pointer capability is added, a client may create a
// wl_pointer object using the wl_seat.get_pointer request. This object
// will receive pointer events until the capability is removed in the
// future.
//
// When the pointer capability is removed, a client should destroy the
// wl_pointer objects associated with the seat where the capability was
// removed, using the wl_pointer.release request. No further pointer
// events will be received on these objects.
//
// In some compositors, if a seat regains the pointer capability and a
// client has a previously obtained wl_pointer object of version 4 or
// less, that object may start sending pointer events again. This
// behavior is considered a misinterpretation of the intended behavior
// and must not be relied upon by the client. wl_pointer objects of
// version 5 or later must not send events if created before the most
// recent event notifying the client of an added pointer capability.
//
// The above behavior also applies to wl_keyboard and wl_touch with the
// keyboard and touch capabilities, respectively.
type WlSeatCapabilitiesEvent struct {
	// Capabilities contains capabilities of the seat
	Capabilities uint32
}

// Opcode returns the event opcode for wl_seat.capabilities in wayland
func (WlSeatCapabilitiesEvent) Opcode() uint16 { return 0 }

// MessageName returns the event name for wl_seat.capabilities in wayland
func (WlSeatCapabilitiesEvent) MessageName() string { return "capabilities" }

// Ensure WlSeatCapabilitiesEvent implements Message.
var _ Message = WlSeatCapabilitiesEvent{}

// Scan scans the event from the socket.
func (e *WlSeatCapabilitiesEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Capabilities = v
	}
	return nil
}

// Ensure WlSeatCapabilitiesEvent implements Event.
var _ Event = &WlSeatCapabilitiesEvent{}

// WlSeatNameEvent signals when unique identifier for this seat
//
// In a multi-seat configuration the seat name can be used by clients to
// help identify which physical devices the seat represents.
//
// The seat name is a UTF-8 string with no convention defined for its
// contents. Each name is unique among all wl_seat globals. The name is
// only guaranteed to be unique for the current compositor instance.
//
// The same seat names are used for all clients. Thus, the name can be
// shared across processes to refer to a specific wl_seat global.
//
// The name event is sent after binding to the seat global. This event is
// only sent once per seat object, and the name does not change over the
// lifetime of the wl_seat global.
//
// Compositors may re-use the same seat name if the wl_seat global is
// destroyed and re-created later.
type WlSeatNameEvent struct {
	// Name contains seat identifier
	Name string
}

// Opcode returns the event opcode for wl_seat.name in wayland
func (WlSeatNameEvent) Opcode() uint16 { return 1 }

// MessageName returns the event name for wl_seat.name in wayland
func (WlSeatNameEvent) MessageName() string { return "name" }

// Ensure WlSeatNameEvent implements Message.
var _ Message = WlSeatNameEvent{}

// Scan scans the event from the socket.
func (e *WlSeatNameEvent) Scan(s *EventScanner) error {
	if v, err := s.String(); err != nil {
		return err
	} else {
		e.Name = v
	}
	return nil
}

// Ensure WlSeatNameEvent implements Event.
var _ Event = &WlSeatNameEvent{}

// WlSeat group of input devices
//
// A seat is a group of keyboards, pointer and touch devices. This
// object is published as a global during start up, or when such a
// device is hot plugged.  A seat typically has a pointer and
// maintains a keyboard focus and a pointer focus.
type WlSeat struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *WlSeat) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (WlSeat) Descriptor() *InterfaceDescriptor {
	return &WlSeatDescriptor
}

// Dispatch returns an Event object for a given opcode.
func (WlSeat) Dispatch(opcode uint16) Event {
	switch opcode {
	case 0:
		return &WlSeatCapabilitiesEvent{}
	case 1:
		return &WlSeatNameEvent{}
	default:
		return nil
	}
}

// GetPointer requests to return pointer object
//
// The ID provided will be initialized to the wl_pointer interface
// for this seat.
//
// This request only takes effect if the seat has the pointer
// capability, or has had the pointer capability in the past.
// It is a protocol violation to issue this request on a seat that has
// never had the pointer capability. The missing_capability error will
// be sent in this case.
func (proxy *WlSeat) GetPointer(connection Connection) (aID *WlPointer, err error) {
	aID = &WlPointer{connection.NewID()}
	request := WlSeatGetPointerRequest{
		ID: aID.id,
	}
	err = connection.SendRequest(proxy.id, &request)
	if err == nil {
		connection.RegisterProxy(aID)
	}
	return
}

// GetKeyboard requests to return keyboard object
//
// The ID provided will be initialized to the wl_keyboard interface
// for this seat.
//
// This request only takes effect if the seat has the keyboard
// capability, or has had the keyboard capability in the past.
// It is a protocol violation to issue this request on a seat that has
// never had the keyboard capability. The missing_capability error will
// be sent in this case.
func (proxy *WlSeat) GetKeyboard(connection Connection) (aID *WlKeyboard, err error) {
	aID = &WlKeyboard{connection.NewID()}
	request := WlSeatGetKeyboardRequest{
		ID: aID.id,
	}
	err = connection.SendRequest(proxy.id, &request)
	if err == nil {
		connection.RegisterProxy(aID)
	}
	return
}

// GetTouch requests to return touch object
//
// The ID provided will be initialized to the wl_touch interface
// for this seat.
//
// This request only takes effect if the seat has the touch
// capability, or has had the touch capability in the past.
// It is a protocol violation to issue this request on a seat that has
// never had the touch capability. The missing_capability error will
// be sent in this case.
func (proxy *WlSeat) GetTouch(connection Connection) (aID *WlTouch, err error) {
	aID = &WlTouch{connection.NewID()}
	request := WlSeatGetTouchRequest{
		ID: aID.id,
	}
	err = connection.SendRequest(proxy.id, &request)
	if err == nil {
		connection.RegisterProxy(aID)
	}
	return
}

// Release requests to release the seat object
//
// Using this request a client can tell the server that it is not going to
// use the seat object anymore.
func (proxy *WlSeat) Release(connection Connection) (err error) {
	request := WlSeatReleaseRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Ensure WlSeat implements Proxy.
var _ Proxy = &WlSeat{}

// #endregion Interface wayland.wl_seat

// ----------------------------------------------------------------------------
// #region Interface wayland.wl_pointer

type WlPointerError int

const (
	// WlPointerErrorRole corresponds to given wl_surface has another role
	WlPointerErrorRole WlPointerError = 0
)

// WlPointerButtonState represents physical button state
//
// Describes the physical state of a button that produced the button
// event.
type WlPointerButtonState int

const (
	// WlPointerButtonStateReleased corresponds to the button is not pressed
	WlPointerButtonStateReleased WlPointerButtonState = 0

	// WlPointerButtonStatePressed corresponds to the button is pressed
	WlPointerButtonStatePressed WlPointerButtonState = 1
)

// WlPointerAxis represents axis types
//
// Describes the axis types of scroll events.
type WlPointerAxis int

const (
	// WlPointerAxisVerticalScroll corresponds to vertical axis
	WlPointerAxisVerticalScroll WlPointerAxis = 0

	// WlPointerAxisHorizontalScroll corresponds to horizontal axis
	WlPointerAxisHorizontalScroll WlPointerAxis = 1
)

// WlPointerAxisSource represents axis source types
//
// Describes the source types for axis events. This indicates to the
// client how an axis event was physically generated; a client may
// adjust the user interface accordingly. For example, scroll events
// from a "finger" source may be in a smooth coordinate space with
// kinetic scrolling whereas a "wheel" source may be in discrete steps
// of a number of lines.
//
// The "continuous" axis source is a device generating events in a
// continuous coordinate space, but using something other than a
// finger. One example for this source is button-based scrolling where
// the vertical motion of a device is converted to scroll events while
// a button is held down.
//
// The "wheel tilt" axis source indicates that the actual device is a
// wheel but the scroll event is not caused by a rotation but a
// (usually sideways) tilt of the wheel.
type WlPointerAxisSource int

const (
	// WlPointerAxisSourceWheel corresponds to a physical wheel rotation
	WlPointerAxisSourceWheel WlPointerAxisSource = 0

	// WlPointerAxisSourceFinger corresponds to finger on a touch surface
	WlPointerAxisSourceFinger WlPointerAxisSource = 1

	// WlPointerAxisSourceContinuous corresponds to continuous coordinate space
	WlPointerAxisSourceContinuous WlPointerAxisSource = 2

	// WlPointerAxisSourceWheelTilt corresponds to a physical wheel tilt
	WlPointerAxisSourceWheelTilt WlPointerAxisSource = 3
)

// WlPointerSetCursorRequest requests to set the pointer surface
//
// Set the pointer surface, i.e., the surface that contains the
// pointer image (cursor). This request gives the surface the role
// of a cursor. If the surface already has another role, it raises
// a protocol error.
//
// The cursor actually changes only if the pointer
// focus for this device is one of the requesting client's surfaces
// or the surface parameter is the current pointer surface. If
// there was a previous surface set with this request it is
// replaced. If surface is NULL, the pointer image is hidden.
//
// The parameters hotspot_x and hotspot_y define the position of
// the pointer surface relative to the pointer location. Its
// top-left corner is always at (x, y) - (hotspot_x, hotspot_y),
// where (x, y) are the coordinates of the pointer location, in
// surface-local coordinates.
//
// On surface.attach requests to the pointer surface, hotspot_x
// and hotspot_y are decremented by the x and y parameters
// passed to the request. Attach must be confirmed by
// wl_surface.commit as usual.
//
// The hotspot can also be updated by passing the currently set
// pointer surface to this request with new values for hotspot_x
// and hotspot_y.
//
// The current and pending input regions of the wl_surface are
// cleared, and wl_surface.set_input_region is ignored until the
// wl_surface is no longer used as the cursor. When the use as a
// cursor ends, the current and pending input regions become
// undefined, and the wl_surface is unmapped.
//
// The serial parameter must match the latest wl_pointer.enter
// serial number sent to the client. Otherwise the request will be
// ignored.
type WlPointerSetCursorRequest struct {
	// Serial contains serial number of the enter event
	Serial uint32

	// Surface contains pointer surface
	Surface ObjectID

	// HotspotX contains surface-local x coordinate
	HotspotX int32

	// HotspotY contains surface-local y coordinate
	HotspotY int32
}

// Opcode returns the request opcode for wl_pointer.set_cursor in wayland
func (WlPointerSetCursorRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for wl_pointer.set_cursor in wayland
func (WlPointerSetCursorRequest) MessageName() string { return "set_cursor" }

// Ensure WlPointerSetCursorRequest implements Message.
var _ Message = WlPointerSetCursorRequest{}

// Emit emits the message to the emitter.
func (r *WlPointerSetCursorRequest) Emit(e *RequestEmitter) error {
	if err := e.PutUint(r.Serial); err != nil {
		return err
	}
	if err := e.PutObjectID(r.Surface); err != nil {
		return err
	}
	if err := e.PutInt(r.HotspotX); err != nil {
		return err
	}
	if err := e.PutInt(r.HotspotY); err != nil {
		return err
	}
	return nil
}

// Ensure WlPointerSetCursorRequest implements Request.
var _ Request = &WlPointerSetCursorRequest{}

// WlPointerReleaseRequest requests to release the pointer object
//
// Using this request a client can tell the server that it is not going to
// use the pointer object anymore.
//
// This request destroys the pointer proxy object, so clients must not call
// wl_pointer_destroy() after using this request.
type WlPointerReleaseRequest struct {
}

// Opcode returns the request opcode for wl_pointer.release in wayland
func (WlPointerReleaseRequest) Opcode() uint16 { return 1 }

// MessageName returns the request name for wl_pointer.release in wayland
func (WlPointerReleaseRequest) MessageName() string { return "release" }

// Ensure WlPointerReleaseRequest implements Message.
var _ Message = WlPointerReleaseRequest{}

// Emit emits the message to the emitter.
func (r *WlPointerReleaseRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure WlPointerReleaseRequest implements Request.
var _ Request = &WlPointerReleaseRequest{}

// WlPointerEnterEvent signals when enter event
//
// Notification that this seat's pointer is focused on a certain
// surface.
//
// When a seat's focus enters a surface, the pointer image
// is undefined and a client should respond to this event by setting
// an appropriate pointer image with the set_cursor request.
type WlPointerEnterEvent struct {
	// Serial contains serial number of the enter event
	Serial uint32

	// Surface contains surface entered by the pointer
	Surface ObjectID

	// SurfaceX contains surface-local x coordinate
	SurfaceX Fixed

	// SurfaceY contains surface-local y coordinate
	SurfaceY Fixed
}

// Opcode returns the event opcode for wl_pointer.enter in wayland
func (WlPointerEnterEvent) Opcode() uint16 { return 0 }

// MessageName returns the event name for wl_pointer.enter in wayland
func (WlPointerEnterEvent) MessageName() string { return "enter" }

// Ensure WlPointerEnterEvent implements Message.
var _ Message = WlPointerEnterEvent{}

// Scan scans the event from the socket.
func (e *WlPointerEnterEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Serial = v
	}
	if v, err := s.ObjectID(); err != nil {
		return err
	} else {
		e.Surface = v
	}
	if v, err := s.Fixed(); err != nil {
		return err
	} else {
		e.SurfaceX = v
	}
	if v, err := s.Fixed(); err != nil {
		return err
	} else {
		e.SurfaceY = v
	}
	return nil
}

// Ensure WlPointerEnterEvent implements Event.
var _ Event = &WlPointerEnterEvent{}

// WlPointerLeaveEvent signals when leave event
//
// Notification that this seat's pointer is no longer focused on
// a certain surface.
//
// The leave notification is sent before the enter notification
// for the new focus.
type WlPointerLeaveEvent struct {
	// Serial contains serial number of the leave event
	Serial uint32

	// Surface contains surface left by the pointer
	Surface ObjectID
}

// Opcode returns the event opcode for wl_pointer.leave in wayland
func (WlPointerLeaveEvent) Opcode() uint16 { return 1 }

// MessageName returns the event name for wl_pointer.leave in wayland
func (WlPointerLeaveEvent) MessageName() string { return "leave" }

// Ensure WlPointerLeaveEvent implements Message.
var _ Message = WlPointerLeaveEvent{}

// Scan scans the event from the socket.
func (e *WlPointerLeaveEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Serial = v
	}
	if v, err := s.ObjectID(); err != nil {
		return err
	} else {
		e.Surface = v
	}
	return nil
}

// Ensure WlPointerLeaveEvent implements Event.
var _ Event = &WlPointerLeaveEvent{}

// WlPointerMotionEvent signals when pointer motion event
//
// Notification of pointer location change. The arguments
// surface_x and surface_y are the location relative to the
// focused surface.
type WlPointerMotionEvent struct {
	// Time contains timestamp with millisecond granularity
	Time uint32

	// SurfaceX contains surface-local x coordinate
	SurfaceX Fixed

	// SurfaceY contains surface-local y coordinate
	SurfaceY Fixed
}

// Opcode returns the event opcode for wl_pointer.motion in wayland
func (WlPointerMotionEvent) Opcode() uint16 { return 2 }

// MessageName returns the event name for wl_pointer.motion in wayland
func (WlPointerMotionEvent) MessageName() string { return "motion" }

// Ensure WlPointerMotionEvent implements Message.
var _ Message = WlPointerMotionEvent{}

// Scan scans the event from the socket.
func (e *WlPointerMotionEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Time = v
	}
	if v, err := s.Fixed(); err != nil {
		return err
	} else {
		e.SurfaceX = v
	}
	if v, err := s.Fixed(); err != nil {
		return err
	} else {
		e.SurfaceY = v
	}
	return nil
}

// Ensure WlPointerMotionEvent implements Event.
var _ Event = &WlPointerMotionEvent{}

// WlPointerButtonEvent signals when pointer button event
//
// Mouse button click and release notifications.
//
// The location of the click is given by the last motion or
// enter event.
// The time argument is a timestamp with millisecond
// granularity, with an undefined base.
//
// The button is a button code as defined in the Linux kernel's
// linux/input-event-codes.h header file, e.g. BTN_LEFT.
//
// Any 16-bit button code value is reserved for future additions to the
// kernel's event code list. All other button codes above 0xFFFF are
// currently undefined but may be used in future versions of this
// protocol.
type WlPointerButtonEvent struct {
	// Serial contains serial number of the button event
	Serial uint32

	// Time contains timestamp with millisecond granularity
	Time uint32

	// Button contains button that produced the event
	Button uint32

	// State contains physical state of the button
	State uint32
}

// Opcode returns the event opcode for wl_pointer.button in wayland
func (WlPointerButtonEvent) Opcode() uint16 { return 3 }

// MessageName returns the event name for wl_pointer.button in wayland
func (WlPointerButtonEvent) MessageName() string { return "button" }

// Ensure WlPointerButtonEvent implements Message.
var _ Message = WlPointerButtonEvent{}

// Scan scans the event from the socket.
func (e *WlPointerButtonEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Serial = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Time = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Button = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.State = v
	}
	return nil
}

// Ensure WlPointerButtonEvent implements Event.
var _ Event = &WlPointerButtonEvent{}

// WlPointerAxisEvent signals when axis event
//
// Scroll and other axis notifications.
//
// For scroll events (vertical and horizontal scroll axes), the
// value parameter is the length of a vector along the specified
// axis in a coordinate space identical to those of motion events,
// representing a relative movement along the specified axis.
//
// For devices that support movements non-parallel to axes multiple
// axis events will be emitted.
//
// When applicable, for example for touch pads, the server can
// choose to emit scroll events where the motion vector is
// equivalent to a motion event vector.
//
// When applicable, a client can transform its content relative to the
// scroll distance.
type WlPointerAxisEvent struct {
	// Time contains timestamp with millisecond granularity
	Time uint32

	// Axis contains axis type
	Axis uint32

	// Value contains length of vector in surface-local coordinate space
	Value Fixed
}

// Opcode returns the event opcode for wl_pointer.axis in wayland
func (WlPointerAxisEvent) Opcode() uint16 { return 4 }

// MessageName returns the event name for wl_pointer.axis in wayland
func (WlPointerAxisEvent) MessageName() string { return "axis" }

// Ensure WlPointerAxisEvent implements Message.
var _ Message = WlPointerAxisEvent{}

// Scan scans the event from the socket.
func (e *WlPointerAxisEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Time = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Axis = v
	}
	if v, err := s.Fixed(); err != nil {
		return err
	} else {
		e.Value = v
	}
	return nil
}

// Ensure WlPointerAxisEvent implements Event.
var _ Event = &WlPointerAxisEvent{}

// WlPointerFrameEvent signals when end of a pointer event sequence
//
// Indicates the end of a set of events that logically belong together.
// A client is expected to accumulate the data in all events within the
// frame before proceeding.
//
// All wl_pointer events before a wl_pointer.frame event belong
// logically together. For example, in a diagonal scroll motion the
// compositor will send an optional wl_pointer.axis_source event, two
// wl_pointer.axis events (horizontal and vertical) and finally a
// wl_pointer.frame event. The client may use this information to
// calculate a diagonal vector for scrolling.
//
// When multiple wl_pointer.axis events occur within the same frame,
// the motion vector is the combined motion of all events.
// When a wl_pointer.axis and a wl_pointer.axis_stop event occur within
// the same frame, this indicates that axis movement in one axis has
// stopped but continues in the other axis.
// When multiple wl_pointer.axis_stop events occur within the same
// frame, this indicates that these axes stopped in the same instance.
//
// A wl_pointer.frame event is sent for every logical event group,
// even if the group only contains a single wl_pointer event.
// Specifically, a client may get a sequence: motion, frame, button,
// frame, axis, frame, axis_stop, frame.
//
// The wl_pointer.enter and wl_pointer.leave events are logical events
// generated by the compositor and not the hardware. These events are
// also grouped by a wl_pointer.frame. When a pointer moves from one
// surface to another, a compositor should group the
// wl_pointer.leave event within the same wl_pointer.frame.
// However, a client must not rely on wl_pointer.leave and
// wl_pointer.enter being in the same wl_pointer.frame.
// Compositor-specific policies may require the wl_pointer.leave and
// wl_pointer.enter event being split across multiple wl_pointer.frame
// groups.
type WlPointerFrameEvent struct {
}

// Opcode returns the event opcode for wl_pointer.frame in wayland
func (WlPointerFrameEvent) Opcode() uint16 { return 5 }

// MessageName returns the event name for wl_pointer.frame in wayland
func (WlPointerFrameEvent) MessageName() string { return "frame" }

// Ensure WlPointerFrameEvent implements Message.
var _ Message = WlPointerFrameEvent{}

// Scan scans the event from the socket.
func (e *WlPointerFrameEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure WlPointerFrameEvent implements Event.
var _ Event = &WlPointerFrameEvent{}

// WlPointerAxisSourceEvent signals when axis source event
//
// Source information for scroll and other axes.
//
// This event does not occur on its own. It is sent before a
// wl_pointer.frame event and carries the source information for
// all events within that frame.
//
// The source specifies how this event was generated. If the source is
// wl_pointer.axis_source.finger, a wl_pointer.axis_stop event will be
// sent when the user lifts the finger off the device.
//
// If the source is wl_pointer.axis_source.wheel,
// wl_pointer.axis_source.wheel_tilt or
// wl_pointer.axis_source.continuous, a wl_pointer.axis_stop event may
// or may not be sent. Whether a compositor sends an axis_stop event
// for these sources is hardware-specific and implementation-dependent;
// clients must not rely on receiving an axis_stop event for these
// scroll sources and should treat scroll sequences from these scroll
// sources as unterminated by default.
//
// This event is optional. If the source is unknown for a particular
// axis event sequence, no event is sent.
// Only one wl_pointer.axis_source event is permitted per frame.
//
// The order of wl_pointer.axis_discrete and wl_pointer.axis_source is
// not guaranteed.
type WlPointerAxisSourceEvent struct {
	// AxisSource contains source of the axis event
	AxisSource uint32
}

// Opcode returns the event opcode for wl_pointer.axis_source in wayland
func (WlPointerAxisSourceEvent) Opcode() uint16 { return 6 }

// MessageName returns the event name for wl_pointer.axis_source in wayland
func (WlPointerAxisSourceEvent) MessageName() string { return "axis_source" }

// Ensure WlPointerAxisSourceEvent implements Message.
var _ Message = WlPointerAxisSourceEvent{}

// Scan scans the event from the socket.
func (e *WlPointerAxisSourceEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.AxisSource = v
	}
	return nil
}

// Ensure WlPointerAxisSourceEvent implements Event.
var _ Event = &WlPointerAxisSourceEvent{}

// WlPointerAxisStopEvent signals when axis stop event
//
// Stop notification for scroll and other axes.
//
// For some wl_pointer.axis_source types, a wl_pointer.axis_stop event
// is sent to notify a client that the axis sequence has terminated.
// This enables the client to implement kinetic scrolling.
// See the wl_pointer.axis_source documentation for information on when
// this event may be generated.
//
// Any wl_pointer.axis events with the same axis_source after this
// event should be considered as the start of a new axis motion.
//
// The timestamp is to be interpreted identical to the timestamp in the
// wl_pointer.axis event. The timestamp value may be the same as a
// preceding wl_pointer.axis event.
type WlPointerAxisStopEvent struct {
	// Time contains timestamp with millisecond granularity
	Time uint32

	// Axis contains the axis stopped with this event
	Axis uint32
}

// Opcode returns the event opcode for wl_pointer.axis_stop in wayland
func (WlPointerAxisStopEvent) Opcode() uint16 { return 7 }

// MessageName returns the event name for wl_pointer.axis_stop in wayland
func (WlPointerAxisStopEvent) MessageName() string { return "axis_stop" }

// Ensure WlPointerAxisStopEvent implements Message.
var _ Message = WlPointerAxisStopEvent{}

// Scan scans the event from the socket.
func (e *WlPointerAxisStopEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Time = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Axis = v
	}
	return nil
}

// Ensure WlPointerAxisStopEvent implements Event.
var _ Event = &WlPointerAxisStopEvent{}

// WlPointerAxisDiscreteEvent signals when axis click event
//
// Discrete step information for scroll and other axes.
//
// This event carries the axis value of the wl_pointer.axis event in
// discrete steps (e.g. mouse wheel clicks).
//
// This event does not occur on its own, it is coupled with a
// wl_pointer.axis event that represents this axis value on a
// continuous scale. The protocol guarantees that each axis_discrete
// event is always followed by exactly one axis event with the same
// axis number within the same wl_pointer.frame. Note that the protocol
// allows for other events to occur between the axis_discrete and
// its coupled axis event, including other axis_discrete or axis
// events.
//
// This event is optional; continuous scrolling devices
// like two-finger scrolling on touchpads do not have discrete
// steps and do not generate this event.
//
// The discrete value carries the directional information. e.g. a value
// of -2 is two steps towards the negative direction of this axis.
//
// The axis number is identical to the axis number in the associated
// axis event.
//
// The order of wl_pointer.axis_discrete and wl_pointer.axis_source is
// not guaranteed.
type WlPointerAxisDiscreteEvent struct {
	// Axis contains axis type
	Axis uint32

	// Discrete contains number of steps
	Discrete int32
}

// Opcode returns the event opcode for wl_pointer.axis_discrete in wayland
func (WlPointerAxisDiscreteEvent) Opcode() uint16 { return 8 }

// MessageName returns the event name for wl_pointer.axis_discrete in wayland
func (WlPointerAxisDiscreteEvent) MessageName() string { return "axis_discrete" }

// Ensure WlPointerAxisDiscreteEvent implements Message.
var _ Message = WlPointerAxisDiscreteEvent{}

// Scan scans the event from the socket.
func (e *WlPointerAxisDiscreteEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Axis = v
	}
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.Discrete = v
	}
	return nil
}

// Ensure WlPointerAxisDiscreteEvent implements Event.
var _ Event = &WlPointerAxisDiscreteEvent{}

// WlPointer pointer input device
//
// The wl_pointer interface represents one or more input devices,
// such as mice, which control the pointer location and pointer_focus
// of a seat.
//
// The wl_pointer interface generates motion, enter and leave
// events for the surfaces that the pointer is located over,
// and button and axis events for button presses, button releases
// and scrolling.
type WlPointer struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *WlPointer) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (WlPointer) Descriptor() *InterfaceDescriptor {
	return &WlPointerDescriptor
}

// Dispatch returns an Event object for a given opcode.
func (WlPointer) Dispatch(opcode uint16) Event {
	switch opcode {
	case 0:
		return &WlPointerEnterEvent{}
	case 1:
		return &WlPointerLeaveEvent{}
	case 2:
		return &WlPointerMotionEvent{}
	case 3:
		return &WlPointerButtonEvent{}
	case 4:
		return &WlPointerAxisEvent{}
	case 5:
		return &WlPointerFrameEvent{}
	case 6:
		return &WlPointerAxisSourceEvent{}
	case 7:
		return &WlPointerAxisStopEvent{}
	case 8:
		return &WlPointerAxisDiscreteEvent{}
	default:
		return nil
	}
}

// SetCursor requests to set the pointer surface
//
// Set the pointer surface, i.e., the surface that contains the
// pointer image (cursor). This request gives the surface the role
// of a cursor. If the surface already has another role, it raises
// a protocol error.
//
// The cursor actually changes only if the pointer
// focus for this device is one of the requesting client's surfaces
// or the surface parameter is the current pointer surface. If
// there was a previous surface set with this request it is
// replaced. If surface is NULL, the pointer image is hidden.
//
// The parameters hotspot_x and hotspot_y define the position of
// the pointer surface relative to the pointer location. Its
// top-left corner is always at (x, y) - (hotspot_x, hotspot_y),
// where (x, y) are the coordinates of the pointer location, in
// surface-local coordinates.
//
// On surface.attach requests to the pointer surface, hotspot_x
// and hotspot_y are decremented by the x and y parameters
// passed to the request. Attach must be confirmed by
// wl_surface.commit as usual.
//
// The hotspot can also be updated by passing the currently set
// pointer surface to this request with new values for hotspot_x
// and hotspot_y.
//
// The current and pending input regions of the wl_surface are
// cleared, and wl_surface.set_input_region is ignored until the
// wl_surface is no longer used as the cursor. When the use as a
// cursor ends, the current and pending input regions become
// undefined, and the wl_surface is unmapped.
//
// The serial parameter must match the latest wl_pointer.enter
// serial number sent to the client. Otherwise the request will be
// ignored.
func (proxy *WlPointer) SetCursor(connection Connection, aSerial uint32, aSurface ObjectID, aHotspotX int32, aHotspotY int32) (err error) {
	request := WlPointerSetCursorRequest{
		Serial:   aSerial,
		Surface:  aSurface,
		HotspotX: aHotspotX,
		HotspotY: aHotspotY,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Release requests to release the pointer object
//
// Using this request a client can tell the server that it is not going to
// use the pointer object anymore.
//
// This request destroys the pointer proxy object, so clients must not call
// wl_pointer_destroy() after using this request.
func (proxy *WlPointer) Release(connection Connection) (err error) {
	request := WlPointerReleaseRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Ensure WlPointer implements Proxy.
var _ Proxy = &WlPointer{}

// #endregion Interface wayland.wl_pointer

// ----------------------------------------------------------------------------
// #region Interface wayland.wl_keyboard

// WlKeyboardKeymapFormat represents keyboard mapping format
//
// This specifies the format of the keymap provided to the
// client with the wl_keyboard.keymap event.
type WlKeyboardKeymapFormat int

const (
	// WlKeyboardKeymapFormatNoKeymap corresponds to no keymap; client must understand how to interpret the raw keycode
	WlKeyboardKeymapFormatNoKeymap WlKeyboardKeymapFormat = 0

	// WlKeyboardKeymapFormatXkbV1 corresponds to libxkbcommon compatible; to determine the xkb keycode, clients must add 8 to the key event keycode
	WlKeyboardKeymapFormatXkbV1 WlKeyboardKeymapFormat = 1
)

// WlKeyboardKeyState represents physical key state
//
// Describes the physical state of a key that produced the key event.
type WlKeyboardKeyState int

const (
	// WlKeyboardKeyStateReleased corresponds to key is not pressed
	WlKeyboardKeyStateReleased WlKeyboardKeyState = 0

	// WlKeyboardKeyStatePressed corresponds to key is pressed
	WlKeyboardKeyStatePressed WlKeyboardKeyState = 1
)

// WlKeyboardReleaseRequest requests to release the keyboard object
type WlKeyboardReleaseRequest struct {
}

// Opcode returns the request opcode for wl_keyboard.release in wayland
func (WlKeyboardReleaseRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for wl_keyboard.release in wayland
func (WlKeyboardReleaseRequest) MessageName() string { return "release" }

// Ensure WlKeyboardReleaseRequest implements Message.
var _ Message = WlKeyboardReleaseRequest{}

// Emit emits the message to the emitter.
func (r *WlKeyboardReleaseRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure WlKeyboardReleaseRequest implements Request.
var _ Request = &WlKeyboardReleaseRequest{}

// WlKeyboardKeymapEvent signals when keyboard mapping
//
// This event provides a file descriptor to the client which can be
// memory-mapped in read-only mode to provide a keyboard mapping
// description.
//
// From version 7 onwards, the fd must be mapped with MAP_PRIVATE by
// the recipient, as MAP_SHARED may fail.
type WlKeyboardKeymapEvent struct {
	// Format contains keymap format
	Format uint32

	// FD contains keymap file descriptor
	FD FD

	// Size contains keymap size, in bytes
	Size uint32
}

// Opcode returns the event opcode for wl_keyboard.keymap in wayland
func (WlKeyboardKeymapEvent) Opcode() uint16 { return 0 }

// MessageName returns the event name for wl_keyboard.keymap in wayland
func (WlKeyboardKeymapEvent) MessageName() string { return "keymap" }

// Ensure WlKeyboardKeymapEvent implements Message.
var _ Message = WlKeyboardKeymapEvent{}

// Scan scans the event from the socket.
func (e *WlKeyboardKeymapEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Format = v
	}
	if v, err := s.FD(); err != nil {
		return err
	} else {
		e.FD = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Size = v
	}
	return nil
}

// Ensure WlKeyboardKeymapEvent implements Event.
var _ Event = &WlKeyboardKeymapEvent{}

// WlKeyboardEnterEvent signals when enter event
//
// Notification that this seat's keyboard focus is on a certain
// surface.
//
// The compositor must send the wl_keyboard.modifiers event after this
// event.
type WlKeyboardEnterEvent struct {
	// Serial contains serial number of the enter event
	Serial uint32

	// Surface contains surface gaining keyboard focus
	Surface ObjectID

	// Keys contains the currently pressed keys
	Keys []byte
}

// Opcode returns the event opcode for wl_keyboard.enter in wayland
func (WlKeyboardEnterEvent) Opcode() uint16 { return 1 }

// MessageName returns the event name for wl_keyboard.enter in wayland
func (WlKeyboardEnterEvent) MessageName() string { return "enter" }

// Ensure WlKeyboardEnterEvent implements Message.
var _ Message = WlKeyboardEnterEvent{}

// Scan scans the event from the socket.
func (e *WlKeyboardEnterEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Serial = v
	}
	if v, err := s.ObjectID(); err != nil {
		return err
	} else {
		e.Surface = v
	}
	if v, err := s.Array(); err != nil {
		return err
	} else {
		e.Keys = v
	}
	return nil
}

// Ensure WlKeyboardEnterEvent implements Event.
var _ Event = &WlKeyboardEnterEvent{}

// WlKeyboardLeaveEvent signals when leave event
//
// Notification that this seat's keyboard focus is no longer on
// a certain surface.
//
// The leave notification is sent before the enter notification
// for the new focus.
//
// After this event client must assume that all keys, including modifiers,
// are lifted and also it must stop key repeating if there's some going on.
type WlKeyboardLeaveEvent struct {
	// Serial contains serial number of the leave event
	Serial uint32

	// Surface contains surface that lost keyboard focus
	Surface ObjectID
}

// Opcode returns the event opcode for wl_keyboard.leave in wayland
func (WlKeyboardLeaveEvent) Opcode() uint16 { return 2 }

// MessageName returns the event name for wl_keyboard.leave in wayland
func (WlKeyboardLeaveEvent) MessageName() string { return "leave" }

// Ensure WlKeyboardLeaveEvent implements Message.
var _ Message = WlKeyboardLeaveEvent{}

// Scan scans the event from the socket.
func (e *WlKeyboardLeaveEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Serial = v
	}
	if v, err := s.ObjectID(); err != nil {
		return err
	} else {
		e.Surface = v
	}
	return nil
}

// Ensure WlKeyboardLeaveEvent implements Event.
var _ Event = &WlKeyboardLeaveEvent{}

// WlKeyboardKeyEvent signals when key event
//
// A key was pressed or released.
// The time argument is a timestamp with millisecond
// granularity, with an undefined base.
//
// The key is a platform-specific key code that can be interpreted
// by feeding it to the keyboard mapping (see the keymap event).
//
// If this event produces a change in modifiers, then the resulting
// wl_keyboard.modifiers event must be sent after this event.
type WlKeyboardKeyEvent struct {
	// Serial contains serial number of the key event
	Serial uint32

	// Time contains timestamp with millisecond granularity
	Time uint32

	// Key contains key that produced the event
	Key uint32

	// State contains physical state of the key
	State uint32
}

// Opcode returns the event opcode for wl_keyboard.key in wayland
func (WlKeyboardKeyEvent) Opcode() uint16 { return 3 }

// MessageName returns the event name for wl_keyboard.key in wayland
func (WlKeyboardKeyEvent) MessageName() string { return "key" }

// Ensure WlKeyboardKeyEvent implements Message.
var _ Message = WlKeyboardKeyEvent{}

// Scan scans the event from the socket.
func (e *WlKeyboardKeyEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Serial = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Time = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Key = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.State = v
	}
	return nil
}

// Ensure WlKeyboardKeyEvent implements Event.
var _ Event = &WlKeyboardKeyEvent{}

// WlKeyboardModifiersEvent signals when modifier and group state
//
// Notifies clients that the modifier and/or group state has
// changed, and it should update its local state.
type WlKeyboardModifiersEvent struct {
	// Serial contains serial number of the modifiers event
	Serial uint32

	// ModsDepressed contains depressed modifiers
	ModsDepressed uint32

	// ModsLatched contains latched modifiers
	ModsLatched uint32

	// ModsLocked contains locked modifiers
	ModsLocked uint32

	// Group contains keyboard layout
	Group uint32
}

// Opcode returns the event opcode for wl_keyboard.modifiers in wayland
func (WlKeyboardModifiersEvent) Opcode() uint16 { return 4 }

// MessageName returns the event name for wl_keyboard.modifiers in wayland
func (WlKeyboardModifiersEvent) MessageName() string { return "modifiers" }

// Ensure WlKeyboardModifiersEvent implements Message.
var _ Message = WlKeyboardModifiersEvent{}

// Scan scans the event from the socket.
func (e *WlKeyboardModifiersEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Serial = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.ModsDepressed = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.ModsLatched = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.ModsLocked = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Group = v
	}
	return nil
}

// Ensure WlKeyboardModifiersEvent implements Event.
var _ Event = &WlKeyboardModifiersEvent{}

// WlKeyboardRepeatInfoEvent signals when repeat rate and delay
//
// Informs the client about the keyboard's repeat rate and delay.
//
// This event is sent as soon as the wl_keyboard object has been created,
// and is guaranteed to be received by the client before any key press
// event.
//
// Negative values for either rate or delay are illegal. A rate of zero
// will disable any repeating (regardless of the value of delay).
//
// This event can be sent later on as well with a new value if necessary,
// so clients should continue listening for the event past the creation
// of wl_keyboard.
type WlKeyboardRepeatInfoEvent struct {
	// Rate contains the rate of repeating keys in characters per second
	Rate int32

	// Delay contains delay in milliseconds since key down until repeating starts
	Delay int32
}

// Opcode returns the event opcode for wl_keyboard.repeat_info in wayland
func (WlKeyboardRepeatInfoEvent) Opcode() uint16 { return 5 }

// MessageName returns the event name for wl_keyboard.repeat_info in wayland
func (WlKeyboardRepeatInfoEvent) MessageName() string { return "repeat_info" }

// Ensure WlKeyboardRepeatInfoEvent implements Message.
var _ Message = WlKeyboardRepeatInfoEvent{}

// Scan scans the event from the socket.
func (e *WlKeyboardRepeatInfoEvent) Scan(s *EventScanner) error {
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.Rate = v
	}
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.Delay = v
	}
	return nil
}

// Ensure WlKeyboardRepeatInfoEvent implements Event.
var _ Event = &WlKeyboardRepeatInfoEvent{}

// WlKeyboard keyboard input device
//
// The wl_keyboard interface represents one or more keyboards
// associated with a seat.
type WlKeyboard struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *WlKeyboard) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (WlKeyboard) Descriptor() *InterfaceDescriptor {
	return &WlKeyboardDescriptor
}

// Dispatch returns an Event object for a given opcode.
func (WlKeyboard) Dispatch(opcode uint16) Event {
	switch opcode {
	case 0:
		return &WlKeyboardKeymapEvent{}
	case 1:
		return &WlKeyboardEnterEvent{}
	case 2:
		return &WlKeyboardLeaveEvent{}
	case 3:
		return &WlKeyboardKeyEvent{}
	case 4:
		return &WlKeyboardModifiersEvent{}
	case 5:
		return &WlKeyboardRepeatInfoEvent{}
	default:
		return nil
	}
}

// Release requests to release the keyboard object
func (proxy *WlKeyboard) Release(connection Connection) (err error) {
	request := WlKeyboardReleaseRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Ensure WlKeyboard implements Proxy.
var _ Proxy = &WlKeyboard{}

// #endregion Interface wayland.wl_keyboard

// ----------------------------------------------------------------------------
// #region Interface wayland.wl_touch

// WlTouchReleaseRequest requests to release the touch object
type WlTouchReleaseRequest struct {
}

// Opcode returns the request opcode for wl_touch.release in wayland
func (WlTouchReleaseRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for wl_touch.release in wayland
func (WlTouchReleaseRequest) MessageName() string { return "release" }

// Ensure WlTouchReleaseRequest implements Message.
var _ Message = WlTouchReleaseRequest{}

// Emit emits the message to the emitter.
func (r *WlTouchReleaseRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure WlTouchReleaseRequest implements Request.
var _ Request = &WlTouchReleaseRequest{}

// WlTouchDownEvent signals when touch down event and beginning of a touch sequence
//
// A new touch point has appeared on the surface. This touch point is
// assigned a unique ID. Future events from this touch point reference
// this ID. The ID ceases to be valid after a touch up event and may be
// reused in the future.
type WlTouchDownEvent struct {
	// Serial contains serial number of the touch down event
	Serial uint32

	// Time contains timestamp with millisecond granularity
	Time uint32

	// Surface contains surface touched
	Surface ObjectID

	// ID contains the unique ID of this touch point
	ID int32

	// X contains surface-local x coordinate
	X Fixed

	// Y contains surface-local y coordinate
	Y Fixed
}

// Opcode returns the event opcode for wl_touch.down in wayland
func (WlTouchDownEvent) Opcode() uint16 { return 0 }

// MessageName returns the event name for wl_touch.down in wayland
func (WlTouchDownEvent) MessageName() string { return "down" }

// Ensure WlTouchDownEvent implements Message.
var _ Message = WlTouchDownEvent{}

// Scan scans the event from the socket.
func (e *WlTouchDownEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Serial = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Time = v
	}
	if v, err := s.ObjectID(); err != nil {
		return err
	} else {
		e.Surface = v
	}
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.ID = v
	}
	if v, err := s.Fixed(); err != nil {
		return err
	} else {
		e.X = v
	}
	if v, err := s.Fixed(); err != nil {
		return err
	} else {
		e.Y = v
	}
	return nil
}

// Ensure WlTouchDownEvent implements Event.
var _ Event = &WlTouchDownEvent{}

// WlTouchUpEvent signals when end of a touch event sequence
//
// The touch point has disappeared. No further events will be sent for
// this touch point and the touch point's ID is released and may be
// reused in a future touch down event.
type WlTouchUpEvent struct {
	// Serial contains serial number of the touch up event
	Serial uint32

	// Time contains timestamp with millisecond granularity
	Time uint32

	// ID contains the unique ID of this touch point
	ID int32
}

// Opcode returns the event opcode for wl_touch.up in wayland
func (WlTouchUpEvent) Opcode() uint16 { return 1 }

// MessageName returns the event name for wl_touch.up in wayland
func (WlTouchUpEvent) MessageName() string { return "up" }

// Ensure WlTouchUpEvent implements Message.
var _ Message = WlTouchUpEvent{}

// Scan scans the event from the socket.
func (e *WlTouchUpEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Serial = v
	}
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Time = v
	}
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.ID = v
	}
	return nil
}

// Ensure WlTouchUpEvent implements Event.
var _ Event = &WlTouchUpEvent{}

// WlTouchMotionEvent signals when update of touch point coordinates
//
// A touch point has changed coordinates.
type WlTouchMotionEvent struct {
	// Time contains timestamp with millisecond granularity
	Time uint32

	// ID contains the unique ID of this touch point
	ID int32

	// X contains surface-local x coordinate
	X Fixed

	// Y contains surface-local y coordinate
	Y Fixed
}

// Opcode returns the event opcode for wl_touch.motion in wayland
func (WlTouchMotionEvent) Opcode() uint16 { return 2 }

// MessageName returns the event name for wl_touch.motion in wayland
func (WlTouchMotionEvent) MessageName() string { return "motion" }

// Ensure WlTouchMotionEvent implements Message.
var _ Message = WlTouchMotionEvent{}

// Scan scans the event from the socket.
func (e *WlTouchMotionEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Time = v
	}
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.ID = v
	}
	if v, err := s.Fixed(); err != nil {
		return err
	} else {
		e.X = v
	}
	if v, err := s.Fixed(); err != nil {
		return err
	} else {
		e.Y = v
	}
	return nil
}

// Ensure WlTouchMotionEvent implements Event.
var _ Event = &WlTouchMotionEvent{}

// WlTouchFrameEvent signals when end of touch frame event
//
// Indicates the end of a set of events that logically belong together.
// A client is expected to accumulate the data in all events within the
// frame before proceeding.
//
// A wl_touch.frame terminates at least one event but otherwise no
// guarantee is provided about the set of events within a frame. A client
// must assume that any state not updated in a frame is unchanged from the
// previously known state.
type WlTouchFrameEvent struct {
}

// Opcode returns the event opcode for wl_touch.frame in wayland
func (WlTouchFrameEvent) Opcode() uint16 { return 3 }

// MessageName returns the event name for wl_touch.frame in wayland
func (WlTouchFrameEvent) MessageName() string { return "frame" }

// Ensure WlTouchFrameEvent implements Message.
var _ Message = WlTouchFrameEvent{}

// Scan scans the event from the socket.
func (e *WlTouchFrameEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure WlTouchFrameEvent implements Event.
var _ Event = &WlTouchFrameEvent{}

// WlTouchCancelEvent signals when touch session cancelled
//
// Sent if the compositor decides the touch stream is a global
// gesture. No further events are sent to the clients from that
// particular gesture. Touch cancellation applies to all touch points
// currently active on this client's surface. The client is
// responsible for finalizing the touch points, future touch points on
// this surface may reuse the touch point ID.
type WlTouchCancelEvent struct {
}

// Opcode returns the event opcode for wl_touch.cancel in wayland
func (WlTouchCancelEvent) Opcode() uint16 { return 4 }

// MessageName returns the event name for wl_touch.cancel in wayland
func (WlTouchCancelEvent) MessageName() string { return "cancel" }

// Ensure WlTouchCancelEvent implements Message.
var _ Message = WlTouchCancelEvent{}

// Scan scans the event from the socket.
func (e *WlTouchCancelEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure WlTouchCancelEvent implements Event.
var _ Event = &WlTouchCancelEvent{}

// WlTouchShapeEvent signals when update shape of touch point
//
// Sent when a touchpoint has changed its shape.
//
// This event does not occur on its own. It is sent before a
// wl_touch.frame event and carries the new shape information for
// any previously reported, or new touch points of that frame.
//
// Other events describing the touch point such as wl_touch.down,
// wl_touch.motion or wl_touch.orientation may be sent within the
// same wl_touch.frame. A client should treat these events as a single
// logical touch point update. The order of wl_touch.shape,
// wl_touch.orientation and wl_touch.motion is not guaranteed.
// A wl_touch.down event is guaranteed to occur before the first
// wl_touch.shape event for this touch ID but both events may occur within
// the same wl_touch.frame.
//
// A touchpoint shape is approximated by an ellipse through the major and
// minor axis length. The major axis length describes the longer diameter
// of the ellipse, while the minor axis length describes the shorter
// diameter. Major and minor are orthogonal and both are specified in
// surface-local coordinates. The center of the ellipse is always at the
// touchpoint location as reported by wl_touch.down or wl_touch.move.
//
// This event is only sent by the compositor if the touch device supports
// shape reports. The client has to make reasonable assumptions about the
// shape if it did not receive this event.
type WlTouchShapeEvent struct {
	// ID contains the unique ID of this touch point
	ID int32

	// Major contains length of the major axis in surface-local coordinates
	Major Fixed

	// Minor contains length of the minor axis in surface-local coordinates
	Minor Fixed
}

// Opcode returns the event opcode for wl_touch.shape in wayland
func (WlTouchShapeEvent) Opcode() uint16 { return 5 }

// MessageName returns the event name for wl_touch.shape in wayland
func (WlTouchShapeEvent) MessageName() string { return "shape" }

// Ensure WlTouchShapeEvent implements Message.
var _ Message = WlTouchShapeEvent{}

// Scan scans the event from the socket.
func (e *WlTouchShapeEvent) Scan(s *EventScanner) error {
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.ID = v
	}
	if v, err := s.Fixed(); err != nil {
		return err
	} else {
		e.Major = v
	}
	if v, err := s.Fixed(); err != nil {
		return err
	} else {
		e.Minor = v
	}
	return nil
}

// Ensure WlTouchShapeEvent implements Event.
var _ Event = &WlTouchShapeEvent{}

// WlTouchOrientationEvent signals when update orientation of touch point
//
// Sent when a touchpoint has changed its orientation.
//
// This event does not occur on its own. It is sent before a
// wl_touch.frame event and carries the new shape information for
// any previously reported, or new touch points of that frame.
//
// Other events describing the touch point such as wl_touch.down,
// wl_touch.motion or wl_touch.shape may be sent within the
// same wl_touch.frame. A client should treat these events as a single
// logical touch point update. The order of wl_touch.shape,
// wl_touch.orientation and wl_touch.motion is not guaranteed.
// A wl_touch.down event is guaranteed to occur before the first
// wl_touch.orientation event for this touch ID but both events may occur
// within the same wl_touch.frame.
//
// The orientation describes the clockwise angle of a touchpoint's major
// axis to the positive surface y-axis and is normalized to the -180 to
// +180 degree range. The granularity of orientation depends on the touch
// device, some devices only support binary rotation values between 0 and
// 90 degrees.
//
// This event is only sent by the compositor if the touch device supports
// orientation reports.
type WlTouchOrientationEvent struct {
	// ID contains the unique ID of this touch point
	ID int32

	// Orientation contains angle between major axis and positive surface y-axis in degrees
	Orientation Fixed
}

// Opcode returns the event opcode for wl_touch.orientation in wayland
func (WlTouchOrientationEvent) Opcode() uint16 { return 6 }

// MessageName returns the event name for wl_touch.orientation in wayland
func (WlTouchOrientationEvent) MessageName() string { return "orientation" }

// Ensure WlTouchOrientationEvent implements Message.
var _ Message = WlTouchOrientationEvent{}

// Scan scans the event from the socket.
func (e *WlTouchOrientationEvent) Scan(s *EventScanner) error {
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.ID = v
	}
	if v, err := s.Fixed(); err != nil {
		return err
	} else {
		e.Orientation = v
	}
	return nil
}

// Ensure WlTouchOrientationEvent implements Event.
var _ Event = &WlTouchOrientationEvent{}

// WlTouch touchscreen input device
//
// The wl_touch interface represents a touchscreen
// associated with a seat.
//
// Touch interactions can consist of one or more contacts.
// For each contact, a series of events is generated, starting
// with a down event, followed by zero or more motion events,
// and ending with an up event. Events relating to the same
// contact point can be identified by the ID of the sequence.
type WlTouch struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *WlTouch) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (WlTouch) Descriptor() *InterfaceDescriptor {
	return &WlTouchDescriptor
}

// Dispatch returns an Event object for a given opcode.
func (WlTouch) Dispatch(opcode uint16) Event {
	switch opcode {
	case 0:
		return &WlTouchDownEvent{}
	case 1:
		return &WlTouchUpEvent{}
	case 2:
		return &WlTouchMotionEvent{}
	case 3:
		return &WlTouchFrameEvent{}
	case 4:
		return &WlTouchCancelEvent{}
	case 5:
		return &WlTouchShapeEvent{}
	case 6:
		return &WlTouchOrientationEvent{}
	default:
		return nil
	}
}

// Release requests to release the touch object
func (proxy *WlTouch) Release(connection Connection) (err error) {
	request := WlTouchReleaseRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Ensure WlTouch implements Proxy.
var _ Proxy = &WlTouch{}

// #endregion Interface wayland.wl_touch

// ----------------------------------------------------------------------------
// #region Interface wayland.wl_output

// WlOutputSubpixel represents subpixel geometry information
//
// This enumeration describes how the physical
// pixels on an output are laid out.
type WlOutputSubpixel int

const (
	// WlOutputSubpixelUnknown corresponds to unknown geometry
	WlOutputSubpixelUnknown WlOutputSubpixel = 0

	// WlOutputSubpixelNone corresponds to no geometry
	WlOutputSubpixelNone WlOutputSubpixel = 1

	// WlOutputSubpixelHorizontalRgb corresponds to horizontal RGB
	WlOutputSubpixelHorizontalRgb WlOutputSubpixel = 2

	// WlOutputSubpixelHorizontalBgr corresponds to horizontal BGR
	WlOutputSubpixelHorizontalBgr WlOutputSubpixel = 3

	// WlOutputSubpixelVerticalRgb corresponds to vertical RGB
	WlOutputSubpixelVerticalRgb WlOutputSubpixel = 4

	// WlOutputSubpixelVerticalBgr corresponds to vertical BGR
	WlOutputSubpixelVerticalBgr WlOutputSubpixel = 5
)

// WlOutputTransform represents transform from framebuffer to output
//
// This describes the transform that a compositor will apply to a
// surface to compensate for the rotation or mirroring of an
// output device.
//
// The flipped values correspond to an initial flip around a
// vertical axis followed by rotation.
//
// The purpose is mainly to allow clients to render accordingly and
// tell the compositor, so that for fullscreen surfaces, the
// compositor will still be able to scan out directly from client
// surfaces.
type WlOutputTransform int

const (
	// WlOutputTransformNormal corresponds to no transform
	WlOutputTransformNormal WlOutputTransform = 0

	// WlOutputTransform90 corresponds to 90 degrees counter-clockwise
	WlOutputTransform90 WlOutputTransform = 1

	// WlOutputTransform180 corresponds to 180 degrees counter-clockwise
	WlOutputTransform180 WlOutputTransform = 2

	// WlOutputTransform270 corresponds to 270 degrees counter-clockwise
	WlOutputTransform270 WlOutputTransform = 3

	// WlOutputTransformFlipped corresponds to 180 degree flip around a vertical axis
	WlOutputTransformFlipped WlOutputTransform = 4

	// WlOutputTransformFlipped90 corresponds to flip and rotate 90 degrees counter-clockwise
	WlOutputTransformFlipped90 WlOutputTransform = 5

	// WlOutputTransformFlipped180 corresponds to flip and rotate 180 degrees counter-clockwise
	WlOutputTransformFlipped180 WlOutputTransform = 6

	// WlOutputTransformFlipped270 corresponds to flip and rotate 270 degrees counter-clockwise
	WlOutputTransformFlipped270 WlOutputTransform = 7
)

// WlOutputMode represents mode information
//
// These flags describe properties of an output mode.
// They are used in the flags bitfield of the mode event.
type WlOutputMode uint

const (
	// WlOutputModeCurrent corresponds to indicates this is the current mode
	WlOutputModeCurrent WlOutputMode = 0x1

	// WlOutputModePreferred corresponds to indicates this is the preferred mode
	WlOutputModePreferred WlOutputMode = 0x2
)

// WlOutputReleaseRequest requests to release the output object
//
// Using this request a client can tell the server that it is not going to
// use the output object anymore.
type WlOutputReleaseRequest struct {
}

// Opcode returns the request opcode for wl_output.release in wayland
func (WlOutputReleaseRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for wl_output.release in wayland
func (WlOutputReleaseRequest) MessageName() string { return "release" }

// Ensure WlOutputReleaseRequest implements Message.
var _ Message = WlOutputReleaseRequest{}

// Emit emits the message to the emitter.
func (r *WlOutputReleaseRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure WlOutputReleaseRequest implements Request.
var _ Request = &WlOutputReleaseRequest{}

// WlOutputGeometryEvent signals when properties of the output
//
// The geometry event describes geometric properties of the output.
// The event is sent when binding to the output object and whenever
// any of the properties change.
//
// The physical size can be set to zero if it doesn't make sense for this
// output (e.g. for projectors or virtual outputs).
//
// Note: wl_output only advertises partial information about the output
// position and identification. Some compositors, for instance those not
// implementing a desktop-style output layout or those exposing virtual
// outputs, might fake this information. Instead of using x and y, clients
// should use xdg_output.logical_position. Instead of using make and model,
// clients should use xdg_output.name and xdg_output.description.
type WlOutputGeometryEvent struct {
	// X contains x position within the global compositor space
	X int32

	// Y contains y position within the global compositor space
	Y int32

	// PhysicalWidth contains width in millimeters of the output
	PhysicalWidth int32

	// PhysicalHeight contains height in millimeters of the output
	PhysicalHeight int32

	// Subpixel contains subpixel orientation of the output
	Subpixel int32

	// Make contains textual description of the manufacturer
	Make string

	// Model contains textual description of the model
	Model string

	// Transform contains transform that maps framebuffer to output
	Transform int32
}

// Opcode returns the event opcode for wl_output.geometry in wayland
func (WlOutputGeometryEvent) Opcode() uint16 { return 0 }

// MessageName returns the event name for wl_output.geometry in wayland
func (WlOutputGeometryEvent) MessageName() string { return "geometry" }

// Ensure WlOutputGeometryEvent implements Message.
var _ Message = WlOutputGeometryEvent{}

// Scan scans the event from the socket.
func (e *WlOutputGeometryEvent) Scan(s *EventScanner) error {
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.X = v
	}
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.Y = v
	}
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.PhysicalWidth = v
	}
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.PhysicalHeight = v
	}
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.Subpixel = v
	}
	if v, err := s.String(); err != nil {
		return err
	} else {
		e.Make = v
	}
	if v, err := s.String(); err != nil {
		return err
	} else {
		e.Model = v
	}
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.Transform = v
	}
	return nil
}

// Ensure WlOutputGeometryEvent implements Event.
var _ Event = &WlOutputGeometryEvent{}

// WlOutputModeEvent signals when advertise available modes for the output
//
// The mode event describes an available mode for the output.
//
// The event is sent when binding to the output object and there
// will always be one mode, the current mode.  The event is sent
// again if an output changes mode, for the mode that is now
// current.  In other words, the current mode is always the last
// mode that was received with the current flag set.
//
// Non-current modes are deprecated. A compositor can decide to only
// advertise the current mode and never send other modes. Clients
// should not rely on non-current modes.
//
// The size of a mode is given in physical hardware units of
// the output device. This is not necessarily the same as
// the output size in the global compositor space. For instance,
// the output may be scaled, as described in wl_output.scale,
// or transformed, as described in wl_output.transform. Clients
// willing to retrieve the output size in the global compositor
// space should use xdg_output.logical_size instead.
//
// The vertical refresh rate can be set to zero if it doesn't make
// sense for this output (e.g. for virtual outputs).
//
// Clients should not use the refresh rate to schedule frames. Instead,
// they should use the wl_surface.frame event or the presentation-time
// protocol.
//
// Note: this information is not always meaningful for all outputs. Some
// compositors, such as those exposing virtual outputs, might fake the
// refresh rate or the size.
type WlOutputModeEvent struct {
	// Flags contains bitfield of mode flags
	Flags uint32

	// Width contains width of the mode in hardware units
	Width int32

	// Height contains height of the mode in hardware units
	Height int32

	// Refresh contains vertical refresh rate in mHz
	Refresh int32
}

// Opcode returns the event opcode for wl_output.mode in wayland
func (WlOutputModeEvent) Opcode() uint16 { return 1 }

// MessageName returns the event name for wl_output.mode in wayland
func (WlOutputModeEvent) MessageName() string { return "mode" }

// Ensure WlOutputModeEvent implements Message.
var _ Message = WlOutputModeEvent{}

// Scan scans the event from the socket.
func (e *WlOutputModeEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Flags = v
	}
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.Width = v
	}
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.Height = v
	}
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.Refresh = v
	}
	return nil
}

// Ensure WlOutputModeEvent implements Event.
var _ Event = &WlOutputModeEvent{}

// WlOutputDoneEvent signals when sent all information about output
//
// This event is sent after all other properties have been
// sent after binding to the output object and after any
// other property changes done after that. This allows
// changes to the output properties to be seen as
// atomic, even if they happen via multiple events.
type WlOutputDoneEvent struct {
}

// Opcode returns the event opcode for wl_output.done in wayland
func (WlOutputDoneEvent) Opcode() uint16 { return 2 }

// MessageName returns the event name for wl_output.done in wayland
func (WlOutputDoneEvent) MessageName() string { return "done" }

// Ensure WlOutputDoneEvent implements Message.
var _ Message = WlOutputDoneEvent{}

// Scan scans the event from the socket.
func (e *WlOutputDoneEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure WlOutputDoneEvent implements Event.
var _ Event = &WlOutputDoneEvent{}

// WlOutputScaleEvent signals when output scaling properties
//
// This event contains scaling geometry information
// that is not in the geometry event. It may be sent after
// binding the output object or if the output scale changes
// later. If it is not sent, the client should assume a
// scale of 1.
//
// A scale larger than 1 means that the compositor will
// automatically scale surface buffers by this amount
// when rendering. This is used for very high resolution
// displays where applications rendering at the native
// resolution would be too small to be legible.
//
// It is intended that scaling aware clients track the
// current output of a surface, and if it is on a scaled
// output it should use wl_surface.set_buffer_scale with
// the scale of the output. That way the compositor can
// avoid scaling the surface, and the client can supply
// a higher detail image.
type WlOutputScaleEvent struct {
	// Factor contains scaling factor of output
	Factor int32
}

// Opcode returns the event opcode for wl_output.scale in wayland
func (WlOutputScaleEvent) Opcode() uint16 { return 3 }

// MessageName returns the event name for wl_output.scale in wayland
func (WlOutputScaleEvent) MessageName() string { return "scale" }

// Ensure WlOutputScaleEvent implements Message.
var _ Message = WlOutputScaleEvent{}

// Scan scans the event from the socket.
func (e *WlOutputScaleEvent) Scan(s *EventScanner) error {
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.Factor = v
	}
	return nil
}

// Ensure WlOutputScaleEvent implements Event.
var _ Event = &WlOutputScaleEvent{}

// WlOutput compositor output region
//
// An output describes part of the compositor geometry.  The
// compositor works in the 'compositor coordinate system' and an
// output corresponds to a rectangular area in that space that is
// actually visible.  This typically corresponds to a monitor that
// displays part of the compositor space.  This object is published
// as global during start up, or when a monitor is hotplugged.
type WlOutput struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *WlOutput) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (WlOutput) Descriptor() *InterfaceDescriptor {
	return &WlOutputDescriptor
}

// Dispatch returns an Event object for a given opcode.
func (WlOutput) Dispatch(opcode uint16) Event {
	switch opcode {
	case 0:
		return &WlOutputGeometryEvent{}
	case 1:
		return &WlOutputModeEvent{}
	case 2:
		return &WlOutputDoneEvent{}
	case 3:
		return &WlOutputScaleEvent{}
	default:
		return nil
	}
}

// Release requests to release the output object
//
// Using this request a client can tell the server that it is not going to
// use the output object anymore.
func (proxy *WlOutput) Release(connection Connection) (err error) {
	request := WlOutputReleaseRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Ensure WlOutput implements Proxy.
var _ Proxy = &WlOutput{}

// #endregion Interface wayland.wl_output

// ----------------------------------------------------------------------------
// #region Interface wayland.wl_region

// WlRegionDestroyRequest requests to destroy region
//
// Destroy the region.  This will invalidate the object ID.
type WlRegionDestroyRequest struct {
}

// Opcode returns the request opcode for wl_region.destroy in wayland
func (WlRegionDestroyRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for wl_region.destroy in wayland
func (WlRegionDestroyRequest) MessageName() string { return "destroy" }

// Ensure WlRegionDestroyRequest implements Message.
var _ Message = WlRegionDestroyRequest{}

// Emit emits the message to the emitter.
func (r *WlRegionDestroyRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure WlRegionDestroyRequest implements Request.
var _ Request = &WlRegionDestroyRequest{}

// WlRegionAddRequest requests to add rectangle to region
//
// Add the specified rectangle to the region.
type WlRegionAddRequest struct {
	// X contains region-local x coordinate
	X int32

	// Y contains region-local y coordinate
	Y int32

	// Width contains rectangle width
	Width int32

	// Height contains rectangle height
	Height int32
}

// Opcode returns the request opcode for wl_region.add in wayland
func (WlRegionAddRequest) Opcode() uint16 { return 1 }

// MessageName returns the request name for wl_region.add in wayland
func (WlRegionAddRequest) MessageName() string { return "add" }

// Ensure WlRegionAddRequest implements Message.
var _ Message = WlRegionAddRequest{}

// Emit emits the message to the emitter.
func (r *WlRegionAddRequest) Emit(e *RequestEmitter) error {
	if err := e.PutInt(r.X); err != nil {
		return err
	}
	if err := e.PutInt(r.Y); err != nil {
		return err
	}
	if err := e.PutInt(r.Width); err != nil {
		return err
	}
	if err := e.PutInt(r.Height); err != nil {
		return err
	}
	return nil
}

// Ensure WlRegionAddRequest implements Request.
var _ Request = &WlRegionAddRequest{}

// WlRegionSubtractRequest requests to subtract rectangle from region
//
// Subtract the specified rectangle from the region.
type WlRegionSubtractRequest struct {
	// X contains region-local x coordinate
	X int32

	// Y contains region-local y coordinate
	Y int32

	// Width contains rectangle width
	Width int32

	// Height contains rectangle height
	Height int32
}

// Opcode returns the request opcode for wl_region.subtract in wayland
func (WlRegionSubtractRequest) Opcode() uint16 { return 2 }

// MessageName returns the request name for wl_region.subtract in wayland
func (WlRegionSubtractRequest) MessageName() string { return "subtract" }

// Ensure WlRegionSubtractRequest implements Message.
var _ Message = WlRegionSubtractRequest{}

// Emit emits the message to the emitter.
func (r *WlRegionSubtractRequest) Emit(e *RequestEmitter) error {
	if err := e.PutInt(r.X); err != nil {
		return err
	}
	if err := e.PutInt(r.Y); err != nil {
		return err
	}
	if err := e.PutInt(r.Width); err != nil {
		return err
	}
	if err := e.PutInt(r.Height); err != nil {
		return err
	}
	return nil
}

// Ensure WlRegionSubtractRequest implements Request.
var _ Request = &WlRegionSubtractRequest{}

// WlRegion region interface
//
// A region object describes an area.
//
// Region objects are used to describe the opaque and input
// regions of a surface.
type WlRegion struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *WlRegion) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (WlRegion) Descriptor() *InterfaceDescriptor {
	return &WlRegionDescriptor
}

// Dispatch returns an Event object for a given opcode.
func (WlRegion) Dispatch(opcode uint16) Event {
	switch opcode {
	default:
		return nil
	}
}

// Destroy requests to destroy region
//
// Destroy the region.  This will invalidate the object ID.
func (proxy *WlRegion) Destroy(connection Connection) (err error) {
	request := WlRegionDestroyRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Add requests to add rectangle to region
//
// Add the specified rectangle to the region.
func (proxy *WlRegion) Add(connection Connection, aX int32, aY int32, aWidth int32, aHeight int32) (err error) {
	request := WlRegionAddRequest{
		X:      aX,
		Y:      aY,
		Width:  aWidth,
		Height: aHeight,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Subtract requests to subtract rectangle from region
//
// Subtract the specified rectangle from the region.
func (proxy *WlRegion) Subtract(connection Connection, aX int32, aY int32, aWidth int32, aHeight int32) (err error) {
	request := WlRegionSubtractRequest{
		X:      aX,
		Y:      aY,
		Width:  aWidth,
		Height: aHeight,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Ensure WlRegion implements Proxy.
var _ Proxy = &WlRegion{}

// #endregion Interface wayland.wl_region

// ----------------------------------------------------------------------------
// #region Interface wayland.wl_subcompositor

type WlSubcompositorError int

const (
	// WlSubcompositorErrorBadSurface corresponds to the to-be sub-surface is invalid
	WlSubcompositorErrorBadSurface WlSubcompositorError = 0
)

// WlSubcompositorDestroyRequest requests to unbind from the subcompositor interface
//
// Informs the server that the client will not be using this
// protocol object anymore. This does not affect any other
// objects, wl_subsurface objects included.
type WlSubcompositorDestroyRequest struct {
}

// Opcode returns the request opcode for wl_subcompositor.destroy in wayland
func (WlSubcompositorDestroyRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for wl_subcompositor.destroy in wayland
func (WlSubcompositorDestroyRequest) MessageName() string { return "destroy" }

// Ensure WlSubcompositorDestroyRequest implements Message.
var _ Message = WlSubcompositorDestroyRequest{}

// Emit emits the message to the emitter.
func (r *WlSubcompositorDestroyRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure WlSubcompositorDestroyRequest implements Request.
var _ Request = &WlSubcompositorDestroyRequest{}

// WlSubcompositorGetSubsurfaceRequest requests to give a surface the role sub-surface
//
// Create a sub-surface interface for the given surface, and
// associate it with the given parent surface. This turns a
// plain wl_surface into a sub-surface.
//
// The to-be sub-surface must not already have another role, and it
// must not have an existing wl_subsurface object. Otherwise a protocol
// error is raised.
//
// Adding sub-surfaces to a parent is a double-buffered operation on the
// parent (see wl_surface.commit). The effect of adding a sub-surface
// becomes visible on the next time the state of the parent surface is
// applied.
//
// This request modifies the behaviour of wl_surface.commit request on
// the sub-surface, see the documentation on wl_subsurface interface.
type WlSubcompositorGetSubsurfaceRequest struct {
	// ID contains the new sub-surface object ID
	ID ObjectID

	// Surface contains the surface to be turned into a sub-surface
	Surface ObjectID

	// Parent contains the parent surface
	Parent ObjectID
}

// Opcode returns the request opcode for wl_subcompositor.get_subsurface in wayland
func (WlSubcompositorGetSubsurfaceRequest) Opcode() uint16 { return 1 }

// MessageName returns the request name for wl_subcompositor.get_subsurface in wayland
func (WlSubcompositorGetSubsurfaceRequest) MessageName() string { return "get_subsurface" }

// Ensure WlSubcompositorGetSubsurfaceRequest implements Message.
var _ Message = WlSubcompositorGetSubsurfaceRequest{}

// Emit emits the message to the emitter.
func (r *WlSubcompositorGetSubsurfaceRequest) Emit(e *RequestEmitter) error {
	if err := e.PutObjectID(r.ID); err != nil {
		return err
	}
	if err := e.PutObjectID(r.Surface); err != nil {
		return err
	}
	if err := e.PutObjectID(r.Parent); err != nil {
		return err
	}
	return nil
}

// Ensure WlSubcompositorGetSubsurfaceRequest implements Request.
var _ Request = &WlSubcompositorGetSubsurfaceRequest{}

// WlSubcompositor sub-surface compositing
//
// The global interface exposing sub-surface compositing capabilities.
// A wl_surface, that has sub-surfaces associated, is called the
// parent surface. Sub-surfaces can be arbitrarily nested and create
// a tree of sub-surfaces.
//
// The root surface in a tree of sub-surfaces is the main
// surface. The main surface cannot be a sub-surface, because
// sub-surfaces must always have a parent.
//
// A main surface with its sub-surfaces forms a (compound) window.
// For window management purposes, this set of wl_surface objects is
// to be considered as a single window, and it should also behave as
// such.
//
// The aim of sub-surfaces is to offload some of the compositing work
// within a window from clients to the compositor. A prime example is
// a video player with decorations and video in separate wl_surface
// objects. This should allow the compositor to pass YUV video buffer
// processing to dedicated overlay hardware when possible.
type WlSubcompositor struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *WlSubcompositor) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (WlSubcompositor) Descriptor() *InterfaceDescriptor {
	return &WlSubcompositorDescriptor
}

// Dispatch returns an Event object for a given opcode.
func (WlSubcompositor) Dispatch(opcode uint16) Event {
	switch opcode {
	default:
		return nil
	}
}

// Destroy requests to unbind from the subcompositor interface
//
// Informs the server that the client will not be using this
// protocol object anymore. This does not affect any other
// objects, wl_subsurface objects included.
func (proxy *WlSubcompositor) Destroy(connection Connection) (err error) {
	request := WlSubcompositorDestroyRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// GetSubsurface requests to give a surface the role sub-surface
//
// Create a sub-surface interface for the given surface, and
// associate it with the given parent surface. This turns a
// plain wl_surface into a sub-surface.
//
// The to-be sub-surface must not already have another role, and it
// must not have an existing wl_subsurface object. Otherwise a protocol
// error is raised.
//
// Adding sub-surfaces to a parent is a double-buffered operation on the
// parent (see wl_surface.commit). The effect of adding a sub-surface
// becomes visible on the next time the state of the parent surface is
// applied.
//
// This request modifies the behaviour of wl_surface.commit request on
// the sub-surface, see the documentation on wl_subsurface interface.
func (proxy *WlSubcompositor) GetSubsurface(connection Connection, aSurface ObjectID, aParent ObjectID) (aID *WlSubsurface, err error) {
	aID = &WlSubsurface{connection.NewID()}
	request := WlSubcompositorGetSubsurfaceRequest{
		ID:      aID.id,
		Surface: aSurface,
		Parent:  aParent,
	}
	err = connection.SendRequest(proxy.id, &request)
	if err == nil {
		connection.RegisterProxy(aID)
	}
	return
}

// Ensure WlSubcompositor implements Proxy.
var _ Proxy = &WlSubcompositor{}

// #endregion Interface wayland.wl_subcompositor

// ----------------------------------------------------------------------------
// #region Interface wayland.wl_subsurface

type WlSubsurfaceError int

const (
	// WlSubsurfaceErrorBadSurface corresponds to wl_surface is not a sibling or the parent
	WlSubsurfaceErrorBadSurface WlSubsurfaceError = 0
)

// WlSubsurfaceDestroyRequest requests to remove sub-surface interface
//
// The sub-surface interface is removed from the wl_surface object
// that was turned into a sub-surface with a
// wl_subcompositor.get_subsurface request. The wl_surface's association
// to the parent is deleted, and the wl_surface loses its role as
// a sub-surface. The wl_surface is unmapped immediately.
type WlSubsurfaceDestroyRequest struct {
}

// Opcode returns the request opcode for wl_subsurface.destroy in wayland
func (WlSubsurfaceDestroyRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for wl_subsurface.destroy in wayland
func (WlSubsurfaceDestroyRequest) MessageName() string { return "destroy" }

// Ensure WlSubsurfaceDestroyRequest implements Message.
var _ Message = WlSubsurfaceDestroyRequest{}

// Emit emits the message to the emitter.
func (r *WlSubsurfaceDestroyRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure WlSubsurfaceDestroyRequest implements Request.
var _ Request = &WlSubsurfaceDestroyRequest{}

// WlSubsurfaceSetPositionRequest requests to reposition the sub-surface
//
// This schedules a sub-surface position change.
// The sub-surface will be moved so that its origin (top left
// corner pixel) will be at the location x, y of the parent surface
// coordinate system. The coordinates are not restricted to the parent
// surface area. Negative values are allowed.
//
// The scheduled coordinates will take effect whenever the state of the
// parent surface is applied. When this happens depends on whether the
// parent surface is in synchronized mode or not. See
// wl_subsurface.set_sync and wl_subsurface.set_desync for details.
//
// If more than one set_position request is invoked by the client before
// the commit of the parent surface, the position of a new request always
// replaces the scheduled position from any previous request.
//
// The initial position is 0, 0.
type WlSubsurfaceSetPositionRequest struct {
	// X contains x coordinate in the parent surface
	X int32

	// Y contains y coordinate in the parent surface
	Y int32
}

// Opcode returns the request opcode for wl_subsurface.set_position in wayland
func (WlSubsurfaceSetPositionRequest) Opcode() uint16 { return 1 }

// MessageName returns the request name for wl_subsurface.set_position in wayland
func (WlSubsurfaceSetPositionRequest) MessageName() string { return "set_position" }

// Ensure WlSubsurfaceSetPositionRequest implements Message.
var _ Message = WlSubsurfaceSetPositionRequest{}

// Emit emits the message to the emitter.
func (r *WlSubsurfaceSetPositionRequest) Emit(e *RequestEmitter) error {
	if err := e.PutInt(r.X); err != nil {
		return err
	}
	if err := e.PutInt(r.Y); err != nil {
		return err
	}
	return nil
}

// Ensure WlSubsurfaceSetPositionRequest implements Request.
var _ Request = &WlSubsurfaceSetPositionRequest{}

// WlSubsurfacePlaceAboveRequest requests to restack the sub-surface
//
// This sub-surface is taken from the stack, and put back just
// above the reference surface, changing the z-order of the sub-surfaces.
// The reference surface must be one of the sibling surfaces, or the
// parent surface. Using any other surface, including this sub-surface,
// will cause a protocol error.
//
// The z-order is double-buffered. Requests are handled in order and
// applied immediately to a pending state. The final pending state is
// copied to the active state the next time the state of the parent
// surface is applied. When this happens depends on whether the parent
// surface is in synchronized mode or not. See wl_subsurface.set_sync and
// wl_subsurface.set_desync for details.
//
// A new sub-surface is initially added as the top-most in the stack
// of its siblings and parent.
type WlSubsurfacePlaceAboveRequest struct {
	// Sibling contains the reference surface
	Sibling ObjectID
}

// Opcode returns the request opcode for wl_subsurface.place_above in wayland
func (WlSubsurfacePlaceAboveRequest) Opcode() uint16 { return 2 }

// MessageName returns the request name for wl_subsurface.place_above in wayland
func (WlSubsurfacePlaceAboveRequest) MessageName() string { return "place_above" }

// Ensure WlSubsurfacePlaceAboveRequest implements Message.
var _ Message = WlSubsurfacePlaceAboveRequest{}

// Emit emits the message to the emitter.
func (r *WlSubsurfacePlaceAboveRequest) Emit(e *RequestEmitter) error {
	if err := e.PutObjectID(r.Sibling); err != nil {
		return err
	}
	return nil
}

// Ensure WlSubsurfacePlaceAboveRequest implements Request.
var _ Request = &WlSubsurfacePlaceAboveRequest{}

// WlSubsurfacePlaceBelowRequest requests to restack the sub-surface
//
// The sub-surface is placed just below the reference surface.
// See wl_subsurface.place_above.
type WlSubsurfacePlaceBelowRequest struct {
	// Sibling contains the reference surface
	Sibling ObjectID
}

// Opcode returns the request opcode for wl_subsurface.place_below in wayland
func (WlSubsurfacePlaceBelowRequest) Opcode() uint16 { return 3 }

// MessageName returns the request name for wl_subsurface.place_below in wayland
func (WlSubsurfacePlaceBelowRequest) MessageName() string { return "place_below" }

// Ensure WlSubsurfacePlaceBelowRequest implements Message.
var _ Message = WlSubsurfacePlaceBelowRequest{}

// Emit emits the message to the emitter.
func (r *WlSubsurfacePlaceBelowRequest) Emit(e *RequestEmitter) error {
	if err := e.PutObjectID(r.Sibling); err != nil {
		return err
	}
	return nil
}

// Ensure WlSubsurfacePlaceBelowRequest implements Request.
var _ Request = &WlSubsurfacePlaceBelowRequest{}

// WlSubsurfaceSetSyncRequest requests to set sub-surface to synchronized mode
//
// Change the commit behaviour of the sub-surface to synchronized
// mode, also described as the parent dependent mode.
//
// In synchronized mode, wl_surface.commit on a sub-surface will
// accumulate the committed state in a cache, but the state will
// not be applied and hence will not change the compositor output.
// The cached state is applied to the sub-surface immediately after
// the parent surface's state is applied. This ensures atomic
// updates of the parent and all its synchronized sub-surfaces.
// Applying the cached state will invalidate the cache, so further
// parent surface commits do not (re-)apply old state.
//
// See wl_subsurface for the recursive effect of this mode.
type WlSubsurfaceSetSyncRequest struct {
}

// Opcode returns the request opcode for wl_subsurface.set_sync in wayland
func (WlSubsurfaceSetSyncRequest) Opcode() uint16 { return 4 }

// MessageName returns the request name for wl_subsurface.set_sync in wayland
func (WlSubsurfaceSetSyncRequest) MessageName() string { return "set_sync" }

// Ensure WlSubsurfaceSetSyncRequest implements Message.
var _ Message = WlSubsurfaceSetSyncRequest{}

// Emit emits the message to the emitter.
func (r *WlSubsurfaceSetSyncRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure WlSubsurfaceSetSyncRequest implements Request.
var _ Request = &WlSubsurfaceSetSyncRequest{}

// WlSubsurfaceSetDesyncRequest requests to set sub-surface to desynchronized mode
//
// Change the commit behaviour of the sub-surface to desynchronized
// mode, also described as independent or freely running mode.
//
// In desynchronized mode, wl_surface.commit on a sub-surface will
// apply the pending state directly, without caching, as happens
// normally with a wl_surface. Calling wl_surface.commit on the
// parent surface has no effect on the sub-surface's wl_surface
// state. This mode allows a sub-surface to be updated on its own.
//
// If cached state exists when wl_surface.commit is called in
// desynchronized mode, the pending state is added to the cached
// state, and applied as a whole. This invalidates the cache.
//
// Note: even if a sub-surface is set to desynchronized, a parent
// sub-surface may override it to behave as synchronized. For details,
// see wl_subsurface.
//
// If a surface's parent surface behaves as desynchronized, then
// the cached state is applied on set_desync.
type WlSubsurfaceSetDesyncRequest struct {
}

// Opcode returns the request opcode for wl_subsurface.set_desync in wayland
func (WlSubsurfaceSetDesyncRequest) Opcode() uint16 { return 5 }

// MessageName returns the request name for wl_subsurface.set_desync in wayland
func (WlSubsurfaceSetDesyncRequest) MessageName() string { return "set_desync" }

// Ensure WlSubsurfaceSetDesyncRequest implements Message.
var _ Message = WlSubsurfaceSetDesyncRequest{}

// Emit emits the message to the emitter.
func (r *WlSubsurfaceSetDesyncRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure WlSubsurfaceSetDesyncRequest implements Request.
var _ Request = &WlSubsurfaceSetDesyncRequest{}

// WlSubsurface sub-surface interface to a wl_surface
//
// An additional interface to a wl_surface object, which has been
// made a sub-surface. A sub-surface has one parent surface. A
// sub-surface's size and position are not limited to that of the parent.
// Particularly, a sub-surface is not automatically clipped to its
// parent's area.
//
// A sub-surface becomes mapped, when a non-NULL wl_buffer is applied
// and the parent surface is mapped. The order of which one happens
// first is irrelevant. A sub-surface is hidden if the parent becomes
// hidden, or if a NULL wl_buffer is applied. These rules apply
// recursively through the tree of surfaces.
//
// The behaviour of a wl_surface.commit request on a sub-surface
// depends on the sub-surface's mode. The possible modes are
// synchronized and desynchronized, see methods
// wl_subsurface.set_sync and wl_subsurface.set_desync. Synchronized
// mode caches the wl_surface state to be applied when the parent's
// state gets applied, and desynchronized mode applies the pending
// wl_surface state directly. A sub-surface is initially in the
// synchronized mode.
//
// Sub-surfaces also have another kind of state, which is managed by
// wl_subsurface requests, as opposed to wl_surface requests. This
// state includes the sub-surface position relative to the parent
// surface (wl_subsurface.set_position), and the stacking order of
// the parent and its sub-surfaces (wl_subsurface.place_above and
// .place_below). This state is applied when the parent surface's
// wl_surface state is applied, regardless of the sub-surface's mode.
// As the exception, set_sync and set_desync are effective immediately.
//
// The main surface can be thought to be always in desynchronized mode,
// since it does not have a parent in the sub-surfaces sense.
//
// Even if a sub-surface is in desynchronized mode, it will behave as
// in synchronized mode, if its parent surface behaves as in
// synchronized mode. This rule is applied recursively throughout the
// tree of surfaces. This means, that one can set a sub-surface into
// synchronized mode, and then assume that all its child and grand-child
// sub-surfaces are synchronized, too, without explicitly setting them.
//
// If the wl_surface associated with the wl_subsurface is destroyed, the
// wl_subsurface object becomes inert. Note, that destroying either object
// takes effect immediately. If you need to synchronize the removal
// of a sub-surface to the parent surface update, unmap the sub-surface
// first by attaching a NULL wl_buffer, update parent, and then destroy
// the sub-surface.
//
// If the parent wl_surface object is destroyed, the sub-surface is
// unmapped.
type WlSubsurface struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *WlSubsurface) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (WlSubsurface) Descriptor() *InterfaceDescriptor {
	return &WlSubsurfaceDescriptor
}

// Dispatch returns an Event object for a given opcode.
func (WlSubsurface) Dispatch(opcode uint16) Event {
	switch opcode {
	default:
		return nil
	}
}

// Destroy requests to remove sub-surface interface
//
// The sub-surface interface is removed from the wl_surface object
// that was turned into a sub-surface with a
// wl_subcompositor.get_subsurface request. The wl_surface's association
// to the parent is deleted, and the wl_surface loses its role as
// a sub-surface. The wl_surface is unmapped immediately.
func (proxy *WlSubsurface) Destroy(connection Connection) (err error) {
	request := WlSubsurfaceDestroyRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// SetPosition requests to reposition the sub-surface
//
// This schedules a sub-surface position change.
// The sub-surface will be moved so that its origin (top left
// corner pixel) will be at the location x, y of the parent surface
// coordinate system. The coordinates are not restricted to the parent
// surface area. Negative values are allowed.
//
// The scheduled coordinates will take effect whenever the state of the
// parent surface is applied. When this happens depends on whether the
// parent surface is in synchronized mode or not. See
// wl_subsurface.set_sync and wl_subsurface.set_desync for details.
//
// If more than one set_position request is invoked by the client before
// the commit of the parent surface, the position of a new request always
// replaces the scheduled position from any previous request.
//
// The initial position is 0, 0.
func (proxy *WlSubsurface) SetPosition(connection Connection, aX int32, aY int32) (err error) {
	request := WlSubsurfaceSetPositionRequest{
		X: aX,
		Y: aY,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// PlaceAbove requests to restack the sub-surface
//
// This sub-surface is taken from the stack, and put back just
// above the reference surface, changing the z-order of the sub-surfaces.
// The reference surface must be one of the sibling surfaces, or the
// parent surface. Using any other surface, including this sub-surface,
// will cause a protocol error.
//
// The z-order is double-buffered. Requests are handled in order and
// applied immediately to a pending state. The final pending state is
// copied to the active state the next time the state of the parent
// surface is applied. When this happens depends on whether the parent
// surface is in synchronized mode or not. See wl_subsurface.set_sync and
// wl_subsurface.set_desync for details.
//
// A new sub-surface is initially added as the top-most in the stack
// of its siblings and parent.
func (proxy *WlSubsurface) PlaceAbove(connection Connection, aSibling ObjectID) (err error) {
	request := WlSubsurfacePlaceAboveRequest{
		Sibling: aSibling,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// PlaceBelow requests to restack the sub-surface
//
// The sub-surface is placed just below the reference surface.
// See wl_subsurface.place_above.
func (proxy *WlSubsurface) PlaceBelow(connection Connection, aSibling ObjectID) (err error) {
	request := WlSubsurfacePlaceBelowRequest{
		Sibling: aSibling,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// SetSync requests to set sub-surface to synchronized mode
//
// Change the commit behaviour of the sub-surface to synchronized
// mode, also described as the parent dependent mode.
//
// In synchronized mode, wl_surface.commit on a sub-surface will
// accumulate the committed state in a cache, but the state will
// not be applied and hence will not change the compositor output.
// The cached state is applied to the sub-surface immediately after
// the parent surface's state is applied. This ensures atomic
// updates of the parent and all its synchronized sub-surfaces.
// Applying the cached state will invalidate the cache, so further
// parent surface commits do not (re-)apply old state.
//
// See wl_subsurface for the recursive effect of this mode.
func (proxy *WlSubsurface) SetSync(connection Connection) (err error) {
	request := WlSubsurfaceSetSyncRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// SetDesync requests to set sub-surface to desynchronized mode
//
// Change the commit behaviour of the sub-surface to desynchronized
// mode, also described as independent or freely running mode.
//
// In desynchronized mode, wl_surface.commit on a sub-surface will
// apply the pending state directly, without caching, as happens
// normally with a wl_surface. Calling wl_surface.commit on the
// parent surface has no effect on the sub-surface's wl_surface
// state. This mode allows a sub-surface to be updated on its own.
//
// If cached state exists when wl_surface.commit is called in
// desynchronized mode, the pending state is added to the cached
// state, and applied as a whole. This invalidates the cache.
//
// Note: even if a sub-surface is set to desynchronized, a parent
// sub-surface may override it to behave as synchronized. For details,
// see wl_subsurface.
//
// If a surface's parent surface behaves as desynchronized, then
// the cached state is applied on set_desync.
func (proxy *WlSubsurface) SetDesync(connection Connection) (err error) {
	request := WlSubsurfaceSetDesyncRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Ensure WlSubsurface implements Proxy.
var _ Proxy = &WlSubsurface{}

// #endregion Interface wayland.wl_subsurface

////////////////////////////////////////////////////////////////////////////////
// #endregion Protocol wayland

////////////////////////////////////////////////////////////////////////////////
// #region Protocol wp_primary_selection_unstable_v1

// ----------------------------------------------------------------------------
// #region Interface wp_primary_selection_unstable_v1.zwp_primary_selection_device_manager_v1

// ZwpPrimarySelectionDeviceManagerV1CreateSourceRequest requests to create a new primary selection source
//
// Create a new primary selection source.
type ZwpPrimarySelectionDeviceManagerV1CreateSourceRequest struct {
	ID ObjectID
}

// Opcode returns the request opcode for zwp_primary_selection_device_manager_v1.create_source in wp_primary_selection_unstable_v1
func (ZwpPrimarySelectionDeviceManagerV1CreateSourceRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for zwp_primary_selection_device_manager_v1.create_source in wp_primary_selection_unstable_v1
func (ZwpPrimarySelectionDeviceManagerV1CreateSourceRequest) MessageName() string {
	return "create_source"
}

// Ensure ZwpPrimarySelectionDeviceManagerV1CreateSourceRequest implements Message.
var _ Message = ZwpPrimarySelectionDeviceManagerV1CreateSourceRequest{}

// Emit emits the message to the emitter.
func (r *ZwpPrimarySelectionDeviceManagerV1CreateSourceRequest) Emit(e *RequestEmitter) error {
	if err := e.PutObjectID(r.ID); err != nil {
		return err
	}
	return nil
}

// Ensure ZwpPrimarySelectionDeviceManagerV1CreateSourceRequest implements Request.
var _ Request = &ZwpPrimarySelectionDeviceManagerV1CreateSourceRequest{}

// ZwpPrimarySelectionDeviceManagerV1GetDeviceRequest requests to create a new primary selection device
//
// Create a new data device for a given seat.
type ZwpPrimarySelectionDeviceManagerV1GetDeviceRequest struct {
	ID ObjectID

	Seat ObjectID
}

// Opcode returns the request opcode for zwp_primary_selection_device_manager_v1.get_device in wp_primary_selection_unstable_v1
func (ZwpPrimarySelectionDeviceManagerV1GetDeviceRequest) Opcode() uint16 { return 1 }

// MessageName returns the request name for zwp_primary_selection_device_manager_v1.get_device in wp_primary_selection_unstable_v1
func (ZwpPrimarySelectionDeviceManagerV1GetDeviceRequest) MessageName() string { return "get_device" }

// Ensure ZwpPrimarySelectionDeviceManagerV1GetDeviceRequest implements Message.
var _ Message = ZwpPrimarySelectionDeviceManagerV1GetDeviceRequest{}

// Emit emits the message to the emitter.
func (r *ZwpPrimarySelectionDeviceManagerV1GetDeviceRequest) Emit(e *RequestEmitter) error {
	if err := e.PutObjectID(r.ID); err != nil {
		return err
	}
	if err := e.PutObjectID(r.Seat); err != nil {
		return err
	}
	return nil
}

// Ensure ZwpPrimarySelectionDeviceManagerV1GetDeviceRequest implements Request.
var _ Request = &ZwpPrimarySelectionDeviceManagerV1GetDeviceRequest{}

// ZwpPrimarySelectionDeviceManagerV1DestroyRequest requests to destroy the primary selection device manager
//
// Destroy the primary selection device manager.
type ZwpPrimarySelectionDeviceManagerV1DestroyRequest struct {
}

// Opcode returns the request opcode for zwp_primary_selection_device_manager_v1.destroy in wp_primary_selection_unstable_v1
func (ZwpPrimarySelectionDeviceManagerV1DestroyRequest) Opcode() uint16 { return 2 }

// MessageName returns the request name for zwp_primary_selection_device_manager_v1.destroy in wp_primary_selection_unstable_v1
func (ZwpPrimarySelectionDeviceManagerV1DestroyRequest) MessageName() string { return "destroy" }

// Ensure ZwpPrimarySelectionDeviceManagerV1DestroyRequest implements Message.
var _ Message = ZwpPrimarySelectionDeviceManagerV1DestroyRequest{}

// Emit emits the message to the emitter.
func (r *ZwpPrimarySelectionDeviceManagerV1DestroyRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure ZwpPrimarySelectionDeviceManagerV1DestroyRequest implements Request.
var _ Request = &ZwpPrimarySelectionDeviceManagerV1DestroyRequest{}

// ZwpPrimarySelectionDeviceManagerV1 X primary selection emulation
//
// The primary selection device manager is a singleton global object that
// provides access to the primary selection. It allows to create
// wp_primary_selection_source objects, as well as retrieving the per-seat
// wp_primary_selection_device objects.
type ZwpPrimarySelectionDeviceManagerV1 struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *ZwpPrimarySelectionDeviceManagerV1) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (ZwpPrimarySelectionDeviceManagerV1) Descriptor() *InterfaceDescriptor {
	return &ZwpPrimarySelectionDeviceManagerV1Descriptor
}

// Dispatch returns an Event object for a given opcode.
func (ZwpPrimarySelectionDeviceManagerV1) Dispatch(opcode uint16) Event {
	switch opcode {
	default:
		return nil
	}
}

// CreateSource requests to create a new primary selection source
//
// Create a new primary selection source.
func (proxy *ZwpPrimarySelectionDeviceManagerV1) CreateSource(connection Connection) (aID *ZwpPrimarySelectionSourceV1, err error) {
	aID = &ZwpPrimarySelectionSourceV1{connection.NewID()}
	request := ZwpPrimarySelectionDeviceManagerV1CreateSourceRequest{
		ID: aID.id,
	}
	err = connection.SendRequest(proxy.id, &request)
	if err == nil {
		connection.RegisterProxy(aID)
	}
	return
}

// GetDevice requests to create a new primary selection device
//
// Create a new data device for a given seat.
func (proxy *ZwpPrimarySelectionDeviceManagerV1) GetDevice(connection Connection, aSeat ObjectID) (aID *ZwpPrimarySelectionDeviceV1, err error) {
	aID = &ZwpPrimarySelectionDeviceV1{connection.NewID()}
	request := ZwpPrimarySelectionDeviceManagerV1GetDeviceRequest{
		ID:   aID.id,
		Seat: aSeat,
	}
	err = connection.SendRequest(proxy.id, &request)
	if err == nil {
		connection.RegisterProxy(aID)
	}
	return
}

// Destroy requests to destroy the primary selection device manager
//
// Destroy the primary selection device manager.
func (proxy *ZwpPrimarySelectionDeviceManagerV1) Destroy(connection Connection) (err error) {
	request := ZwpPrimarySelectionDeviceManagerV1DestroyRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Ensure ZwpPrimarySelectionDeviceManagerV1 implements Proxy.
var _ Proxy = &ZwpPrimarySelectionDeviceManagerV1{}

// #endregion Interface wp_primary_selection_unstable_v1.zwp_primary_selection_device_manager_v1

// ----------------------------------------------------------------------------
// #region Interface wp_primary_selection_unstable_v1.zwp_primary_selection_device_v1

// ZwpPrimarySelectionDeviceV1SetSelectionRequest requests to set the primary selection
//
// Replaces the current selection. The previous owner of the primary
// selection will receive a wp_primary_selection_source.cancelled event.
//
// To unset the selection, set the source to NULL.
type ZwpPrimarySelectionDeviceV1SetSelectionRequest struct {
	Source ObjectID

	// Serial contains serial of the event that triggered this request
	Serial uint32
}

// Opcode returns the request opcode for zwp_primary_selection_device_v1.set_selection in wp_primary_selection_unstable_v1
func (ZwpPrimarySelectionDeviceV1SetSelectionRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for zwp_primary_selection_device_v1.set_selection in wp_primary_selection_unstable_v1
func (ZwpPrimarySelectionDeviceV1SetSelectionRequest) MessageName() string { return "set_selection" }

// Ensure ZwpPrimarySelectionDeviceV1SetSelectionRequest implements Message.
var _ Message = ZwpPrimarySelectionDeviceV1SetSelectionRequest{}

// Emit emits the message to the emitter.
func (r *ZwpPrimarySelectionDeviceV1SetSelectionRequest) Emit(e *RequestEmitter) error {
	if err := e.PutObjectID(r.Source); err != nil {
		return err
	}
	if err := e.PutUint(r.Serial); err != nil {
		return err
	}
	return nil
}

// Ensure ZwpPrimarySelectionDeviceV1SetSelectionRequest implements Request.
var _ Request = &ZwpPrimarySelectionDeviceV1SetSelectionRequest{}

// ZwpPrimarySelectionDeviceV1DestroyRequest requests to destroy the primary selection device
//
// Destroy the primary selection device.
type ZwpPrimarySelectionDeviceV1DestroyRequest struct {
}

// Opcode returns the request opcode for zwp_primary_selection_device_v1.destroy in wp_primary_selection_unstable_v1
func (ZwpPrimarySelectionDeviceV1DestroyRequest) Opcode() uint16 { return 1 }

// MessageName returns the request name for zwp_primary_selection_device_v1.destroy in wp_primary_selection_unstable_v1
func (ZwpPrimarySelectionDeviceV1DestroyRequest) MessageName() string { return "destroy" }

// Ensure ZwpPrimarySelectionDeviceV1DestroyRequest implements Message.
var _ Message = ZwpPrimarySelectionDeviceV1DestroyRequest{}

// Emit emits the message to the emitter.
func (r *ZwpPrimarySelectionDeviceV1DestroyRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure ZwpPrimarySelectionDeviceV1DestroyRequest implements Request.
var _ Request = &ZwpPrimarySelectionDeviceV1DestroyRequest{}

// ZwpPrimarySelectionDeviceV1DataOfferEvent signals when introduce a new wp_primary_selection_offer
//
// Introduces a new wp_primary_selection_offer object that may be used
// to receive the current primary selection. Immediately following this
// event, the new wp_primary_selection_offer object will send
// wp_primary_selection_offer.offer events to describe the offered mime
// types.
type ZwpPrimarySelectionDeviceV1DataOfferEvent struct {
	Offer ObjectID
}

// Opcode returns the event opcode for zwp_primary_selection_device_v1.data_offer in wp_primary_selection_unstable_v1
func (ZwpPrimarySelectionDeviceV1DataOfferEvent) Opcode() uint16 { return 0 }

// MessageName returns the event name for zwp_primary_selection_device_v1.data_offer in wp_primary_selection_unstable_v1
func (ZwpPrimarySelectionDeviceV1DataOfferEvent) MessageName() string { return "data_offer" }

// Ensure ZwpPrimarySelectionDeviceV1DataOfferEvent implements Message.
var _ Message = ZwpPrimarySelectionDeviceV1DataOfferEvent{}

// Scan scans the event from the socket.
func (e *ZwpPrimarySelectionDeviceV1DataOfferEvent) Scan(s *EventScanner) error {
	if v, err := s.ObjectID(); err != nil {
		return err
	} else {
		e.Offer = v
	}
	return nil
}

// Ensure ZwpPrimarySelectionDeviceV1DataOfferEvent implements Event.
var _ Event = &ZwpPrimarySelectionDeviceV1DataOfferEvent{}

// ZwpPrimarySelectionDeviceV1SelectionEvent signals when advertise a new primary selection
//
// The wp_primary_selection_device.selection event is sent to notify the
// client of a new primary selection. This event is sent after the
// wp_primary_selection.data_offer event introducing this object, and after
// the offer has announced its mimetypes through
// wp_primary_selection_offer.offer.
//
// The data_offer is valid until a new offer or NULL is received
// or until the client loses keyboard focus. The client must destroy the
// previous selection data_offer, if any, upon receiving this event.
type ZwpPrimarySelectionDeviceV1SelectionEvent struct {
	ID ObjectID
}

// Opcode returns the event opcode for zwp_primary_selection_device_v1.selection in wp_primary_selection_unstable_v1
func (ZwpPrimarySelectionDeviceV1SelectionEvent) Opcode() uint16 { return 1 }

// MessageName returns the event name for zwp_primary_selection_device_v1.selection in wp_primary_selection_unstable_v1
func (ZwpPrimarySelectionDeviceV1SelectionEvent) MessageName() string { return "selection" }

// Ensure ZwpPrimarySelectionDeviceV1SelectionEvent implements Message.
var _ Message = ZwpPrimarySelectionDeviceV1SelectionEvent{}

// Scan scans the event from the socket.
func (e *ZwpPrimarySelectionDeviceV1SelectionEvent) Scan(s *EventScanner) error {
	if v, err := s.ObjectID(); err != nil {
		return err
	} else {
		e.ID = v
	}
	return nil
}

// Ensure ZwpPrimarySelectionDeviceV1SelectionEvent implements Event.
var _ Event = &ZwpPrimarySelectionDeviceV1SelectionEvent{}

type ZwpPrimarySelectionDeviceV1 struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *ZwpPrimarySelectionDeviceV1) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (ZwpPrimarySelectionDeviceV1) Descriptor() *InterfaceDescriptor {
	return &ZwpPrimarySelectionDeviceV1Descriptor
}

// Dispatch returns an Event object for a given opcode.
func (ZwpPrimarySelectionDeviceV1) Dispatch(opcode uint16) Event {
	switch opcode {
	case 0:
		return &ZwpPrimarySelectionDeviceV1DataOfferEvent{}
	case 1:
		return &ZwpPrimarySelectionDeviceV1SelectionEvent{}
	default:
		return nil
	}
}

// SetSelection requests to set the primary selection
//
// Replaces the current selection. The previous owner of the primary
// selection will receive a wp_primary_selection_source.cancelled event.
//
// To unset the selection, set the source to NULL.
func (proxy *ZwpPrimarySelectionDeviceV1) SetSelection(connection Connection, aSource ObjectID, aSerial uint32) (err error) {
	request := ZwpPrimarySelectionDeviceV1SetSelectionRequest{
		Source: aSource,
		Serial: aSerial,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Destroy requests to destroy the primary selection device
//
// Destroy the primary selection device.
func (proxy *ZwpPrimarySelectionDeviceV1) Destroy(connection Connection) (err error) {
	request := ZwpPrimarySelectionDeviceV1DestroyRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Ensure ZwpPrimarySelectionDeviceV1 implements Proxy.
var _ Proxy = &ZwpPrimarySelectionDeviceV1{}

// #endregion Interface wp_primary_selection_unstable_v1.zwp_primary_selection_device_v1

// ----------------------------------------------------------------------------
// #region Interface wp_primary_selection_unstable_v1.zwp_primary_selection_offer_v1

// ZwpPrimarySelectionOfferV1ReceiveRequest requests to request that the data is transferred
//
// To transfer the contents of the primary selection clipboard, the client
// issues this request and indicates the mime type that it wants to
// receive. The transfer happens through the passed file descriptor
// (typically created with the pipe system call). The source client writes
// the data in the mime type representation requested and then closes the
// file descriptor.
//
// The receiving client reads from the read end of the pipe until EOF and
// closes its end, at which point the transfer is complete.
type ZwpPrimarySelectionOfferV1ReceiveRequest struct {
	MimeType string

	FD FD
}

// Opcode returns the request opcode for zwp_primary_selection_offer_v1.receive in wp_primary_selection_unstable_v1
func (ZwpPrimarySelectionOfferV1ReceiveRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for zwp_primary_selection_offer_v1.receive in wp_primary_selection_unstable_v1
func (ZwpPrimarySelectionOfferV1ReceiveRequest) MessageName() string { return "receive" }

// Ensure ZwpPrimarySelectionOfferV1ReceiveRequest implements Message.
var _ Message = ZwpPrimarySelectionOfferV1ReceiveRequest{}

// Emit emits the message to the emitter.
func (r *ZwpPrimarySelectionOfferV1ReceiveRequest) Emit(e *RequestEmitter) error {
	if err := e.PutString(r.MimeType); err != nil {
		return err
	}
	if err := e.PutFD(r.FD); err != nil {
		return err
	}
	return nil
}

// Ensure ZwpPrimarySelectionOfferV1ReceiveRequest implements Request.
var _ Request = &ZwpPrimarySelectionOfferV1ReceiveRequest{}

// ZwpPrimarySelectionOfferV1DestroyRequest requests to destroy the primary selection offer
//
// Destroy the primary selection offer.
type ZwpPrimarySelectionOfferV1DestroyRequest struct {
}

// Opcode returns the request opcode for zwp_primary_selection_offer_v1.destroy in wp_primary_selection_unstable_v1
func (ZwpPrimarySelectionOfferV1DestroyRequest) Opcode() uint16 { return 1 }

// MessageName returns the request name for zwp_primary_selection_offer_v1.destroy in wp_primary_selection_unstable_v1
func (ZwpPrimarySelectionOfferV1DestroyRequest) MessageName() string { return "destroy" }

// Ensure ZwpPrimarySelectionOfferV1DestroyRequest implements Message.
var _ Message = ZwpPrimarySelectionOfferV1DestroyRequest{}

// Emit emits the message to the emitter.
func (r *ZwpPrimarySelectionOfferV1DestroyRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure ZwpPrimarySelectionOfferV1DestroyRequest implements Request.
var _ Request = &ZwpPrimarySelectionOfferV1DestroyRequest{}

// ZwpPrimarySelectionOfferV1OfferEvent signals when advertise offered mime type
//
// Sent immediately after creating announcing the
// wp_primary_selection_offer through
// wp_primary_selection_device.data_offer. One event is sent per offered
// mime type.
type ZwpPrimarySelectionOfferV1OfferEvent struct {
	MimeType string
}

// Opcode returns the event opcode for zwp_primary_selection_offer_v1.offer in wp_primary_selection_unstable_v1
func (ZwpPrimarySelectionOfferV1OfferEvent) Opcode() uint16 { return 0 }

// MessageName returns the event name for zwp_primary_selection_offer_v1.offer in wp_primary_selection_unstable_v1
func (ZwpPrimarySelectionOfferV1OfferEvent) MessageName() string { return "offer" }

// Ensure ZwpPrimarySelectionOfferV1OfferEvent implements Message.
var _ Message = ZwpPrimarySelectionOfferV1OfferEvent{}

// Scan scans the event from the socket.
func (e *ZwpPrimarySelectionOfferV1OfferEvent) Scan(s *EventScanner) error {
	if v, err := s.String(); err != nil {
		return err
	} else {
		e.MimeType = v
	}
	return nil
}

// Ensure ZwpPrimarySelectionOfferV1OfferEvent implements Event.
var _ Event = &ZwpPrimarySelectionOfferV1OfferEvent{}

// ZwpPrimarySelectionOfferV1 offer to transfer primary selection contents
//
// A wp_primary_selection_offer represents an offer to transfer the contents
// of the primary selection clipboard to the client. Similar to
// wl_data_offer, the offer also describes the mime types that the data can
// be converted to and provides the mechanisms for transferring the data
// directly to the client.
type ZwpPrimarySelectionOfferV1 struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *ZwpPrimarySelectionOfferV1) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (ZwpPrimarySelectionOfferV1) Descriptor() *InterfaceDescriptor {
	return &ZwpPrimarySelectionOfferV1Descriptor
}

// Dispatch returns an Event object for a given opcode.
func (ZwpPrimarySelectionOfferV1) Dispatch(opcode uint16) Event {
	switch opcode {
	case 0:
		return &ZwpPrimarySelectionOfferV1OfferEvent{}
	default:
		return nil
	}
}

// Receive requests to request that the data is transferred
//
// To transfer the contents of the primary selection clipboard, the client
// issues this request and indicates the mime type that it wants to
// receive. The transfer happens through the passed file descriptor
// (typically created with the pipe system call). The source client writes
// the data in the mime type representation requested and then closes the
// file descriptor.
//
// The receiving client reads from the read end of the pipe until EOF and
// closes its end, at which point the transfer is complete.
func (proxy *ZwpPrimarySelectionOfferV1) Receive(connection Connection, aMimeType string, aFD FD) (err error) {
	request := ZwpPrimarySelectionOfferV1ReceiveRequest{
		MimeType: aMimeType,
		FD:       aFD,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Destroy requests to destroy the primary selection offer
//
// Destroy the primary selection offer.
func (proxy *ZwpPrimarySelectionOfferV1) Destroy(connection Connection) (err error) {
	request := ZwpPrimarySelectionOfferV1DestroyRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Ensure ZwpPrimarySelectionOfferV1 implements Proxy.
var _ Proxy = &ZwpPrimarySelectionOfferV1{}

// #endregion Interface wp_primary_selection_unstable_v1.zwp_primary_selection_offer_v1

// ----------------------------------------------------------------------------
// #region Interface wp_primary_selection_unstable_v1.zwp_primary_selection_source_v1

// ZwpPrimarySelectionSourceV1OfferRequest requests to add an offered mime type
//
// This request adds a mime type to the set of mime types advertised to
// targets. Can be called several times to offer multiple types.
type ZwpPrimarySelectionSourceV1OfferRequest struct {
	MimeType string
}

// Opcode returns the request opcode for zwp_primary_selection_source_v1.offer in wp_primary_selection_unstable_v1
func (ZwpPrimarySelectionSourceV1OfferRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for zwp_primary_selection_source_v1.offer in wp_primary_selection_unstable_v1
func (ZwpPrimarySelectionSourceV1OfferRequest) MessageName() string { return "offer" }

// Ensure ZwpPrimarySelectionSourceV1OfferRequest implements Message.
var _ Message = ZwpPrimarySelectionSourceV1OfferRequest{}

// Emit emits the message to the emitter.
func (r *ZwpPrimarySelectionSourceV1OfferRequest) Emit(e *RequestEmitter) error {
	if err := e.PutString(r.MimeType); err != nil {
		return err
	}
	return nil
}

// Ensure ZwpPrimarySelectionSourceV1OfferRequest implements Request.
var _ Request = &ZwpPrimarySelectionSourceV1OfferRequest{}

// ZwpPrimarySelectionSourceV1DestroyRequest requests to destroy the primary selection source
//
// Destroy the primary selection source.
type ZwpPrimarySelectionSourceV1DestroyRequest struct {
}

// Opcode returns the request opcode for zwp_primary_selection_source_v1.destroy in wp_primary_selection_unstable_v1
func (ZwpPrimarySelectionSourceV1DestroyRequest) Opcode() uint16 { return 1 }

// MessageName returns the request name for zwp_primary_selection_source_v1.destroy in wp_primary_selection_unstable_v1
func (ZwpPrimarySelectionSourceV1DestroyRequest) MessageName() string { return "destroy" }

// Ensure ZwpPrimarySelectionSourceV1DestroyRequest implements Message.
var _ Message = ZwpPrimarySelectionSourceV1DestroyRequest{}

// Emit emits the message to the emitter.
func (r *ZwpPrimarySelectionSourceV1DestroyRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure ZwpPrimarySelectionSourceV1DestroyRequest implements Request.
var _ Request = &ZwpPrimarySelectionSourceV1DestroyRequest{}

// ZwpPrimarySelectionSourceV1SendEvent signals when send the primary selection contents
//
// Request for the current primary selection contents from the client.
// Send the specified mime type over the passed file descriptor, then
// close it.
type ZwpPrimarySelectionSourceV1SendEvent struct {
	MimeType string

	FD FD
}

// Opcode returns the event opcode for zwp_primary_selection_source_v1.send in wp_primary_selection_unstable_v1
func (ZwpPrimarySelectionSourceV1SendEvent) Opcode() uint16 { return 0 }

// MessageName returns the event name for zwp_primary_selection_source_v1.send in wp_primary_selection_unstable_v1
func (ZwpPrimarySelectionSourceV1SendEvent) MessageName() string { return "send" }

// Ensure ZwpPrimarySelectionSourceV1SendEvent implements Message.
var _ Message = ZwpPrimarySelectionSourceV1SendEvent{}

// Scan scans the event from the socket.
func (e *ZwpPrimarySelectionSourceV1SendEvent) Scan(s *EventScanner) error {
	if v, err := s.String(); err != nil {
		return err
	} else {
		e.MimeType = v
	}
	if v, err := s.FD(); err != nil {
		return err
	} else {
		e.FD = v
	}
	return nil
}

// Ensure ZwpPrimarySelectionSourceV1SendEvent implements Event.
var _ Event = &ZwpPrimarySelectionSourceV1SendEvent{}

// ZwpPrimarySelectionSourceV1CancelledEvent signals when request for primary selection contents was canceled
//
// This primary selection source is no longer valid. The client should
// clean up and destroy this primary selection source.
type ZwpPrimarySelectionSourceV1CancelledEvent struct {
}

// Opcode returns the event opcode for zwp_primary_selection_source_v1.cancelled in wp_primary_selection_unstable_v1
func (ZwpPrimarySelectionSourceV1CancelledEvent) Opcode() uint16 { return 1 }

// MessageName returns the event name for zwp_primary_selection_source_v1.cancelled in wp_primary_selection_unstable_v1
func (ZwpPrimarySelectionSourceV1CancelledEvent) MessageName() string { return "cancelled" }

// Ensure ZwpPrimarySelectionSourceV1CancelledEvent implements Message.
var _ Message = ZwpPrimarySelectionSourceV1CancelledEvent{}

// Scan scans the event from the socket.
func (e *ZwpPrimarySelectionSourceV1CancelledEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure ZwpPrimarySelectionSourceV1CancelledEvent implements Event.
var _ Event = &ZwpPrimarySelectionSourceV1CancelledEvent{}

// ZwpPrimarySelectionSourceV1 offer to replace the contents of the primary selection
//
// The source side of a wp_primary_selection_offer, it provides a way to
// describe the offered data and respond to requests to transfer the
// requested contents of the primary selection clipboard.
type ZwpPrimarySelectionSourceV1 struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *ZwpPrimarySelectionSourceV1) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (ZwpPrimarySelectionSourceV1) Descriptor() *InterfaceDescriptor {
	return &ZwpPrimarySelectionSourceV1Descriptor
}

// Dispatch returns an Event object for a given opcode.
func (ZwpPrimarySelectionSourceV1) Dispatch(opcode uint16) Event {
	switch opcode {
	case 0:
		return &ZwpPrimarySelectionSourceV1SendEvent{}
	case 1:
		return &ZwpPrimarySelectionSourceV1CancelledEvent{}
	default:
		return nil
	}
}

// Offer requests to add an offered mime type
//
// This request adds a mime type to the set of mime types advertised to
// targets. Can be called several times to offer multiple types.
func (proxy *ZwpPrimarySelectionSourceV1) Offer(connection Connection, aMimeType string) (err error) {
	request := ZwpPrimarySelectionSourceV1OfferRequest{
		MimeType: aMimeType,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Destroy requests to destroy the primary selection source
//
// Destroy the primary selection source.
func (proxy *ZwpPrimarySelectionSourceV1) Destroy(connection Connection) (err error) {
	request := ZwpPrimarySelectionSourceV1DestroyRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Ensure ZwpPrimarySelectionSourceV1 implements Proxy.
var _ Proxy = &ZwpPrimarySelectionSourceV1{}

// #endregion Interface wp_primary_selection_unstable_v1.zwp_primary_selection_source_v1

////////////////////////////////////////////////////////////////////////////////
// #endregion Protocol wp_primary_selection_unstable_v1

////////////////////////////////////////////////////////////////////////////////
// #region Protocol xdg_activation_v1

// ----------------------------------------------------------------------------
// #region Interface xdg_activation_v1.xdg_activation_v1

// XdgActivationV1DestroyRequest requests to destroy the xdg_activation object
//
// Notify the compositor that the xdg_activation object will no longer be
// used.
//
// The child objects created via this interface are unaffected and should
// be destroyed separately.
type XdgActivationV1DestroyRequest struct {
}

// Opcode returns the request opcode for xdg_activation_v1.destroy in xdg_activation_v1
func (XdgActivationV1DestroyRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for xdg_activation_v1.destroy in xdg_activation_v1
func (XdgActivationV1DestroyRequest) MessageName() string { return "destroy" }

// Ensure XdgActivationV1DestroyRequest implements Message.
var _ Message = XdgActivationV1DestroyRequest{}

// Emit emits the message to the emitter.
func (r *XdgActivationV1DestroyRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure XdgActivationV1DestroyRequest implements Request.
var _ Request = &XdgActivationV1DestroyRequest{}

// XdgActivationV1GetActivationTokenRequest requests to requests a token
//
// Creates an xdg_activation_token_v1 object that will provide
// the initiating client with a unique token for this activation. This
// token should be offered to the clients to be activated.
type XdgActivationV1GetActivationTokenRequest struct {
	ID ObjectID
}

// Opcode returns the request opcode for xdg_activation_v1.get_activation_token in xdg_activation_v1
func (XdgActivationV1GetActivationTokenRequest) Opcode() uint16 { return 1 }

// MessageName returns the request name for xdg_activation_v1.get_activation_token in xdg_activation_v1
func (XdgActivationV1GetActivationTokenRequest) MessageName() string { return "get_activation_token" }

// Ensure XdgActivationV1GetActivationTokenRequest implements Message.
var _ Message = XdgActivationV1GetActivationTokenRequest{}

// Emit emits the message to the emitter.
func (r *XdgActivationV1GetActivationTokenRequest) Emit(e *RequestEmitter) error {
	if err := e.PutObjectID(r.ID); err != nil {
		return err
	}
	return nil
}

// Ensure XdgActivationV1GetActivationTokenRequest implements Request.
var _ Request = &XdgActivationV1GetActivationTokenRequest{}

// XdgActivationV1ActivateRequest requests to notify new interaction being available
//
// Requests surface activation. It's up to the compositor to display
// this information as desired, for example by placing the surface above
// the rest.
//
// The compositor may know who requested this by checking the activation
// token and might decide not to follow through with the activation if it's
// considered unwanted.
//
// Compositors can ignore unknown activation tokens when an invalid
// token is passed.
type XdgActivationV1ActivateRequest struct {
	// Token contains the activation token of the initiating client
	Token string

	// Surface contains the wl_surface to activate
	Surface ObjectID
}

// Opcode returns the request opcode for xdg_activation_v1.activate in xdg_activation_v1
func (XdgActivationV1ActivateRequest) Opcode() uint16 { return 2 }

// MessageName returns the request name for xdg_activation_v1.activate in xdg_activation_v1
func (XdgActivationV1ActivateRequest) MessageName() string { return "activate" }

// Ensure XdgActivationV1ActivateRequest implements Message.
var _ Message = XdgActivationV1ActivateRequest{}

// Emit emits the message to the emitter.
func (r *XdgActivationV1ActivateRequest) Emit(e *RequestEmitter) error {
	if err := e.PutString(r.Token); err != nil {
		return err
	}
	if err := e.PutObjectID(r.Surface); err != nil {
		return err
	}
	return nil
}

// Ensure XdgActivationV1ActivateRequest implements Request.
var _ Request = &XdgActivationV1ActivateRequest{}

// XdgActivationV1 interface for activating surfaces
//
// A global interface used for informing the compositor about applications
// being activated or started, or for applications to request to be
// activated.
type XdgActivationV1 struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *XdgActivationV1) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (XdgActivationV1) Descriptor() *InterfaceDescriptor {
	return &XdgActivationV1Descriptor
}

// Dispatch returns an Event object for a given opcode.
func (XdgActivationV1) Dispatch(opcode uint16) Event {
	switch opcode {
	default:
		return nil
	}
}

// Destroy requests to destroy the xdg_activation object
//
// Notify the compositor that the xdg_activation object will no longer be
// used.
//
// The child objects created via this interface are unaffected and should
// be destroyed separately.
func (proxy *XdgActivationV1) Destroy(connection Connection) (err error) {
	request := XdgActivationV1DestroyRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// GetActivationToken requests to requests a token
//
// Creates an xdg_activation_token_v1 object that will provide
// the initiating client with a unique token for this activation. This
// token should be offered to the clients to be activated.
func (proxy *XdgActivationV1) GetActivationToken(connection Connection) (aID *XdgActivationTokenV1, err error) {
	aID = &XdgActivationTokenV1{connection.NewID()}
	request := XdgActivationV1GetActivationTokenRequest{
		ID: aID.id,
	}
	err = connection.SendRequest(proxy.id, &request)
	if err == nil {
		connection.RegisterProxy(aID)
	}
	return
}

// Activate requests to notify new interaction being available
//
// Requests surface activation. It's up to the compositor to display
// this information as desired, for example by placing the surface above
// the rest.
//
// The compositor may know who requested this by checking the activation
// token and might decide not to follow through with the activation if it's
// considered unwanted.
//
// Compositors can ignore unknown activation tokens when an invalid
// token is passed.
func (proxy *XdgActivationV1) Activate(connection Connection, aToken string, aSurface ObjectID) (err error) {
	request := XdgActivationV1ActivateRequest{
		Token:   aToken,
		Surface: aSurface,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Ensure XdgActivationV1 implements Proxy.
var _ Proxy = &XdgActivationV1{}

// #endregion Interface xdg_activation_v1.xdg_activation_v1

// ----------------------------------------------------------------------------
// #region Interface xdg_activation_v1.xdg_activation_token_v1

type XdgActivationTokenV1Error int

const (
	// XdgActivationTokenV1ErrorAlreadyUsed corresponds to The token has already been used previously
	XdgActivationTokenV1ErrorAlreadyUsed XdgActivationTokenV1Error = 0
)

// XdgActivationTokenV1SetSerialRequest requests to specifies the seat and serial of the activating event
//
// Provides information about the seat and serial event that requested the
// token.
//
// The serial can come from an input or focus event. For instance, if a
// click triggers the launch of a third-party client, the launcher client
// should send a set_serial request with the serial and seat from the
// wl_pointer.button event.
//
// Some compositors might refuse to activate toplevels when the token
// doesn't have a valid and recent enough event serial.
//
// Must be sent before commit. This information is optional.
type XdgActivationTokenV1SetSerialRequest struct {
	// Serial contains the serial of the event that triggered the activation
	Serial uint32

	// Seat contains the wl_seat of the event
	Seat ObjectID
}

// Opcode returns the request opcode for xdg_activation_token_v1.set_serial in xdg_activation_v1
func (XdgActivationTokenV1SetSerialRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for xdg_activation_token_v1.set_serial in xdg_activation_v1
func (XdgActivationTokenV1SetSerialRequest) MessageName() string { return "set_serial" }

// Ensure XdgActivationTokenV1SetSerialRequest implements Message.
var _ Message = XdgActivationTokenV1SetSerialRequest{}

// Emit emits the message to the emitter.
func (r *XdgActivationTokenV1SetSerialRequest) Emit(e *RequestEmitter) error {
	if err := e.PutUint(r.Serial); err != nil {
		return err
	}
	if err := e.PutObjectID(r.Seat); err != nil {
		return err
	}
	return nil
}

// Ensure XdgActivationTokenV1SetSerialRequest implements Request.
var _ Request = &XdgActivationTokenV1SetSerialRequest{}

// XdgActivationTokenV1SetAppIDRequest requests to specifies the application being activated
//
// The requesting client can specify an app_id to associate the token
// being created with it.
//
// Must be sent before commit. This information is optional.
type XdgActivationTokenV1SetAppIDRequest struct {
	// AppID contains the application id of the client being activated.
	AppID string
}

// Opcode returns the request opcode for xdg_activation_token_v1.set_app_id in xdg_activation_v1
func (XdgActivationTokenV1SetAppIDRequest) Opcode() uint16 { return 1 }

// MessageName returns the request name for xdg_activation_token_v1.set_app_id in xdg_activation_v1
func (XdgActivationTokenV1SetAppIDRequest) MessageName() string { return "set_app_id" }

// Ensure XdgActivationTokenV1SetAppIDRequest implements Message.
var _ Message = XdgActivationTokenV1SetAppIDRequest{}

// Emit emits the message to the emitter.
func (r *XdgActivationTokenV1SetAppIDRequest) Emit(e *RequestEmitter) error {
	if err := e.PutString(r.AppID); err != nil {
		return err
	}
	return nil
}

// Ensure XdgActivationTokenV1SetAppIDRequest implements Request.
var _ Request = &XdgActivationTokenV1SetAppIDRequest{}

// XdgActivationTokenV1SetSurfaceRequest requests to specifies the surface requesting activation
//
// This request sets the surface requesting the activation. Note, this is
// different from the surface that will be activated.
//
// Some compositors might refuse to activate toplevels when the token
// doesn't have a requesting surface.
//
// Must be sent before commit. This information is optional.
type XdgActivationTokenV1SetSurfaceRequest struct {
	// Surface contains the requesting surface
	Surface ObjectID
}

// Opcode returns the request opcode for xdg_activation_token_v1.set_surface in xdg_activation_v1
func (XdgActivationTokenV1SetSurfaceRequest) Opcode() uint16 { return 2 }

// MessageName returns the request name for xdg_activation_token_v1.set_surface in xdg_activation_v1
func (XdgActivationTokenV1SetSurfaceRequest) MessageName() string { return "set_surface" }

// Ensure XdgActivationTokenV1SetSurfaceRequest implements Message.
var _ Message = XdgActivationTokenV1SetSurfaceRequest{}

// Emit emits the message to the emitter.
func (r *XdgActivationTokenV1SetSurfaceRequest) Emit(e *RequestEmitter) error {
	if err := e.PutObjectID(r.Surface); err != nil {
		return err
	}
	return nil
}

// Ensure XdgActivationTokenV1SetSurfaceRequest implements Request.
var _ Request = &XdgActivationTokenV1SetSurfaceRequest{}

// XdgActivationTokenV1CommitRequest requests to issues the token request
//
// Requests an activation token based on the different parameters that
// have been offered through set_serial, set_surface and set_app_id.
type XdgActivationTokenV1CommitRequest struct {
}

// Opcode returns the request opcode for xdg_activation_token_v1.commit in xdg_activation_v1
func (XdgActivationTokenV1CommitRequest) Opcode() uint16 { return 3 }

// MessageName returns the request name for xdg_activation_token_v1.commit in xdg_activation_v1
func (XdgActivationTokenV1CommitRequest) MessageName() string { return "commit" }

// Ensure XdgActivationTokenV1CommitRequest implements Message.
var _ Message = XdgActivationTokenV1CommitRequest{}

// Emit emits the message to the emitter.
func (r *XdgActivationTokenV1CommitRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure XdgActivationTokenV1CommitRequest implements Request.
var _ Request = &XdgActivationTokenV1CommitRequest{}

// XdgActivationTokenV1DestroyRequest requests to destroy the xdg_activation_token_v1 object
//
// Notify the compositor that the xdg_activation_token_v1 object will no
// longer be used.
type XdgActivationTokenV1DestroyRequest struct {
}

// Opcode returns the request opcode for xdg_activation_token_v1.destroy in xdg_activation_v1
func (XdgActivationTokenV1DestroyRequest) Opcode() uint16 { return 4 }

// MessageName returns the request name for xdg_activation_token_v1.destroy in xdg_activation_v1
func (XdgActivationTokenV1DestroyRequest) MessageName() string { return "destroy" }

// Ensure XdgActivationTokenV1DestroyRequest implements Message.
var _ Message = XdgActivationTokenV1DestroyRequest{}

// Emit emits the message to the emitter.
func (r *XdgActivationTokenV1DestroyRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure XdgActivationTokenV1DestroyRequest implements Request.
var _ Request = &XdgActivationTokenV1DestroyRequest{}

// XdgActivationTokenV1DoneEvent signals when the exported activation token
//
// The 'done' event contains the unique token of this activation request
// and notifies that the provider is done.
type XdgActivationTokenV1DoneEvent struct {
	// Token contains the exported activation token
	Token string
}

// Opcode returns the event opcode for xdg_activation_token_v1.done in xdg_activation_v1
func (XdgActivationTokenV1DoneEvent) Opcode() uint16 { return 0 }

// MessageName returns the event name for xdg_activation_token_v1.done in xdg_activation_v1
func (XdgActivationTokenV1DoneEvent) MessageName() string { return "done" }

// Ensure XdgActivationTokenV1DoneEvent implements Message.
var _ Message = XdgActivationTokenV1DoneEvent{}

// Scan scans the event from the socket.
func (e *XdgActivationTokenV1DoneEvent) Scan(s *EventScanner) error {
	if v, err := s.String(); err != nil {
		return err
	} else {
		e.Token = v
	}
	return nil
}

// Ensure XdgActivationTokenV1DoneEvent implements Event.
var _ Event = &XdgActivationTokenV1DoneEvent{}

// XdgActivationTokenV1 an exported activation handle
//
// An object for setting up a token and receiving a token handle that can
// be passed as an activation token to another client.
//
// The object is created using the xdg_activation_v1.get_activation_token
// request. This object should then be populated with the app_id, surface
// and serial information and committed. The compositor shall then issue a
// done event with the token. In case the request's parameters are invalid,
// the compositor will provide an invalid token.
type XdgActivationTokenV1 struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *XdgActivationTokenV1) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (XdgActivationTokenV1) Descriptor() *InterfaceDescriptor {
	return &XdgActivationTokenV1Descriptor
}

// Dispatch returns an Event object for a given opcode.
func (XdgActivationTokenV1) Dispatch(opcode uint16) Event {
	switch opcode {
	case 0:
		return &XdgActivationTokenV1DoneEvent{}
	default:
		return nil
	}
}

// SetSerial requests to specifies the seat and serial of the activating event
//
// Provides information about the seat and serial event that requested the
// token.
//
// The serial can come from an input or focus event. For instance, if a
// click triggers the launch of a third-party client, the launcher client
// should send a set_serial request with the serial and seat from the
// wl_pointer.button event.
//
// Some compositors might refuse to activate toplevels when the token
// doesn't have a valid and recent enough event serial.
//
// Must be sent before commit. This information is optional.
func (proxy *XdgActivationTokenV1) SetSerial(connection Connection, aSerial uint32, aSeat ObjectID) (err error) {
	request := XdgActivationTokenV1SetSerialRequest{
		Serial: aSerial,
		Seat:   aSeat,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// SetAppID requests to specifies the application being activated
//
// The requesting client can specify an app_id to associate the token
// being created with it.
//
// Must be sent before commit. This information is optional.
func (proxy *XdgActivationTokenV1) SetAppID(connection Connection, aAppID string) (err error) {
	request := XdgActivationTokenV1SetAppIDRequest{
		AppID: aAppID,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// SetSurface requests to specifies the surface requesting activation
//
// This request sets the surface requesting the activation. Note, this is
// different from the surface that will be activated.
//
// Some compositors might refuse to activate toplevels when the token
// doesn't have a requesting surface.
//
// Must be sent before commit. This information is optional.
func (proxy *XdgActivationTokenV1) SetSurface(connection Connection, aSurface ObjectID) (err error) {
	request := XdgActivationTokenV1SetSurfaceRequest{
		Surface: aSurface,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Commit requests to issues the token request
//
// Requests an activation token based on the different parameters that
// have been offered through set_serial, set_surface and set_app_id.
func (proxy *XdgActivationTokenV1) Commit(connection Connection) (err error) {
	request := XdgActivationTokenV1CommitRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Destroy requests to destroy the xdg_activation_token_v1 object
//
// Notify the compositor that the xdg_activation_token_v1 object will no
// longer be used.
func (proxy *XdgActivationTokenV1) Destroy(connection Connection) (err error) {
	request := XdgActivationTokenV1DestroyRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Ensure XdgActivationTokenV1 implements Proxy.
var _ Proxy = &XdgActivationTokenV1{}

// #endregion Interface xdg_activation_v1.xdg_activation_token_v1

////////////////////////////////////////////////////////////////////////////////
// #endregion Protocol xdg_activation_v1

////////////////////////////////////////////////////////////////////////////////
// #region Protocol xdg_decoration_unstable_v1

// ----------------------------------------------------------------------------
// #region Interface xdg_decoration_unstable_v1.zxdg_decoration_manager_v1

// ZxdgDecorationManagerV1DestroyRequest requests to destroy the decoration manager object
//
// Destroy the decoration manager. This doesn't destroy objects created
// with the manager.
type ZxdgDecorationManagerV1DestroyRequest struct {
}

// Opcode returns the request opcode for zxdg_decoration_manager_v1.destroy in xdg_decoration_unstable_v1
func (ZxdgDecorationManagerV1DestroyRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for zxdg_decoration_manager_v1.destroy in xdg_decoration_unstable_v1
func (ZxdgDecorationManagerV1DestroyRequest) MessageName() string { return "destroy" }

// Ensure ZxdgDecorationManagerV1DestroyRequest implements Message.
var _ Message = ZxdgDecorationManagerV1DestroyRequest{}

// Emit emits the message to the emitter.
func (r *ZxdgDecorationManagerV1DestroyRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure ZxdgDecorationManagerV1DestroyRequest implements Request.
var _ Request = &ZxdgDecorationManagerV1DestroyRequest{}

// ZxdgDecorationManagerV1GetToplevelDecorationRequest requests to create a new toplevel decoration object
//
// Create a new decoration object associated with the given toplevel.
//
// Creating an xdg_toplevel_decoration from an xdg_toplevel which has a
// buffer attached or committed is a client error, and any attempts by a
// client to attach or manipulate a buffer prior to the first
// xdg_toplevel_decoration.configure event must also be treated as
// errors.
type ZxdgDecorationManagerV1GetToplevelDecorationRequest struct {
	ID ObjectID

	Toplevel ObjectID
}

// Opcode returns the request opcode for zxdg_decoration_manager_v1.get_toplevel_decoration in xdg_decoration_unstable_v1
func (ZxdgDecorationManagerV1GetToplevelDecorationRequest) Opcode() uint16 { return 1 }

// MessageName returns the request name for zxdg_decoration_manager_v1.get_toplevel_decoration in xdg_decoration_unstable_v1
func (ZxdgDecorationManagerV1GetToplevelDecorationRequest) MessageName() string {
	return "get_toplevel_decoration"
}

// Ensure ZxdgDecorationManagerV1GetToplevelDecorationRequest implements Message.
var _ Message = ZxdgDecorationManagerV1GetToplevelDecorationRequest{}

// Emit emits the message to the emitter.
func (r *ZxdgDecorationManagerV1GetToplevelDecorationRequest) Emit(e *RequestEmitter) error {
	if err := e.PutObjectID(r.ID); err != nil {
		return err
	}
	if err := e.PutObjectID(r.Toplevel); err != nil {
		return err
	}
	return nil
}

// Ensure ZxdgDecorationManagerV1GetToplevelDecorationRequest implements Request.
var _ Request = &ZxdgDecorationManagerV1GetToplevelDecorationRequest{}

// ZxdgDecorationManagerV1 window decoration manager
//
// This interface allows a compositor to announce support for server-side
// decorations.
//
// A window decoration is a set of window controls as deemed appropriate by
// the party managing them, such as user interface components used to move,
// resize and change a window's state.
//
// A client can use this protocol to request being decorated by a supporting
// compositor.
//
// If compositor and client do not negotiate the use of a server-side
// decoration using this protocol, clients continue to self-decorate as they
// see fit.
//
// Warning! The protocol described in this file is experimental and
// backward incompatible changes may be made. Backward compatible changes
// may be added together with the corresponding interface version bump.
// Backward incompatible changes are done by bumping the version number in
// the protocol and interface names and resetting the interface version.
// Once the protocol is to be declared stable, the 'z' prefix and the
// version number in the protocol and interface names are removed and the
// interface version number is reset.
type ZxdgDecorationManagerV1 struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *ZxdgDecorationManagerV1) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (ZxdgDecorationManagerV1) Descriptor() *InterfaceDescriptor {
	return &ZxdgDecorationManagerV1Descriptor
}

// Dispatch returns an Event object for a given opcode.
func (ZxdgDecorationManagerV1) Dispatch(opcode uint16) Event {
	switch opcode {
	default:
		return nil
	}
}

// Destroy requests to destroy the decoration manager object
//
// Destroy the decoration manager. This doesn't destroy objects created
// with the manager.
func (proxy *ZxdgDecorationManagerV1) Destroy(connection Connection) (err error) {
	request := ZxdgDecorationManagerV1DestroyRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// GetToplevelDecoration requests to create a new toplevel decoration object
//
// Create a new decoration object associated with the given toplevel.
//
// Creating an xdg_toplevel_decoration from an xdg_toplevel which has a
// buffer attached or committed is a client error, and any attempts by a
// client to attach or manipulate a buffer prior to the first
// xdg_toplevel_decoration.configure event must also be treated as
// errors.
func (proxy *ZxdgDecorationManagerV1) GetToplevelDecoration(connection Connection, aToplevel ObjectID) (aID *ZxdgToplevelDecorationV1, err error) {
	aID = &ZxdgToplevelDecorationV1{connection.NewID()}
	request := ZxdgDecorationManagerV1GetToplevelDecorationRequest{
		ID:       aID.id,
		Toplevel: aToplevel,
	}
	err = connection.SendRequest(proxy.id, &request)
	if err == nil {
		connection.RegisterProxy(aID)
	}
	return
}

// Ensure ZxdgDecorationManagerV1 implements Proxy.
var _ Proxy = &ZxdgDecorationManagerV1{}

// #endregion Interface xdg_decoration_unstable_v1.zxdg_decoration_manager_v1

// ----------------------------------------------------------------------------
// #region Interface xdg_decoration_unstable_v1.zxdg_toplevel_decoration_v1

type ZxdgToplevelDecorationV1Error int

const (
	// ZxdgToplevelDecorationV1ErrorUnconfiguredBuffer corresponds to xdg_toplevel has a buffer attached before configure
	ZxdgToplevelDecorationV1ErrorUnconfiguredBuffer ZxdgToplevelDecorationV1Error = 0

	// ZxdgToplevelDecorationV1ErrorAlreadyConstructed corresponds to xdg_toplevel already has a decoration object
	ZxdgToplevelDecorationV1ErrorAlreadyConstructed ZxdgToplevelDecorationV1Error = 1

	// ZxdgToplevelDecorationV1ErrorOrphaned corresponds to xdg_toplevel destroyed before the decoration object
	ZxdgToplevelDecorationV1ErrorOrphaned ZxdgToplevelDecorationV1Error = 2
)

// ZxdgToplevelDecorationV1Mode represents window decoration modes
//
// These values describe window decoration modes.
type ZxdgToplevelDecorationV1Mode int

const (
	// ZxdgToplevelDecorationV1ModeClientSide corresponds to no server-side window decoration
	ZxdgToplevelDecorationV1ModeClientSide ZxdgToplevelDecorationV1Mode = 1

	// ZxdgToplevelDecorationV1ModeServerSide corresponds to server-side window decoration
	ZxdgToplevelDecorationV1ModeServerSide ZxdgToplevelDecorationV1Mode = 2
)

// ZxdgToplevelDecorationV1DestroyRequest requests to destroy the decoration object
//
// Switch back to a mode without any server-side decorations at the next
// commit.
type ZxdgToplevelDecorationV1DestroyRequest struct {
}

// Opcode returns the request opcode for zxdg_toplevel_decoration_v1.destroy in xdg_decoration_unstable_v1
func (ZxdgToplevelDecorationV1DestroyRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for zxdg_toplevel_decoration_v1.destroy in xdg_decoration_unstable_v1
func (ZxdgToplevelDecorationV1DestroyRequest) MessageName() string { return "destroy" }

// Ensure ZxdgToplevelDecorationV1DestroyRequest implements Message.
var _ Message = ZxdgToplevelDecorationV1DestroyRequest{}

// Emit emits the message to the emitter.
func (r *ZxdgToplevelDecorationV1DestroyRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure ZxdgToplevelDecorationV1DestroyRequest implements Request.
var _ Request = &ZxdgToplevelDecorationV1DestroyRequest{}

// ZxdgToplevelDecorationV1SetModeRequest requests to set the decoration mode
//
// Set the toplevel surface decoration mode. This informs the compositor
// that the client prefers the provided decoration mode.
//
// After requesting a decoration mode, the compositor will respond by
// emitting an xdg_surface.configure event. The client should then update
// its content, drawing it without decorations if the received mode is
// server-side decorations. The client must also acknowledge the configure
// when committing the new content (see xdg_surface.ack_configure).
//
// The compositor can decide not to use the client's mode and enforce a
// different mode instead.
//
// Clients whose decoration mode depend on the xdg_toplevel state may send
// a set_mode request in response to an xdg_surface.configure event and wait
// for the next xdg_surface.configure event to prevent unwanted state.
// Such clients are responsible for preventing configure loops and must
// make sure not to send multiple successive set_mode requests with the
// same decoration mode.
type ZxdgToplevelDecorationV1SetModeRequest struct {
	// Mode contains the decoration mode
	Mode uint32
}

// Opcode returns the request opcode for zxdg_toplevel_decoration_v1.set_mode in xdg_decoration_unstable_v1
func (ZxdgToplevelDecorationV1SetModeRequest) Opcode() uint16 { return 1 }

// MessageName returns the request name for zxdg_toplevel_decoration_v1.set_mode in xdg_decoration_unstable_v1
func (ZxdgToplevelDecorationV1SetModeRequest) MessageName() string { return "set_mode" }

// Ensure ZxdgToplevelDecorationV1SetModeRequest implements Message.
var _ Message = ZxdgToplevelDecorationV1SetModeRequest{}

// Emit emits the message to the emitter.
func (r *ZxdgToplevelDecorationV1SetModeRequest) Emit(e *RequestEmitter) error {
	if err := e.PutUint(r.Mode); err != nil {
		return err
	}
	return nil
}

// Ensure ZxdgToplevelDecorationV1SetModeRequest implements Request.
var _ Request = &ZxdgToplevelDecorationV1SetModeRequest{}

// ZxdgToplevelDecorationV1UnsetModeRequest requests to unset the decoration mode
//
// Unset the toplevel surface decoration mode. This informs the compositor
// that the client doesn't prefer a particular decoration mode.
//
// This request has the same semantics as set_mode.
type ZxdgToplevelDecorationV1UnsetModeRequest struct {
}

// Opcode returns the request opcode for zxdg_toplevel_decoration_v1.unset_mode in xdg_decoration_unstable_v1
func (ZxdgToplevelDecorationV1UnsetModeRequest) Opcode() uint16 { return 2 }

// MessageName returns the request name for zxdg_toplevel_decoration_v1.unset_mode in xdg_decoration_unstable_v1
func (ZxdgToplevelDecorationV1UnsetModeRequest) MessageName() string { return "unset_mode" }

// Ensure ZxdgToplevelDecorationV1UnsetModeRequest implements Message.
var _ Message = ZxdgToplevelDecorationV1UnsetModeRequest{}

// Emit emits the message to the emitter.
func (r *ZxdgToplevelDecorationV1UnsetModeRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure ZxdgToplevelDecorationV1UnsetModeRequest implements Request.
var _ Request = &ZxdgToplevelDecorationV1UnsetModeRequest{}

// ZxdgToplevelDecorationV1ConfigureEvent signals when suggest a surface change
//
// The configure event asks the client to change its decoration mode. The
// configured state should not be applied immediately. Clients must send an
// ack_configure in response to this event. See xdg_surface.configure and
// xdg_surface.ack_configure for details.
//
// A configure event can be sent at any time. The specified mode must be
// obeyed by the client.
type ZxdgToplevelDecorationV1ConfigureEvent struct {
	// Mode contains the decoration mode
	Mode uint32
}

// Opcode returns the event opcode for zxdg_toplevel_decoration_v1.configure in xdg_decoration_unstable_v1
func (ZxdgToplevelDecorationV1ConfigureEvent) Opcode() uint16 { return 0 }

// MessageName returns the event name for zxdg_toplevel_decoration_v1.configure in xdg_decoration_unstable_v1
func (ZxdgToplevelDecorationV1ConfigureEvent) MessageName() string { return "configure" }

// Ensure ZxdgToplevelDecorationV1ConfigureEvent implements Message.
var _ Message = ZxdgToplevelDecorationV1ConfigureEvent{}

// Scan scans the event from the socket.
func (e *ZxdgToplevelDecorationV1ConfigureEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Mode = v
	}
	return nil
}

// Ensure ZxdgToplevelDecorationV1ConfigureEvent implements Event.
var _ Event = &ZxdgToplevelDecorationV1ConfigureEvent{}

// ZxdgToplevelDecorationV1 decoration object for a toplevel surface
//
// The decoration object allows the compositor to toggle server-side window
// decorations for a toplevel surface. The client can request to switch to
// another mode.
//
// The xdg_toplevel_decoration object must be destroyed before its
// xdg_toplevel.
type ZxdgToplevelDecorationV1 struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *ZxdgToplevelDecorationV1) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (ZxdgToplevelDecorationV1) Descriptor() *InterfaceDescriptor {
	return &ZxdgToplevelDecorationV1Descriptor
}

// Dispatch returns an Event object for a given opcode.
func (ZxdgToplevelDecorationV1) Dispatch(opcode uint16) Event {
	switch opcode {
	case 0:
		return &ZxdgToplevelDecorationV1ConfigureEvent{}
	default:
		return nil
	}
}

// Destroy requests to destroy the decoration object
//
// Switch back to a mode without any server-side decorations at the next
// commit.
func (proxy *ZxdgToplevelDecorationV1) Destroy(connection Connection) (err error) {
	request := ZxdgToplevelDecorationV1DestroyRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// SetMode requests to set the decoration mode
//
// Set the toplevel surface decoration mode. This informs the compositor
// that the client prefers the provided decoration mode.
//
// After requesting a decoration mode, the compositor will respond by
// emitting an xdg_surface.configure event. The client should then update
// its content, drawing it without decorations if the received mode is
// server-side decorations. The client must also acknowledge the configure
// when committing the new content (see xdg_surface.ack_configure).
//
// The compositor can decide not to use the client's mode and enforce a
// different mode instead.
//
// Clients whose decoration mode depend on the xdg_toplevel state may send
// a set_mode request in response to an xdg_surface.configure event and wait
// for the next xdg_surface.configure event to prevent unwanted state.
// Such clients are responsible for preventing configure loops and must
// make sure not to send multiple successive set_mode requests with the
// same decoration mode.
func (proxy *ZxdgToplevelDecorationV1) SetMode(connection Connection, aMode uint32) (err error) {
	request := ZxdgToplevelDecorationV1SetModeRequest{
		Mode: aMode,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// UnsetMode requests to unset the decoration mode
//
// Unset the toplevel surface decoration mode. This informs the compositor
// that the client doesn't prefer a particular decoration mode.
//
// This request has the same semantics as set_mode.
func (proxy *ZxdgToplevelDecorationV1) UnsetMode(connection Connection) (err error) {
	request := ZxdgToplevelDecorationV1UnsetModeRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Ensure ZxdgToplevelDecorationV1 implements Proxy.
var _ Proxy = &ZxdgToplevelDecorationV1{}

// #endregion Interface xdg_decoration_unstable_v1.zxdg_toplevel_decoration_v1

////////////////////////////////////////////////////////////////////////////////
// #endregion Protocol xdg_decoration_unstable_v1

////////////////////////////////////////////////////////////////////////////////
// #region Protocol xdg_foreign_unstable_v1

// ----------------------------------------------------------------------------
// #region Interface xdg_foreign_unstable_v1.zxdg_exporter_v1

// ZxdgExporterV1DestroyRequest requests to destroy the xdg_exporter object
//
// Notify the compositor that the xdg_exporter object will no longer be
// used.
type ZxdgExporterV1DestroyRequest struct {
}

// Opcode returns the request opcode for zxdg_exporter_v1.destroy in xdg_foreign_unstable_v1
func (ZxdgExporterV1DestroyRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for zxdg_exporter_v1.destroy in xdg_foreign_unstable_v1
func (ZxdgExporterV1DestroyRequest) MessageName() string { return "destroy" }

// Ensure ZxdgExporterV1DestroyRequest implements Message.
var _ Message = ZxdgExporterV1DestroyRequest{}

// Emit emits the message to the emitter.
func (r *ZxdgExporterV1DestroyRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure ZxdgExporterV1DestroyRequest implements Request.
var _ Request = &ZxdgExporterV1DestroyRequest{}

// ZxdgExporterV1ExportRequest requests to export a surface
//
// The export request exports the passed surface so that it can later be
// imported via xdg_importer. When called, a new xdg_exported object will
// be created and xdg_exported.handle will be sent immediately. See the
// corresponding interface and event for details.
//
// A surface may be exported multiple times, and each exported handle may
// be used to create an xdg_imported multiple times. Only xdg_surface
// surfaces may be exported.
type ZxdgExporterV1ExportRequest struct {
	// ID contains the new xdg_exported object
	ID ObjectID

	// Surface contains the surface to export
	Surface ObjectID
}

// Opcode returns the request opcode for zxdg_exporter_v1.export in xdg_foreign_unstable_v1
func (ZxdgExporterV1ExportRequest) Opcode() uint16 { return 1 }

// MessageName returns the request name for zxdg_exporter_v1.export in xdg_foreign_unstable_v1
func (ZxdgExporterV1ExportRequest) MessageName() string { return "export" }

// Ensure ZxdgExporterV1ExportRequest implements Message.
var _ Message = ZxdgExporterV1ExportRequest{}

// Emit emits the message to the emitter.
func (r *ZxdgExporterV1ExportRequest) Emit(e *RequestEmitter) error {
	if err := e.PutObjectID(r.ID); err != nil {
		return err
	}
	if err := e.PutObjectID(r.Surface); err != nil {
		return err
	}
	return nil
}

// Ensure ZxdgExporterV1ExportRequest implements Request.
var _ Request = &ZxdgExporterV1ExportRequest{}

// ZxdgExporterV1 interface for exporting surfaces
//
// A global interface used for exporting surfaces that can later be imported
// using xdg_importer.
type ZxdgExporterV1 struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *ZxdgExporterV1) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (ZxdgExporterV1) Descriptor() *InterfaceDescriptor {
	return &ZxdgExporterV1Descriptor
}

// Dispatch returns an Event object for a given opcode.
func (ZxdgExporterV1) Dispatch(opcode uint16) Event {
	switch opcode {
	default:
		return nil
	}
}

// Destroy requests to destroy the xdg_exporter object
//
// Notify the compositor that the xdg_exporter object will no longer be
// used.
func (proxy *ZxdgExporterV1) Destroy(connection Connection) (err error) {
	request := ZxdgExporterV1DestroyRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Export requests to export a surface
//
// The export request exports the passed surface so that it can later be
// imported via xdg_importer. When called, a new xdg_exported object will
// be created and xdg_exported.handle will be sent immediately. See the
// corresponding interface and event for details.
//
// A surface may be exported multiple times, and each exported handle may
// be used to create an xdg_imported multiple times. Only xdg_surface
// surfaces may be exported.
func (proxy *ZxdgExporterV1) Export(connection Connection, aSurface ObjectID) (aID *ZxdgExportedV1, err error) {
	aID = &ZxdgExportedV1{connection.NewID()}
	request := ZxdgExporterV1ExportRequest{
		ID:      aID.id,
		Surface: aSurface,
	}
	err = connection.SendRequest(proxy.id, &request)
	if err == nil {
		connection.RegisterProxy(aID)
	}
	return
}

// Ensure ZxdgExporterV1 implements Proxy.
var _ Proxy = &ZxdgExporterV1{}

// #endregion Interface xdg_foreign_unstable_v1.zxdg_exporter_v1

// ----------------------------------------------------------------------------
// #region Interface xdg_foreign_unstable_v1.zxdg_importer_v1

// ZxdgImporterV1DestroyRequest requests to destroy the xdg_importer object
//
// Notify the compositor that the xdg_importer object will no longer be
// used.
type ZxdgImporterV1DestroyRequest struct {
}

// Opcode returns the request opcode for zxdg_importer_v1.destroy in xdg_foreign_unstable_v1
func (ZxdgImporterV1DestroyRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for zxdg_importer_v1.destroy in xdg_foreign_unstable_v1
func (ZxdgImporterV1DestroyRequest) MessageName() string { return "destroy" }

// Ensure ZxdgImporterV1DestroyRequest implements Message.
var _ Message = ZxdgImporterV1DestroyRequest{}

// Emit emits the message to the emitter.
func (r *ZxdgImporterV1DestroyRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure ZxdgImporterV1DestroyRequest implements Request.
var _ Request = &ZxdgImporterV1DestroyRequest{}

// ZxdgImporterV1ImportRequest requests to import a surface
//
// The import request imports a surface from any client given a handle
// retrieved by exporting said surface using xdg_exporter.export. When
// called, a new xdg_imported object will be created. This new object
// represents the imported surface, and the importing client can
// manipulate its relationship using it. See xdg_imported for details.
type ZxdgImporterV1ImportRequest struct {
	// ID contains the new xdg_imported object
	ID ObjectID

	// Handle contains the exported surface handle
	Handle string
}

// Opcode returns the request opcode for zxdg_importer_v1.import in xdg_foreign_unstable_v1
func (ZxdgImporterV1ImportRequest) Opcode() uint16 { return 1 }

// MessageName returns the request name for zxdg_importer_v1.import in xdg_foreign_unstable_v1
func (ZxdgImporterV1ImportRequest) MessageName() string { return "import" }

// Ensure ZxdgImporterV1ImportRequest implements Message.
var _ Message = ZxdgImporterV1ImportRequest{}

// Emit emits the message to the emitter.
func (r *ZxdgImporterV1ImportRequest) Emit(e *RequestEmitter) error {
	if err := e.PutObjectID(r.ID); err != nil {
		return err
	}
	if err := e.PutString(r.Handle); err != nil {
		return err
	}
	return nil
}

// Ensure ZxdgImporterV1ImportRequest implements Request.
var _ Request = &ZxdgImporterV1ImportRequest{}

// ZxdgImporterV1 interface for importing surfaces
//
// A global interface used for importing surfaces exported by xdg_exporter.
// With this interface, a client can create a reference to a surface of
// another client.
type ZxdgImporterV1 struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *ZxdgImporterV1) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (ZxdgImporterV1) Descriptor() *InterfaceDescriptor {
	return &ZxdgImporterV1Descriptor
}

// Dispatch returns an Event object for a given opcode.
func (ZxdgImporterV1) Dispatch(opcode uint16) Event {
	switch opcode {
	default:
		return nil
	}
}

// Destroy requests to destroy the xdg_importer object
//
// Notify the compositor that the xdg_importer object will no longer be
// used.
func (proxy *ZxdgImporterV1) Destroy(connection Connection) (err error) {
	request := ZxdgImporterV1DestroyRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Import requests to import a surface
//
// The import request imports a surface from any client given a handle
// retrieved by exporting said surface using xdg_exporter.export. When
// called, a new xdg_imported object will be created. This new object
// represents the imported surface, and the importing client can
// manipulate its relationship using it. See xdg_imported for details.
func (proxy *ZxdgImporterV1) Import(connection Connection, aHandle string) (aID *ZxdgImportedV1, err error) {
	aID = &ZxdgImportedV1{connection.NewID()}
	request := ZxdgImporterV1ImportRequest{
		ID:     aID.id,
		Handle: aHandle,
	}
	err = connection.SendRequest(proxy.id, &request)
	if err == nil {
		connection.RegisterProxy(aID)
	}
	return
}

// Ensure ZxdgImporterV1 implements Proxy.
var _ Proxy = &ZxdgImporterV1{}

// #endregion Interface xdg_foreign_unstable_v1.zxdg_importer_v1

// ----------------------------------------------------------------------------
// #region Interface xdg_foreign_unstable_v1.zxdg_exported_v1

// ZxdgExportedV1DestroyRequest requests to unexport the exported surface
//
// Revoke the previously exported surface. This invalidates any
// relationship the importer may have set up using the xdg_imported created
// given the handle sent via xdg_exported.handle.
type ZxdgExportedV1DestroyRequest struct {
}

// Opcode returns the request opcode for zxdg_exported_v1.destroy in xdg_foreign_unstable_v1
func (ZxdgExportedV1DestroyRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for zxdg_exported_v1.destroy in xdg_foreign_unstable_v1
func (ZxdgExportedV1DestroyRequest) MessageName() string { return "destroy" }

// Ensure ZxdgExportedV1DestroyRequest implements Message.
var _ Message = ZxdgExportedV1DestroyRequest{}

// Emit emits the message to the emitter.
func (r *ZxdgExportedV1DestroyRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure ZxdgExportedV1DestroyRequest implements Request.
var _ Request = &ZxdgExportedV1DestroyRequest{}

// ZxdgExportedV1HandleEvent signals when the exported surface handle
//
// The handle event contains the unique handle of this exported surface
// reference. It may be shared with any client, which then can use it to
// import the surface by calling xdg_importer.import. A handle may be
// used to import the surface multiple times.
type ZxdgExportedV1HandleEvent struct {
	// Handle contains the exported surface handle
	Handle string
}

// Opcode returns the event opcode for zxdg_exported_v1.handle in xdg_foreign_unstable_v1
func (ZxdgExportedV1HandleEvent) Opcode() uint16 { return 0 }

// MessageName returns the event name for zxdg_exported_v1.handle in xdg_foreign_unstable_v1
func (ZxdgExportedV1HandleEvent) MessageName() string { return "handle" }

// Ensure ZxdgExportedV1HandleEvent implements Message.
var _ Message = ZxdgExportedV1HandleEvent{}

// Scan scans the event from the socket.
func (e *ZxdgExportedV1HandleEvent) Scan(s *EventScanner) error {
	if v, err := s.String(); err != nil {
		return err
	} else {
		e.Handle = v
	}
	return nil
}

// Ensure ZxdgExportedV1HandleEvent implements Event.
var _ Event = &ZxdgExportedV1HandleEvent{}

// ZxdgExportedV1 an exported surface handle
//
// An xdg_exported object represents an exported reference to a surface. The
// exported surface may be referenced as long as the xdg_exported object not
// destroyed. Destroying the xdg_exported invalidates any relationship the
// importer may have established using xdg_imported.
type ZxdgExportedV1 struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *ZxdgExportedV1) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (ZxdgExportedV1) Descriptor() *InterfaceDescriptor {
	return &ZxdgExportedV1Descriptor
}

// Dispatch returns an Event object for a given opcode.
func (ZxdgExportedV1) Dispatch(opcode uint16) Event {
	switch opcode {
	case 0:
		return &ZxdgExportedV1HandleEvent{}
	default:
		return nil
	}
}

// Destroy requests to unexport the exported surface
//
// Revoke the previously exported surface. This invalidates any
// relationship the importer may have set up using the xdg_imported created
// given the handle sent via xdg_exported.handle.
func (proxy *ZxdgExportedV1) Destroy(connection Connection) (err error) {
	request := ZxdgExportedV1DestroyRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Ensure ZxdgExportedV1 implements Proxy.
var _ Proxy = &ZxdgExportedV1{}

// #endregion Interface xdg_foreign_unstable_v1.zxdg_exported_v1

// ----------------------------------------------------------------------------
// #region Interface xdg_foreign_unstable_v1.zxdg_imported_v1

// ZxdgImportedV1DestroyRequest requests to destroy the xdg_imported object
//
// Notify the compositor that it will no longer use the xdg_imported
// object. Any relationship that may have been set up will at this point
// be invalidated.
type ZxdgImportedV1DestroyRequest struct {
}

// Opcode returns the request opcode for zxdg_imported_v1.destroy in xdg_foreign_unstable_v1
func (ZxdgImportedV1DestroyRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for zxdg_imported_v1.destroy in xdg_foreign_unstable_v1
func (ZxdgImportedV1DestroyRequest) MessageName() string { return "destroy" }

// Ensure ZxdgImportedV1DestroyRequest implements Message.
var _ Message = ZxdgImportedV1DestroyRequest{}

// Emit emits the message to the emitter.
func (r *ZxdgImportedV1DestroyRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure ZxdgImportedV1DestroyRequest implements Request.
var _ Request = &ZxdgImportedV1DestroyRequest{}

// ZxdgImportedV1SetParentOfRequest requests to set as the parent of some surface
//
// Set the imported surface as the parent of some surface of the client.
// The passed surface must be a toplevel xdg_surface. Calling this function
// sets up a surface to surface relation with the same stacking and positioning
// semantics as xdg_surface.set_parent.
type ZxdgImportedV1SetParentOfRequest struct {
	// Surface contains the child surface
	Surface ObjectID
}

// Opcode returns the request opcode for zxdg_imported_v1.set_parent_of in xdg_foreign_unstable_v1
func (ZxdgImportedV1SetParentOfRequest) Opcode() uint16 { return 1 }

// MessageName returns the request name for zxdg_imported_v1.set_parent_of in xdg_foreign_unstable_v1
func (ZxdgImportedV1SetParentOfRequest) MessageName() string { return "set_parent_of" }

// Ensure ZxdgImportedV1SetParentOfRequest implements Message.
var _ Message = ZxdgImportedV1SetParentOfRequest{}

// Emit emits the message to the emitter.
func (r *ZxdgImportedV1SetParentOfRequest) Emit(e *RequestEmitter) error {
	if err := e.PutObjectID(r.Surface); err != nil {
		return err
	}
	return nil
}

// Ensure ZxdgImportedV1SetParentOfRequest implements Request.
var _ Request = &ZxdgImportedV1SetParentOfRequest{}

// ZxdgImportedV1DestroyedEvent signals when the imported surface handle has been destroyed
//
// The imported surface handle has been destroyed and any relationship set
// up has been invalidated. This may happen for various reasons, for
// example if the exported surface or the exported surface handle has been
// destroyed, if the handle used for importing was invalid.
type ZxdgImportedV1DestroyedEvent struct {
}

// Opcode returns the event opcode for zxdg_imported_v1.destroyed in xdg_foreign_unstable_v1
func (ZxdgImportedV1DestroyedEvent) Opcode() uint16 { return 0 }

// MessageName returns the event name for zxdg_imported_v1.destroyed in xdg_foreign_unstable_v1
func (ZxdgImportedV1DestroyedEvent) MessageName() string { return "destroyed" }

// Ensure ZxdgImportedV1DestroyedEvent implements Message.
var _ Message = ZxdgImportedV1DestroyedEvent{}

// Scan scans the event from the socket.
func (e *ZxdgImportedV1DestroyedEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure ZxdgImportedV1DestroyedEvent implements Event.
var _ Event = &ZxdgImportedV1DestroyedEvent{}

// ZxdgImportedV1 an imported surface handle
//
// An xdg_imported object represents an imported reference to surface exported
// by some client. A client can use this interface to manipulate
// relationships between its own surfaces and the imported surface.
type ZxdgImportedV1 struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *ZxdgImportedV1) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (ZxdgImportedV1) Descriptor() *InterfaceDescriptor {
	return &ZxdgImportedV1Descriptor
}

// Dispatch returns an Event object for a given opcode.
func (ZxdgImportedV1) Dispatch(opcode uint16) Event {
	switch opcode {
	case 0:
		return &ZxdgImportedV1DestroyedEvent{}
	default:
		return nil
	}
}

// Destroy requests to destroy the xdg_imported object
//
// Notify the compositor that it will no longer use the xdg_imported
// object. Any relationship that may have been set up will at this point
// be invalidated.
func (proxy *ZxdgImportedV1) Destroy(connection Connection) (err error) {
	request := ZxdgImportedV1DestroyRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// SetParentOf requests to set as the parent of some surface
//
// Set the imported surface as the parent of some surface of the client.
// The passed surface must be a toplevel xdg_surface. Calling this function
// sets up a surface to surface relation with the same stacking and positioning
// semantics as xdg_surface.set_parent.
func (proxy *ZxdgImportedV1) SetParentOf(connection Connection, aSurface ObjectID) (err error) {
	request := ZxdgImportedV1SetParentOfRequest{
		Surface: aSurface,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Ensure ZxdgImportedV1 implements Proxy.
var _ Proxy = &ZxdgImportedV1{}

// #endregion Interface xdg_foreign_unstable_v1.zxdg_imported_v1

////////////////////////////////////////////////////////////////////////////////
// #endregion Protocol xdg_foreign_unstable_v1

////////////////////////////////////////////////////////////////////////////////
// #region Protocol xdg_foreign_unstable_v2

// ----------------------------------------------------------------------------
// #region Interface xdg_foreign_unstable_v2.zxdg_exporter_v2

// ZxdgExporterV2Error represents error values
//
// These errors can be emitted in response to invalid xdg_exporter
// requests.
type ZxdgExporterV2Error int

const (
	// ZxdgExporterV2ErrorInvalidSurface corresponds to surface is not an xdg_toplevel
	ZxdgExporterV2ErrorInvalidSurface ZxdgExporterV2Error = 0
)

// ZxdgExporterV2DestroyRequest requests to destroy the xdg_exporter object
//
// Notify the compositor that the xdg_exporter object will no longer be
// used.
type ZxdgExporterV2DestroyRequest struct {
}

// Opcode returns the request opcode for zxdg_exporter_v2.destroy in xdg_foreign_unstable_v2
func (ZxdgExporterV2DestroyRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for zxdg_exporter_v2.destroy in xdg_foreign_unstable_v2
func (ZxdgExporterV2DestroyRequest) MessageName() string { return "destroy" }

// Ensure ZxdgExporterV2DestroyRequest implements Message.
var _ Message = ZxdgExporterV2DestroyRequest{}

// Emit emits the message to the emitter.
func (r *ZxdgExporterV2DestroyRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure ZxdgExporterV2DestroyRequest implements Request.
var _ Request = &ZxdgExporterV2DestroyRequest{}

// ZxdgExporterV2ExportToplevelRequest requests to export a toplevel surface
//
// The export_toplevel request exports the passed surface so that it can later be
// imported via xdg_importer. When called, a new xdg_exported object will
// be created and xdg_exported.handle will be sent immediately. See the
// corresponding interface and event for details.
//
// A surface may be exported multiple times, and each exported handle may
// be used to create an xdg_imported multiple times. Only xdg_toplevel
// equivalent surfaces may be exported, otherwise an invalid_surface
// protocol error is sent.
type ZxdgExporterV2ExportToplevelRequest struct {
	// ID contains the new xdg_exported object
	ID ObjectID

	// Surface contains the surface to export
	Surface ObjectID
}

// Opcode returns the request opcode for zxdg_exporter_v2.export_toplevel in xdg_foreign_unstable_v2
func (ZxdgExporterV2ExportToplevelRequest) Opcode() uint16 { return 1 }

// MessageName returns the request name for zxdg_exporter_v2.export_toplevel in xdg_foreign_unstable_v2
func (ZxdgExporterV2ExportToplevelRequest) MessageName() string { return "export_toplevel" }

// Ensure ZxdgExporterV2ExportToplevelRequest implements Message.
var _ Message = ZxdgExporterV2ExportToplevelRequest{}

// Emit emits the message to the emitter.
func (r *ZxdgExporterV2ExportToplevelRequest) Emit(e *RequestEmitter) error {
	if err := e.PutObjectID(r.ID); err != nil {
		return err
	}
	if err := e.PutObjectID(r.Surface); err != nil {
		return err
	}
	return nil
}

// Ensure ZxdgExporterV2ExportToplevelRequest implements Request.
var _ Request = &ZxdgExporterV2ExportToplevelRequest{}

// ZxdgExporterV2 interface for exporting surfaces
//
// A global interface used for exporting surfaces that can later be imported
// using xdg_importer.
type ZxdgExporterV2 struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *ZxdgExporterV2) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (ZxdgExporterV2) Descriptor() *InterfaceDescriptor {
	return &ZxdgExporterV2Descriptor
}

// Dispatch returns an Event object for a given opcode.
func (ZxdgExporterV2) Dispatch(opcode uint16) Event {
	switch opcode {
	default:
		return nil
	}
}

// Destroy requests to destroy the xdg_exporter object
//
// Notify the compositor that the xdg_exporter object will no longer be
// used.
func (proxy *ZxdgExporterV2) Destroy(connection Connection) (err error) {
	request := ZxdgExporterV2DestroyRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// ExportToplevel requests to export a toplevel surface
//
// The export_toplevel request exports the passed surface so that it can later be
// imported via xdg_importer. When called, a new xdg_exported object will
// be created and xdg_exported.handle will be sent immediately. See the
// corresponding interface and event for details.
//
// A surface may be exported multiple times, and each exported handle may
// be used to create an xdg_imported multiple times. Only xdg_toplevel
// equivalent surfaces may be exported, otherwise an invalid_surface
// protocol error is sent.
func (proxy *ZxdgExporterV2) ExportToplevel(connection Connection, aSurface ObjectID) (aID *ZxdgExportedV2, err error) {
	aID = &ZxdgExportedV2{connection.NewID()}
	request := ZxdgExporterV2ExportToplevelRequest{
		ID:      aID.id,
		Surface: aSurface,
	}
	err = connection.SendRequest(proxy.id, &request)
	if err == nil {
		connection.RegisterProxy(aID)
	}
	return
}

// Ensure ZxdgExporterV2 implements Proxy.
var _ Proxy = &ZxdgExporterV2{}

// #endregion Interface xdg_foreign_unstable_v2.zxdg_exporter_v2

// ----------------------------------------------------------------------------
// #region Interface xdg_foreign_unstable_v2.zxdg_importer_v2

// ZxdgImporterV2DestroyRequest requests to destroy the xdg_importer object
//
// Notify the compositor that the xdg_importer object will no longer be
// used.
type ZxdgImporterV2DestroyRequest struct {
}

// Opcode returns the request opcode for zxdg_importer_v2.destroy in xdg_foreign_unstable_v2
func (ZxdgImporterV2DestroyRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for zxdg_importer_v2.destroy in xdg_foreign_unstable_v2
func (ZxdgImporterV2DestroyRequest) MessageName() string { return "destroy" }

// Ensure ZxdgImporterV2DestroyRequest implements Message.
var _ Message = ZxdgImporterV2DestroyRequest{}

// Emit emits the message to the emitter.
func (r *ZxdgImporterV2DestroyRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure ZxdgImporterV2DestroyRequest implements Request.
var _ Request = &ZxdgImporterV2DestroyRequest{}

// ZxdgImporterV2ImportToplevelRequest requests to import a toplevel surface
//
// The import_toplevel request imports a surface from any client given a handle
// retrieved by exporting said surface using xdg_exporter.export_toplevel.
// When called, a new xdg_imported object will be created. This new object
// represents the imported surface, and the importing client can
// manipulate its relationship using it. See xdg_imported for details.
type ZxdgImporterV2ImportToplevelRequest struct {
	// ID contains the new xdg_imported object
	ID ObjectID

	// Handle contains the exported surface handle
	Handle string
}

// Opcode returns the request opcode for zxdg_importer_v2.import_toplevel in xdg_foreign_unstable_v2
func (ZxdgImporterV2ImportToplevelRequest) Opcode() uint16 { return 1 }

// MessageName returns the request name for zxdg_importer_v2.import_toplevel in xdg_foreign_unstable_v2
func (ZxdgImporterV2ImportToplevelRequest) MessageName() string { return "import_toplevel" }

// Ensure ZxdgImporterV2ImportToplevelRequest implements Message.
var _ Message = ZxdgImporterV2ImportToplevelRequest{}

// Emit emits the message to the emitter.
func (r *ZxdgImporterV2ImportToplevelRequest) Emit(e *RequestEmitter) error {
	if err := e.PutObjectID(r.ID); err != nil {
		return err
	}
	if err := e.PutString(r.Handle); err != nil {
		return err
	}
	return nil
}

// Ensure ZxdgImporterV2ImportToplevelRequest implements Request.
var _ Request = &ZxdgImporterV2ImportToplevelRequest{}

// ZxdgImporterV2 interface for importing surfaces
//
// A global interface used for importing surfaces exported by xdg_exporter.
// With this interface, a client can create a reference to a surface of
// another client.
type ZxdgImporterV2 struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *ZxdgImporterV2) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (ZxdgImporterV2) Descriptor() *InterfaceDescriptor {
	return &ZxdgImporterV2Descriptor
}

// Dispatch returns an Event object for a given opcode.
func (ZxdgImporterV2) Dispatch(opcode uint16) Event {
	switch opcode {
	default:
		return nil
	}
}

// Destroy requests to destroy the xdg_importer object
//
// Notify the compositor that the xdg_importer object will no longer be
// used.
func (proxy *ZxdgImporterV2) Destroy(connection Connection) (err error) {
	request := ZxdgImporterV2DestroyRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// ImportToplevel requests to import a toplevel surface
//
// The import_toplevel request imports a surface from any client given a handle
// retrieved by exporting said surface using xdg_exporter.export_toplevel.
// When called, a new xdg_imported object will be created. This new object
// represents the imported surface, and the importing client can
// manipulate its relationship using it. See xdg_imported for details.
func (proxy *ZxdgImporterV2) ImportToplevel(connection Connection, aHandle string) (aID *ZxdgImportedV2, err error) {
	aID = &ZxdgImportedV2{connection.NewID()}
	request := ZxdgImporterV2ImportToplevelRequest{
		ID:     aID.id,
		Handle: aHandle,
	}
	err = connection.SendRequest(proxy.id, &request)
	if err == nil {
		connection.RegisterProxy(aID)
	}
	return
}

// Ensure ZxdgImporterV2 implements Proxy.
var _ Proxy = &ZxdgImporterV2{}

// #endregion Interface xdg_foreign_unstable_v2.zxdg_importer_v2

// ----------------------------------------------------------------------------
// #region Interface xdg_foreign_unstable_v2.zxdg_exported_v2

// ZxdgExportedV2DestroyRequest requests to unexport the exported surface
//
// Revoke the previously exported surface. This invalidates any
// relationship the importer may have set up using the xdg_imported created
// given the handle sent via xdg_exported.handle.
type ZxdgExportedV2DestroyRequest struct {
}

// Opcode returns the request opcode for zxdg_exported_v2.destroy in xdg_foreign_unstable_v2
func (ZxdgExportedV2DestroyRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for zxdg_exported_v2.destroy in xdg_foreign_unstable_v2
func (ZxdgExportedV2DestroyRequest) MessageName() string { return "destroy" }

// Ensure ZxdgExportedV2DestroyRequest implements Message.
var _ Message = ZxdgExportedV2DestroyRequest{}

// Emit emits the message to the emitter.
func (r *ZxdgExportedV2DestroyRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure ZxdgExportedV2DestroyRequest implements Request.
var _ Request = &ZxdgExportedV2DestroyRequest{}

// ZxdgExportedV2HandleEvent signals when the exported surface handle
//
// The handle event contains the unique handle of this exported surface
// reference. It may be shared with any client, which then can use it to
// import the surface by calling xdg_importer.import_toplevel. A handle
// may be used to import the surface multiple times.
type ZxdgExportedV2HandleEvent struct {
	// Handle contains the exported surface handle
	Handle string
}

// Opcode returns the event opcode for zxdg_exported_v2.handle in xdg_foreign_unstable_v2
func (ZxdgExportedV2HandleEvent) Opcode() uint16 { return 0 }

// MessageName returns the event name for zxdg_exported_v2.handle in xdg_foreign_unstable_v2
func (ZxdgExportedV2HandleEvent) MessageName() string { return "handle" }

// Ensure ZxdgExportedV2HandleEvent implements Message.
var _ Message = ZxdgExportedV2HandleEvent{}

// Scan scans the event from the socket.
func (e *ZxdgExportedV2HandleEvent) Scan(s *EventScanner) error {
	if v, err := s.String(); err != nil {
		return err
	} else {
		e.Handle = v
	}
	return nil
}

// Ensure ZxdgExportedV2HandleEvent implements Event.
var _ Event = &ZxdgExportedV2HandleEvent{}

// ZxdgExportedV2 an exported surface handle
//
// An xdg_exported object represents an exported reference to a surface. The
// exported surface may be referenced as long as the xdg_exported object not
// destroyed. Destroying the xdg_exported invalidates any relationship the
// importer may have established using xdg_imported.
type ZxdgExportedV2 struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *ZxdgExportedV2) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (ZxdgExportedV2) Descriptor() *InterfaceDescriptor {
	return &ZxdgExportedV2Descriptor
}

// Dispatch returns an Event object for a given opcode.
func (ZxdgExportedV2) Dispatch(opcode uint16) Event {
	switch opcode {
	case 0:
		return &ZxdgExportedV2HandleEvent{}
	default:
		return nil
	}
}

// Destroy requests to unexport the exported surface
//
// Revoke the previously exported surface. This invalidates any
// relationship the importer may have set up using the xdg_imported created
// given the handle sent via xdg_exported.handle.
func (proxy *ZxdgExportedV2) Destroy(connection Connection) (err error) {
	request := ZxdgExportedV2DestroyRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Ensure ZxdgExportedV2 implements Proxy.
var _ Proxy = &ZxdgExportedV2{}

// #endregion Interface xdg_foreign_unstable_v2.zxdg_exported_v2

// ----------------------------------------------------------------------------
// #region Interface xdg_foreign_unstable_v2.zxdg_imported_v2

// ZxdgImportedV2Error represents error values
//
// These errors can be emitted in response to invalid xdg_imported
// requests.
type ZxdgImportedV2Error int

const (
	// ZxdgImportedV2ErrorInvalidSurface corresponds to surface is not an xdg_toplevel
	ZxdgImportedV2ErrorInvalidSurface ZxdgImportedV2Error = 0
)

// ZxdgImportedV2DestroyRequest requests to destroy the xdg_imported object
//
// Notify the compositor that it will no longer use the xdg_imported
// object. Any relationship that may have been set up will at this point
// be invalidated.
type ZxdgImportedV2DestroyRequest struct {
}

// Opcode returns the request opcode for zxdg_imported_v2.destroy in xdg_foreign_unstable_v2
func (ZxdgImportedV2DestroyRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for zxdg_imported_v2.destroy in xdg_foreign_unstable_v2
func (ZxdgImportedV2DestroyRequest) MessageName() string { return "destroy" }

// Ensure ZxdgImportedV2DestroyRequest implements Message.
var _ Message = ZxdgImportedV2DestroyRequest{}

// Emit emits the message to the emitter.
func (r *ZxdgImportedV2DestroyRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure ZxdgImportedV2DestroyRequest implements Request.
var _ Request = &ZxdgImportedV2DestroyRequest{}

// ZxdgImportedV2SetParentOfRequest requests to set as the parent of some surface
//
// Set the imported surface as the parent of some surface of the client.
// The passed surface must be an xdg_toplevel equivalent, otherwise an
// invalid_surface protocol error is sent. Calling this function sets up
// a surface to surface relation with the same stacking and positioning
// semantics as xdg_toplevel.set_parent.
type ZxdgImportedV2SetParentOfRequest struct {
	// Surface contains the child surface
	Surface ObjectID
}

// Opcode returns the request opcode for zxdg_imported_v2.set_parent_of in xdg_foreign_unstable_v2
func (ZxdgImportedV2SetParentOfRequest) Opcode() uint16 { return 1 }

// MessageName returns the request name for zxdg_imported_v2.set_parent_of in xdg_foreign_unstable_v2
func (ZxdgImportedV2SetParentOfRequest) MessageName() string { return "set_parent_of" }

// Ensure ZxdgImportedV2SetParentOfRequest implements Message.
var _ Message = ZxdgImportedV2SetParentOfRequest{}

// Emit emits the message to the emitter.
func (r *ZxdgImportedV2SetParentOfRequest) Emit(e *RequestEmitter) error {
	if err := e.PutObjectID(r.Surface); err != nil {
		return err
	}
	return nil
}

// Ensure ZxdgImportedV2SetParentOfRequest implements Request.
var _ Request = &ZxdgImportedV2SetParentOfRequest{}

// ZxdgImportedV2DestroyedEvent signals when the imported surface handle has been destroyed
//
// The imported surface handle has been destroyed and any relationship set
// up has been invalidated. This may happen for various reasons, for
// example if the exported surface or the exported surface handle has been
// destroyed, if the handle used for importing was invalid.
type ZxdgImportedV2DestroyedEvent struct {
}

// Opcode returns the event opcode for zxdg_imported_v2.destroyed in xdg_foreign_unstable_v2
func (ZxdgImportedV2DestroyedEvent) Opcode() uint16 { return 0 }

// MessageName returns the event name for zxdg_imported_v2.destroyed in xdg_foreign_unstable_v2
func (ZxdgImportedV2DestroyedEvent) MessageName() string { return "destroyed" }

// Ensure ZxdgImportedV2DestroyedEvent implements Message.
var _ Message = ZxdgImportedV2DestroyedEvent{}

// Scan scans the event from the socket.
func (e *ZxdgImportedV2DestroyedEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure ZxdgImportedV2DestroyedEvent implements Event.
var _ Event = &ZxdgImportedV2DestroyedEvent{}

// ZxdgImportedV2 an imported surface handle
//
// An xdg_imported object represents an imported reference to surface exported
// by some client. A client can use this interface to manipulate
// relationships between its own surfaces and the imported surface.
type ZxdgImportedV2 struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *ZxdgImportedV2) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (ZxdgImportedV2) Descriptor() *InterfaceDescriptor {
	return &ZxdgImportedV2Descriptor
}

// Dispatch returns an Event object for a given opcode.
func (ZxdgImportedV2) Dispatch(opcode uint16) Event {
	switch opcode {
	case 0:
		return &ZxdgImportedV2DestroyedEvent{}
	default:
		return nil
	}
}

// Destroy requests to destroy the xdg_imported object
//
// Notify the compositor that it will no longer use the xdg_imported
// object. Any relationship that may have been set up will at this point
// be invalidated.
func (proxy *ZxdgImportedV2) Destroy(connection Connection) (err error) {
	request := ZxdgImportedV2DestroyRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// SetParentOf requests to set as the parent of some surface
//
// Set the imported surface as the parent of some surface of the client.
// The passed surface must be an xdg_toplevel equivalent, otherwise an
// invalid_surface protocol error is sent. Calling this function sets up
// a surface to surface relation with the same stacking and positioning
// semantics as xdg_toplevel.set_parent.
func (proxy *ZxdgImportedV2) SetParentOf(connection Connection, aSurface ObjectID) (err error) {
	request := ZxdgImportedV2SetParentOfRequest{
		Surface: aSurface,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Ensure ZxdgImportedV2 implements Proxy.
var _ Proxy = &ZxdgImportedV2{}

// #endregion Interface xdg_foreign_unstable_v2.zxdg_imported_v2

////////////////////////////////////////////////////////////////////////////////
// #endregion Protocol xdg_foreign_unstable_v2

////////////////////////////////////////////////////////////////////////////////
// #region Protocol xdg_output_unstable_v1

// ----------------------------------------------------------------------------
// #region Interface xdg_output_unstable_v1.zxdg_output_manager_v1

// ZxdgOutputManagerV1DestroyRequest requests to destroy the xdg_output_manager object
//
// Using this request a client can tell the server that it is not
// going to use the xdg_output_manager object anymore.
//
// Any objects already created through this instance are not affected.
type ZxdgOutputManagerV1DestroyRequest struct {
}

// Opcode returns the request opcode for zxdg_output_manager_v1.destroy in xdg_output_unstable_v1
func (ZxdgOutputManagerV1DestroyRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for zxdg_output_manager_v1.destroy in xdg_output_unstable_v1
func (ZxdgOutputManagerV1DestroyRequest) MessageName() string { return "destroy" }

// Ensure ZxdgOutputManagerV1DestroyRequest implements Message.
var _ Message = ZxdgOutputManagerV1DestroyRequest{}

// Emit emits the message to the emitter.
func (r *ZxdgOutputManagerV1DestroyRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure ZxdgOutputManagerV1DestroyRequest implements Request.
var _ Request = &ZxdgOutputManagerV1DestroyRequest{}

// ZxdgOutputManagerV1GetXdgOutputRequest requests to create an xdg output from a wl_output
//
// This creates a new xdg_output object for the given wl_output.
type ZxdgOutputManagerV1GetXdgOutputRequest struct {
	ID ObjectID

	Output ObjectID
}

// Opcode returns the request opcode for zxdg_output_manager_v1.get_xdg_output in xdg_output_unstable_v1
func (ZxdgOutputManagerV1GetXdgOutputRequest) Opcode() uint16 { return 1 }

// MessageName returns the request name for zxdg_output_manager_v1.get_xdg_output in xdg_output_unstable_v1
func (ZxdgOutputManagerV1GetXdgOutputRequest) MessageName() string { return "get_xdg_output" }

// Ensure ZxdgOutputManagerV1GetXdgOutputRequest implements Message.
var _ Message = ZxdgOutputManagerV1GetXdgOutputRequest{}

// Emit emits the message to the emitter.
func (r *ZxdgOutputManagerV1GetXdgOutputRequest) Emit(e *RequestEmitter) error {
	if err := e.PutObjectID(r.ID); err != nil {
		return err
	}
	if err := e.PutObjectID(r.Output); err != nil {
		return err
	}
	return nil
}

// Ensure ZxdgOutputManagerV1GetXdgOutputRequest implements Request.
var _ Request = &ZxdgOutputManagerV1GetXdgOutputRequest{}

// ZxdgOutputManagerV1 manage xdg_output objects
//
// A global factory interface for xdg_output objects.
type ZxdgOutputManagerV1 struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *ZxdgOutputManagerV1) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (ZxdgOutputManagerV1) Descriptor() *InterfaceDescriptor {
	return &ZxdgOutputManagerV1Descriptor
}

// Dispatch returns an Event object for a given opcode.
func (ZxdgOutputManagerV1) Dispatch(opcode uint16) Event {
	switch opcode {
	default:
		return nil
	}
}

// Destroy requests to destroy the xdg_output_manager object
//
// Using this request a client can tell the server that it is not
// going to use the xdg_output_manager object anymore.
//
// Any objects already created through this instance are not affected.
func (proxy *ZxdgOutputManagerV1) Destroy(connection Connection) (err error) {
	request := ZxdgOutputManagerV1DestroyRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// GetXdgOutput requests to create an xdg output from a wl_output
//
// This creates a new xdg_output object for the given wl_output.
func (proxy *ZxdgOutputManagerV1) GetXdgOutput(connection Connection, aOutput ObjectID) (aID *ZxdgOutputV1, err error) {
	aID = &ZxdgOutputV1{connection.NewID()}
	request := ZxdgOutputManagerV1GetXdgOutputRequest{
		ID:     aID.id,
		Output: aOutput,
	}
	err = connection.SendRequest(proxy.id, &request)
	if err == nil {
		connection.RegisterProxy(aID)
	}
	return
}

// Ensure ZxdgOutputManagerV1 implements Proxy.
var _ Proxy = &ZxdgOutputManagerV1{}

// #endregion Interface xdg_output_unstable_v1.zxdg_output_manager_v1

// ----------------------------------------------------------------------------
// #region Interface xdg_output_unstable_v1.zxdg_output_v1

// ZxdgOutputV1DestroyRequest requests to destroy the xdg_output object
//
// Using this request a client can tell the server that it is not
// going to use the xdg_output object anymore.
type ZxdgOutputV1DestroyRequest struct {
}

// Opcode returns the request opcode for zxdg_output_v1.destroy in xdg_output_unstable_v1
func (ZxdgOutputV1DestroyRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for zxdg_output_v1.destroy in xdg_output_unstable_v1
func (ZxdgOutputV1DestroyRequest) MessageName() string { return "destroy" }

// Ensure ZxdgOutputV1DestroyRequest implements Message.
var _ Message = ZxdgOutputV1DestroyRequest{}

// Emit emits the message to the emitter.
func (r *ZxdgOutputV1DestroyRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure ZxdgOutputV1DestroyRequest implements Request.
var _ Request = &ZxdgOutputV1DestroyRequest{}

// ZxdgOutputV1LogicalPositionEvent signals when position of the output within the global compositor space
//
// The position event describes the location of the wl_output within
// the global compositor space.
//
// The logical_position event is sent after creating an xdg_output
// (see xdg_output_manager.get_xdg_output) and whenever the location
// of the output changes within the global compositor space.
type ZxdgOutputV1LogicalPositionEvent struct {
	// X contains x position within the global compositor space
	X int32

	// Y contains y position within the global compositor space
	Y int32
}

// Opcode returns the event opcode for zxdg_output_v1.logical_position in xdg_output_unstable_v1
func (ZxdgOutputV1LogicalPositionEvent) Opcode() uint16 { return 0 }

// MessageName returns the event name for zxdg_output_v1.logical_position in xdg_output_unstable_v1
func (ZxdgOutputV1LogicalPositionEvent) MessageName() string { return "logical_position" }

// Ensure ZxdgOutputV1LogicalPositionEvent implements Message.
var _ Message = ZxdgOutputV1LogicalPositionEvent{}

// Scan scans the event from the socket.
func (e *ZxdgOutputV1LogicalPositionEvent) Scan(s *EventScanner) error {
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.X = v
	}
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.Y = v
	}
	return nil
}

// Ensure ZxdgOutputV1LogicalPositionEvent implements Event.
var _ Event = &ZxdgOutputV1LogicalPositionEvent{}

// ZxdgOutputV1LogicalSizeEvent signals when size of the output in the global compositor space
//
// The logical_size event describes the size of the output in the
// global compositor space.
//
// For example, a surface without any buffer scale, transformation
// nor rotation set, with the size matching the logical_size will
// have the same size as the corresponding output when displayed.
//
// Most regular Wayland clients should not pay attention to the
// logical size and would rather rely on xdg_shell interfaces.
//
// Some clients such as Xwayland, however, need this to configure
// their surfaces in the global compositor space as the compositor
// may apply a different scale from what is advertised by the output
// scaling property (to achieve fractional scaling, for example).
//
// For example, for a wl_output mode 3840×2160 and a scale factor 2:
//
// - A compositor not scaling the surface buffers will advertise a
// logical size of 3840×2160,
//
// - A compositor automatically scaling the surface buffers will
// advertise a logical size of 1920×1080,
//
// - A compositor using a fractional scale of 1.5 will advertise a
// logical size of 2560×1440.
//
// For example, for a wl_output mode 1920×1080 and a 90 degree rotation,
// the compositor will advertise a logical size of 1080x1920.
//
// The logical_size event is sent after creating an xdg_output
// (see xdg_output_manager.get_xdg_output) and whenever the logical
// size of the output changes, either as a result of a change in the
// applied scale or because of a change in the corresponding output
// mode(see wl_output.mode) or transform (see wl_output.transform).
type ZxdgOutputV1LogicalSizeEvent struct {
	// Width contains width in global compositor space
	Width int32

	// Height contains height in global compositor space
	Height int32
}

// Opcode returns the event opcode for zxdg_output_v1.logical_size in xdg_output_unstable_v1
func (ZxdgOutputV1LogicalSizeEvent) Opcode() uint16 { return 1 }

// MessageName returns the event name for zxdg_output_v1.logical_size in xdg_output_unstable_v1
func (ZxdgOutputV1LogicalSizeEvent) MessageName() string { return "logical_size" }

// Ensure ZxdgOutputV1LogicalSizeEvent implements Message.
var _ Message = ZxdgOutputV1LogicalSizeEvent{}

// Scan scans the event from the socket.
func (e *ZxdgOutputV1LogicalSizeEvent) Scan(s *EventScanner) error {
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.Width = v
	}
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.Height = v
	}
	return nil
}

// Ensure ZxdgOutputV1LogicalSizeEvent implements Event.
var _ Event = &ZxdgOutputV1LogicalSizeEvent{}

// ZxdgOutputV1DoneEvent signals when all information about the output have been sent
//
// This event is sent after all other properties of an xdg_output
// have been sent.
//
// This allows changes to the xdg_output properties to be seen as
// atomic, even if they happen via multiple events.
//
// For objects version 3 onwards, this event is deprecated. Compositors
// are not required to send it anymore and must send wl_output.done
// instead.
type ZxdgOutputV1DoneEvent struct {
}

// Opcode returns the event opcode for zxdg_output_v1.done in xdg_output_unstable_v1
func (ZxdgOutputV1DoneEvent) Opcode() uint16 { return 2 }

// MessageName returns the event name for zxdg_output_v1.done in xdg_output_unstable_v1
func (ZxdgOutputV1DoneEvent) MessageName() string { return "done" }

// Ensure ZxdgOutputV1DoneEvent implements Message.
var _ Message = ZxdgOutputV1DoneEvent{}

// Scan scans the event from the socket.
func (e *ZxdgOutputV1DoneEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure ZxdgOutputV1DoneEvent implements Event.
var _ Event = &ZxdgOutputV1DoneEvent{}

// ZxdgOutputV1NameEvent signals when name of this output
//
// Many compositors will assign names to their outputs, show them to the
// user, allow them to be configured by name, etc. The client may wish to
// know this name as well to offer the user similar behaviors.
//
// The naming convention is compositor defined, but limited to
// alphanumeric characters and dashes (-). Each name is unique among all
// wl_output globals, but if a wl_output global is destroyed the same name
// may be reused later. The names will also remain consistent across
// sessions with the same hardware and software configuration.
//
// Examples of names include 'HDMI-A-1', 'WL-1', 'X11-1', etc. However, do
// not assume that the name is a reflection of an underlying DRM
// connector, X11 connection, etc.
//
// The name event is sent after creating an xdg_output (see
// xdg_output_manager.get_xdg_output). This event is only sent once per
// xdg_output, and the name does not change over the lifetime of the
// wl_output global.
type ZxdgOutputV1NameEvent struct {
	// Name contains output name
	Name string
}

// Opcode returns the event opcode for zxdg_output_v1.name in xdg_output_unstable_v1
func (ZxdgOutputV1NameEvent) Opcode() uint16 { return 3 }

// MessageName returns the event name for zxdg_output_v1.name in xdg_output_unstable_v1
func (ZxdgOutputV1NameEvent) MessageName() string { return "name" }

// Ensure ZxdgOutputV1NameEvent implements Message.
var _ Message = ZxdgOutputV1NameEvent{}

// Scan scans the event from the socket.
func (e *ZxdgOutputV1NameEvent) Scan(s *EventScanner) error {
	if v, err := s.String(); err != nil {
		return err
	} else {
		e.Name = v
	}
	return nil
}

// Ensure ZxdgOutputV1NameEvent implements Event.
var _ Event = &ZxdgOutputV1NameEvent{}

// ZxdgOutputV1DescriptionEvent signals when human-readable description of this output
//
// Many compositors can produce human-readable descriptions of their
// outputs.  The client may wish to know this description as well, to
// communicate the user for various purposes.
//
// The description is a UTF-8 string with no convention defined for its
// contents. Examples might include 'Foocorp 11" Display' or 'Virtual X11
// output via :1'.
//
// The description event is sent after creating an xdg_output (see
// xdg_output_manager.get_xdg_output) and whenever the description
// changes. The description is optional, and may not be sent at all.
//
// For objects of version 2 and lower, this event is only sent once per
// xdg_output, and the description does not change over the lifetime of
// the wl_output global.
type ZxdgOutputV1DescriptionEvent struct {
	// Description contains output description
	Description string
}

// Opcode returns the event opcode for zxdg_output_v1.description in xdg_output_unstable_v1
func (ZxdgOutputV1DescriptionEvent) Opcode() uint16 { return 4 }

// MessageName returns the event name for zxdg_output_v1.description in xdg_output_unstable_v1
func (ZxdgOutputV1DescriptionEvent) MessageName() string { return "description" }

// Ensure ZxdgOutputV1DescriptionEvent implements Message.
var _ Message = ZxdgOutputV1DescriptionEvent{}

// Scan scans the event from the socket.
func (e *ZxdgOutputV1DescriptionEvent) Scan(s *EventScanner) error {
	if v, err := s.String(); err != nil {
		return err
	} else {
		e.Description = v
	}
	return nil
}

// Ensure ZxdgOutputV1DescriptionEvent implements Event.
var _ Event = &ZxdgOutputV1DescriptionEvent{}

// ZxdgOutputV1 compositor logical output region
//
// An xdg_output describes part of the compositor geometry.
//
// This typically corresponds to a monitor that displays part of the
// compositor space.
//
// For objects version 3 onwards, after all xdg_output properties have been
// sent (when the object is created and when properties are updated), a
// wl_output.done event is sent. This allows changes to the output
// properties to be seen as atomic, even if they happen via multiple events.
type ZxdgOutputV1 struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *ZxdgOutputV1) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (ZxdgOutputV1) Descriptor() *InterfaceDescriptor {
	return &ZxdgOutputV1Descriptor
}

// Dispatch returns an Event object for a given opcode.
func (ZxdgOutputV1) Dispatch(opcode uint16) Event {
	switch opcode {
	case 0:
		return &ZxdgOutputV1LogicalPositionEvent{}
	case 1:
		return &ZxdgOutputV1LogicalSizeEvent{}
	case 2:
		return &ZxdgOutputV1DoneEvent{}
	case 3:
		return &ZxdgOutputV1NameEvent{}
	case 4:
		return &ZxdgOutputV1DescriptionEvent{}
	default:
		return nil
	}
}

// Destroy requests to destroy the xdg_output object
//
// Using this request a client can tell the server that it is not
// going to use the xdg_output object anymore.
func (proxy *ZxdgOutputV1) Destroy(connection Connection) (err error) {
	request := ZxdgOutputV1DestroyRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Ensure ZxdgOutputV1 implements Proxy.
var _ Proxy = &ZxdgOutputV1{}

// #endregion Interface xdg_output_unstable_v1.zxdg_output_v1

////////////////////////////////////////////////////////////////////////////////
// #endregion Protocol xdg_output_unstable_v1

////////////////////////////////////////////////////////////////////////////////
// #region Protocol xdg_shell

// ----------------------------------------------------------------------------
// #region Interface xdg_shell.xdg_wm_base

type XdgWmBaseError int

const (
	// XdgWmBaseErrorRole corresponds to given wl_surface has another role
	XdgWmBaseErrorRole XdgWmBaseError = 0

	// XdgWmBaseErrorDefunctSurfaces corresponds to xdg_wm_base was destroyed before children
	XdgWmBaseErrorDefunctSurfaces XdgWmBaseError = 1

	// XdgWmBaseErrorNotTheTopmostPopup corresponds to the client tried to map or destroy a non-topmost popup
	XdgWmBaseErrorNotTheTopmostPopup XdgWmBaseError = 2

	// XdgWmBaseErrorInvalidPopupParent corresponds to the client specified an invalid popup parent surface
	XdgWmBaseErrorInvalidPopupParent XdgWmBaseError = 3

	// XdgWmBaseErrorInvalidSurfaceState corresponds to the client provided an invalid surface state
	XdgWmBaseErrorInvalidSurfaceState XdgWmBaseError = 4

	// XdgWmBaseErrorInvalidPositioner corresponds to the client provided an invalid positioner
	XdgWmBaseErrorInvalidPositioner XdgWmBaseError = 5
)

// XdgWmBaseDestroyRequest requests to destroy xdg_wm_base
//
// Destroy this xdg_wm_base object.
//
// Destroying a bound xdg_wm_base object while there are surfaces
// still alive created by this xdg_wm_base object instance is illegal
// and will result in a protocol error.
type XdgWmBaseDestroyRequest struct {
}

// Opcode returns the request opcode for xdg_wm_base.destroy in xdg_shell
func (XdgWmBaseDestroyRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for xdg_wm_base.destroy in xdg_shell
func (XdgWmBaseDestroyRequest) MessageName() string { return "destroy" }

// Ensure XdgWmBaseDestroyRequest implements Message.
var _ Message = XdgWmBaseDestroyRequest{}

// Emit emits the message to the emitter.
func (r *XdgWmBaseDestroyRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure XdgWmBaseDestroyRequest implements Request.
var _ Request = &XdgWmBaseDestroyRequest{}

// XdgWmBaseCreatePositionerRequest requests to create a positioner object
//
// Create a positioner object. A positioner object is used to position
// surfaces relative to some parent surface. See the interface description
// and xdg_surface.get_popup for details.
type XdgWmBaseCreatePositionerRequest struct {
	ID ObjectID
}

// Opcode returns the request opcode for xdg_wm_base.create_positioner in xdg_shell
func (XdgWmBaseCreatePositionerRequest) Opcode() uint16 { return 1 }

// MessageName returns the request name for xdg_wm_base.create_positioner in xdg_shell
func (XdgWmBaseCreatePositionerRequest) MessageName() string { return "create_positioner" }

// Ensure XdgWmBaseCreatePositionerRequest implements Message.
var _ Message = XdgWmBaseCreatePositionerRequest{}

// Emit emits the message to the emitter.
func (r *XdgWmBaseCreatePositionerRequest) Emit(e *RequestEmitter) error {
	if err := e.PutObjectID(r.ID); err != nil {
		return err
	}
	return nil
}

// Ensure XdgWmBaseCreatePositionerRequest implements Request.
var _ Request = &XdgWmBaseCreatePositionerRequest{}

// XdgWmBaseGetXdgSurfaceRequest requests to create a shell surface from a surface
//
// This creates an xdg_surface for the given surface. While xdg_surface
// itself is not a role, the corresponding surface may only be assigned
// a role extending xdg_surface, such as xdg_toplevel or xdg_popup. It is
// illegal to create an xdg_surface for a wl_surface which already has an
// assigned role and this will result in a protocol error.
//
// This creates an xdg_surface for the given surface. An xdg_surface is
// used as basis to define a role to a given surface, such as xdg_toplevel
// or xdg_popup. It also manages functionality shared between xdg_surface
// based surface roles.
//
// See the documentation of xdg_surface for more details about what an
// xdg_surface is and how it is used.
type XdgWmBaseGetXdgSurfaceRequest struct {
	ID ObjectID

	Surface ObjectID
}

// Opcode returns the request opcode for xdg_wm_base.get_xdg_surface in xdg_shell
func (XdgWmBaseGetXdgSurfaceRequest) Opcode() uint16 { return 2 }

// MessageName returns the request name for xdg_wm_base.get_xdg_surface in xdg_shell
func (XdgWmBaseGetXdgSurfaceRequest) MessageName() string { return "get_xdg_surface" }

// Ensure XdgWmBaseGetXdgSurfaceRequest implements Message.
var _ Message = XdgWmBaseGetXdgSurfaceRequest{}

// Emit emits the message to the emitter.
func (r *XdgWmBaseGetXdgSurfaceRequest) Emit(e *RequestEmitter) error {
	if err := e.PutObjectID(r.ID); err != nil {
		return err
	}
	if err := e.PutObjectID(r.Surface); err != nil {
		return err
	}
	return nil
}

// Ensure XdgWmBaseGetXdgSurfaceRequest implements Request.
var _ Request = &XdgWmBaseGetXdgSurfaceRequest{}

// XdgWmBasePongRequest requests to respond to a ping event
//
// A client must respond to a ping event with a pong request or
// the client may be deemed unresponsive. See xdg_wm_base.ping.
type XdgWmBasePongRequest struct {
	// Serial contains serial of the ping event
	Serial uint32
}

// Opcode returns the request opcode for xdg_wm_base.pong in xdg_shell
func (XdgWmBasePongRequest) Opcode() uint16 { return 3 }

// MessageName returns the request name for xdg_wm_base.pong in xdg_shell
func (XdgWmBasePongRequest) MessageName() string { return "pong" }

// Ensure XdgWmBasePongRequest implements Message.
var _ Message = XdgWmBasePongRequest{}

// Emit emits the message to the emitter.
func (r *XdgWmBasePongRequest) Emit(e *RequestEmitter) error {
	if err := e.PutUint(r.Serial); err != nil {
		return err
	}
	return nil
}

// Ensure XdgWmBasePongRequest implements Request.
var _ Request = &XdgWmBasePongRequest{}

// XdgWmBasePingEvent signals when check if the client is alive
//
// The ping event asks the client if it's still alive. Pass the
// serial specified in the event back to the compositor by sending
// a "pong" request back with the specified serial. See xdg_wm_base.pong.
//
// Compositors can use this to determine if the client is still
// alive. It's unspecified what will happen if the client doesn't
// respond to the ping request, or in what timeframe. Clients should
// try to respond in a reasonable amount of time.
//
// A compositor is free to ping in any way it wants, but a client must
// always respond to any xdg_wm_base object it created.
type XdgWmBasePingEvent struct {
	// Serial contains pass this to the pong request
	Serial uint32
}

// Opcode returns the event opcode for xdg_wm_base.ping in xdg_shell
func (XdgWmBasePingEvent) Opcode() uint16 { return 0 }

// MessageName returns the event name for xdg_wm_base.ping in xdg_shell
func (XdgWmBasePingEvent) MessageName() string { return "ping" }

// Ensure XdgWmBasePingEvent implements Message.
var _ Message = XdgWmBasePingEvent{}

// Scan scans the event from the socket.
func (e *XdgWmBasePingEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Serial = v
	}
	return nil
}

// Ensure XdgWmBasePingEvent implements Event.
var _ Event = &XdgWmBasePingEvent{}

// XdgWmBase create desktop-style surfaces
//
// The xdg_wm_base interface is exposed as a global object enabling clients
// to turn their wl_surfaces into windows in a desktop environment. It
// defines the basic functionality needed for clients and the compositor to
// create windows that can be dragged, resized, maximized, etc, as well as
// creating transient windows such as popup menus.
type XdgWmBase struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *XdgWmBase) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (XdgWmBase) Descriptor() *InterfaceDescriptor {
	return &XdgWmBaseDescriptor
}

// Dispatch returns an Event object for a given opcode.
func (XdgWmBase) Dispatch(opcode uint16) Event {
	switch opcode {
	case 0:
		return &XdgWmBasePingEvent{}
	default:
		return nil
	}
}

// Destroy requests to destroy xdg_wm_base
//
// Destroy this xdg_wm_base object.
//
// Destroying a bound xdg_wm_base object while there are surfaces
// still alive created by this xdg_wm_base object instance is illegal
// and will result in a protocol error.
func (proxy *XdgWmBase) Destroy(connection Connection) (err error) {
	request := XdgWmBaseDestroyRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// CreatePositioner requests to create a positioner object
//
// Create a positioner object. A positioner object is used to position
// surfaces relative to some parent surface. See the interface description
// and xdg_surface.get_popup for details.
func (proxy *XdgWmBase) CreatePositioner(connection Connection) (aID *XdgPositioner, err error) {
	aID = &XdgPositioner{connection.NewID()}
	request := XdgWmBaseCreatePositionerRequest{
		ID: aID.id,
	}
	err = connection.SendRequest(proxy.id, &request)
	if err == nil {
		connection.RegisterProxy(aID)
	}
	return
}

// GetXdgSurface requests to create a shell surface from a surface
//
// This creates an xdg_surface for the given surface. While xdg_surface
// itself is not a role, the corresponding surface may only be assigned
// a role extending xdg_surface, such as xdg_toplevel or xdg_popup. It is
// illegal to create an xdg_surface for a wl_surface which already has an
// assigned role and this will result in a protocol error.
//
// This creates an xdg_surface for the given surface. An xdg_surface is
// used as basis to define a role to a given surface, such as xdg_toplevel
// or xdg_popup. It also manages functionality shared between xdg_surface
// based surface roles.
//
// See the documentation of xdg_surface for more details about what an
// xdg_surface is and how it is used.
func (proxy *XdgWmBase) GetXdgSurface(connection Connection, aSurface ObjectID) (aID *XdgSurface, err error) {
	aID = &XdgSurface{connection.NewID()}
	request := XdgWmBaseGetXdgSurfaceRequest{
		ID:      aID.id,
		Surface: aSurface,
	}
	err = connection.SendRequest(proxy.id, &request)
	if err == nil {
		connection.RegisterProxy(aID)
	}
	return
}

// Pong requests to respond to a ping event
//
// A client must respond to a ping event with a pong request or
// the client may be deemed unresponsive. See xdg_wm_base.ping.
func (proxy *XdgWmBase) Pong(connection Connection, aSerial uint32) (err error) {
	request := XdgWmBasePongRequest{
		Serial: aSerial,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Ensure XdgWmBase implements Proxy.
var _ Proxy = &XdgWmBase{}

// #endregion Interface xdg_shell.xdg_wm_base

// ----------------------------------------------------------------------------
// #region Interface xdg_shell.xdg_positioner

type XdgPositionerError int

const (
	// XdgPositionerErrorInvalidInput corresponds to invalid input provided
	XdgPositionerErrorInvalidInput XdgPositionerError = 0
)

type XdgPositionerAnchor int

const (
	XdgPositionerAnchorNone XdgPositionerAnchor = 0

	XdgPositionerAnchorTop XdgPositionerAnchor = 1

	XdgPositionerAnchorBottom XdgPositionerAnchor = 2

	XdgPositionerAnchorLeft XdgPositionerAnchor = 3

	XdgPositionerAnchorRight XdgPositionerAnchor = 4

	XdgPositionerAnchorTopLeft XdgPositionerAnchor = 5

	XdgPositionerAnchorBottomLeft XdgPositionerAnchor = 6

	XdgPositionerAnchorTopRight XdgPositionerAnchor = 7

	XdgPositionerAnchorBottomRight XdgPositionerAnchor = 8
)

type XdgPositionerGravity int

const (
	XdgPositionerGravityNone XdgPositionerGravity = 0

	XdgPositionerGravityTop XdgPositionerGravity = 1

	XdgPositionerGravityBottom XdgPositionerGravity = 2

	XdgPositionerGravityLeft XdgPositionerGravity = 3

	XdgPositionerGravityRight XdgPositionerGravity = 4

	XdgPositionerGravityTopLeft XdgPositionerGravity = 5

	XdgPositionerGravityBottomLeft XdgPositionerGravity = 6

	XdgPositionerGravityTopRight XdgPositionerGravity = 7

	XdgPositionerGravityBottomRight XdgPositionerGravity = 8
)

// XdgPositionerConstraintAdjustment represents constraint adjustments
//
// The constraint adjustment value define ways the compositor will adjust
// the position of the surface, if the unadjusted position would result
// in the surface being partly constrained.
//
// Whether a surface is considered 'constrained' is left to the compositor
// to determine. For example, the surface may be partly outside the
// compositor's defined 'work area', thus necessitating the child surface's
// position be adjusted until it is entirely inside the work area.
//
// The adjustments can be combined, according to a defined precedence: 1)
// Flip, 2) Slide, 3) Resize.
type XdgPositionerConstraintAdjustment uint

const (
	XdgPositionerConstraintAdjustmentNone XdgPositionerConstraintAdjustment = 0

	XdgPositionerConstraintAdjustmentSlideX XdgPositionerConstraintAdjustment = 1

	XdgPositionerConstraintAdjustmentSlideY XdgPositionerConstraintAdjustment = 2

	XdgPositionerConstraintAdjustmentFlipX XdgPositionerConstraintAdjustment = 4

	XdgPositionerConstraintAdjustmentFlipY XdgPositionerConstraintAdjustment = 8

	XdgPositionerConstraintAdjustmentResizeX XdgPositionerConstraintAdjustment = 16

	XdgPositionerConstraintAdjustmentResizeY XdgPositionerConstraintAdjustment = 32
)

// XdgPositionerDestroyRequest requests to destroy the xdg_positioner object
//
// Notify the compositor that the xdg_positioner will no longer be used.
type XdgPositionerDestroyRequest struct {
}

// Opcode returns the request opcode for xdg_positioner.destroy in xdg_shell
func (XdgPositionerDestroyRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for xdg_positioner.destroy in xdg_shell
func (XdgPositionerDestroyRequest) MessageName() string { return "destroy" }

// Ensure XdgPositionerDestroyRequest implements Message.
var _ Message = XdgPositionerDestroyRequest{}

// Emit emits the message to the emitter.
func (r *XdgPositionerDestroyRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure XdgPositionerDestroyRequest implements Request.
var _ Request = &XdgPositionerDestroyRequest{}

// XdgPositionerSetSizeRequest requests to set the size of the to-be positioned rectangle
//
// Set the size of the surface that is to be positioned with the positioner
// object. The size is in surface-local coordinates and corresponds to the
// window geometry. See xdg_surface.set_window_geometry.
//
// If a zero or negative size is set the invalid_input error is raised.
type XdgPositionerSetSizeRequest struct {
	// Width contains width of positioned rectangle
	Width int32

	// Height contains height of positioned rectangle
	Height int32
}

// Opcode returns the request opcode for xdg_positioner.set_size in xdg_shell
func (XdgPositionerSetSizeRequest) Opcode() uint16 { return 1 }

// MessageName returns the request name for xdg_positioner.set_size in xdg_shell
func (XdgPositionerSetSizeRequest) MessageName() string { return "set_size" }

// Ensure XdgPositionerSetSizeRequest implements Message.
var _ Message = XdgPositionerSetSizeRequest{}

// Emit emits the message to the emitter.
func (r *XdgPositionerSetSizeRequest) Emit(e *RequestEmitter) error {
	if err := e.PutInt(r.Width); err != nil {
		return err
	}
	if err := e.PutInt(r.Height); err != nil {
		return err
	}
	return nil
}

// Ensure XdgPositionerSetSizeRequest implements Request.
var _ Request = &XdgPositionerSetSizeRequest{}

// XdgPositionerSetAnchorRectRequest requests to set the anchor rectangle within the parent surface
//
// Specify the anchor rectangle within the parent surface that the child
// surface will be placed relative to. The rectangle is relative to the
// window geometry as defined by xdg_surface.set_window_geometry of the
// parent surface.
//
// When the xdg_positioner object is used to position a child surface, the
// anchor rectangle may not extend outside the window geometry of the
// positioned child's parent surface.
//
// If a negative size is set the invalid_input error is raised.
type XdgPositionerSetAnchorRectRequest struct {
	// X contains x position of anchor rectangle
	X int32

	// Y contains y position of anchor rectangle
	Y int32

	// Width contains width of anchor rectangle
	Width int32

	// Height contains height of anchor rectangle
	Height int32
}

// Opcode returns the request opcode for xdg_positioner.set_anchor_rect in xdg_shell
func (XdgPositionerSetAnchorRectRequest) Opcode() uint16 { return 2 }

// MessageName returns the request name for xdg_positioner.set_anchor_rect in xdg_shell
func (XdgPositionerSetAnchorRectRequest) MessageName() string { return "set_anchor_rect" }

// Ensure XdgPositionerSetAnchorRectRequest implements Message.
var _ Message = XdgPositionerSetAnchorRectRequest{}

// Emit emits the message to the emitter.
func (r *XdgPositionerSetAnchorRectRequest) Emit(e *RequestEmitter) error {
	if err := e.PutInt(r.X); err != nil {
		return err
	}
	if err := e.PutInt(r.Y); err != nil {
		return err
	}
	if err := e.PutInt(r.Width); err != nil {
		return err
	}
	if err := e.PutInt(r.Height); err != nil {
		return err
	}
	return nil
}

// Ensure XdgPositionerSetAnchorRectRequest implements Request.
var _ Request = &XdgPositionerSetAnchorRectRequest{}

// XdgPositionerSetAnchorRequest requests to set anchor rectangle anchor
//
// Defines the anchor point for the anchor rectangle. The specified anchor
// is used derive an anchor point that the child surface will be
// positioned relative to. If a corner anchor is set (e.g. 'top_left' or
// 'bottom_right'), the anchor point will be at the specified corner;
// otherwise, the derived anchor point will be centered on the specified
// edge, or in the center of the anchor rectangle if no edge is specified.
type XdgPositionerSetAnchorRequest struct {
	// Anchor contains anchor
	Anchor uint32
}

// Opcode returns the request opcode for xdg_positioner.set_anchor in xdg_shell
func (XdgPositionerSetAnchorRequest) Opcode() uint16 { return 3 }

// MessageName returns the request name for xdg_positioner.set_anchor in xdg_shell
func (XdgPositionerSetAnchorRequest) MessageName() string { return "set_anchor" }

// Ensure XdgPositionerSetAnchorRequest implements Message.
var _ Message = XdgPositionerSetAnchorRequest{}

// Emit emits the message to the emitter.
func (r *XdgPositionerSetAnchorRequest) Emit(e *RequestEmitter) error {
	if err := e.PutUint(r.Anchor); err != nil {
		return err
	}
	return nil
}

// Ensure XdgPositionerSetAnchorRequest implements Request.
var _ Request = &XdgPositionerSetAnchorRequest{}

// XdgPositionerSetGravityRequest requests to set child surface gravity
//
// Defines in what direction a surface should be positioned, relative to
// the anchor point of the parent surface. If a corner gravity is
// specified (e.g. 'bottom_right' or 'top_left'), then the child surface
// will be placed towards the specified gravity; otherwise, the child
// surface will be centered over the anchor point on any axis that had no
// gravity specified.
type XdgPositionerSetGravityRequest struct {
	// Gravity contains gravity direction
	Gravity uint32
}

// Opcode returns the request opcode for xdg_positioner.set_gravity in xdg_shell
func (XdgPositionerSetGravityRequest) Opcode() uint16 { return 4 }

// MessageName returns the request name for xdg_positioner.set_gravity in xdg_shell
func (XdgPositionerSetGravityRequest) MessageName() string { return "set_gravity" }

// Ensure XdgPositionerSetGravityRequest implements Message.
var _ Message = XdgPositionerSetGravityRequest{}

// Emit emits the message to the emitter.
func (r *XdgPositionerSetGravityRequest) Emit(e *RequestEmitter) error {
	if err := e.PutUint(r.Gravity); err != nil {
		return err
	}
	return nil
}

// Ensure XdgPositionerSetGravityRequest implements Request.
var _ Request = &XdgPositionerSetGravityRequest{}

// XdgPositionerSetConstraintAdjustmentRequest requests to set the adjustment to be done when constrained
//
// Specify how the window should be positioned if the originally intended
// position caused the surface to be constrained, meaning at least
// partially outside positioning boundaries set by the compositor. The
// adjustment is set by constructing a bitmask describing the adjustment to
// be made when the surface is constrained on that axis.
//
// If no bit for one axis is set, the compositor will assume that the child
// surface should not change its position on that axis when constrained.
//
// If more than one bit for one axis is set, the order of how adjustments
// are applied is specified in the corresponding adjustment descriptions.
//
// The default adjustment is none.
type XdgPositionerSetConstraintAdjustmentRequest struct {
	// ConstraintAdjustment contains bit mask of constraint adjustments
	ConstraintAdjustment uint32
}

// Opcode returns the request opcode for xdg_positioner.set_constraint_adjustment in xdg_shell
func (XdgPositionerSetConstraintAdjustmentRequest) Opcode() uint16 { return 5 }

// MessageName returns the request name for xdg_positioner.set_constraint_adjustment in xdg_shell
func (XdgPositionerSetConstraintAdjustmentRequest) MessageName() string {
	return "set_constraint_adjustment"
}

// Ensure XdgPositionerSetConstraintAdjustmentRequest implements Message.
var _ Message = XdgPositionerSetConstraintAdjustmentRequest{}

// Emit emits the message to the emitter.
func (r *XdgPositionerSetConstraintAdjustmentRequest) Emit(e *RequestEmitter) error {
	if err := e.PutUint(r.ConstraintAdjustment); err != nil {
		return err
	}
	return nil
}

// Ensure XdgPositionerSetConstraintAdjustmentRequest implements Request.
var _ Request = &XdgPositionerSetConstraintAdjustmentRequest{}

// XdgPositionerSetOffsetRequest requests to set surface position offset
//
// Specify the surface position offset relative to the position of the
// anchor on the anchor rectangle and the anchor on the surface. For
// example if the anchor of the anchor rectangle is at (x, y), the surface
// has the gravity bottom|right, and the offset is (ox, oy), the calculated
// surface position will be (x + ox, y + oy). The offset position of the
// surface is the one used for constraint testing. See
// set_constraint_adjustment.
//
// An example use case is placing a popup menu on top of a user interface
// element, while aligning the user interface element of the parent surface
// with some user interface element placed somewhere in the popup surface.
type XdgPositionerSetOffsetRequest struct {
	// X contains surface position x offset
	X int32

	// Y contains surface position y offset
	Y int32
}

// Opcode returns the request opcode for xdg_positioner.set_offset in xdg_shell
func (XdgPositionerSetOffsetRequest) Opcode() uint16 { return 6 }

// MessageName returns the request name for xdg_positioner.set_offset in xdg_shell
func (XdgPositionerSetOffsetRequest) MessageName() string { return "set_offset" }

// Ensure XdgPositionerSetOffsetRequest implements Message.
var _ Message = XdgPositionerSetOffsetRequest{}

// Emit emits the message to the emitter.
func (r *XdgPositionerSetOffsetRequest) Emit(e *RequestEmitter) error {
	if err := e.PutInt(r.X); err != nil {
		return err
	}
	if err := e.PutInt(r.Y); err != nil {
		return err
	}
	return nil
}

// Ensure XdgPositionerSetOffsetRequest implements Request.
var _ Request = &XdgPositionerSetOffsetRequest{}

// XdgPositionerSetReactiveRequest requests to continuously reconstrain the surface
//
// When set reactive, the surface is reconstrained if the conditions used
// for constraining changed, e.g. the parent window moved.
//
// If the conditions changed and the popup was reconstrained, an
// xdg_popup.configure event is sent with updated geometry, followed by an
// xdg_surface.configure event.
type XdgPositionerSetReactiveRequest struct {
}

// Opcode returns the request opcode for xdg_positioner.set_reactive in xdg_shell
func (XdgPositionerSetReactiveRequest) Opcode() uint16 { return 7 }

// MessageName returns the request name for xdg_positioner.set_reactive in xdg_shell
func (XdgPositionerSetReactiveRequest) MessageName() string { return "set_reactive" }

// Ensure XdgPositionerSetReactiveRequest implements Message.
var _ Message = XdgPositionerSetReactiveRequest{}

// Emit emits the message to the emitter.
func (r *XdgPositionerSetReactiveRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure XdgPositionerSetReactiveRequest implements Request.
var _ Request = &XdgPositionerSetReactiveRequest{}

type XdgPositionerSetParentSizeRequest struct {
	// ParentWidth contains future window geometry width of parent
	ParentWidth int32

	// ParentHeight contains future window geometry height of parent
	ParentHeight int32
}

// Opcode returns the request opcode for xdg_positioner.set_parent_size in xdg_shell
func (XdgPositionerSetParentSizeRequest) Opcode() uint16 { return 8 }

// MessageName returns the request name for xdg_positioner.set_parent_size in xdg_shell
func (XdgPositionerSetParentSizeRequest) MessageName() string { return "set_parent_size" }

// Ensure XdgPositionerSetParentSizeRequest implements Message.
var _ Message = XdgPositionerSetParentSizeRequest{}

// Emit emits the message to the emitter.
func (r *XdgPositionerSetParentSizeRequest) Emit(e *RequestEmitter) error {
	if err := e.PutInt(r.ParentWidth); err != nil {
		return err
	}
	if err := e.PutInt(r.ParentHeight); err != nil {
		return err
	}
	return nil
}

// Ensure XdgPositionerSetParentSizeRequest implements Request.
var _ Request = &XdgPositionerSetParentSizeRequest{}

// XdgPositionerSetParentConfigureRequest requests to set parent configure this is a response to
//
// Set the serial of an xdg_surface.configure event this positioner will be
// used in response to. The compositor may use this information together
// with set_parent_size to determine what future state the popup should be
// constrained using.
type XdgPositionerSetParentConfigureRequest struct {
	// Serial contains serial of parent configure event
	Serial uint32
}

// Opcode returns the request opcode for xdg_positioner.set_parent_configure in xdg_shell
func (XdgPositionerSetParentConfigureRequest) Opcode() uint16 { return 9 }

// MessageName returns the request name for xdg_positioner.set_parent_configure in xdg_shell
func (XdgPositionerSetParentConfigureRequest) MessageName() string { return "set_parent_configure" }

// Ensure XdgPositionerSetParentConfigureRequest implements Message.
var _ Message = XdgPositionerSetParentConfigureRequest{}

// Emit emits the message to the emitter.
func (r *XdgPositionerSetParentConfigureRequest) Emit(e *RequestEmitter) error {
	if err := e.PutUint(r.Serial); err != nil {
		return err
	}
	return nil
}

// Ensure XdgPositionerSetParentConfigureRequest implements Request.
var _ Request = &XdgPositionerSetParentConfigureRequest{}

// XdgPositioner child surface positioner
//
// The xdg_positioner provides a collection of rules for the placement of a
// child surface relative to a parent surface. Rules can be defined to ensure
// the child surface remains within the visible area's borders, and to
// specify how the child surface changes its position, such as sliding along
// an axis, or flipping around a rectangle. These positioner-created rules are
// constrained by the requirement that a child surface must intersect with or
// be at least partially adjacent to its parent surface.
//
// See the various requests for details about possible rules.
//
// At the time of the request, the compositor makes a copy of the rules
// specified by the xdg_positioner. Thus, after the request is complete the
// xdg_positioner object can be destroyed or reused; further changes to the
// object will have no effect on previous usages.
//
// For an xdg_positioner object to be considered complete, it must have a
// non-zero size set by set_size, and a non-zero anchor rectangle set by
// set_anchor_rect. Passing an incomplete xdg_positioner object when
// positioning a surface raises an error.
type XdgPositioner struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *XdgPositioner) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (XdgPositioner) Descriptor() *InterfaceDescriptor {
	return &XdgPositionerDescriptor
}

// Dispatch returns an Event object for a given opcode.
func (XdgPositioner) Dispatch(opcode uint16) Event {
	switch opcode {
	default:
		return nil
	}
}

// Destroy requests to destroy the xdg_positioner object
//
// Notify the compositor that the xdg_positioner will no longer be used.
func (proxy *XdgPositioner) Destroy(connection Connection) (err error) {
	request := XdgPositionerDestroyRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// SetSize requests to set the size of the to-be positioned rectangle
//
// Set the size of the surface that is to be positioned with the positioner
// object. The size is in surface-local coordinates and corresponds to the
// window geometry. See xdg_surface.set_window_geometry.
//
// If a zero or negative size is set the invalid_input error is raised.
func (proxy *XdgPositioner) SetSize(connection Connection, aWidth int32, aHeight int32) (err error) {
	request := XdgPositionerSetSizeRequest{
		Width:  aWidth,
		Height: aHeight,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// SetAnchorRect requests to set the anchor rectangle within the parent surface
//
// Specify the anchor rectangle within the parent surface that the child
// surface will be placed relative to. The rectangle is relative to the
// window geometry as defined by xdg_surface.set_window_geometry of the
// parent surface.
//
// When the xdg_positioner object is used to position a child surface, the
// anchor rectangle may not extend outside the window geometry of the
// positioned child's parent surface.
//
// If a negative size is set the invalid_input error is raised.
func (proxy *XdgPositioner) SetAnchorRect(connection Connection, aX int32, aY int32, aWidth int32, aHeight int32) (err error) {
	request := XdgPositionerSetAnchorRectRequest{
		X:      aX,
		Y:      aY,
		Width:  aWidth,
		Height: aHeight,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// SetAnchor requests to set anchor rectangle anchor
//
// Defines the anchor point for the anchor rectangle. The specified anchor
// is used derive an anchor point that the child surface will be
// positioned relative to. If a corner anchor is set (e.g. 'top_left' or
// 'bottom_right'), the anchor point will be at the specified corner;
// otherwise, the derived anchor point will be centered on the specified
// edge, or in the center of the anchor rectangle if no edge is specified.
func (proxy *XdgPositioner) SetAnchor(connection Connection, aAnchor uint32) (err error) {
	request := XdgPositionerSetAnchorRequest{
		Anchor: aAnchor,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// SetGravity requests to set child surface gravity
//
// Defines in what direction a surface should be positioned, relative to
// the anchor point of the parent surface. If a corner gravity is
// specified (e.g. 'bottom_right' or 'top_left'), then the child surface
// will be placed towards the specified gravity; otherwise, the child
// surface will be centered over the anchor point on any axis that had no
// gravity specified.
func (proxy *XdgPositioner) SetGravity(connection Connection, aGravity uint32) (err error) {
	request := XdgPositionerSetGravityRequest{
		Gravity: aGravity,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// SetConstraintAdjustment requests to set the adjustment to be done when constrained
//
// Specify how the window should be positioned if the originally intended
// position caused the surface to be constrained, meaning at least
// partially outside positioning boundaries set by the compositor. The
// adjustment is set by constructing a bitmask describing the adjustment to
// be made when the surface is constrained on that axis.
//
// If no bit for one axis is set, the compositor will assume that the child
// surface should not change its position on that axis when constrained.
//
// If more than one bit for one axis is set, the order of how adjustments
// are applied is specified in the corresponding adjustment descriptions.
//
// The default adjustment is none.
func (proxy *XdgPositioner) SetConstraintAdjustment(connection Connection, aConstraintAdjustment uint32) (err error) {
	request := XdgPositionerSetConstraintAdjustmentRequest{
		ConstraintAdjustment: aConstraintAdjustment,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// SetOffset requests to set surface position offset
//
// Specify the surface position offset relative to the position of the
// anchor on the anchor rectangle and the anchor on the surface. For
// example if the anchor of the anchor rectangle is at (x, y), the surface
// has the gravity bottom|right, and the offset is (ox, oy), the calculated
// surface position will be (x + ox, y + oy). The offset position of the
// surface is the one used for constraint testing. See
// set_constraint_adjustment.
//
// An example use case is placing a popup menu on top of a user interface
// element, while aligning the user interface element of the parent surface
// with some user interface element placed somewhere in the popup surface.
func (proxy *XdgPositioner) SetOffset(connection Connection, aX int32, aY int32) (err error) {
	request := XdgPositionerSetOffsetRequest{
		X: aX,
		Y: aY,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// SetReactive requests to continuously reconstrain the surface
//
// When set reactive, the surface is reconstrained if the conditions used
// for constraining changed, e.g. the parent window moved.
//
// If the conditions changed and the popup was reconstrained, an
// xdg_popup.configure event is sent with updated geometry, followed by an
// xdg_surface.configure event.
func (proxy *XdgPositioner) SetReactive(connection Connection) (err error) {
	request := XdgPositionerSetReactiveRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

func (proxy *XdgPositioner) SetParentSize(connection Connection, aParentWidth int32, aParentHeight int32) (err error) {
	request := XdgPositionerSetParentSizeRequest{
		ParentWidth:  aParentWidth,
		ParentHeight: aParentHeight,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// SetParentConfigure requests to set parent configure this is a response to
//
// Set the serial of an xdg_surface.configure event this positioner will be
// used in response to. The compositor may use this information together
// with set_parent_size to determine what future state the popup should be
// constrained using.
func (proxy *XdgPositioner) SetParentConfigure(connection Connection, aSerial uint32) (err error) {
	request := XdgPositionerSetParentConfigureRequest{
		Serial: aSerial,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Ensure XdgPositioner implements Proxy.
var _ Proxy = &XdgPositioner{}

// #endregion Interface xdg_shell.xdg_positioner

// ----------------------------------------------------------------------------
// #region Interface xdg_shell.xdg_surface

type XdgSurfaceError int

const (
	XdgSurfaceErrorNotConstructed XdgSurfaceError = 1

	XdgSurfaceErrorAlreadyConstructed XdgSurfaceError = 2

	XdgSurfaceErrorUnconfiguredBuffer XdgSurfaceError = 3
)

// XdgSurfaceDestroyRequest requests to destroy the xdg_surface
//
// Destroy the xdg_surface object. An xdg_surface must only be destroyed
// after its role object has been destroyed.
type XdgSurfaceDestroyRequest struct {
}

// Opcode returns the request opcode for xdg_surface.destroy in xdg_shell
func (XdgSurfaceDestroyRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for xdg_surface.destroy in xdg_shell
func (XdgSurfaceDestroyRequest) MessageName() string { return "destroy" }

// Ensure XdgSurfaceDestroyRequest implements Message.
var _ Message = XdgSurfaceDestroyRequest{}

// Emit emits the message to the emitter.
func (r *XdgSurfaceDestroyRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure XdgSurfaceDestroyRequest implements Request.
var _ Request = &XdgSurfaceDestroyRequest{}

// XdgSurfaceGetToplevelRequest requests to assign the xdg_toplevel surface role
//
// This creates an xdg_toplevel object for the given xdg_surface and gives
// the associated wl_surface the xdg_toplevel role.
//
// See the documentation of xdg_toplevel for more details about what an
// xdg_toplevel is and how it is used.
type XdgSurfaceGetToplevelRequest struct {
	ID ObjectID
}

// Opcode returns the request opcode for xdg_surface.get_toplevel in xdg_shell
func (XdgSurfaceGetToplevelRequest) Opcode() uint16 { return 1 }

// MessageName returns the request name for xdg_surface.get_toplevel in xdg_shell
func (XdgSurfaceGetToplevelRequest) MessageName() string { return "get_toplevel" }

// Ensure XdgSurfaceGetToplevelRequest implements Message.
var _ Message = XdgSurfaceGetToplevelRequest{}

// Emit emits the message to the emitter.
func (r *XdgSurfaceGetToplevelRequest) Emit(e *RequestEmitter) error {
	if err := e.PutObjectID(r.ID); err != nil {
		return err
	}
	return nil
}

// Ensure XdgSurfaceGetToplevelRequest implements Request.
var _ Request = &XdgSurfaceGetToplevelRequest{}

// XdgSurfaceGetPopupRequest requests to assign the xdg_popup surface role
//
// This creates an xdg_popup object for the given xdg_surface and gives
// the associated wl_surface the xdg_popup role.
//
// If null is passed as a parent, a parent surface must be specified using
// some other protocol, before committing the initial state.
//
// See the documentation of xdg_popup for more details about what an
// xdg_popup is and how it is used.
type XdgSurfaceGetPopupRequest struct {
	ID ObjectID

	Parent ObjectID

	Positioner ObjectID
}

// Opcode returns the request opcode for xdg_surface.get_popup in xdg_shell
func (XdgSurfaceGetPopupRequest) Opcode() uint16 { return 2 }

// MessageName returns the request name for xdg_surface.get_popup in xdg_shell
func (XdgSurfaceGetPopupRequest) MessageName() string { return "get_popup" }

// Ensure XdgSurfaceGetPopupRequest implements Message.
var _ Message = XdgSurfaceGetPopupRequest{}

// Emit emits the message to the emitter.
func (r *XdgSurfaceGetPopupRequest) Emit(e *RequestEmitter) error {
	if err := e.PutObjectID(r.ID); err != nil {
		return err
	}
	if err := e.PutObjectID(r.Parent); err != nil {
		return err
	}
	if err := e.PutObjectID(r.Positioner); err != nil {
		return err
	}
	return nil
}

// Ensure XdgSurfaceGetPopupRequest implements Request.
var _ Request = &XdgSurfaceGetPopupRequest{}

// XdgSurfaceSetWindowGeometryRequest requests to set the new window geometry
//
// The window geometry of a surface is its "visible bounds" from the
// user's perspective. Client-side decorations often have invisible
// portions like drop-shadows which should be ignored for the
// purposes of aligning, placing and constraining windows.
//
// The window geometry is double buffered, and will be applied at the
// time wl_surface.commit of the corresponding wl_surface is called.
//
// When maintaining a position, the compositor should treat the (x, y)
// coordinate of the window geometry as the top left corner of the window.
// A client changing the (x, y) window geometry coordinate should in
// general not alter the position of the window.
//
// Once the window geometry of the surface is set, it is not possible to
// unset it, and it will remain the same until set_window_geometry is
// called again, even if a new subsurface or buffer is attached.
//
// If never set, the value is the full bounds of the surface,
// including any subsurfaces. This updates dynamically on every
// commit. This unset is meant for extremely simple clients.
//
// The arguments are given in the surface-local coordinate space of
// the wl_surface associated with this xdg_surface.
//
// The width and height must be greater than zero. Setting an invalid size
// will raise an error. When applied, the effective window geometry will be
// the set window geometry clamped to the bounding rectangle of the
// combined geometry of the surface of the xdg_surface and the associated
// subsurfaces.
type XdgSurfaceSetWindowGeometryRequest struct {
	X int32

	Y int32

	Width int32

	Height int32
}

// Opcode returns the request opcode for xdg_surface.set_window_geometry in xdg_shell
func (XdgSurfaceSetWindowGeometryRequest) Opcode() uint16 { return 3 }

// MessageName returns the request name for xdg_surface.set_window_geometry in xdg_shell
func (XdgSurfaceSetWindowGeometryRequest) MessageName() string { return "set_window_geometry" }

// Ensure XdgSurfaceSetWindowGeometryRequest implements Message.
var _ Message = XdgSurfaceSetWindowGeometryRequest{}

// Emit emits the message to the emitter.
func (r *XdgSurfaceSetWindowGeometryRequest) Emit(e *RequestEmitter) error {
	if err := e.PutInt(r.X); err != nil {
		return err
	}
	if err := e.PutInt(r.Y); err != nil {
		return err
	}
	if err := e.PutInt(r.Width); err != nil {
		return err
	}
	if err := e.PutInt(r.Height); err != nil {
		return err
	}
	return nil
}

// Ensure XdgSurfaceSetWindowGeometryRequest implements Request.
var _ Request = &XdgSurfaceSetWindowGeometryRequest{}

// XdgSurfaceAckConfigureRequest requests to ack a configure event
//
// When a configure event is received, if a client commits the
// surface in response to the configure event, then the client
// must make an ack_configure request sometime before the commit
// request, passing along the serial of the configure event.
//
// For instance, for toplevel surfaces the compositor might use this
// information to move a surface to the top left only when the client has
// drawn itself for the maximized or fullscreen state.
//
// If the client receives multiple configure events before it
// can respond to one, it only has to ack the last configure event.
//
// A client is not required to commit immediately after sending
// an ack_configure request - it may even ack_configure several times
// before its next surface commit.
//
// A client may send multiple ack_configure requests before committing, but
// only the last request sent before a commit indicates which configure
// event the client really is responding to.
type XdgSurfaceAckConfigureRequest struct {
	// Serial contains the serial from the configure event
	Serial uint32
}

// Opcode returns the request opcode for xdg_surface.ack_configure in xdg_shell
func (XdgSurfaceAckConfigureRequest) Opcode() uint16 { return 4 }

// MessageName returns the request name for xdg_surface.ack_configure in xdg_shell
func (XdgSurfaceAckConfigureRequest) MessageName() string { return "ack_configure" }

// Ensure XdgSurfaceAckConfigureRequest implements Message.
var _ Message = XdgSurfaceAckConfigureRequest{}

// Emit emits the message to the emitter.
func (r *XdgSurfaceAckConfigureRequest) Emit(e *RequestEmitter) error {
	if err := e.PutUint(r.Serial); err != nil {
		return err
	}
	return nil
}

// Ensure XdgSurfaceAckConfigureRequest implements Request.
var _ Request = &XdgSurfaceAckConfigureRequest{}

// XdgSurfaceConfigureEvent signals when suggest a surface change
//
// The configure event marks the end of a configure sequence. A configure
// sequence is a set of one or more events configuring the state of the
// xdg_surface, including the final xdg_surface.configure event.
//
// Where applicable, xdg_surface surface roles will during a configure
// sequence extend this event as a latched state sent as events before the
// xdg_surface.configure event. Such events should be considered to make up
// a set of atomically applied configuration states, where the
// xdg_surface.configure commits the accumulated state.
//
// Clients should arrange their surface for the new states, and then send
// an ack_configure request with the serial sent in this configure event at
// some point before committing the new surface.
//
// If the client receives multiple configure events before it can respond
// to one, it is free to discard all but the last event it received.
type XdgSurfaceConfigureEvent struct {
	// Serial contains serial of the configure event
	Serial uint32
}

// Opcode returns the event opcode for xdg_surface.configure in xdg_shell
func (XdgSurfaceConfigureEvent) Opcode() uint16 { return 0 }

// MessageName returns the event name for xdg_surface.configure in xdg_shell
func (XdgSurfaceConfigureEvent) MessageName() string { return "configure" }

// Ensure XdgSurfaceConfigureEvent implements Message.
var _ Message = XdgSurfaceConfigureEvent{}

// Scan scans the event from the socket.
func (e *XdgSurfaceConfigureEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Serial = v
	}
	return nil
}

// Ensure XdgSurfaceConfigureEvent implements Event.
var _ Event = &XdgSurfaceConfigureEvent{}

// XdgSurface desktop user interface surface base interface
//
// An interface that may be implemented by a wl_surface, for
// implementations that provide a desktop-style user interface.
//
// It provides a base set of functionality required to construct user
// interface elements requiring management by the compositor, such as
// toplevel windows, menus, etc. The types of functionality are split into
// xdg_surface roles.
//
// Creating an xdg_surface does not set the role for a wl_surface. In order
// to map an xdg_surface, the client must create a role-specific object
// using, e.g., get_toplevel, get_popup. The wl_surface for any given
// xdg_surface can have at most one role, and may not be assigned any role
// not based on xdg_surface.
//
// A role must be assigned before any other requests are made to the
// xdg_surface object.
//
// The client must call wl_surface.commit on the corresponding wl_surface
// for the xdg_surface state to take effect.
//
// Creating an xdg_surface from a wl_surface which has a buffer attached or
// committed is a client error, and any attempts by a client to attach or
// manipulate a buffer prior to the first xdg_surface.configure call must
// also be treated as errors.
//
// After creating a role-specific object and setting it up, the client must
// perform an initial commit without any buffer attached. The compositor
// will reply with an xdg_surface.configure event. The client must
// acknowledge it and is then allowed to attach a buffer to map the surface.
//
// Mapping an xdg_surface-based role surface is defined as making it
// possible for the surface to be shown by the compositor. Note that
// a mapped surface is not guaranteed to be visible once it is mapped.
//
// For an xdg_surface to be mapped by the compositor, the following
// conditions must be met:
// (1) the client has assigned an xdg_surface-based role to the surface
// (2) the client has set and committed the xdg_surface state and the
// role-dependent state to the surface
// (3) the client has committed a buffer to the surface
//
// A newly-unmapped surface is considered to have met condition (1) out
// of the 3 required conditions for mapping a surface if its role surface
// has not been destroyed.
type XdgSurface struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *XdgSurface) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (XdgSurface) Descriptor() *InterfaceDescriptor {
	return &XdgSurfaceDescriptor
}

// Dispatch returns an Event object for a given opcode.
func (XdgSurface) Dispatch(opcode uint16) Event {
	switch opcode {
	case 0:
		return &XdgSurfaceConfigureEvent{}
	default:
		return nil
	}
}

// Destroy requests to destroy the xdg_surface
//
// Destroy the xdg_surface object. An xdg_surface must only be destroyed
// after its role object has been destroyed.
func (proxy *XdgSurface) Destroy(connection Connection) (err error) {
	request := XdgSurfaceDestroyRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// GetToplevel requests to assign the xdg_toplevel surface role
//
// This creates an xdg_toplevel object for the given xdg_surface and gives
// the associated wl_surface the xdg_toplevel role.
//
// See the documentation of xdg_toplevel for more details about what an
// xdg_toplevel is and how it is used.
func (proxy *XdgSurface) GetToplevel(connection Connection) (aID *XdgToplevel, err error) {
	aID = &XdgToplevel{connection.NewID()}
	request := XdgSurfaceGetToplevelRequest{
		ID: aID.id,
	}
	err = connection.SendRequest(proxy.id, &request)
	if err == nil {
		connection.RegisterProxy(aID)
	}
	return
}

// GetPopup requests to assign the xdg_popup surface role
//
// This creates an xdg_popup object for the given xdg_surface and gives
// the associated wl_surface the xdg_popup role.
//
// If null is passed as a parent, a parent surface must be specified using
// some other protocol, before committing the initial state.
//
// See the documentation of xdg_popup for more details about what an
// xdg_popup is and how it is used.
func (proxy *XdgSurface) GetPopup(connection Connection, aParent ObjectID, aPositioner ObjectID) (aID *XdgPopup, err error) {
	aID = &XdgPopup{connection.NewID()}
	request := XdgSurfaceGetPopupRequest{
		ID:         aID.id,
		Parent:     aParent,
		Positioner: aPositioner,
	}
	err = connection.SendRequest(proxy.id, &request)
	if err == nil {
		connection.RegisterProxy(aID)
	}
	return
}

// SetWindowGeometry requests to set the new window geometry
//
// The window geometry of a surface is its "visible bounds" from the
// user's perspective. Client-side decorations often have invisible
// portions like drop-shadows which should be ignored for the
// purposes of aligning, placing and constraining windows.
//
// The window geometry is double buffered, and will be applied at the
// time wl_surface.commit of the corresponding wl_surface is called.
//
// When maintaining a position, the compositor should treat the (x, y)
// coordinate of the window geometry as the top left corner of the window.
// A client changing the (x, y) window geometry coordinate should in
// general not alter the position of the window.
//
// Once the window geometry of the surface is set, it is not possible to
// unset it, and it will remain the same until set_window_geometry is
// called again, even if a new subsurface or buffer is attached.
//
// If never set, the value is the full bounds of the surface,
// including any subsurfaces. This updates dynamically on every
// commit. This unset is meant for extremely simple clients.
//
// The arguments are given in the surface-local coordinate space of
// the wl_surface associated with this xdg_surface.
//
// The width and height must be greater than zero. Setting an invalid size
// will raise an error. When applied, the effective window geometry will be
// the set window geometry clamped to the bounding rectangle of the
// combined geometry of the surface of the xdg_surface and the associated
// subsurfaces.
func (proxy *XdgSurface) SetWindowGeometry(connection Connection, aX int32, aY int32, aWidth int32, aHeight int32) (err error) {
	request := XdgSurfaceSetWindowGeometryRequest{
		X:      aX,
		Y:      aY,
		Width:  aWidth,
		Height: aHeight,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// AckConfigure requests to ack a configure event
//
// When a configure event is received, if a client commits the
// surface in response to the configure event, then the client
// must make an ack_configure request sometime before the commit
// request, passing along the serial of the configure event.
//
// For instance, for toplevel surfaces the compositor might use this
// information to move a surface to the top left only when the client has
// drawn itself for the maximized or fullscreen state.
//
// If the client receives multiple configure events before it
// can respond to one, it only has to ack the last configure event.
//
// A client is not required to commit immediately after sending
// an ack_configure request - it may even ack_configure several times
// before its next surface commit.
//
// A client may send multiple ack_configure requests before committing, but
// only the last request sent before a commit indicates which configure
// event the client really is responding to.
func (proxy *XdgSurface) AckConfigure(connection Connection, aSerial uint32) (err error) {
	request := XdgSurfaceAckConfigureRequest{
		Serial: aSerial,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Ensure XdgSurface implements Proxy.
var _ Proxy = &XdgSurface{}

// #endregion Interface xdg_shell.xdg_surface

// ----------------------------------------------------------------------------
// #region Interface xdg_shell.xdg_toplevel

// XdgToplevelResizeEdge represents edge values for resizing
//
// These values are used to indicate which edge of a surface
// is being dragged in a resize operation.
type XdgToplevelResizeEdge int

const (
	XdgToplevelResizeEdgeNone XdgToplevelResizeEdge = 0

	XdgToplevelResizeEdgeTop XdgToplevelResizeEdge = 1

	XdgToplevelResizeEdgeBottom XdgToplevelResizeEdge = 2

	XdgToplevelResizeEdgeLeft XdgToplevelResizeEdge = 4

	XdgToplevelResizeEdgeTopLeft XdgToplevelResizeEdge = 5

	XdgToplevelResizeEdgeBottomLeft XdgToplevelResizeEdge = 6

	XdgToplevelResizeEdgeRight XdgToplevelResizeEdge = 8

	XdgToplevelResizeEdgeTopRight XdgToplevelResizeEdge = 9

	XdgToplevelResizeEdgeBottomRight XdgToplevelResizeEdge = 10
)

// XdgToplevelState represents types of state on the surface
//
// The different state values used on the surface. This is designed for
// state values like maximized, fullscreen. It is paired with the
// configure event to ensure that both the client and the compositor
// setting the state can be synchronized.
//
// States set in this way are double-buffered. They will get applied on
// the next commit.
type XdgToplevelState int

const (
	// XdgToplevelStateMaximized corresponds to the surface is maximized
	XdgToplevelStateMaximized XdgToplevelState = 1

	// XdgToplevelStateFullscreen corresponds to the surface is fullscreen
	XdgToplevelStateFullscreen XdgToplevelState = 2

	// XdgToplevelStateResizing corresponds to the surface is being resized
	XdgToplevelStateResizing XdgToplevelState = 3

	// XdgToplevelStateActivated corresponds to the surface is now activated
	XdgToplevelStateActivated XdgToplevelState = 4

	XdgToplevelStateTiledLeft XdgToplevelState = 5

	XdgToplevelStateTiledRight XdgToplevelState = 6

	XdgToplevelStateTiledTop XdgToplevelState = 7

	XdgToplevelStateTiledBottom XdgToplevelState = 8
)

// XdgToplevelDestroyRequest requests to destroy the xdg_toplevel
//
// This request destroys the role surface and unmaps the surface;
// see "Unmapping" behavior in interface section for details.
type XdgToplevelDestroyRequest struct {
}

// Opcode returns the request opcode for xdg_toplevel.destroy in xdg_shell
func (XdgToplevelDestroyRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for xdg_toplevel.destroy in xdg_shell
func (XdgToplevelDestroyRequest) MessageName() string { return "destroy" }

// Ensure XdgToplevelDestroyRequest implements Message.
var _ Message = XdgToplevelDestroyRequest{}

// Emit emits the message to the emitter.
func (r *XdgToplevelDestroyRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure XdgToplevelDestroyRequest implements Request.
var _ Request = &XdgToplevelDestroyRequest{}

// XdgToplevelSetParentRequest requests to set the parent of this surface
//
// Set the "parent" of this surface. This surface should be stacked
// above the parent surface and all other ancestor surfaces.
//
// Parent windows should be set on dialogs, toolboxes, or other
// "auxiliary" surfaces, so that the parent is raised when the dialog
// is raised.
//
// Setting a null parent for a child window removes any parent-child
// relationship for the child. Setting a null parent for a window which
// currently has no parent is a no-op.
//
// If the parent is unmapped then its children are managed as
// though the parent of the now-unmapped parent has become the
// parent of this surface. If no parent exists for the now-unmapped
// parent then the children are managed as though they have no
// parent surface.
type XdgToplevelSetParentRequest struct {
	Parent ObjectID
}

// Opcode returns the request opcode for xdg_toplevel.set_parent in xdg_shell
func (XdgToplevelSetParentRequest) Opcode() uint16 { return 1 }

// MessageName returns the request name for xdg_toplevel.set_parent in xdg_shell
func (XdgToplevelSetParentRequest) MessageName() string { return "set_parent" }

// Ensure XdgToplevelSetParentRequest implements Message.
var _ Message = XdgToplevelSetParentRequest{}

// Emit emits the message to the emitter.
func (r *XdgToplevelSetParentRequest) Emit(e *RequestEmitter) error {
	if err := e.PutObjectID(r.Parent); err != nil {
		return err
	}
	return nil
}

// Ensure XdgToplevelSetParentRequest implements Request.
var _ Request = &XdgToplevelSetParentRequest{}

// XdgToplevelSetTitleRequest requests to set surface title
//
// Set a short title for the surface.
//
// This string may be used to identify the surface in a task bar,
// window list, or other user interface elements provided by the
// compositor.
//
// The string must be encoded in UTF-8.
type XdgToplevelSetTitleRequest struct {
	Title string
}

// Opcode returns the request opcode for xdg_toplevel.set_title in xdg_shell
func (XdgToplevelSetTitleRequest) Opcode() uint16 { return 2 }

// MessageName returns the request name for xdg_toplevel.set_title in xdg_shell
func (XdgToplevelSetTitleRequest) MessageName() string { return "set_title" }

// Ensure XdgToplevelSetTitleRequest implements Message.
var _ Message = XdgToplevelSetTitleRequest{}

// Emit emits the message to the emitter.
func (r *XdgToplevelSetTitleRequest) Emit(e *RequestEmitter) error {
	if err := e.PutString(r.Title); err != nil {
		return err
	}
	return nil
}

// Ensure XdgToplevelSetTitleRequest implements Request.
var _ Request = &XdgToplevelSetTitleRequest{}

// XdgToplevelSetAppIDRequest requests to set application ID
//
// Set an application identifier for the surface.
//
// The app ID identifies the general class of applications to which
// the surface belongs. The compositor can use this to group multiple
// surfaces together, or to determine how to launch a new application.
//
// For D-Bus activatable applications, the app ID is used as the D-Bus
// service name.
//
// The compositor shell will try to group application surfaces together
// by their app ID. As a best practice, it is suggested to select app
// ID's that match the basename of the application's .desktop file.
// For example, "org.freedesktop.FooViewer" where the .desktop file is
// "org.freedesktop.FooViewer.desktop".
//
// Like other properties, a set_app_id request can be sent after the
// xdg_toplevel has been mapped to update the property.
//
// See the desktop-entry specification [0] for more details on
// application identifiers and how they relate to well-known D-Bus
// names and .desktop files.
//
// [0] http://standards.freedesktop.org/desktop-entry-spec/
type XdgToplevelSetAppIDRequest struct {
	AppID string
}

// Opcode returns the request opcode for xdg_toplevel.set_app_id in xdg_shell
func (XdgToplevelSetAppIDRequest) Opcode() uint16 { return 3 }

// MessageName returns the request name for xdg_toplevel.set_app_id in xdg_shell
func (XdgToplevelSetAppIDRequest) MessageName() string { return "set_app_id" }

// Ensure XdgToplevelSetAppIDRequest implements Message.
var _ Message = XdgToplevelSetAppIDRequest{}

// Emit emits the message to the emitter.
func (r *XdgToplevelSetAppIDRequest) Emit(e *RequestEmitter) error {
	if err := e.PutString(r.AppID); err != nil {
		return err
	}
	return nil
}

// Ensure XdgToplevelSetAppIDRequest implements Request.
var _ Request = &XdgToplevelSetAppIDRequest{}

// XdgToplevelShowWindowMenuRequest requests to show the window menu
//
// Clients implementing client-side decorations might want to show
// a context menu when right-clicking on the decorations, giving the
// user a menu that they can use to maximize or minimize the window.
//
// This request asks the compositor to pop up such a window menu at
// the given position, relative to the local surface coordinates of
// the parent surface. There are no guarantees as to what menu items
// the window menu contains.
//
// This request must be used in response to some sort of user action
// like a button press, key press, or touch down event.
type XdgToplevelShowWindowMenuRequest struct {
	// Seat contains the wl_seat of the user event
	Seat ObjectID

	// Serial contains the serial of the user event
	Serial uint32

	// X contains the x position to pop up the window menu at
	X int32

	// Y contains the y position to pop up the window menu at
	Y int32
}

// Opcode returns the request opcode for xdg_toplevel.show_window_menu in xdg_shell
func (XdgToplevelShowWindowMenuRequest) Opcode() uint16 { return 4 }

// MessageName returns the request name for xdg_toplevel.show_window_menu in xdg_shell
func (XdgToplevelShowWindowMenuRequest) MessageName() string { return "show_window_menu" }

// Ensure XdgToplevelShowWindowMenuRequest implements Message.
var _ Message = XdgToplevelShowWindowMenuRequest{}

// Emit emits the message to the emitter.
func (r *XdgToplevelShowWindowMenuRequest) Emit(e *RequestEmitter) error {
	if err := e.PutObjectID(r.Seat); err != nil {
		return err
	}
	if err := e.PutUint(r.Serial); err != nil {
		return err
	}
	if err := e.PutInt(r.X); err != nil {
		return err
	}
	if err := e.PutInt(r.Y); err != nil {
		return err
	}
	return nil
}

// Ensure XdgToplevelShowWindowMenuRequest implements Request.
var _ Request = &XdgToplevelShowWindowMenuRequest{}

// XdgToplevelMoveRequest requests to start an interactive move
//
// Start an interactive, user-driven move of the surface.
//
// This request must be used in response to some sort of user action
// like a button press, key press, or touch down event. The passed
// serial is used to determine the type of interactive move (touch,
// pointer, etc).
//
// The server may ignore move requests depending on the state of
// the surface (e.g. fullscreen or maximized), or if the passed serial
// is no longer valid.
//
// If triggered, the surface will lose the focus of the device
// (wl_pointer, wl_touch, etc) used for the move. It is up to the
// compositor to visually indicate that the move is taking place, such as
// updating a pointer cursor, during the move. There is no guarantee
// that the device focus will return when the move is completed.
type XdgToplevelMoveRequest struct {
	// Seat contains the wl_seat of the user event
	Seat ObjectID

	// Serial contains the serial of the user event
	Serial uint32
}

// Opcode returns the request opcode for xdg_toplevel.move in xdg_shell
func (XdgToplevelMoveRequest) Opcode() uint16 { return 5 }

// MessageName returns the request name for xdg_toplevel.move in xdg_shell
func (XdgToplevelMoveRequest) MessageName() string { return "move" }

// Ensure XdgToplevelMoveRequest implements Message.
var _ Message = XdgToplevelMoveRequest{}

// Emit emits the message to the emitter.
func (r *XdgToplevelMoveRequest) Emit(e *RequestEmitter) error {
	if err := e.PutObjectID(r.Seat); err != nil {
		return err
	}
	if err := e.PutUint(r.Serial); err != nil {
		return err
	}
	return nil
}

// Ensure XdgToplevelMoveRequest implements Request.
var _ Request = &XdgToplevelMoveRequest{}

// XdgToplevelResizeRequest requests to start an interactive resize
//
// Start a user-driven, interactive resize of the surface.
//
// This request must be used in response to some sort of user action
// like a button press, key press, or touch down event. The passed
// serial is used to determine the type of interactive resize (touch,
// pointer, etc).
//
// The server may ignore resize requests depending on the state of
// the surface (e.g. fullscreen or maximized).
//
// If triggered, the client will receive configure events with the
// "resize" state enum value and the expected sizes. See the "resize"
// enum value for more details about what is required. The client
// must also acknowledge configure events using "ack_configure". After
// the resize is completed, the client will receive another "configure"
// event without the resize state.
//
// If triggered, the surface also will lose the focus of the device
// (wl_pointer, wl_touch, etc) used for the resize. It is up to the
// compositor to visually indicate that the resize is taking place,
// such as updating a pointer cursor, during the resize. There is no
// guarantee that the device focus will return when the resize is
// completed.
//
// The edges parameter specifies how the surface should be resized,
// and is one of the values of the resize_edge enum. The compositor
// may use this information to update the surface position for
// example when dragging the top left corner. The compositor may also
// use this information to adapt its behavior, e.g. choose an
// appropriate cursor image.
type XdgToplevelResizeRequest struct {
	// Seat contains the wl_seat of the user event
	Seat ObjectID

	// Serial contains the serial of the user event
	Serial uint32

	// Edges contains which edge or corner is being dragged
	Edges uint32
}

// Opcode returns the request opcode for xdg_toplevel.resize in xdg_shell
func (XdgToplevelResizeRequest) Opcode() uint16 { return 6 }

// MessageName returns the request name for xdg_toplevel.resize in xdg_shell
func (XdgToplevelResizeRequest) MessageName() string { return "resize" }

// Ensure XdgToplevelResizeRequest implements Message.
var _ Message = XdgToplevelResizeRequest{}

// Emit emits the message to the emitter.
func (r *XdgToplevelResizeRequest) Emit(e *RequestEmitter) error {
	if err := e.PutObjectID(r.Seat); err != nil {
		return err
	}
	if err := e.PutUint(r.Serial); err != nil {
		return err
	}
	if err := e.PutUint(r.Edges); err != nil {
		return err
	}
	return nil
}

// Ensure XdgToplevelResizeRequest implements Request.
var _ Request = &XdgToplevelResizeRequest{}

// XdgToplevelSetMaxSizeRequest requests to set the maximum size
//
// Set a maximum size for the window.
//
// The client can specify a maximum size so that the compositor does
// not try to configure the window beyond this size.
//
// The width and height arguments are in window geometry coordinates.
// See xdg_surface.set_window_geometry.
//
// Values set in this way are double-buffered. They will get applied
// on the next commit.
//
// The compositor can use this information to allow or disallow
// different states like maximize or fullscreen and draw accurate
// animations.
//
// Similarly, a tiling window manager may use this information to
// place and resize client windows in a more effective way.
//
// The client should not rely on the compositor to obey the maximum
// size. The compositor may decide to ignore the values set by the
// client and request a larger size.
//
// If never set, or a value of zero in the request, means that the
// client has no expected maximum size in the given dimension.
// As a result, a client wishing to reset the maximum size
// to an unspecified state can use zero for width and height in the
// request.
//
// Requesting a maximum size to be smaller than the minimum size of
// a surface is illegal and will result in a protocol error.
//
// The width and height must be greater than or equal to zero. Using
// strictly negative values for width and height will result in a
// protocol error.
type XdgToplevelSetMaxSizeRequest struct {
	Width int32

	Height int32
}

// Opcode returns the request opcode for xdg_toplevel.set_max_size in xdg_shell
func (XdgToplevelSetMaxSizeRequest) Opcode() uint16 { return 7 }

// MessageName returns the request name for xdg_toplevel.set_max_size in xdg_shell
func (XdgToplevelSetMaxSizeRequest) MessageName() string { return "set_max_size" }

// Ensure XdgToplevelSetMaxSizeRequest implements Message.
var _ Message = XdgToplevelSetMaxSizeRequest{}

// Emit emits the message to the emitter.
func (r *XdgToplevelSetMaxSizeRequest) Emit(e *RequestEmitter) error {
	if err := e.PutInt(r.Width); err != nil {
		return err
	}
	if err := e.PutInt(r.Height); err != nil {
		return err
	}
	return nil
}

// Ensure XdgToplevelSetMaxSizeRequest implements Request.
var _ Request = &XdgToplevelSetMaxSizeRequest{}

// XdgToplevelSetMinSizeRequest requests to set the minimum size
//
// Set a minimum size for the window.
//
// The client can specify a minimum size so that the compositor does
// not try to configure the window below this size.
//
// The width and height arguments are in window geometry coordinates.
// See xdg_surface.set_window_geometry.
//
// Values set in this way are double-buffered. They will get applied
// on the next commit.
//
// The compositor can use this information to allow or disallow
// different states like maximize or fullscreen and draw accurate
// animations.
//
// Similarly, a tiling window manager may use this information to
// place and resize client windows in a more effective way.
//
// The client should not rely on the compositor to obey the minimum
// size. The compositor may decide to ignore the values set by the
// client and request a smaller size.
//
// If never set, or a value of zero in the request, means that the
// client has no expected minimum size in the given dimension.
// As a result, a client wishing to reset the minimum size
// to an unspecified state can use zero for width and height in the
// request.
//
// Requesting a minimum size to be larger than the maximum size of
// a surface is illegal and will result in a protocol error.
//
// The width and height must be greater than or equal to zero. Using
// strictly negative values for width and height will result in a
// protocol error.
type XdgToplevelSetMinSizeRequest struct {
	Width int32

	Height int32
}

// Opcode returns the request opcode for xdg_toplevel.set_min_size in xdg_shell
func (XdgToplevelSetMinSizeRequest) Opcode() uint16 { return 8 }

// MessageName returns the request name for xdg_toplevel.set_min_size in xdg_shell
func (XdgToplevelSetMinSizeRequest) MessageName() string { return "set_min_size" }

// Ensure XdgToplevelSetMinSizeRequest implements Message.
var _ Message = XdgToplevelSetMinSizeRequest{}

// Emit emits the message to the emitter.
func (r *XdgToplevelSetMinSizeRequest) Emit(e *RequestEmitter) error {
	if err := e.PutInt(r.Width); err != nil {
		return err
	}
	if err := e.PutInt(r.Height); err != nil {
		return err
	}
	return nil
}

// Ensure XdgToplevelSetMinSizeRequest implements Request.
var _ Request = &XdgToplevelSetMinSizeRequest{}

// XdgToplevelSetMaximizedRequest requests to maximize the window
//
// Maximize the surface.
//
// After requesting that the surface should be maximized, the compositor
// will respond by emitting a configure event. Whether this configure
// actually sets the window maximized is subject to compositor policies.
// The client must then update its content, drawing in the configured
// state. The client must also acknowledge the configure when committing
// the new content (see ack_configure).
//
// It is up to the compositor to decide how and where to maximize the
// surface, for example which output and what region of the screen should
// be used.
//
// If the surface was already maximized, the compositor will still emit
// a configure event with the "maximized" state.
//
// If the surface is in a fullscreen state, this request has no direct
// effect. It may alter the state the surface is returned to when
// unmaximized unless overridden by the compositor.
type XdgToplevelSetMaximizedRequest struct {
}

// Opcode returns the request opcode for xdg_toplevel.set_maximized in xdg_shell
func (XdgToplevelSetMaximizedRequest) Opcode() uint16 { return 9 }

// MessageName returns the request name for xdg_toplevel.set_maximized in xdg_shell
func (XdgToplevelSetMaximizedRequest) MessageName() string { return "set_maximized" }

// Ensure XdgToplevelSetMaximizedRequest implements Message.
var _ Message = XdgToplevelSetMaximizedRequest{}

// Emit emits the message to the emitter.
func (r *XdgToplevelSetMaximizedRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure XdgToplevelSetMaximizedRequest implements Request.
var _ Request = &XdgToplevelSetMaximizedRequest{}

// XdgToplevelUnsetMaximizedRequest requests to unmaximize the window
//
// Unmaximize the surface.
//
// After requesting that the surface should be unmaximized, the compositor
// will respond by emitting a configure event. Whether this actually
// un-maximizes the window is subject to compositor policies.
// If available and applicable, the compositor will include the window
// geometry dimensions the window had prior to being maximized in the
// configure event. The client must then update its content, drawing it in
// the configured state. The client must also acknowledge the configure
// when committing the new content (see ack_configure).
//
// It is up to the compositor to position the surface after it was
// unmaximized; usually the position the surface had before maximizing, if
// applicable.
//
// If the surface was already not maximized, the compositor will still
// emit a configure event without the "maximized" state.
//
// If the surface is in a fullscreen state, this request has no direct
// effect. It may alter the state the surface is returned to when
// unmaximized unless overridden by the compositor.
type XdgToplevelUnsetMaximizedRequest struct {
}

// Opcode returns the request opcode for xdg_toplevel.unset_maximized in xdg_shell
func (XdgToplevelUnsetMaximizedRequest) Opcode() uint16 { return 10 }

// MessageName returns the request name for xdg_toplevel.unset_maximized in xdg_shell
func (XdgToplevelUnsetMaximizedRequest) MessageName() string { return "unset_maximized" }

// Ensure XdgToplevelUnsetMaximizedRequest implements Message.
var _ Message = XdgToplevelUnsetMaximizedRequest{}

// Emit emits the message to the emitter.
func (r *XdgToplevelUnsetMaximizedRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure XdgToplevelUnsetMaximizedRequest implements Request.
var _ Request = &XdgToplevelUnsetMaximizedRequest{}

// XdgToplevelSetFullscreenRequest requests to set the window as fullscreen on an output
//
// Make the surface fullscreen.
//
// After requesting that the surface should be fullscreened, the
// compositor will respond by emitting a configure event. Whether the
// client is actually put into a fullscreen state is subject to compositor
// policies. The client must also acknowledge the configure when
// committing the new content (see ack_configure).
//
// The output passed by the request indicates the client's preference as
// to which display it should be set fullscreen on. If this value is NULL,
// it's up to the compositor to choose which display will be used to map
// this surface.
//
// If the surface doesn't cover the whole output, the compositor will
// position the surface in the center of the output and compensate with
// with border fill covering the rest of the output. The content of the
// border fill is undefined, but should be assumed to be in some way that
// attempts to blend into the surrounding area (e.g. solid black).
//
// If the fullscreened surface is not opaque, the compositor must make
// sure that other screen content not part of the same surface tree (made
// up of subsurfaces, popups or similarly coupled surfaces) are not
// visible below the fullscreened surface.
type XdgToplevelSetFullscreenRequest struct {
	Output ObjectID
}

// Opcode returns the request opcode for xdg_toplevel.set_fullscreen in xdg_shell
func (XdgToplevelSetFullscreenRequest) Opcode() uint16 { return 11 }

// MessageName returns the request name for xdg_toplevel.set_fullscreen in xdg_shell
func (XdgToplevelSetFullscreenRequest) MessageName() string { return "set_fullscreen" }

// Ensure XdgToplevelSetFullscreenRequest implements Message.
var _ Message = XdgToplevelSetFullscreenRequest{}

// Emit emits the message to the emitter.
func (r *XdgToplevelSetFullscreenRequest) Emit(e *RequestEmitter) error {
	if err := e.PutObjectID(r.Output); err != nil {
		return err
	}
	return nil
}

// Ensure XdgToplevelSetFullscreenRequest implements Request.
var _ Request = &XdgToplevelSetFullscreenRequest{}

// XdgToplevelUnsetFullscreenRequest requests to unset the window as fullscreen
//
// Make the surface no longer fullscreen.
//
// After requesting that the surface should be unfullscreened, the
// compositor will respond by emitting a configure event.
// Whether this actually removes the fullscreen state of the client is
// subject to compositor policies.
//
// Making a surface unfullscreen sets states for the surface based on the following:
// * the state(s) it may have had before becoming fullscreen
// * any state(s) decided by the compositor
// * any state(s) requested by the client while the surface was fullscreen
//
// The compositor may include the previous window geometry dimensions in
// the configure event, if applicable.
//
// The client must also acknowledge the configure when committing the new
// content (see ack_configure).
type XdgToplevelUnsetFullscreenRequest struct {
}

// Opcode returns the request opcode for xdg_toplevel.unset_fullscreen in xdg_shell
func (XdgToplevelUnsetFullscreenRequest) Opcode() uint16 { return 12 }

// MessageName returns the request name for xdg_toplevel.unset_fullscreen in xdg_shell
func (XdgToplevelUnsetFullscreenRequest) MessageName() string { return "unset_fullscreen" }

// Ensure XdgToplevelUnsetFullscreenRequest implements Message.
var _ Message = XdgToplevelUnsetFullscreenRequest{}

// Emit emits the message to the emitter.
func (r *XdgToplevelUnsetFullscreenRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure XdgToplevelUnsetFullscreenRequest implements Request.
var _ Request = &XdgToplevelUnsetFullscreenRequest{}

// XdgToplevelSetMinimizedRequest requests to set the window as minimized
//
// Request that the compositor minimize your surface. There is no
// way to know if the surface is currently minimized, nor is there
// any way to unset minimization on this surface.
//
// If you are looking to throttle redrawing when minimized, please
// instead use the wl_surface.frame event for this, as this will
// also work with live previews on windows in Alt-Tab, Expose or
// similar compositor features.
type XdgToplevelSetMinimizedRequest struct {
}

// Opcode returns the request opcode for xdg_toplevel.set_minimized in xdg_shell
func (XdgToplevelSetMinimizedRequest) Opcode() uint16 { return 13 }

// MessageName returns the request name for xdg_toplevel.set_minimized in xdg_shell
func (XdgToplevelSetMinimizedRequest) MessageName() string { return "set_minimized" }

// Ensure XdgToplevelSetMinimizedRequest implements Message.
var _ Message = XdgToplevelSetMinimizedRequest{}

// Emit emits the message to the emitter.
func (r *XdgToplevelSetMinimizedRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure XdgToplevelSetMinimizedRequest implements Request.
var _ Request = &XdgToplevelSetMinimizedRequest{}

// XdgToplevelConfigureEvent signals when suggest a surface change
//
// This configure event asks the client to resize its toplevel surface or
// to change its state. The configured state should not be applied
// immediately. See xdg_surface.configure for details.
//
// The width and height arguments specify a hint to the window
// about how its surface should be resized in window geometry
// coordinates. See set_window_geometry.
//
// If the width or height arguments are zero, it means the client
// should decide its own window dimension. This may happen when the
// compositor needs to configure the state of the surface but doesn't
// have any information about any previous or expected dimension.
//
// The states listed in the event specify how the width/height
// arguments should be interpreted, and possibly how it should be
// drawn.
//
// Clients must send an ack_configure in response to this event. See
// xdg_surface.configure and xdg_surface.ack_configure for details.
type XdgToplevelConfigureEvent struct {
	Width int32

	Height int32

	States []byte
}

// Opcode returns the event opcode for xdg_toplevel.configure in xdg_shell
func (XdgToplevelConfigureEvent) Opcode() uint16 { return 0 }

// MessageName returns the event name for xdg_toplevel.configure in xdg_shell
func (XdgToplevelConfigureEvent) MessageName() string { return "configure" }

// Ensure XdgToplevelConfigureEvent implements Message.
var _ Message = XdgToplevelConfigureEvent{}

// Scan scans the event from the socket.
func (e *XdgToplevelConfigureEvent) Scan(s *EventScanner) error {
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.Width = v
	}
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.Height = v
	}
	if v, err := s.Array(); err != nil {
		return err
	} else {
		e.States = v
	}
	return nil
}

// Ensure XdgToplevelConfigureEvent implements Event.
var _ Event = &XdgToplevelConfigureEvent{}

// XdgToplevelCloseEvent signals when surface wants to be closed
//
// The close event is sent by the compositor when the user
// wants the surface to be closed. This should be equivalent to
// the user clicking the close button in client-side decorations,
// if your application has any.
//
// This is only a request that the user intends to close the
// window. The client may choose to ignore this request, or show
// a dialog to ask the user to save their data, etc.
type XdgToplevelCloseEvent struct {
}

// Opcode returns the event opcode for xdg_toplevel.close in xdg_shell
func (XdgToplevelCloseEvent) Opcode() uint16 { return 1 }

// MessageName returns the event name for xdg_toplevel.close in xdg_shell
func (XdgToplevelCloseEvent) MessageName() string { return "close" }

// Ensure XdgToplevelCloseEvent implements Message.
var _ Message = XdgToplevelCloseEvent{}

// Scan scans the event from the socket.
func (e *XdgToplevelCloseEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure XdgToplevelCloseEvent implements Event.
var _ Event = &XdgToplevelCloseEvent{}

// XdgToplevel toplevel surface
//
// This interface defines an xdg_surface role which allows a surface to,
// among other things, set window-like properties such as maximize,
// fullscreen, and minimize, set application-specific metadata like title and
// id, and well as trigger user interactive operations such as interactive
// resize and move.
//
// Unmapping an xdg_toplevel means that the surface cannot be shown
// by the compositor until it is explicitly mapped again.
// All active operations (e.g., move, resize) are canceled and all
// attributes (e.g. title, state, stacking, ...) are discarded for
// an xdg_toplevel surface when it is unmapped. The xdg_toplevel returns to
// the state it had right after xdg_surface.get_toplevel. The client
// can re-map the toplevel by perfoming a commit without any buffer
// attached, waiting for a configure event and handling it as usual (see
// xdg_surface description).
//
// Attaching a null buffer to a toplevel unmaps the surface.
type XdgToplevel struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *XdgToplevel) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (XdgToplevel) Descriptor() *InterfaceDescriptor {
	return &XdgToplevelDescriptor
}

// Dispatch returns an Event object for a given opcode.
func (XdgToplevel) Dispatch(opcode uint16) Event {
	switch opcode {
	case 0:
		return &XdgToplevelConfigureEvent{}
	case 1:
		return &XdgToplevelCloseEvent{}
	default:
		return nil
	}
}

// Destroy requests to destroy the xdg_toplevel
//
// This request destroys the role surface and unmaps the surface;
// see "Unmapping" behavior in interface section for details.
func (proxy *XdgToplevel) Destroy(connection Connection) (err error) {
	request := XdgToplevelDestroyRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// SetParent requests to set the parent of this surface
//
// Set the "parent" of this surface. This surface should be stacked
// above the parent surface and all other ancestor surfaces.
//
// Parent windows should be set on dialogs, toolboxes, or other
// "auxiliary" surfaces, so that the parent is raised when the dialog
// is raised.
//
// Setting a null parent for a child window removes any parent-child
// relationship for the child. Setting a null parent for a window which
// currently has no parent is a no-op.
//
// If the parent is unmapped then its children are managed as
// though the parent of the now-unmapped parent has become the
// parent of this surface. If no parent exists for the now-unmapped
// parent then the children are managed as though they have no
// parent surface.
func (proxy *XdgToplevel) SetParent(connection Connection, aParent ObjectID) (err error) {
	request := XdgToplevelSetParentRequest{
		Parent: aParent,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// SetTitle requests to set surface title
//
// Set a short title for the surface.
//
// This string may be used to identify the surface in a task bar,
// window list, or other user interface elements provided by the
// compositor.
//
// The string must be encoded in UTF-8.
func (proxy *XdgToplevel) SetTitle(connection Connection, aTitle string) (err error) {
	request := XdgToplevelSetTitleRequest{
		Title: aTitle,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// SetAppID requests to set application ID
//
// Set an application identifier for the surface.
//
// The app ID identifies the general class of applications to which
// the surface belongs. The compositor can use this to group multiple
// surfaces together, or to determine how to launch a new application.
//
// For D-Bus activatable applications, the app ID is used as the D-Bus
// service name.
//
// The compositor shell will try to group application surfaces together
// by their app ID. As a best practice, it is suggested to select app
// ID's that match the basename of the application's .desktop file.
// For example, "org.freedesktop.FooViewer" where the .desktop file is
// "org.freedesktop.FooViewer.desktop".
//
// Like other properties, a set_app_id request can be sent after the
// xdg_toplevel has been mapped to update the property.
//
// See the desktop-entry specification [0] for more details on
// application identifiers and how they relate to well-known D-Bus
// names and .desktop files.
//
// [0] http://standards.freedesktop.org/desktop-entry-spec/
func (proxy *XdgToplevel) SetAppID(connection Connection, aAppID string) (err error) {
	request := XdgToplevelSetAppIDRequest{
		AppID: aAppID,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// ShowWindowMenu requests to show the window menu
//
// Clients implementing client-side decorations might want to show
// a context menu when right-clicking on the decorations, giving the
// user a menu that they can use to maximize or minimize the window.
//
// This request asks the compositor to pop up such a window menu at
// the given position, relative to the local surface coordinates of
// the parent surface. There are no guarantees as to what menu items
// the window menu contains.
//
// This request must be used in response to some sort of user action
// like a button press, key press, or touch down event.
func (proxy *XdgToplevel) ShowWindowMenu(connection Connection, aSeat ObjectID, aSerial uint32, aX int32, aY int32) (err error) {
	request := XdgToplevelShowWindowMenuRequest{
		Seat:   aSeat,
		Serial: aSerial,
		X:      aX,
		Y:      aY,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Move requests to start an interactive move
//
// Start an interactive, user-driven move of the surface.
//
// This request must be used in response to some sort of user action
// like a button press, key press, or touch down event. The passed
// serial is used to determine the type of interactive move (touch,
// pointer, etc).
//
// The server may ignore move requests depending on the state of
// the surface (e.g. fullscreen or maximized), or if the passed serial
// is no longer valid.
//
// If triggered, the surface will lose the focus of the device
// (wl_pointer, wl_touch, etc) used for the move. It is up to the
// compositor to visually indicate that the move is taking place, such as
// updating a pointer cursor, during the move. There is no guarantee
// that the device focus will return when the move is completed.
func (proxy *XdgToplevel) Move(connection Connection, aSeat ObjectID, aSerial uint32) (err error) {
	request := XdgToplevelMoveRequest{
		Seat:   aSeat,
		Serial: aSerial,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Resize requests to start an interactive resize
//
// Start a user-driven, interactive resize of the surface.
//
// This request must be used in response to some sort of user action
// like a button press, key press, or touch down event. The passed
// serial is used to determine the type of interactive resize (touch,
// pointer, etc).
//
// The server may ignore resize requests depending on the state of
// the surface (e.g. fullscreen or maximized).
//
// If triggered, the client will receive configure events with the
// "resize" state enum value and the expected sizes. See the "resize"
// enum value for more details about what is required. The client
// must also acknowledge configure events using "ack_configure". After
// the resize is completed, the client will receive another "configure"
// event without the resize state.
//
// If triggered, the surface also will lose the focus of the device
// (wl_pointer, wl_touch, etc) used for the resize. It is up to the
// compositor to visually indicate that the resize is taking place,
// such as updating a pointer cursor, during the resize. There is no
// guarantee that the device focus will return when the resize is
// completed.
//
// The edges parameter specifies how the surface should be resized,
// and is one of the values of the resize_edge enum. The compositor
// may use this information to update the surface position for
// example when dragging the top left corner. The compositor may also
// use this information to adapt its behavior, e.g. choose an
// appropriate cursor image.
func (proxy *XdgToplevel) Resize(connection Connection, aSeat ObjectID, aSerial uint32, aEdges uint32) (err error) {
	request := XdgToplevelResizeRequest{
		Seat:   aSeat,
		Serial: aSerial,
		Edges:  aEdges,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// SetMaxSize requests to set the maximum size
//
// Set a maximum size for the window.
//
// The client can specify a maximum size so that the compositor does
// not try to configure the window beyond this size.
//
// The width and height arguments are in window geometry coordinates.
// See xdg_surface.set_window_geometry.
//
// Values set in this way are double-buffered. They will get applied
// on the next commit.
//
// The compositor can use this information to allow or disallow
// different states like maximize or fullscreen and draw accurate
// animations.
//
// Similarly, a tiling window manager may use this information to
// place and resize client windows in a more effective way.
//
// The client should not rely on the compositor to obey the maximum
// size. The compositor may decide to ignore the values set by the
// client and request a larger size.
//
// If never set, or a value of zero in the request, means that the
// client has no expected maximum size in the given dimension.
// As a result, a client wishing to reset the maximum size
// to an unspecified state can use zero for width and height in the
// request.
//
// Requesting a maximum size to be smaller than the minimum size of
// a surface is illegal and will result in a protocol error.
//
// The width and height must be greater than or equal to zero. Using
// strictly negative values for width and height will result in a
// protocol error.
func (proxy *XdgToplevel) SetMaxSize(connection Connection, aWidth int32, aHeight int32) (err error) {
	request := XdgToplevelSetMaxSizeRequest{
		Width:  aWidth,
		Height: aHeight,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// SetMinSize requests to set the minimum size
//
// Set a minimum size for the window.
//
// The client can specify a minimum size so that the compositor does
// not try to configure the window below this size.
//
// The width and height arguments are in window geometry coordinates.
// See xdg_surface.set_window_geometry.
//
// Values set in this way are double-buffered. They will get applied
// on the next commit.
//
// The compositor can use this information to allow or disallow
// different states like maximize or fullscreen and draw accurate
// animations.
//
// Similarly, a tiling window manager may use this information to
// place and resize client windows in a more effective way.
//
// The client should not rely on the compositor to obey the minimum
// size. The compositor may decide to ignore the values set by the
// client and request a smaller size.
//
// If never set, or a value of zero in the request, means that the
// client has no expected minimum size in the given dimension.
// As a result, a client wishing to reset the minimum size
// to an unspecified state can use zero for width and height in the
// request.
//
// Requesting a minimum size to be larger than the maximum size of
// a surface is illegal and will result in a protocol error.
//
// The width and height must be greater than or equal to zero. Using
// strictly negative values for width and height will result in a
// protocol error.
func (proxy *XdgToplevel) SetMinSize(connection Connection, aWidth int32, aHeight int32) (err error) {
	request := XdgToplevelSetMinSizeRequest{
		Width:  aWidth,
		Height: aHeight,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// SetMaximized requests to maximize the window
//
// Maximize the surface.
//
// After requesting that the surface should be maximized, the compositor
// will respond by emitting a configure event. Whether this configure
// actually sets the window maximized is subject to compositor policies.
// The client must then update its content, drawing in the configured
// state. The client must also acknowledge the configure when committing
// the new content (see ack_configure).
//
// It is up to the compositor to decide how and where to maximize the
// surface, for example which output and what region of the screen should
// be used.
//
// If the surface was already maximized, the compositor will still emit
// a configure event with the "maximized" state.
//
// If the surface is in a fullscreen state, this request has no direct
// effect. It may alter the state the surface is returned to when
// unmaximized unless overridden by the compositor.
func (proxy *XdgToplevel) SetMaximized(connection Connection) (err error) {
	request := XdgToplevelSetMaximizedRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// UnsetMaximized requests to unmaximize the window
//
// Unmaximize the surface.
//
// After requesting that the surface should be unmaximized, the compositor
// will respond by emitting a configure event. Whether this actually
// un-maximizes the window is subject to compositor policies.
// If available and applicable, the compositor will include the window
// geometry dimensions the window had prior to being maximized in the
// configure event. The client must then update its content, drawing it in
// the configured state. The client must also acknowledge the configure
// when committing the new content (see ack_configure).
//
// It is up to the compositor to position the surface after it was
// unmaximized; usually the position the surface had before maximizing, if
// applicable.
//
// If the surface was already not maximized, the compositor will still
// emit a configure event without the "maximized" state.
//
// If the surface is in a fullscreen state, this request has no direct
// effect. It may alter the state the surface is returned to when
// unmaximized unless overridden by the compositor.
func (proxy *XdgToplevel) UnsetMaximized(connection Connection) (err error) {
	request := XdgToplevelUnsetMaximizedRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// SetFullscreen requests to set the window as fullscreen on an output
//
// Make the surface fullscreen.
//
// After requesting that the surface should be fullscreened, the
// compositor will respond by emitting a configure event. Whether the
// client is actually put into a fullscreen state is subject to compositor
// policies. The client must also acknowledge the configure when
// committing the new content (see ack_configure).
//
// The output passed by the request indicates the client's preference as
// to which display it should be set fullscreen on. If this value is NULL,
// it's up to the compositor to choose which display will be used to map
// this surface.
//
// If the surface doesn't cover the whole output, the compositor will
// position the surface in the center of the output and compensate with
// with border fill covering the rest of the output. The content of the
// border fill is undefined, but should be assumed to be in some way that
// attempts to blend into the surrounding area (e.g. solid black).
//
// If the fullscreened surface is not opaque, the compositor must make
// sure that other screen content not part of the same surface tree (made
// up of subsurfaces, popups or similarly coupled surfaces) are not
// visible below the fullscreened surface.
func (proxy *XdgToplevel) SetFullscreen(connection Connection, aOutput ObjectID) (err error) {
	request := XdgToplevelSetFullscreenRequest{
		Output: aOutput,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// UnsetFullscreen requests to unset the window as fullscreen
//
// Make the surface no longer fullscreen.
//
// After requesting that the surface should be unfullscreened, the
// compositor will respond by emitting a configure event.
// Whether this actually removes the fullscreen state of the client is
// subject to compositor policies.
//
// Making a surface unfullscreen sets states for the surface based on the following:
// * the state(s) it may have had before becoming fullscreen
// * any state(s) decided by the compositor
// * any state(s) requested by the client while the surface was fullscreen
//
// The compositor may include the previous window geometry dimensions in
// the configure event, if applicable.
//
// The client must also acknowledge the configure when committing the new
// content (see ack_configure).
func (proxy *XdgToplevel) UnsetFullscreen(connection Connection) (err error) {
	request := XdgToplevelUnsetFullscreenRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// SetMinimized requests to set the window as minimized
//
// Request that the compositor minimize your surface. There is no
// way to know if the surface is currently minimized, nor is there
// any way to unset minimization on this surface.
//
// If you are looking to throttle redrawing when minimized, please
// instead use the wl_surface.frame event for this, as this will
// also work with live previews on windows in Alt-Tab, Expose or
// similar compositor features.
func (proxy *XdgToplevel) SetMinimized(connection Connection) (err error) {
	request := XdgToplevelSetMinimizedRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Ensure XdgToplevel implements Proxy.
var _ Proxy = &XdgToplevel{}

// #endregion Interface xdg_shell.xdg_toplevel

// ----------------------------------------------------------------------------
// #region Interface xdg_shell.xdg_popup

type XdgPopupError int

const (
	// XdgPopupErrorInvalidGrab corresponds to tried to grab after being mapped
	XdgPopupErrorInvalidGrab XdgPopupError = 0
)

// XdgPopupDestroyRequest requests to remove xdg_popup interface
//
// This destroys the popup. Explicitly destroying the xdg_popup
// object will also dismiss the popup, and unmap the surface.
//
// If this xdg_popup is not the "topmost" popup, a protocol error
// will be sent.
type XdgPopupDestroyRequest struct {
}

// Opcode returns the request opcode for xdg_popup.destroy in xdg_shell
func (XdgPopupDestroyRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for xdg_popup.destroy in xdg_shell
func (XdgPopupDestroyRequest) MessageName() string { return "destroy" }

// Ensure XdgPopupDestroyRequest implements Message.
var _ Message = XdgPopupDestroyRequest{}

// Emit emits the message to the emitter.
func (r *XdgPopupDestroyRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure XdgPopupDestroyRequest implements Request.
var _ Request = &XdgPopupDestroyRequest{}

// XdgPopupGrabRequest requests to make the popup take an explicit grab
//
// This request makes the created popup take an explicit grab. An explicit
// grab will be dismissed when the user dismisses the popup, or when the
// client destroys the xdg_popup. This can be done by the user clicking
// outside the surface, using the keyboard, or even locking the screen
// through closing the lid or a timeout.
//
// If the compositor denies the grab, the popup will be immediately
// dismissed.
//
// This request must be used in response to some sort of user action like a
// button press, key press, or touch down event. The serial number of the
// event should be passed as 'serial'.
//
// The parent of a grabbing popup must either be an xdg_toplevel surface or
// another xdg_popup with an explicit grab. If the parent is another
// xdg_popup it means that the popups are nested, with this popup now being
// the topmost popup.
//
// Nested popups must be destroyed in the reverse order they were created
// in, e.g. the only popup you are allowed to destroy at all times is the
// topmost one.
//
// When compositors choose to dismiss a popup, they may dismiss every
// nested grabbing popup as well. When a compositor dismisses popups, it
// will follow the same dismissing order as required from the client.
//
// The parent of a grabbing popup must either be another xdg_popup with an
// active explicit grab, or an xdg_popup or xdg_toplevel, if there are no
// explicit grabs already taken.
//
// If the topmost grabbing popup is destroyed, the grab will be returned to
// the parent of the popup, if that parent previously had an explicit grab.
//
// If the parent is a grabbing popup which has already been dismissed, this
// popup will be immediately dismissed. If the parent is a popup that did
// not take an explicit grab, an error will be raised.
//
// During a popup grab, the client owning the grab will receive pointer
// and touch events for all their surfaces as normal (similar to an
// "owner-events" grab in X11 parlance), while the top most grabbing popup
// will always have keyboard focus.
type XdgPopupGrabRequest struct {
	// Seat contains the wl_seat of the user event
	Seat ObjectID

	// Serial contains the serial of the user event
	Serial uint32
}

// Opcode returns the request opcode for xdg_popup.grab in xdg_shell
func (XdgPopupGrabRequest) Opcode() uint16 { return 1 }

// MessageName returns the request name for xdg_popup.grab in xdg_shell
func (XdgPopupGrabRequest) MessageName() string { return "grab" }

// Ensure XdgPopupGrabRequest implements Message.
var _ Message = XdgPopupGrabRequest{}

// Emit emits the message to the emitter.
func (r *XdgPopupGrabRequest) Emit(e *RequestEmitter) error {
	if err := e.PutObjectID(r.Seat); err != nil {
		return err
	}
	if err := e.PutUint(r.Serial); err != nil {
		return err
	}
	return nil
}

// Ensure XdgPopupGrabRequest implements Request.
var _ Request = &XdgPopupGrabRequest{}

// XdgPopupRepositionRequest requests to recalculate the popup's location
//
// Reposition an already-mapped popup. The popup will be placed given the
// details in the passed xdg_positioner object, and a
// xdg_popup.repositioned followed by xdg_popup.configure and
// xdg_surface.configure will be emitted in response. Any parameters set
// by the previous positioner will be discarded.
//
// The passed token will be sent in the corresponding
// xdg_popup.repositioned event. The new popup position will not take
// effect until the corresponding configure event is acknowledged by the
// client. See xdg_popup.repositioned for details. The token itself is
// opaque, and has no other special meaning.
//
// If multiple reposition requests are sent, the compositor may skip all
// but the last one.
//
// If the popup is repositioned in response to a configure event for its
// parent, the client should send an xdg_positioner.set_parent_configure
// and possibly an xdg_positioner.set_parent_size request to allow the
// compositor to properly constrain the popup.
//
// If the popup is repositioned together with a parent that is being
// resized, but not in response to a configure event, the client should
// send an xdg_positioner.set_parent_size request.
type XdgPopupRepositionRequest struct {
	Positioner ObjectID

	// Token contains reposition request token
	Token uint32
}

// Opcode returns the request opcode for xdg_popup.reposition in xdg_shell
func (XdgPopupRepositionRequest) Opcode() uint16 { return 2 }

// MessageName returns the request name for xdg_popup.reposition in xdg_shell
func (XdgPopupRepositionRequest) MessageName() string { return "reposition" }

// Ensure XdgPopupRepositionRequest implements Message.
var _ Message = XdgPopupRepositionRequest{}

// Emit emits the message to the emitter.
func (r *XdgPopupRepositionRequest) Emit(e *RequestEmitter) error {
	if err := e.PutObjectID(r.Positioner); err != nil {
		return err
	}
	if err := e.PutUint(r.Token); err != nil {
		return err
	}
	return nil
}

// Ensure XdgPopupRepositionRequest implements Request.
var _ Request = &XdgPopupRepositionRequest{}

// XdgPopupConfigureEvent signals when configure the popup surface
//
// This event asks the popup surface to configure itself given the
// configuration. The configured state should not be applied immediately.
// See xdg_surface.configure for details.
//
// The x and y arguments represent the position the popup was placed at
// given the xdg_positioner rule, relative to the upper left corner of the
// window geometry of the parent surface.
//
// For version 2 or older, the configure event for an xdg_popup is only
// ever sent once for the initial configuration. Starting with version 3,
// it may be sent again if the popup is setup with an xdg_positioner with
// set_reactive requested, or in response to xdg_popup.reposition requests.
type XdgPopupConfigureEvent struct {
	// X contains x position relative to parent surface window geometry
	X int32

	// Y contains y position relative to parent surface window geometry
	Y int32

	// Width contains window geometry width
	Width int32

	// Height contains window geometry height
	Height int32
}

// Opcode returns the event opcode for xdg_popup.configure in xdg_shell
func (XdgPopupConfigureEvent) Opcode() uint16 { return 0 }

// MessageName returns the event name for xdg_popup.configure in xdg_shell
func (XdgPopupConfigureEvent) MessageName() string { return "configure" }

// Ensure XdgPopupConfigureEvent implements Message.
var _ Message = XdgPopupConfigureEvent{}

// Scan scans the event from the socket.
func (e *XdgPopupConfigureEvent) Scan(s *EventScanner) error {
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.X = v
	}
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.Y = v
	}
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.Width = v
	}
	if v, err := s.Int(); err != nil {
		return err
	} else {
		e.Height = v
	}
	return nil
}

// Ensure XdgPopupConfigureEvent implements Event.
var _ Event = &XdgPopupConfigureEvent{}

// XdgPopupPopupDoneEvent signals when popup interaction is done
//
// The popup_done event is sent out when a popup is dismissed by the
// compositor. The client should destroy the xdg_popup object at this
// point.
type XdgPopupPopupDoneEvent struct {
}

// Opcode returns the event opcode for xdg_popup.popup_done in xdg_shell
func (XdgPopupPopupDoneEvent) Opcode() uint16 { return 1 }

// MessageName returns the event name for xdg_popup.popup_done in xdg_shell
func (XdgPopupPopupDoneEvent) MessageName() string { return "popup_done" }

// Ensure XdgPopupPopupDoneEvent implements Message.
var _ Message = XdgPopupPopupDoneEvent{}

// Scan scans the event from the socket.
func (e *XdgPopupPopupDoneEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure XdgPopupPopupDoneEvent implements Event.
var _ Event = &XdgPopupPopupDoneEvent{}

// XdgPopupRepositionedEvent signals when signal the completion of a repositioned request
//
// The repositioned event is sent as part of a popup configuration
// sequence, together with xdg_popup.configure and lastly
// xdg_surface.configure to notify the completion of a reposition request.
//
// The repositioned event is to notify about the completion of a
// xdg_popup.reposition request. The token argument is the token passed
// in the xdg_popup.reposition request.
//
// Immediately after this event is emitted, xdg_popup.configure and
// xdg_surface.configure will be sent with the updated size and position,
// as well as a new configure serial.
//
// The client should optionally update the content of the popup, but must
// acknowledge the new popup configuration for the new position to take
// effect. See xdg_surface.ack_configure for details.
type XdgPopupRepositionedEvent struct {
	// Token contains reposition request token
	Token uint32
}

// Opcode returns the event opcode for xdg_popup.repositioned in xdg_shell
func (XdgPopupRepositionedEvent) Opcode() uint16 { return 2 }

// MessageName returns the event name for xdg_popup.repositioned in xdg_shell
func (XdgPopupRepositionedEvent) MessageName() string { return "repositioned" }

// Ensure XdgPopupRepositionedEvent implements Message.
var _ Message = XdgPopupRepositionedEvent{}

// Scan scans the event from the socket.
func (e *XdgPopupRepositionedEvent) Scan(s *EventScanner) error {
	if v, err := s.Uint(); err != nil {
		return err
	} else {
		e.Token = v
	}
	return nil
}

// Ensure XdgPopupRepositionedEvent implements Event.
var _ Event = &XdgPopupRepositionedEvent{}

// XdgPopup short-lived, popup surfaces for menus
//
// A popup surface is a short-lived, temporary surface. It can be used to
// implement for example menus, popovers, tooltips and other similar user
// interface concepts.
//
// A popup can be made to take an explicit grab. See xdg_popup.grab for
// details.
//
// When the popup is dismissed, a popup_done event will be sent out, and at
// the same time the surface will be unmapped. See the xdg_popup.popup_done
// event for details.
//
// Explicitly destroying the xdg_popup object will also dismiss the popup and
// unmap the surface. Clients that want to dismiss the popup when another
// surface of their own is clicked should dismiss the popup using the destroy
// request.
//
// A newly created xdg_popup will be stacked on top of all previously created
// xdg_popup surfaces associated with the same xdg_toplevel.
//
// The parent of an xdg_popup must be mapped (see the xdg_surface
// description) before the xdg_popup itself.
//
// The client must call wl_surface.commit on the corresponding wl_surface
// for the xdg_popup state to take effect.
type XdgPopup struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *XdgPopup) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (XdgPopup) Descriptor() *InterfaceDescriptor {
	return &XdgPopupDescriptor
}

// Dispatch returns an Event object for a given opcode.
func (XdgPopup) Dispatch(opcode uint16) Event {
	switch opcode {
	case 0:
		return &XdgPopupConfigureEvent{}
	case 1:
		return &XdgPopupPopupDoneEvent{}
	case 2:
		return &XdgPopupRepositionedEvent{}
	default:
		return nil
	}
}

// Destroy requests to remove xdg_popup interface
//
// This destroys the popup. Explicitly destroying the xdg_popup
// object will also dismiss the popup, and unmap the surface.
//
// If this xdg_popup is not the "topmost" popup, a protocol error
// will be sent.
func (proxy *XdgPopup) Destroy(connection Connection) (err error) {
	request := XdgPopupDestroyRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Grab requests to make the popup take an explicit grab
//
// This request makes the created popup take an explicit grab. An explicit
// grab will be dismissed when the user dismisses the popup, or when the
// client destroys the xdg_popup. This can be done by the user clicking
// outside the surface, using the keyboard, or even locking the screen
// through closing the lid or a timeout.
//
// If the compositor denies the grab, the popup will be immediately
// dismissed.
//
// This request must be used in response to some sort of user action like a
// button press, key press, or touch down event. The serial number of the
// event should be passed as 'serial'.
//
// The parent of a grabbing popup must either be an xdg_toplevel surface or
// another xdg_popup with an explicit grab. If the parent is another
// xdg_popup it means that the popups are nested, with this popup now being
// the topmost popup.
//
// Nested popups must be destroyed in the reverse order they were created
// in, e.g. the only popup you are allowed to destroy at all times is the
// topmost one.
//
// When compositors choose to dismiss a popup, they may dismiss every
// nested grabbing popup as well. When a compositor dismisses popups, it
// will follow the same dismissing order as required from the client.
//
// The parent of a grabbing popup must either be another xdg_popup with an
// active explicit grab, or an xdg_popup or xdg_toplevel, if there are no
// explicit grabs already taken.
//
// If the topmost grabbing popup is destroyed, the grab will be returned to
// the parent of the popup, if that parent previously had an explicit grab.
//
// If the parent is a grabbing popup which has already been dismissed, this
// popup will be immediately dismissed. If the parent is a popup that did
// not take an explicit grab, an error will be raised.
//
// During a popup grab, the client owning the grab will receive pointer
// and touch events for all their surfaces as normal (similar to an
// "owner-events" grab in X11 parlance), while the top most grabbing popup
// will always have keyboard focus.
func (proxy *XdgPopup) Grab(connection Connection, aSeat ObjectID, aSerial uint32) (err error) {
	request := XdgPopupGrabRequest{
		Seat:   aSeat,
		Serial: aSerial,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Reposition requests to recalculate the popup's location
//
// Reposition an already-mapped popup. The popup will be placed given the
// details in the passed xdg_positioner object, and a
// xdg_popup.repositioned followed by xdg_popup.configure and
// xdg_surface.configure will be emitted in response. Any parameters set
// by the previous positioner will be discarded.
//
// The passed token will be sent in the corresponding
// xdg_popup.repositioned event. The new popup position will not take
// effect until the corresponding configure event is acknowledged by the
// client. See xdg_popup.repositioned for details. The token itself is
// opaque, and has no other special meaning.
//
// If multiple reposition requests are sent, the compositor may skip all
// but the last one.
//
// If the popup is repositioned in response to a configure event for its
// parent, the client should send an xdg_positioner.set_parent_configure
// and possibly an xdg_positioner.set_parent_size request to allow the
// compositor to properly constrain the popup.
//
// If the popup is repositioned together with a parent that is being
// resized, but not in response to a configure event, the client should
// send an xdg_positioner.set_parent_size request.
func (proxy *XdgPopup) Reposition(connection Connection, aPositioner ObjectID, aToken uint32) (err error) {
	request := XdgPopupRepositionRequest{
		Positioner: aPositioner,
		Token:      aToken,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Ensure XdgPopup implements Proxy.
var _ Proxy = &XdgPopup{}

// #endregion Interface xdg_shell.xdg_popup

////////////////////////////////////////////////////////////////////////////////
// #endregion Protocol xdg_shell

////////////////////////////////////////////////////////////////////////////////
// #region Protocol xwayland_keyboard_grab_unstable_v1

// ----------------------------------------------------------------------------
// #region Interface xwayland_keyboard_grab_unstable_v1.zwp_xwayland_keyboard_grab_manager_v1

// ZwpXwaylandKeyboardGrabManagerV1DestroyRequest requests to destroy the keyboard grab manager
//
// Destroy the keyboard grab manager.
type ZwpXwaylandKeyboardGrabManagerV1DestroyRequest struct {
}

// Opcode returns the request opcode for zwp_xwayland_keyboard_grab_manager_v1.destroy in xwayland_keyboard_grab_unstable_v1
func (ZwpXwaylandKeyboardGrabManagerV1DestroyRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for zwp_xwayland_keyboard_grab_manager_v1.destroy in xwayland_keyboard_grab_unstable_v1
func (ZwpXwaylandKeyboardGrabManagerV1DestroyRequest) MessageName() string { return "destroy" }

// Ensure ZwpXwaylandKeyboardGrabManagerV1DestroyRequest implements Message.
var _ Message = ZwpXwaylandKeyboardGrabManagerV1DestroyRequest{}

// Emit emits the message to the emitter.
func (r *ZwpXwaylandKeyboardGrabManagerV1DestroyRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure ZwpXwaylandKeyboardGrabManagerV1DestroyRequest implements Request.
var _ Request = &ZwpXwaylandKeyboardGrabManagerV1DestroyRequest{}

// ZwpXwaylandKeyboardGrabManagerV1GrabKeyboardRequest requests to grab the keyboard to a surface
//
// The grab_keyboard request asks for a grab of the keyboard, forcing
// the keyboard focus for the given seat upon the given surface.
//
// The protocol provides no guarantee that the grab is ever satisfied,
// and does not require the compositor to send an error if the grab
// cannot ever be satisfied. It is thus possible to request a keyboard
// grab that will never be effective.
//
// The protocol:
//
// * does not guarantee that the grab itself is applied for a surface,
// the grab request may be silently ignored by the compositor,
// * does not guarantee that any events are sent to this client even
// if the grab is applied to a surface,
// * does not guarantee that events sent to this client are exhaustive,
// a compositor may filter some events for its own consumption,
// * does not guarantee that events sent to this client are continuous,
// a compositor may change and reroute keyboard events while the grab
// is nominally active.
type ZwpXwaylandKeyboardGrabManagerV1GrabKeyboardRequest struct {
	ID ObjectID

	// Surface contains surface to report keyboard events to
	Surface ObjectID

	// Seat contains the seat for which the keyboard should be grabbed
	Seat ObjectID
}

// Opcode returns the request opcode for zwp_xwayland_keyboard_grab_manager_v1.grab_keyboard in xwayland_keyboard_grab_unstable_v1
func (ZwpXwaylandKeyboardGrabManagerV1GrabKeyboardRequest) Opcode() uint16 { return 1 }

// MessageName returns the request name for zwp_xwayland_keyboard_grab_manager_v1.grab_keyboard in xwayland_keyboard_grab_unstable_v1
func (ZwpXwaylandKeyboardGrabManagerV1GrabKeyboardRequest) MessageName() string {
	return "grab_keyboard"
}

// Ensure ZwpXwaylandKeyboardGrabManagerV1GrabKeyboardRequest implements Message.
var _ Message = ZwpXwaylandKeyboardGrabManagerV1GrabKeyboardRequest{}

// Emit emits the message to the emitter.
func (r *ZwpXwaylandKeyboardGrabManagerV1GrabKeyboardRequest) Emit(e *RequestEmitter) error {
	if err := e.PutObjectID(r.ID); err != nil {
		return err
	}
	if err := e.PutObjectID(r.Surface); err != nil {
		return err
	}
	if err := e.PutObjectID(r.Seat); err != nil {
		return err
	}
	return nil
}

// Ensure ZwpXwaylandKeyboardGrabManagerV1GrabKeyboardRequest implements Request.
var _ Request = &ZwpXwaylandKeyboardGrabManagerV1GrabKeyboardRequest{}

// ZwpXwaylandKeyboardGrabManagerV1 context object for keyboard grab manager
//
// A global interface used for grabbing the keyboard.
type ZwpXwaylandKeyboardGrabManagerV1 struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *ZwpXwaylandKeyboardGrabManagerV1) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (ZwpXwaylandKeyboardGrabManagerV1) Descriptor() *InterfaceDescriptor {
	return &ZwpXwaylandKeyboardGrabManagerV1Descriptor
}

// Dispatch returns an Event object for a given opcode.
func (ZwpXwaylandKeyboardGrabManagerV1) Dispatch(opcode uint16) Event {
	switch opcode {
	default:
		return nil
	}
}

// Destroy requests to destroy the keyboard grab manager
//
// Destroy the keyboard grab manager.
func (proxy *ZwpXwaylandKeyboardGrabManagerV1) Destroy(connection Connection) (err error) {
	request := ZwpXwaylandKeyboardGrabManagerV1DestroyRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// GrabKeyboard requests to grab the keyboard to a surface
//
// The grab_keyboard request asks for a grab of the keyboard, forcing
// the keyboard focus for the given seat upon the given surface.
//
// The protocol provides no guarantee that the grab is ever satisfied,
// and does not require the compositor to send an error if the grab
// cannot ever be satisfied. It is thus possible to request a keyboard
// grab that will never be effective.
//
// The protocol:
//
// * does not guarantee that the grab itself is applied for a surface,
// the grab request may be silently ignored by the compositor,
// * does not guarantee that any events are sent to this client even
// if the grab is applied to a surface,
// * does not guarantee that events sent to this client are exhaustive,
// a compositor may filter some events for its own consumption,
// * does not guarantee that events sent to this client are continuous,
// a compositor may change and reroute keyboard events while the grab
// is nominally active.
func (proxy *ZwpXwaylandKeyboardGrabManagerV1) GrabKeyboard(connection Connection, aSurface ObjectID, aSeat ObjectID) (aID *ZwpXwaylandKeyboardGrabV1, err error) {
	aID = &ZwpXwaylandKeyboardGrabV1{connection.NewID()}
	request := ZwpXwaylandKeyboardGrabManagerV1GrabKeyboardRequest{
		ID:      aID.id,
		Surface: aSurface,
		Seat:    aSeat,
	}
	err = connection.SendRequest(proxy.id, &request)
	if err == nil {
		connection.RegisterProxy(aID)
	}
	return
}

// Ensure ZwpXwaylandKeyboardGrabManagerV1 implements Proxy.
var _ Proxy = &ZwpXwaylandKeyboardGrabManagerV1{}

// #endregion Interface xwayland_keyboard_grab_unstable_v1.zwp_xwayland_keyboard_grab_manager_v1

// ----------------------------------------------------------------------------
// #region Interface xwayland_keyboard_grab_unstable_v1.zwp_xwayland_keyboard_grab_v1

// ZwpXwaylandKeyboardGrabV1DestroyRequest requests to destroy the grabbed keyboard object
//
// Destroy the grabbed keyboard object. If applicable, the compositor
// will ungrab the keyboard.
type ZwpXwaylandKeyboardGrabV1DestroyRequest struct {
}

// Opcode returns the request opcode for zwp_xwayland_keyboard_grab_v1.destroy in xwayland_keyboard_grab_unstable_v1
func (ZwpXwaylandKeyboardGrabV1DestroyRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for zwp_xwayland_keyboard_grab_v1.destroy in xwayland_keyboard_grab_unstable_v1
func (ZwpXwaylandKeyboardGrabV1DestroyRequest) MessageName() string { return "destroy" }

// Ensure ZwpXwaylandKeyboardGrabV1DestroyRequest implements Message.
var _ Message = ZwpXwaylandKeyboardGrabV1DestroyRequest{}

// Emit emits the message to the emitter.
func (r *ZwpXwaylandKeyboardGrabV1DestroyRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure ZwpXwaylandKeyboardGrabV1DestroyRequest implements Request.
var _ Request = &ZwpXwaylandKeyboardGrabV1DestroyRequest{}

// ZwpXwaylandKeyboardGrabV1 interface for grabbing the keyboard
//
// A global interface used for grabbing the keyboard.
type ZwpXwaylandKeyboardGrabV1 struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *ZwpXwaylandKeyboardGrabV1) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (ZwpXwaylandKeyboardGrabV1) Descriptor() *InterfaceDescriptor {
	return &ZwpXwaylandKeyboardGrabV1Descriptor
}

// Dispatch returns an Event object for a given opcode.
func (ZwpXwaylandKeyboardGrabV1) Dispatch(opcode uint16) Event {
	switch opcode {
	default:
		return nil
	}
}

// Destroy requests to destroy the grabbed keyboard object
//
// Destroy the grabbed keyboard object. If applicable, the compositor
// will ungrab the keyboard.
func (proxy *ZwpXwaylandKeyboardGrabV1) Destroy(connection Connection) (err error) {
	request := ZwpXwaylandKeyboardGrabV1DestroyRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// Ensure ZwpXwaylandKeyboardGrabV1 implements Proxy.
var _ Proxy = &ZwpXwaylandKeyboardGrabV1{}

// #endregion Interface xwayland_keyboard_grab_unstable_v1.zwp_xwayland_keyboard_grab_v1

////////////////////////////////////////////////////////////////////////////////
// #endregion Protocol xwayland_keyboard_grab_unstable_v1

////////////////////////////////////////////////////////////////////////////////
// #region Protocol zwp_linux_explicit_synchronization_unstable_v1

// ----------------------------------------------------------------------------
// #region Interface zwp_linux_explicit_synchronization_unstable_v1.zwp_linux_explicit_synchronization_v1

type ZwpLinuxExplicitSynchronizationV1Error int

const (
	// ZwpLinuxExplicitSynchronizationV1ErrorSynchronizationExists corresponds to the surface already has a synchronization object associated
	ZwpLinuxExplicitSynchronizationV1ErrorSynchronizationExists ZwpLinuxExplicitSynchronizationV1Error = 0
)

// ZwpLinuxExplicitSynchronizationV1DestroyRequest requests to destroy explicit synchronization factory object
//
// Destroy this explicit synchronization factory object. Other objects,
// including zwp_linux_surface_synchronization_v1 objects created by this
// factory, shall not be affected by this request.
type ZwpLinuxExplicitSynchronizationV1DestroyRequest struct {
}

// Opcode returns the request opcode for zwp_linux_explicit_synchronization_v1.destroy in zwp_linux_explicit_synchronization_unstable_v1
func (ZwpLinuxExplicitSynchronizationV1DestroyRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for zwp_linux_explicit_synchronization_v1.destroy in zwp_linux_explicit_synchronization_unstable_v1
func (ZwpLinuxExplicitSynchronizationV1DestroyRequest) MessageName() string { return "destroy" }

// Ensure ZwpLinuxExplicitSynchronizationV1DestroyRequest implements Message.
var _ Message = ZwpLinuxExplicitSynchronizationV1DestroyRequest{}

// Emit emits the message to the emitter.
func (r *ZwpLinuxExplicitSynchronizationV1DestroyRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure ZwpLinuxExplicitSynchronizationV1DestroyRequest implements Request.
var _ Request = &ZwpLinuxExplicitSynchronizationV1DestroyRequest{}

// ZwpLinuxExplicitSynchronizationV1GetSynchronizationRequest requests to extend surface interface for explicit synchronization
//
// Instantiate an interface extension for the given wl_surface to provide
// explicit synchronization.
//
// If the given wl_surface already has an explicit synchronization object
// associated, the synchronization_exists protocol error is raised.
//
// Graphics APIs, like EGL or Vulkan, that manage the buffer queue and
// commits of a wl_surface themselves, are likely to be using this
// extension internally. If a client is using such an API for a
// wl_surface, it should not directly use this extension on that surface,
// to avoid raising a synchronization_exists protocol error.
type ZwpLinuxExplicitSynchronizationV1GetSynchronizationRequest struct {
	// ID contains the new synchronization interface id
	ID ObjectID

	// Surface contains the surface
	Surface ObjectID
}

// Opcode returns the request opcode for zwp_linux_explicit_synchronization_v1.get_synchronization in zwp_linux_explicit_synchronization_unstable_v1
func (ZwpLinuxExplicitSynchronizationV1GetSynchronizationRequest) Opcode() uint16 { return 1 }

// MessageName returns the request name for zwp_linux_explicit_synchronization_v1.get_synchronization in zwp_linux_explicit_synchronization_unstable_v1
func (ZwpLinuxExplicitSynchronizationV1GetSynchronizationRequest) MessageName() string {
	return "get_synchronization"
}

// Ensure ZwpLinuxExplicitSynchronizationV1GetSynchronizationRequest implements Message.
var _ Message = ZwpLinuxExplicitSynchronizationV1GetSynchronizationRequest{}

// Emit emits the message to the emitter.
func (r *ZwpLinuxExplicitSynchronizationV1GetSynchronizationRequest) Emit(e *RequestEmitter) error {
	if err := e.PutObjectID(r.ID); err != nil {
		return err
	}
	if err := e.PutObjectID(r.Surface); err != nil {
		return err
	}
	return nil
}

// Ensure ZwpLinuxExplicitSynchronizationV1GetSynchronizationRequest implements Request.
var _ Request = &ZwpLinuxExplicitSynchronizationV1GetSynchronizationRequest{}

// ZwpLinuxExplicitSynchronizationV1 protocol for providing explicit synchronization
//
// This global is a factory interface, allowing clients to request
// explicit synchronization for buffers on a per-surface basis.
//
// See zwp_linux_surface_synchronization_v1 for more information.
//
// This interface is derived from Chromium's
// zcr_linux_explicit_synchronization_v1.
//
// Warning! The protocol described in this file is experimental and
// backward incompatible changes may be made. Backward compatible changes
// may be added together with the corresponding interface version bump.
// Backward incompatible changes are done by bumping the version number in
// the protocol and interface names and resetting the interface version.
// Once the protocol is to be declared stable, the 'z' prefix and the
// version number in the protocol and interface names are removed and the
// interface version number is reset.
type ZwpLinuxExplicitSynchronizationV1 struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *ZwpLinuxExplicitSynchronizationV1) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (ZwpLinuxExplicitSynchronizationV1) Descriptor() *InterfaceDescriptor {
	return &ZwpLinuxExplicitSynchronizationV1Descriptor
}

// Dispatch returns an Event object for a given opcode.
func (ZwpLinuxExplicitSynchronizationV1) Dispatch(opcode uint16) Event {
	switch opcode {
	default:
		return nil
	}
}

// Destroy requests to destroy explicit synchronization factory object
//
// Destroy this explicit synchronization factory object. Other objects,
// including zwp_linux_surface_synchronization_v1 objects created by this
// factory, shall not be affected by this request.
func (proxy *ZwpLinuxExplicitSynchronizationV1) Destroy(connection Connection) (err error) {
	request := ZwpLinuxExplicitSynchronizationV1DestroyRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// GetSynchronization requests to extend surface interface for explicit synchronization
//
// Instantiate an interface extension for the given wl_surface to provide
// explicit synchronization.
//
// If the given wl_surface already has an explicit synchronization object
// associated, the synchronization_exists protocol error is raised.
//
// Graphics APIs, like EGL or Vulkan, that manage the buffer queue and
// commits of a wl_surface themselves, are likely to be using this
// extension internally. If a client is using such an API for a
// wl_surface, it should not directly use this extension on that surface,
// to avoid raising a synchronization_exists protocol error.
func (proxy *ZwpLinuxExplicitSynchronizationV1) GetSynchronization(connection Connection, aSurface ObjectID) (aID *ZwpLinuxSurfaceSynchronizationV1, err error) {
	aID = &ZwpLinuxSurfaceSynchronizationV1{connection.NewID()}
	request := ZwpLinuxExplicitSynchronizationV1GetSynchronizationRequest{
		ID:      aID.id,
		Surface: aSurface,
	}
	err = connection.SendRequest(proxy.id, &request)
	if err == nil {
		connection.RegisterProxy(aID)
	}
	return
}

// Ensure ZwpLinuxExplicitSynchronizationV1 implements Proxy.
var _ Proxy = &ZwpLinuxExplicitSynchronizationV1{}

// #endregion Interface zwp_linux_explicit_synchronization_unstable_v1.zwp_linux_explicit_synchronization_v1

// ----------------------------------------------------------------------------
// #region Interface zwp_linux_explicit_synchronization_unstable_v1.zwp_linux_surface_synchronization_v1

type ZwpLinuxSurfaceSynchronizationV1Error int

const (
	// ZwpLinuxSurfaceSynchronizationV1ErrorInvalidFence corresponds to the fence specified by the client could not be imported
	ZwpLinuxSurfaceSynchronizationV1ErrorInvalidFence ZwpLinuxSurfaceSynchronizationV1Error = 0

	// ZwpLinuxSurfaceSynchronizationV1ErrorDuplicateFence corresponds to multiple fences added for a single surface commit
	ZwpLinuxSurfaceSynchronizationV1ErrorDuplicateFence ZwpLinuxSurfaceSynchronizationV1Error = 1

	// ZwpLinuxSurfaceSynchronizationV1ErrorDuplicateRelease corresponds to multiple releases added for a single surface commit
	ZwpLinuxSurfaceSynchronizationV1ErrorDuplicateRelease ZwpLinuxSurfaceSynchronizationV1Error = 2

	// ZwpLinuxSurfaceSynchronizationV1ErrorNoSurface corresponds to the associated wl_surface was destroyed
	ZwpLinuxSurfaceSynchronizationV1ErrorNoSurface ZwpLinuxSurfaceSynchronizationV1Error = 3

	// ZwpLinuxSurfaceSynchronizationV1ErrorUnsupportedBuffer corresponds to the buffer does not support explicit synchronization
	ZwpLinuxSurfaceSynchronizationV1ErrorUnsupportedBuffer ZwpLinuxSurfaceSynchronizationV1Error = 4

	// ZwpLinuxSurfaceSynchronizationV1ErrorNoBuffer corresponds to no buffer was attached
	ZwpLinuxSurfaceSynchronizationV1ErrorNoBuffer ZwpLinuxSurfaceSynchronizationV1Error = 5
)

// ZwpLinuxSurfaceSynchronizationV1DestroyRequest requests to destroy synchronization object
//
// Destroy this explicit synchronization object.
//
// Any fence set by this object with set_acquire_fence since the last
// commit will be discarded by the server. Any fences set by this object
// before the last commit are not affected.
//
// zwp_linux_buffer_release_v1 objects created by this object are not
// affected by this request.
type ZwpLinuxSurfaceSynchronizationV1DestroyRequest struct {
}

// Opcode returns the request opcode for zwp_linux_surface_synchronization_v1.destroy in zwp_linux_explicit_synchronization_unstable_v1
func (ZwpLinuxSurfaceSynchronizationV1DestroyRequest) Opcode() uint16 { return 0 }

// MessageName returns the request name for zwp_linux_surface_synchronization_v1.destroy in zwp_linux_explicit_synchronization_unstable_v1
func (ZwpLinuxSurfaceSynchronizationV1DestroyRequest) MessageName() string { return "destroy" }

// Ensure ZwpLinuxSurfaceSynchronizationV1DestroyRequest implements Message.
var _ Message = ZwpLinuxSurfaceSynchronizationV1DestroyRequest{}

// Emit emits the message to the emitter.
func (r *ZwpLinuxSurfaceSynchronizationV1DestroyRequest) Emit(e *RequestEmitter) error {
	return nil
}

// Ensure ZwpLinuxSurfaceSynchronizationV1DestroyRequest implements Request.
var _ Request = &ZwpLinuxSurfaceSynchronizationV1DestroyRequest{}

// ZwpLinuxSurfaceSynchronizationV1SetAcquireFenceRequest requests to set the acquire fence
//
// Set the acquire fence that must be signaled before the compositor
// may sample from the buffer attached with wl_surface.attach. The fence
// is a dma_fence kernel object.
//
// The acquire fence is double-buffered state, and will be applied on the
// next wl_surface.commit request for the associated surface. Thus, it
// applies only to the buffer that is attached to the surface at commit
// time.
//
// If the provided fd is not a valid dma_fence fd, then an INVALID_FENCE
// error is raised.
//
// If a fence has already been attached during the same commit cycle, a
// DUPLICATE_FENCE error is raised.
//
// If the associated wl_surface was destroyed, a NO_SURFACE error is
// raised.
//
// If at surface commit time the attached buffer does not support explicit
// synchronization, an UNSUPPORTED_BUFFER error is raised.
//
// If at surface commit time there is no buffer attached, a NO_BUFFER
// error is raised.
type ZwpLinuxSurfaceSynchronizationV1SetAcquireFenceRequest struct {
	// FD contains acquire fence fd
	FD FD
}

// Opcode returns the request opcode for zwp_linux_surface_synchronization_v1.set_acquire_fence in zwp_linux_explicit_synchronization_unstable_v1
func (ZwpLinuxSurfaceSynchronizationV1SetAcquireFenceRequest) Opcode() uint16 { return 1 }

// MessageName returns the request name for zwp_linux_surface_synchronization_v1.set_acquire_fence in zwp_linux_explicit_synchronization_unstable_v1
func (ZwpLinuxSurfaceSynchronizationV1SetAcquireFenceRequest) MessageName() string {
	return "set_acquire_fence"
}

// Ensure ZwpLinuxSurfaceSynchronizationV1SetAcquireFenceRequest implements Message.
var _ Message = ZwpLinuxSurfaceSynchronizationV1SetAcquireFenceRequest{}

// Emit emits the message to the emitter.
func (r *ZwpLinuxSurfaceSynchronizationV1SetAcquireFenceRequest) Emit(e *RequestEmitter) error {
	if err := e.PutFD(r.FD); err != nil {
		return err
	}
	return nil
}

// Ensure ZwpLinuxSurfaceSynchronizationV1SetAcquireFenceRequest implements Request.
var _ Request = &ZwpLinuxSurfaceSynchronizationV1SetAcquireFenceRequest{}

// ZwpLinuxSurfaceSynchronizationV1GetReleaseRequest requests to release fence for last-attached buffer
//
// Create a listener for the release of the buffer attached by the
// client with wl_surface.attach. See zwp_linux_buffer_release_v1
// documentation for more information.
//
// The release object is double-buffered state, and will be associated
// with the buffer that is attached to the surface at wl_surface.commit
// time.
//
// If a zwp_linux_buffer_release_v1 object has already been requested for
// the surface in the same commit cycle, a DUPLICATE_RELEASE error is
// raised.
//
// If the associated wl_surface was destroyed, a NO_SURFACE error
// is raised.
//
// If at surface commit time there is no buffer attached, a NO_BUFFER
// error is raised.
type ZwpLinuxSurfaceSynchronizationV1GetReleaseRequest struct {
	// Release contains new zwp_linux_buffer_release_v1 object
	Release ObjectID
}

// Opcode returns the request opcode for zwp_linux_surface_synchronization_v1.get_release in zwp_linux_explicit_synchronization_unstable_v1
func (ZwpLinuxSurfaceSynchronizationV1GetReleaseRequest) Opcode() uint16 { return 2 }

// MessageName returns the request name for zwp_linux_surface_synchronization_v1.get_release in zwp_linux_explicit_synchronization_unstable_v1
func (ZwpLinuxSurfaceSynchronizationV1GetReleaseRequest) MessageName() string { return "get_release" }

// Ensure ZwpLinuxSurfaceSynchronizationV1GetReleaseRequest implements Message.
var _ Message = ZwpLinuxSurfaceSynchronizationV1GetReleaseRequest{}

// Emit emits the message to the emitter.
func (r *ZwpLinuxSurfaceSynchronizationV1GetReleaseRequest) Emit(e *RequestEmitter) error {
	if err := e.PutObjectID(r.Release); err != nil {
		return err
	}
	return nil
}

// Ensure ZwpLinuxSurfaceSynchronizationV1GetReleaseRequest implements Request.
var _ Request = &ZwpLinuxSurfaceSynchronizationV1GetReleaseRequest{}

// ZwpLinuxSurfaceSynchronizationV1 per-surface explicit synchronization support
//
// This object implements per-surface explicit synchronization.
//
// Synchronization refers to co-ordination of pipelined operations performed
// on buffers. Most GPU clients will schedule an asynchronous operation to
// render to the buffer, then immediately send the buffer to the compositor
// to be attached to a surface.
//
// In implicit synchronization, ensuring that the rendering operation is
// complete before the compositor displays the buffer is an implementation
// detail handled by either the kernel or userspace graphics driver.
//
// By contrast, in explicit synchronization, dma_fence objects mark when the
// asynchronous operations are complete. When submitting a buffer, the
// client provides an acquire fence which will be waited on before the
// compositor accesses the buffer. The Wayland server, through a
// zwp_linux_buffer_release_v1 object, will inform the client with an event
// which may be accompanied by a release fence, when the compositor will no
// longer access the buffer contents due to the specific commit that
// requested the release event.
//
// Each surface can be associated with only one object of this interface at
// any time.
//
// In version 1 of this interface, explicit synchronization is only
// guaranteed to be supported for buffers created with any version of the
// wp_linux_dmabuf buffer factory. Version 2 additionally guarantees
// explicit synchronization support for opaque EGL buffers, which is a type
// of platform specific buffers described in the EGL_WL_bind_wayland_display
// extension. Compositors are free to support explicit synchronization for
// additional buffer types.
type ZwpLinuxSurfaceSynchronizationV1 struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *ZwpLinuxSurfaceSynchronizationV1) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (ZwpLinuxSurfaceSynchronizationV1) Descriptor() *InterfaceDescriptor {
	return &ZwpLinuxSurfaceSynchronizationV1Descriptor
}

// Dispatch returns an Event object for a given opcode.
func (ZwpLinuxSurfaceSynchronizationV1) Dispatch(opcode uint16) Event {
	switch opcode {
	default:
		return nil
	}
}

// Destroy requests to destroy synchronization object
//
// Destroy this explicit synchronization object.
//
// Any fence set by this object with set_acquire_fence since the last
// commit will be discarded by the server. Any fences set by this object
// before the last commit are not affected.
//
// zwp_linux_buffer_release_v1 objects created by this object are not
// affected by this request.
func (proxy *ZwpLinuxSurfaceSynchronizationV1) Destroy(connection Connection) (err error) {
	request := ZwpLinuxSurfaceSynchronizationV1DestroyRequest{}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// SetAcquireFence requests to set the acquire fence
//
// Set the acquire fence that must be signaled before the compositor
// may sample from the buffer attached with wl_surface.attach. The fence
// is a dma_fence kernel object.
//
// The acquire fence is double-buffered state, and will be applied on the
// next wl_surface.commit request for the associated surface. Thus, it
// applies only to the buffer that is attached to the surface at commit
// time.
//
// If the provided fd is not a valid dma_fence fd, then an INVALID_FENCE
// error is raised.
//
// If a fence has already been attached during the same commit cycle, a
// DUPLICATE_FENCE error is raised.
//
// If the associated wl_surface was destroyed, a NO_SURFACE error is
// raised.
//
// If at surface commit time the attached buffer does not support explicit
// synchronization, an UNSUPPORTED_BUFFER error is raised.
//
// If at surface commit time there is no buffer attached, a NO_BUFFER
// error is raised.
func (proxy *ZwpLinuxSurfaceSynchronizationV1) SetAcquireFence(connection Connection, aFD FD) (err error) {
	request := ZwpLinuxSurfaceSynchronizationV1SetAcquireFenceRequest{
		FD: aFD,
	}
	err = connection.SendRequest(proxy.id, &request)
	return
}

// GetRelease requests to release fence for last-attached buffer
//
// Create a listener for the release of the buffer attached by the
// client with wl_surface.attach. See zwp_linux_buffer_release_v1
// documentation for more information.
//
// The release object is double-buffered state, and will be associated
// with the buffer that is attached to the surface at wl_surface.commit
// time.
//
// If a zwp_linux_buffer_release_v1 object has already been requested for
// the surface in the same commit cycle, a DUPLICATE_RELEASE error is
// raised.
//
// If the associated wl_surface was destroyed, a NO_SURFACE error
// is raised.
//
// If at surface commit time there is no buffer attached, a NO_BUFFER
// error is raised.
func (proxy *ZwpLinuxSurfaceSynchronizationV1) GetRelease(connection Connection) (aRelease *ZwpLinuxBufferReleaseV1, err error) {
	aRelease = &ZwpLinuxBufferReleaseV1{connection.NewID()}
	request := ZwpLinuxSurfaceSynchronizationV1GetReleaseRequest{
		Release: aRelease.id,
	}
	err = connection.SendRequest(proxy.id, &request)
	if err == nil {
		connection.RegisterProxy(aRelease)
	}
	return
}

// Ensure ZwpLinuxSurfaceSynchronizationV1 implements Proxy.
var _ Proxy = &ZwpLinuxSurfaceSynchronizationV1{}

// #endregion Interface zwp_linux_explicit_synchronization_unstable_v1.zwp_linux_surface_synchronization_v1

// ----------------------------------------------------------------------------
// #region Interface zwp_linux_explicit_synchronization_unstable_v1.zwp_linux_buffer_release_v1

// ZwpLinuxBufferReleaseV1FencedReleaseEvent signals when release buffer with fence
//
// Sent when the compositor has finalised its usage of the associated
// buffer for the relevant commit, providing a dma_fence which will be
// signaled when all operations by the compositor on that buffer for that
// commit have finished.
//
// Once the fence has signaled, and assuming the associated buffer is not
// pending release from other wl_surface.commit requests, no additional
// explicit or implicit synchronization is required to safely reuse or
// destroy the buffer.
//
// This event destroys the zwp_linux_buffer_release_v1 object.
type ZwpLinuxBufferReleaseV1FencedReleaseEvent struct {
	// Fence contains fence for last operation on buffer
	Fence FD
}

// Opcode returns the event opcode for zwp_linux_buffer_release_v1.fenced_release in zwp_linux_explicit_synchronization_unstable_v1
func (ZwpLinuxBufferReleaseV1FencedReleaseEvent) Opcode() uint16 { return 0 }

// MessageName returns the event name for zwp_linux_buffer_release_v1.fenced_release in zwp_linux_explicit_synchronization_unstable_v1
func (ZwpLinuxBufferReleaseV1FencedReleaseEvent) MessageName() string { return "fenced_release" }

// Ensure ZwpLinuxBufferReleaseV1FencedReleaseEvent implements Message.
var _ Message = ZwpLinuxBufferReleaseV1FencedReleaseEvent{}

// Scan scans the event from the socket.
func (e *ZwpLinuxBufferReleaseV1FencedReleaseEvent) Scan(s *EventScanner) error {
	if v, err := s.FD(); err != nil {
		return err
	} else {
		e.Fence = v
	}
	return nil
}

// Ensure ZwpLinuxBufferReleaseV1FencedReleaseEvent implements Event.
var _ Event = &ZwpLinuxBufferReleaseV1FencedReleaseEvent{}

// ZwpLinuxBufferReleaseV1ImmediateReleaseEvent signals when release buffer immediately
//
// Sent when the compositor has finalised its usage of the associated
// buffer for the relevant commit, and either performed no operations
// using it, or has a guarantee that all its operations on that buffer for
// that commit have finished.
//
// Once this event is received, and assuming the associated buffer is not
// pending release from other wl_surface.commit requests, no additional
// explicit or implicit synchronization is required to safely reuse or
// destroy the buffer.
//
// This event destroys the zwp_linux_buffer_release_v1 object.
type ZwpLinuxBufferReleaseV1ImmediateReleaseEvent struct {
}

// Opcode returns the event opcode for zwp_linux_buffer_release_v1.immediate_release in zwp_linux_explicit_synchronization_unstable_v1
func (ZwpLinuxBufferReleaseV1ImmediateReleaseEvent) Opcode() uint16 { return 1 }

// MessageName returns the event name for zwp_linux_buffer_release_v1.immediate_release in zwp_linux_explicit_synchronization_unstable_v1
func (ZwpLinuxBufferReleaseV1ImmediateReleaseEvent) MessageName() string { return "immediate_release" }

// Ensure ZwpLinuxBufferReleaseV1ImmediateReleaseEvent implements Message.
var _ Message = ZwpLinuxBufferReleaseV1ImmediateReleaseEvent{}

// Scan scans the event from the socket.
func (e *ZwpLinuxBufferReleaseV1ImmediateReleaseEvent) Scan(s *EventScanner) error {
	return nil
}

// Ensure ZwpLinuxBufferReleaseV1ImmediateReleaseEvent implements Event.
var _ Event = &ZwpLinuxBufferReleaseV1ImmediateReleaseEvent{}

// ZwpLinuxBufferReleaseV1 buffer release explicit synchronization
//
// This object is instantiated in response to a
// zwp_linux_surface_synchronization_v1.get_release request.
//
// It provides an alternative to wl_buffer.release events, providing a
// unique release from a single wl_surface.commit request. The release event
// also supports explicit synchronization, providing a fence FD for the
// client to synchronize against.
//
// Exactly one event, either a fenced_release or an immediate_release, will
// be emitted for the wl_surface.commit request. The compositor can choose
// release by release which event it uses.
//
// This event does not replace wl_buffer.release events; servers are still
// required to send those events.
//
// Once a buffer release object has delivered a 'fenced_release' or an
// 'immediate_release' event it is automatically destroyed.
type ZwpLinuxBufferReleaseV1 struct {
	id ObjectID
}

// ID returns the ID of the object.
func (proxy *ZwpLinuxBufferReleaseV1) ID() ObjectID {
	return proxy.id
}

// Descriptor returns the interface descriptor for the interface of the object.
func (ZwpLinuxBufferReleaseV1) Descriptor() *InterfaceDescriptor {
	return &ZwpLinuxBufferReleaseV1Descriptor
}

// Dispatch returns an Event object for a given opcode.
func (ZwpLinuxBufferReleaseV1) Dispatch(opcode uint16) Event {
	switch opcode {
	case 0:
		return &ZwpLinuxBufferReleaseV1FencedReleaseEvent{}
	case 1:
		return &ZwpLinuxBufferReleaseV1ImmediateReleaseEvent{}
	default:
		return nil
	}
}

// Ensure ZwpLinuxBufferReleaseV1 implements Proxy.
var _ Proxy = &ZwpLinuxBufferReleaseV1{}

// #endregion Interface zwp_linux_explicit_synchronization_unstable_v1.zwp_linux_buffer_release_v1

////////////////////////////////////////////////////////////////////////////////
// #endregion Protocol zwp_linux_explicit_synchronization_unstable_v1
