// Package main implements a Wayland protocol code generator.

package main

import (
	"bytes"
	"encoding/xml"
	"flag"
	"fmt"
	"go/format"
	"io"
	"io/fs"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strings"
)

// The following datatypes map Wayland protocol schemas into Go structs.

type protocol struct {
	XMLName xml.Name `xml:"protocol"`
	Name    string   `xml:"name,attr"`

	Copyright  string  `xml:"copyright"`
	Interfaces []iface `xml:"interface"`
}

type iface struct {
	XMLName xml.Name `xml:"interface"`
	Name    string   `xml:"name,attr"`
	Version int      `xml:"version,attr"`

	Description description `xml:"description"`
	Enums       []enum      `xml:"enum"`
	Requests    []request   `xml:"request"`
	Events      []event     `xml:"event"`
}

type enum struct {
	XMLName  xml.Name `xml:"enum"`
	Name     string   `xml:"name,attr"`
	Bitfield bool     `xml:"bitfield,attr,omitempty"`

	Description description `xml:"description"`
	Entries     []entry     `xml:"entry"`
}

type entry struct {
	XMLName xml.Name `xml:"entry"`
	Name    string   `xml:"name,attr"`
	Value   string   `xml:"value,attr"`
	Summary string   `xml:"summary,attr"`
}

type request struct {
	XMLName xml.Name `xml:"request"`
	Name    string   `xml:"name,attr"`

	Description description `xml:"description"`
	Args        []arg       `xml:"arg"`
}

type event struct {
	XMLName xml.Name `xml:"event"`
	Name    string   `xml:"name,attr"`
	Since   int      `xml:"since,attr,omitempty"`

	Description description `xml:"description"`
	Args        []arg       `xml:"arg"`
}

type arg struct {
	XMLName   xml.Name `xml:"arg"`
	Name      string   `xml:"name,attr"`
	Type      string   `xml:"type,attr"`
	Interface string   `xml:"interface,attr,omitempty"`
	Summary   string   `xml:"summary,attr,omitempty"`
}

type description struct {
	XMLName xml.Name `xml:"description"`
	Summary string   `xml:"summary,attr"`

	Text string `xml:",chardata"`
}

type protocols []protocol

func (p protocols) Len() int {
	return len(p)
}

func (p protocols) Less(i, j int) bool {
	return p[i].Name < p[j].Name
}

func (p protocols) Swap(i, j int) {
	tmp := p[i]
	p[i] = p[j]
	p[j] = tmp
}

// Map of all known protocols. This is populated during the scanning phase.
var protos = protocols{}

func main() {
	flag.Parse()

	// Recursively scan each path provided on the command line.
	for _, arg := range flag.Args() {
		if err := walkdir(arg); err != nil {
			log.Printf("Error: parsing protocols: %v", err)
			os.Exit(1)
		}
	}

	// Sort protocols alphabetically.
	sort.Sort(protos)

	// Generate code to buffer
	buf := bytes.Buffer{}
	if err := codegen(&buf); err != nil {
		log.Printf("Error: generating code: %v", err)
	}

	// Format code
	b, err := format.Source(buf.Bytes())
	if err != nil {
		log.Printf("Error: formatting code: %v", err)
	}

	// Generate an output file containing all of our protocol data.
	if err := os.WriteFile("waylandproto_gen.go", b, 0644); err != nil {
		log.Printf("Error: creating output file: %v", err)
	}
}

func walkdir(path string) error {
	return filepath.Walk(path, func(path string, info fs.FileInfo, err error) error {
		if err != nil {
			return err
		}

		name := info.Name()

		// Skip dotfiles.
		if name == "" || name[0] == '.' {
			if info.IsDir() {
				return filepath.SkipDir
			} else {
				return nil
			}
		}

		// Descend into directories.
		if info.IsDir() {
			return nil
		}

		// Skip non-XML files.
		if !strings.HasSuffix(name, ".xml") {
			return nil
		}

		if err := parsefile(path); err != nil {
			return fmt.Errorf("processing %q: %w", name, err)
		}

		return nil
	})
}

func parsefile(filename string) error {
	f, err := os.Open(filename)
	if err != nil {
		return fmt.Errorf("opening file %q for reading: %w", filename, err)
	}

	defer func() {
		if err := f.Close(); err != nil {
			log.Printf("Warning: error closing %q: %v", filename, err)
		}
	}()

	protocol := protocol{}
	if err := xml.NewDecoder(f).Decode(&protocol); err != nil {
		return fmt.Errorf("parsing xml in %q: %w", filename, err)
	}

	protos = append(protos, protocol)

	return nil
}

func codegen(w io.Writer) error {
	// Output a preamble containing a comment explaining that the code is generated.
	args := strings.Join(os.Args[1:], " ")
	if _, err := fmt.Fprintf(w, "// THIS FILE IS GENERATED BY WAYGEN - DO NOT EDIT\n// Generated with: waygen %s\npackage jtk\n\n", args); err != nil {
		return fmt.Errorf("writing preamble: %w", err)
	}

	for _, proto := range protos {
		if err := codegenproto(w, proto); err != nil {
			return fmt.Errorf("generating code for proto %v: %w", proto.Name, err)
		}
	}

	return nil
}

var spacesRE = regexp.MustCompile(`\s+`)

func codegenproto(w io.Writer, proto protocol) error {
	for _, intf := range proto.Interfaces {
		// Generate enums
		for _, enum := range intf.Enums {
			// Bitfields are uint; other enums are just int.
			typ := "int"
			if enum.Bitfield {
				typ = "uint"
			}

			enumname := namegen(initialism(proto.Name), intf.Name, enum.Name)

			// Make doc comment.
			docgen(w, enumname, enum.Description, "represents", "")

			// Make type declaration.
			fmt.Fprintf(w, "type %s %s\n", enumname, typ)

			// Make entry constants.
			fmt.Fprintf(w, "const (\n")
			for _, entry := range enum.Entries {
				entryname := namegen(initialism(proto.Name), intf.Name, enum.Name, entry.Name)
				docgen(w, entryname, enum.Description, "corresponds to", "\t")
				fmt.Fprintf(w, "\t%s %s = %s\n\n", entryname, enumname, entry.Value)
			}
			fmt.Fprintf(w, ")\n\n")
		}

		// Generate request structs.
		for _, request := range intf.Requests {
			structname := namegen(initialism(proto.Name), intf.Name, request.Name, "request")

			// Make doc comment.
			docgen(w, structname, request.Description, "requests to", "")

			// Make struct declaration.
			fmt.Fprintf(w, "type %s struct {}\n\n", structname)

			// TODO: args
		}

		// Generate event structs.
		for _, event := range intf.Events {
			structname := namegen(initialism(proto.Name), intf.Name, event.Name, "event")

			// Make doc comment.
			docgen(w, structname, event.Description, "requests to", "")

			// Make struct declaration.
			fmt.Fprintf(w, "type %s struct {}\n\n", structname)

			// TODO: args
		}
	}

	return nil
}

func docgen(w io.Writer, name string, desc description, filler string, prefix string) error {
	// Make doc comment.
	if desc.Summary != "" {
		// Summary
		summary := strings.TrimSpace(spacesRE.ReplaceAllString(desc.Summary, " "))
		fmt.Fprintf(w, "%s// %s %s %s\n", prefix, name, filler, summary)

		// Full documentation
		text := strings.TrimSpace(desc.Text)
		if text != "" {
			fmt.Fprintf(w, "%s//\n", prefix)
			for _, line := range strings.Split(text, "\n") {
				fmt.Fprintf(w, "%s// %s\n", prefix, strings.TrimSpace(line))
			}
		}
	}

	return nil
}

func initialism(name string) string {
	b := strings.Builder{}
	for _, part := range strings.Split(name, "_") {
		b.WriteByte(part[0])
		b.WriteByte('_')
	}
	return b.String()
}

func namegen(names ...string) string {
	b := strings.Builder{}
	for _, name := range names {
		for _, part := range strings.Split(name, "_") {
			if part == "" {
				continue
			}

			if part[0] >= 'a' && part[0] <= 'z' {
				b.WriteByte(part[0] & 0b11011111)
				b.WriteString(part[1:])
			} else {
				b.WriteString(part)
			}
		}
	}
	return b.String()
}
