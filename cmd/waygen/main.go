// Package main implements a Wayland protocol code generator.

package main

import (
	"bytes"
	"encoding/xml"
	"flag"
	"fmt"
	"go/format"
	"io"
	"io/fs"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strings"
)

// The following datatypes map Wayland protocol schemas into Go structs.

type protocol struct {
	XMLName xml.Name `xml:"protocol"`
	Name    string   `xml:"name,attr"`

	Copyright  string  `xml:"copyright"`
	Interfaces []iface `xml:"interface"`
}

type iface struct {
	XMLName xml.Name `xml:"interface"`
	Name    string   `xml:"name,attr"`
	Version int      `xml:"version,attr"`

	Description description `xml:"description"`
	Enums       []enum      `xml:"enum"`
	Requests    []request   `xml:"request"`
	Events      []event     `xml:"event"`
}

type enum struct {
	XMLName  xml.Name `xml:"enum"`
	Name     string   `xml:"name,attr"`
	Bitfield bool     `xml:"bitfield,attr,omitempty"`

	Description description `xml:"description"`
	Entries     []entry     `xml:"entry"`
}

type entry struct {
	XMLName xml.Name `xml:"entry"`
	Name    string   `xml:"name,attr"`
	Value   string   `xml:"value,attr"`
	Summary string   `xml:"summary,attr"`
}

type request struct {
	XMLName xml.Name `xml:"request"`
	Name    string   `xml:"name,attr"`
	Since   int      `xml:"since,attr,omitempty"`

	Description description `xml:"description"`
	Args        []arg       `xml:"arg"`
}

type event struct {
	XMLName xml.Name `xml:"event"`
	Name    string   `xml:"name,attr"`
	Since   int      `xml:"since,attr,omitempty"`

	Description description `xml:"description"`
	Args        []arg       `xml:"arg"`
}

type arg struct {
	XMLName   xml.Name `xml:"arg"`
	Name      string   `xml:"name,attr"`
	Type      string   `xml:"type,attr"`
	Interface string   `xml:"interface,attr,omitempty"`
	Summary   string   `xml:"summary,attr,omitempty"`
}

type description struct {
	XMLName xml.Name `xml:"description"`
	Summary string   `xml:"summary,attr"`

	Text string `xml:",chardata"`
}

type protocols []protocol

func (p protocols) Len() int {
	return len(p)
}

func (p protocols) Less(i, j int) bool {
	return p[i].Name < p[j].Name
}

func (p protocols) Swap(i, j int) {
	tmp := p[i]
	p[i] = p[j]
	p[j] = tmp
}

// Map of all known protocols. This is populated during the scanning phase.
var protos = protocols{}

func main() {
	flag.Parse()

	// Recursively scan each path provided on the command line.
	for _, arg := range flag.Args() {
		if err := walkdir(arg); err != nil {
			log.Printf("Error: parsing protocols: %v", err)
			os.Exit(1)
		}
	}

	// Sort protocols alphabetically.
	sort.Sort(protos)

	// Generate code to buffer
	buf := bytes.Buffer{}
	if err := codegen(&buf); err != nil {
		log.Printf("Error: generating code: %v", err)
	}

	// Format code
	b, err := format.Source(buf.Bytes())
	if err != nil {
		log.Printf("Error: formatting code: %v", err)
		b = buf.Bytes()
	}

	// Generate an output file containing all of our protocol data.
	if err := os.WriteFile("waylandproto_gen.go", b, 0644); err != nil {
		log.Printf("Error: creating output file: %v", err)
	}
}

func walkdir(path string) error {
	return filepath.Walk(path, func(path string, info fs.FileInfo, err error) error {
		if err != nil {
			return err
		}

		name := info.Name()

		// Skip dotfiles.
		if name == "" || name[0] == '.' {
			if info.IsDir() {
				return filepath.SkipDir
			} else {
				return nil
			}
		}

		// Descend into directories.
		if info.IsDir() {
			return nil
		}

		// Skip non-XML files.
		if !strings.HasSuffix(name, ".xml") {
			return nil
		}

		// Skip tests.xml.
		if name == "tests.xml" {
			return nil
		}

		// Skip old xdg_shell.
		if name == "xdg-shell-unstable-v5.xml" || name == "xdg-shell-unstable-v6.xml" {
			return nil
		}

		if err := parsefile(path); err != nil {
			return fmt.Errorf("processing %q: %w", name, err)
		}

		return nil
	})
}

func parsefile(filename string) error {
	f, err := os.Open(filename)
	if err != nil {
		return fmt.Errorf("opening file %q for reading: %w", filename, err)
	}

	defer func() {
		if err := f.Close(); err != nil {
			log.Printf("Warning: error closing %q: %v", filename, err)
		}
	}()

	protocol := protocol{}
	if err := xml.NewDecoder(f).Decode(&protocol); err != nil {
		return fmt.Errorf("parsing xml in %q: %w", filename, err)
	}

	protos = append(protos, protocol)

	return nil
}

func codegen(w io.Writer) error {
	// Output a preamble containing a comment explaining that the code is generated.
	args := strings.Join(os.Args[1:], " ")
	if _, err := fmt.Fprintf(w, "// THIS FILE IS GENERATED BY WAYGEN - DO NOT EDIT\n// Generated with: waygen %s\npackage wayland\n\n", args); err != nil {
		return fmt.Errorf("writing preamble: %w", err)
	}

	if _, err := fmt.Fprintf(w, "////////////////////////////////////////////////////////////////////////////////\n// Interface Descriptors\n"); err != nil {
		return fmt.Errorf("writing interface descriptors comment: %w", err)
	}

	for _, proto := range protos {
		for _, intf := range proto.Interfaces {
			if _, err := fmt.Fprintf(w, "var %s = InterfaceDescriptor{\n", namegen(intf.Name, "descriptor")); err != nil {
				return fmt.Errorf("writing protocol %q interface descriptor %q header: %w", proto.Name, intf.Name, err)
			}

			if _, err := fmt.Fprintf(w, "\tName: %q,\n", intf.Name); err != nil {
				return fmt.Errorf("writing protocol %q interface descriptor %q name value: %w", proto.Name, intf.Name, err)
			}

			if _, err := fmt.Fprintf(w, "\tVersion: %d,\n", intf.Version); err != nil {
				return fmt.Errorf("writing protocol %q interface descriptor %q version value: %w", proto.Name, intf.Name, err)
			}

			if _, err := fmt.Fprintf(w, "\tEvents: []EventDescriptor{\n"); err != nil {
				return fmt.Errorf("writing protocol %q interface descriptor %q events header: %w", proto.Name, intf.Name, err)
			}
			for opcode, event := range intf.Events {
				if _, err := fmt.Fprintf(w, "\t\t{Name: %q, Opcode: %d, Type: &%s{}},\n", event.Name, opcode, namegen(intf.Name, event.Name, "event")); err != nil {
					return fmt.Errorf("writing protocol %q interface descriptor %q event %q entry: %w", proto.Name, intf.Name, event.Name, err)
				}
			}
			if _, err := fmt.Fprintf(w, "\t},\n"); err != nil {
				return fmt.Errorf("writing protocol %q interface descriptor %q events footer: %w", proto.Name, intf.Name, err)
			}

			if _, err := fmt.Fprintf(w, "\tRequests: []RequestDescriptor{\n"); err != nil {
				return fmt.Errorf("writing protocol %q interface descriptor %q requests header: %w", proto.Name, intf.Name, err)
			}
			for opcode, request := range intf.Requests {
				if _, err := fmt.Fprintf(w, "\t\t{Name: %q, Opcode: %d, Type: &%s{}},\n", request.Name, opcode, namegen(intf.Name, request.Name, "request")); err != nil {
					return fmt.Errorf("writing protocol %q interface descriptor %q request %q entry: %w", proto.Name, intf.Name, request.Name, err)
				}
			}
			if _, err := fmt.Fprintf(w, "\t},\n"); err != nil {
				return fmt.Errorf("writing protocol %q interface descriptor %q requests footer: %w", proto.Name, intf.Name, err)
			}

			if _, err := fmt.Fprintf(w, "}\n"); err != nil {
				return fmt.Errorf("writing protocol %q interface descriptor %q footer: %w", proto.Name, intf.Name, err)
			}
		}
	}

	if _, err := fmt.Fprintf(w, "////////////////////////////////////////////////////////////////////////////////\n// Protocol Map\nvar Protocols = map[string]ProtocolDescriptor{\n"); err != nil {
		return fmt.Errorf("writing protocol map header: %w", err)
	}

	for _, proto := range protos {
		if _, err := fmt.Fprintf(w, "\t%q: {\n", proto.Name); err != nil {
			return fmt.Errorf("writing protocol map entry %q header: %w", proto.Name, err)
		}
		if _, err := fmt.Fprintf(w, "\t\tName: %q,\n", proto.Name); err != nil {
			return fmt.Errorf("writing protocol map entry %q name value: %w", proto.Name, err)
		}
		if _, err := fmt.Fprintf(w, "\t\tInterfaces: []*InterfaceDescriptor{\n"); err != nil {
			return fmt.Errorf("writing protocol map entry %q interface list header: %w", proto.Name, err)
		}
		for _, intf := range proto.Interfaces {
			if _, err := fmt.Fprintf(w, "\t\t\t&%s,\n", namegen(intf.Name, "descriptor")); err != nil {
				return fmt.Errorf("writing protocol map entry %q interface %q entry header: %w", proto.Name, intf.Name, err)
			}
		}
		if _, err := fmt.Fprintf(w, "\t\t},\n"); err != nil {
			return fmt.Errorf("writing protocol map entry %q interface list header: %w", proto.Name, err)
		}
		if _, err := fmt.Fprintf(w, "\t},\n"); err != nil {
			return fmt.Errorf("writing protocol map entry %q footer: %w", proto.Name, err)
		}
	}

	if _, err := fmt.Fprintf(w, "}\n\n"); err != nil {
		return fmt.Errorf("writing protocol map footer: %w", err)
	}

	for _, proto := range protos {
		if err := codegenproto(w, proto); err != nil {
			return fmt.Errorf("generating code for proto %s: %w", proto.Name, err)
		}
	}

	return nil
}

var spacesRE = regexp.MustCompile(`\s+`)

func codegenproto(w io.Writer, proto protocol) error {
	if _, err := fmt.Fprintf(w, "////////////////////////////////////////////////////////////////////////////////\n// #region Protocol %s\n\n", proto.Name); err != nil {
		return fmt.Errorf("writing protocol %s begin region: %w", proto.Name, err)
	}

	for _, intf := range proto.Interfaces {
		if _, err := fmt.Fprintf(w, "// ----------------------------------------------------------------------------\n// #region Interface %s.%s\n\n", proto.Name, intf.Name); err != nil {
			return fmt.Errorf("writing protocol %s begin region: %w", intf.Name, err)
		}

		// Generate enums
		for _, enum := range intf.Enums {
			// Bitfields are uint; other enums are just int.
			typ := "int"
			if enum.Bitfield {
				typ = "uint"
			}

			enumname := namegen(intf.Name, enum.Name)

			// Make doc comment.
			if err := docgen(w, enumname, enum.Description, " represents ", ""); err != nil {
				return fmt.Errorf("writing enum %s doc comment: %w", enumname, err)
			}

			// Make type declaration.
			if _, err := fmt.Fprintf(w, "type %s %s\n", enumname, typ); err != nil {
				return fmt.Errorf("writing enum %s type declaration: %w", enumname, err)
			}

			// Make entry constants.
			fmt.Fprintf(w, "const (\n")
			for _, entry := range enum.Entries {
				entryname := namegen(intf.Name, enum.Name, entry.Name)

				if err := docgen(w, entryname, description{Summary: entry.Summary}, " corresponds to ", "\t"); err != nil {
					return fmt.Errorf("writing enum entry %s doc comment: %w", entryname, err)
				}

				if _, err := fmt.Fprintf(w, "\t%s %s = %s\n\n", entryname, enumname, entry.Value); err != nil {
					return fmt.Errorf("writing enum entry %s declaration: %w", entryname, err)
				}
			}
			fmt.Fprint(w, ")\n\n")
		}

		// Generate request structs.
		for opcode, request := range intf.Requests {
			structname := namegen(intf.Name, request.Name, "request")

			// Make doc comment.
			if err := docgen(w, structname, request.Description, " requests to ", ""); err != nil {
				return fmt.Errorf("writing request %s doc comment: %w", structname, err)
			}

			// Open struct declaration.
			if _, err := fmt.Fprintf(w, "type %s struct {\n", structname); err != nil {
				return fmt.Errorf("writing request %s struct open: %w", structname, err)
			}

			// Write arguments.
			for _, arg := range request.Args {
				if err := arggen(w, arg); err != nil {
					return fmt.Errorf("writing request %s struct: %w", structname, err)
				}
			}

			// Close struct declaration.
			if _, err := fmt.Fprint(w, "}\n\n"); err != nil {
				return fmt.Errorf("writing request %s struct close: %w", structname, err)
			}

			// Implement Opcode function.
			if _, err := fmt.Fprintf(w,
				"// Opcode returns the request opcode for %s.%s in %s\nfunc (%s) Opcode() uint16 { return %d }\n\n",
				intf.Name, request.Name, proto.Name, structname, opcode); err != nil {
				return fmt.Errorf("writing request %s Opcode implementation: %w", structname, err)
			}

			// Implement Name function.
			if _, err := fmt.Fprintf(w,
				"// MessageName returns the request name for %s.%s in %s\nfunc (%s) MessageName() string { return %q }\n\n",
				intf.Name, request.Name, proto.Name, structname, request.Name); err != nil {
				return fmt.Errorf("writing request %s MessageName implementation: %w", structname, err)
			}

			// Ensure implementation of Message
			if _, err := fmt.Fprintf(w, "// Ensure %s implements Message.\nvar _ Message = %s{}\n\n", structname, structname); err != nil {
				return fmt.Errorf("writing request %s Message interface check: %w", structname, err)
			}

			// Implement Emit function.
			if _, err := fmt.Fprintf(w,
				"// Emit emits the message to the emitter.\nfunc (r *%s) Emit(e *RequestEmitter) error {\n", structname); err != nil {
				return fmt.Errorf("writing request %s Emit function header: %w", structname, err)
			}

			// Write argument emitters.
			for _, arg := range request.Args {
				if err := argemitgen(w, arg); err != nil {
					return err
				}
			}

			if _, err := fmt.Fprintf(w, "\treturn nil\n}\n"); err != nil {
				return fmt.Errorf("writing request %s Emit function footer: %w", structname, err)
			}

			// Ensure implementation of Request
			if _, err := fmt.Fprintf(w, "// Ensure %s implements Request.\nvar _ Request = &%s{}\n\n", structname, structname); err != nil {
				return fmt.Errorf("writing request %s Request interface check: %w", structname, err)
			}
		}

		// Generate event structs.
		for opcode, event := range intf.Events {
			structname := namegen(intf.Name, event.Name, "event")

			// Make doc comment.
			if err := docgen(w, structname, event.Description, " signals when ", ""); err != nil {
				return fmt.Errorf("writing event %s doc comment: %w", structname, err)
			}

			// Open struct declaration.
			if _, err := fmt.Fprintf(w, "type %s struct {\n", structname); err != nil {
				return fmt.Errorf("writing event %s struct open: %w", structname, err)
			}

			// Write arguments.
			for _, arg := range event.Args {
				if err := arggen(w, arg); err != nil {
					return fmt.Errorf("writing event %s struct: %w", structname, err)
				}
			}

			// Close struct declaration.
			if _, err := fmt.Fprint(w, "}\n\n"); err != nil {
				return fmt.Errorf("writing event %s struct close: %w", structname, err)
			}

			// Implement Opcode function.
			if _, err := fmt.Fprintf(w,
				"// Opcode returns the event opcode for %s.%s in %s\nfunc (%s) Opcode() uint16 { return %d }\n\n",
				intf.Name, event.Name, proto.Name, structname, opcode); err != nil {
				return fmt.Errorf("writing event %s Opcode implementation: %w", structname, err)
			}

			// Implement Name function.
			if _, err := fmt.Fprintf(w,
				"// MessageName returns the event name for %s.%s in %s\nfunc (%s) MessageName() string { return %q }\n\n",
				intf.Name, event.Name, proto.Name, structname, event.Name); err != nil {
				return fmt.Errorf("writing event %s MessageName implementation: %w", structname, err)
			}

			// Ensure implementation of Message
			if _, err := fmt.Fprintf(w, "// Ensure %s implements Message.\nvar _ Message = %s{}\n\n", structname, structname); err != nil {
				return fmt.Errorf("writing event %s Message interface check: %w", structname, err)
			}

			// Implement Scan function.
			if _, err := fmt.Fprintf(w,
				"// Scan scans the event from the socket.\nfunc (e *%s) Scan(s *EventScanner) error {\n", structname); err != nil {
				return fmt.Errorf("writing event %s Scan function header: %w", structname, err)
			}

			// Write argument scanners.
			for _, arg := range event.Args {
				if err := argscangen(w, arg); err != nil {
					return err
				}
			}

			if _, err := fmt.Fprintf(w, "\treturn nil\n}\n"); err != nil {
				return fmt.Errorf("writing event %s Scan function footer: %w", structname, err)
			}

			// Ensure implementation of Event
			if _, err := fmt.Fprintf(w, "// Ensure %s implements Event.\nvar _ Event = &%s{}\n\n", structname, structname); err != nil {
				return fmt.Errorf("writing event %s Event interface check: %w", structname, err)
			}
		}

		// Generate proxy.
		structname := namegen(intf.Name)

		// Make doc comment.
		if err := docgen(w, structname, intf.Description, " ", ""); err != nil {
			return fmt.Errorf("writing proxy %s doc comment: %w", structname, err)
		}

		// Proxy struct declaration.
		if _, err := fmt.Fprintf(w, "type %s struct {\n\tid ObjectID\n\tversion uint32\n}\n\n", structname); err != nil {
			return fmt.Errorf("writing proxy %s struct: %w", structname, err)
		}

		// Implement ID function.
		if _, err := fmt.Fprintf(w, "// ID returns the ID of the object.\nfunc (proxy *%s) ID() ObjectID {\n\treturn proxy.id\n}\n\n", structname); err != nil {
			return fmt.Errorf("writing event %s Proxy interface Descriptor method: %w", structname, err)
		}

		// Implement Version function.
		if _, err := fmt.Fprintf(w, "// ID returns the Version of the interface.\nfunc (proxy *%s) Version() uint32 {\n\treturn proxy.version\n}\n\n", structname); err != nil {
			return fmt.Errorf("writing event %s Proxy interface Descriptor method: %w", structname, err)
		}

		// Implement Descriptor function.
		if _, err := fmt.Fprintf(w, "// Descriptor returns the interface descriptor for the interface of the object.\nfunc (%s) Descriptor() *InterfaceDescriptor {\n\treturn &%s\n}\n\n", structname, namegen(intf.Name, "descriptor")); err != nil {
			return fmt.Errorf("writing event %s Proxy interface Descriptor method: %w", structname, err)
		}

		// Write Dispatch function header.
		if _, err := fmt.Fprintf(w, "// Dispatch returns an Event object for a given opcode.\nfunc (%s) Dispatch(opcode uint16) Event {\n\tswitch opcode {\n", structname); err != nil {
			return fmt.Errorf("writing event %s Proxy interface Dispatch method header: %w", structname, err)
		}

		for opcode, event := range intf.Events {
			if _, err := fmt.Fprintf(w, "\tcase %d:\n\t\treturn &%s{}\n", opcode, namegen(intf.Name, event.Name, "event")); err != nil {
				return fmt.Errorf("writing event %s Proxy interface Dispatch method %s case: %w", structname, event.Name, err)
			}
		}

		// Write Dispatch function footer.
		if _, err := fmt.Fprintf(w, "\tdefault:\n\t\treturn nil\n\t}\n}\n"); err != nil {
			return fmt.Errorf("writing event %s Proxy interface Dispatch method footer: %w", structname, err)
		}

		for _, request := range intf.Requests {
			funcname := namegen(request.Name)

			// Make doc comment.
			if err := docgen(w, funcname, request.Description, " requests to ", ""); err != nil {
				return fmt.Errorf("writing request %s doc comment: %w", funcname, err)
			}

			// Make function declaration.
			if _, err := fmt.Fprintf(w, "func (proxy *%s) %s(connection Connection", structname, funcname); err != nil {
				return fmt.Errorf("writing request %s function part 1: %w", funcname, err)
			}

			// Write input arguments.
			for _, arg := range request.Args {
				var err error

				argname := "a" + namegen(arg.Name)

				switch arg.Type {
				case "int":
					_, err = fmt.Fprintf(w, ", %s int32", argname)
				case "uint":
					_, err = fmt.Fprintf(w, ", %s uint32", argname)
				case "fixed":
					_, err = fmt.Fprintf(w, ", %s Fixed", argname)
				case "object":
					_, err = fmt.Fprintf(w, ", %s ObjectID", argname)
				case "string":
					_, err = fmt.Fprintf(w, ", %s string", argname)
				case "array":
					_, err = fmt.Fprintf(w, ", %s []byte", argname)
				case "fd":
					_, err = fmt.Fprintf(w, ", %s FD", argname)
				case "new_id":
					// Untyped new_id needs interface name and version.
					// I have no idea why these aren't just explicit.
					// In fact, I have no idea why name is needed at all.
					if arg.Interface == "" {
						_, err = fmt.Fprintf(w, ", %sInterfaceName string, %sInterfaceVersion uint32", argname, argname)
					}
				default:
					err = fmt.Errorf("invalid type %s", arg.Type)
				}
				if err != nil {
					return fmt.Errorf("writing function %s arg %s: %w", funcname, argname, err)
				}
			}

			if _, err := fmt.Fprintf(w, ") ("); err != nil {
				return fmt.Errorf("writing request %s function part 2: %w", funcname, err)
			}

			// Write output arguments.
			for _, arg := range request.Args {
				argname := "a" + namegen(arg.Name)

				switch arg.Type {
				case "int", "uint", "fixed", "object", "string", "array", "fd":
					// Skip, leave for input.
					continue
				case "new_id":
					if arg.Interface != "" {
						if _, err := fmt.Fprintf(w, "%s *%s", argname, namegen(arg.Interface)); err != nil {
							return fmt.Errorf("writing function %s output %s: %w", funcname, argname, err)
						}
					} else {
						if _, err := fmt.Fprintf(w, "%s ObjectID", argname); err != nil {
							return fmt.Errorf("writing function %s output %s: %w", funcname, argname, err)
						}
					}
				default:
					return fmt.Errorf("writing function %s output %s: invalid type %s", funcname, argname, arg.Type)
				}
				if _, err := fmt.Fprint(w, ", "); err != nil {
					return fmt.Errorf("writing comma between args in %s function: %w", funcname, err)
				}
			}

			if _, err := fmt.Fprintf(w, "err error) {\n"); err != nil {
				return fmt.Errorf("writing request %s function part 3: %w", funcname, err)
			}

			// Setup new object IDs/proxies.
			for _, arg := range request.Args {
				argname := "a" + namegen(arg.Name)

				switch arg.Type {
				case "int", "uint", "fixed", "object", "string", "array", "fd":
					continue
				case "new_id":
					if arg.Interface != "" {
						if _, err := fmt.Fprintf(w, "\t%s = &%s{connection.NewID(), proxy.version}\n", argname, namegen(arg.Interface)); err != nil {
							return fmt.Errorf("writing function %s id assignment %s: %w", funcname, argname, err)
						}
					} else {
						if _, err := fmt.Fprintf(w, "\t%s = connection.NewID()\n", argname); err != nil {
							return fmt.Errorf("writing function %s id assignment %s: %w", funcname, argname, err)
						}
					}
				default:
					return fmt.Errorf("writing function %s id assignment %s: invalid type %s", funcname, argname, arg.Type)
				}
			}

			reqname := namegen(intf.Name, request.Name, "request")

			// Construct request object.
			if _, err := fmt.Fprintf(w, "\trequest := %s{\n", reqname); err != nil {
				return fmt.Errorf("writing request function %s request struct open: %w", funcname, err)
			}

			hasProxies := false
			for _, arg := range request.Args {
				argname := namegen(arg.Name)
				if arg.Type == "new_id" && arg.Interface != "" {
					hasProxies = true
					if _, err := fmt.Fprintf(w, "\t\t%s: a%s.id,\n", argname, argname); err != nil {
						return fmt.Errorf("writing function %s request arg %s assignment: %w", funcname, argname, err)
					}
				} else {
					if _, err := fmt.Fprintf(w, "\t\t%s: a%s,\n", argname, argname); err != nil {
						return fmt.Errorf("writing function %s request arg %s assignment: %w", funcname, argname, err)
					}

					// Set synthesized arguments.
					if arg.Type == "new_id" {
						if _, err := fmt.Fprintf(w, "\t\t%sInterfaceName: a%sInterfaceName,\n", argname, argname); err != nil {
							return fmt.Errorf("writing function %s request arg %sInterfaceName assignment: %w", funcname, argname, err)
						}
						if _, err := fmt.Fprintf(w, "\t\t%sInterfaceVersion: a%sInterfaceVersion,\n", argname, argname); err != nil {
							return fmt.Errorf("writing function %s request arg %sInterfaceVersion assignment: %w", funcname, argname, err)
						}
					}
				}
			}

			if _, err := fmt.Fprint(w, "\t}\n"); err != nil {
				return fmt.Errorf("writing request function %s request struct open: %w", funcname, err)
			}

			// Send request.
			if _, err := fmt.Fprintf(w, "\terr = connection.SendRequest(proxy.id, &request)\n"); err != nil {
				return fmt.Errorf("writing request function %s request call: %w", funcname, err)
			}

			// Register new proxies.
			if hasProxies {
				if _, err := fmt.Fprintf(w, "\tif err == nil {\n"); err != nil {
					return fmt.Errorf("writing request function %s request call: %w", funcname, err)
				}
				for _, arg := range request.Args {
					argname := "a" + namegen(arg.Name)

					if arg.Type == "new_id" && arg.Interface != "" {
						if _, err := fmt.Fprintf(w, "\t\tconnection.RegisterProxy(%s)\n", argname); err != nil {
							return fmt.Errorf("writing function %s request arg %s assignment: %w", funcname, argname, err)
						}
					}
				}
				if _, err := fmt.Fprintf(w, "\t}\n"); err != nil {
					return fmt.Errorf("writing request function %s request call: %w", funcname, err)
				}
			}

			if _, err := fmt.Fprint(w, "\treturn\n}\n\n"); err != nil {
				return fmt.Errorf("writing request %s function tail: %w", funcname, err)
			}
		}

		// Ensure implementation of Proxy
		if _, err := fmt.Fprintf(w, "// Ensure %s implements Proxy.\nvar _ Proxy = &%s{}\n\n", structname, structname); err != nil {
			return fmt.Errorf("writing event %s Proxy interface check: %w", structname, err)
		}

		if _, err := fmt.Fprintf(w, "// #endregion Interface %s.%s\n\n", proto.Name, intf.Name); err != nil {
			return fmt.Errorf("writing protocol %s end region: %w", intf.Name, err)
		}
	}

	if _, err := fmt.Fprintf(w, "////////////////////////////////////////////////////////////////////////////////\n// #endregion Protocol %s\n\n", proto.Name); err != nil {
		return fmt.Errorf("writing protocol %s end region: %w", proto.Name, err)
	}

	return nil
}

func arggen(w io.Writer, arg arg) error {
	argname := namegen(arg.Name)

	// Make doc comment.
	if err := docgen(w, argname, description{Summary: arg.Summary}, " contains ", "\t"); err != nil {
		return fmt.Errorf("writing argument %s doc comment: %w", argname, err)
	}

	typ := ""
	switch arg.Type {
	case "int":
		typ = "int32"
	case "uint":
		typ = "uint32"
	case "fixed":
		typ = "Fixed"
	case "object", "new_id":
		typ = "ObjectID"
	case "string":
		typ = "string"
	case "array":
		typ = "[]byte"
	case "fd":
		typ = "FD"
	default:
		return fmt.Errorf("argument %s: unknown argument type %q", argname, arg.Type)
	}

	// Write actual arg.
	if _, err := fmt.Fprintf(w, "\t%s %s\n", argname, typ); err != nil {
		return fmt.Errorf("writing argument %s: %w", argname, err)
	}

	// Synthesize implied arguments.
	if arg.Type == "new_id" && arg.Interface == "" {
		if _, err := fmt.Fprintf(w, "\t%sInterfaceName string\n", argname); err != nil {
			return fmt.Errorf("writing argument %sInterfaceName: %w", argname, err)
		}
		if _, err := fmt.Fprintf(w, "\t%sInterfaceVersion uint32\n", argname); err != nil {
			return fmt.Errorf("writing argument %sInterfaceVersion: %w", argname, err)
		}
	}

	if _, err := fmt.Fprint(w, "\n"); err != nil {
		return fmt.Errorf("writing extra newline for %s: %w", argname, err)
	}

	return nil
}

func argscangen(w io.Writer, arg arg) error {
	typ, err := argtypfn(arg)
	if err != nil {
		return err
	}

	argname := namegen(arg.Name)

	if _, err := fmt.Fprintf(w, "\tif v, err := s.%s(); err != nil {\n\t\treturn err\n\t} else {\n\t\te.%s = v\n\t}\n", typ, argname); err != nil {
		return fmt.Errorf("writing argument scanner %s: %w", argname, err)
	}

	return nil
}

func argemitgen(w io.Writer, arg arg) error {
	typ, err := argtypfn(arg)
	if err != nil {
		return err
	}

	argname := namegen(arg.Name)

	// Emit implied arguments.
	if arg.Type == "new_id" && arg.Interface == "" {
		if _, err := fmt.Fprintf(w, "\tif err := e.PutString(r.%sInterfaceName); err != nil {\n\t\treturn err\n\t}\n", argname); err != nil {
			return fmt.Errorf("writing argument emitter %s: %w", argname, err)
		}
		if _, err := fmt.Fprintf(w, "\tif err := e.PutUint(r.%sInterfaceVersion); err != nil {\n\t\treturn err\n\t}\n", argname); err != nil {
			return fmt.Errorf("writing argument emitter %s: %w", argname, err)
		}
	}

	if _, err := fmt.Fprintf(w, "\tif err := e.Put%s(r.%s); err != nil {\n\t\treturn err\n\t}\n", typ, argname); err != nil {
		return fmt.Errorf("writing argument emitter %s: %w", argname, err)
	}

	return nil
}

func argtypfn(arg arg) (string, error) {
	switch arg.Type {
	case "int":
		return "Int", nil
	case "uint":
		return "Uint", nil
	case "fixed":
		return "Fixed", nil
	case "object", "new_id":
		return "ObjectID", nil
	case "string":
		return "String", nil
	case "array":
		return "Array", nil
	case "fd":
		return "FD", nil
	default:
		return "", fmt.Errorf("argument %s: unknown argument type %q", namegen(arg.Name), arg.Type)
	}
}

func docgen(w io.Writer, name string, desc description, filler string, prefix string) error {
	// Make doc comment.
	if desc.Summary != "" {
		// Summary
		summary := strings.TrimSpace(spacesRE.ReplaceAllString(desc.Summary, " "))
		if _, err := fmt.Fprintf(w, "%s// %s%s%s\n", prefix, name, filler, summary); err != nil {
			return err
		}

		// Full documentation
		text := strings.TrimSpace(desc.Text)
		if text != "" {
			if _, err := fmt.Fprintf(w, "%s//\n", prefix); err != nil {
				return err
			}
			for _, line := range strings.Split(text, "\n") {
				if _, err := fmt.Fprintf(w, "%s// %s\n", prefix, strings.TrimSpace(line)); err != nil {
					return err
				}
			}
		}
	}

	return nil
}

func namegen(names ...string) string {
	b := strings.Builder{}

	for _, name := range names {
		for _, part := range strings.Split(name, "_") {
			if part == "" {
				continue
			}

			switch part {
			case "id", "fd":
				b.WriteString(strings.ToUpper(part))

			default:
				if part[0] >= 'a' && part[0] <= 'z' {
					b.WriteByte(part[0] & 0b11011111)
					b.WriteString(part[1:])
				} else {
					b.WriteString(part)
				}
			}
		}
	}

	return b.String()
}
